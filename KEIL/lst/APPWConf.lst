L 1 "..\Application\Source\Generated\APPWConf.c"
N/*********************************************************************
N*                     SEGGER Microcontroller GmbH                    *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2025  SEGGER Microcontroller GmbH                *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N----------------------------------------------------------------------
NFile        : APPWConf.c
NPurpose     : Generated file do NOT edit!
N---------------------------END-OF-HEADER------------------------------
N*/
N
N#include "AppWizard.h"
L 1 "..\..\..\..\ThirdParty\emWin\Include\AppWizard.h" 1
N/*********************************************************************
N*                    SEGGER Microcontroller GmbH                     *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2023  SEGGER Microcontroller GmbH                *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V6.46 - Graphical user interface for embedded applications **
NemWin is protected by international copyright laws. Knowledge of the
Nsource code may not be used to write a similar product. 
NThis file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed by SEGGER Software GmbH to Nuvoton Technology Corporation
Nat the address: No. 4, Creation Rd. III, Hsinchu Science Park, Taiwan
Nfor the purposes  of  creating  libraries  for its 
NArm Cortex-A, Arm Cortex-M and  Arm9 32-bit microcontrollers, commercialized and distributed by Nuvoton Technology Corporation
Nunder  the terms and conditions  of  an  End  User  
NLicense  Agreement  supplied  with  the libraries.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NLicensing information
NLicensor:                 SEGGER Software GmbH
NLicensed to:              Nuvoton Technology Corporation, No. 4, Creation Rd. III, Hsinchu Science Park, 30077 Hsinchu City, Taiwan
NLicensed SEGGER software: emWin
NLicense number:           GUI-00735
NLicense model:            emWin License Agreement, signed February 27, 2018
NLicensed platform:        Cortex-M, Cortex-A, and ARM9 32-bit series microcontroller designed and manufactured by Nuvoton Technology Corporation.
N----------------------------------------------------------------------
NSupport and Update Agreement (SUA)
NSUA period:               2018-03-26 - 2025-09-04
NContact to extend SUA:    sales@segger.com
N----------------------------------------------------------------------
NFile        : AppWizard.h
NPurpose     : Interface of AppWizard
N---------------------------END-OF-HEADER------------------------------
N*/
N
N#ifndef APPWIZARD_H
N#define APPWIZARD_H
N
N#include <stddef.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stddef.h" 1
N/* stddef.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.1.4 */
N
N/* Copyright (C) ARM Ltd., 1999
N * All rights reserved
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N
N/* Copyright (C) Codemist Ltd., 1988                            */
N/* Copyright 1991 ARM Limited. All rights reserved.             */
N/* version 0.05 */
N
N/*
N * The following types and macros are defined in several headers referred to in
N * the descriptions of the functions declared in that header. They are also
N * defined in this header file.
N */
N
N#ifndef __stddef_h
N#define __stddef_h
N#define __ARMCLIB_VERSION 5060019
N
N  #ifndef __STDDEF_DECLS
N  #define __STDDEF_DECLS
N    #undef __CLIBNS
N    #ifdef __cplusplus
S        namespace std {
S        #define __CLIBNS ::std::
S        extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if __sizeof_ptr == 8
X#if 4 == 8
S  typedef signed long ptrdiff_t;
N#else
N  typedef signed int ptrdiff_t;
N#endif
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N#elif !defined(__size_t)
S  #define __size_t 1
S  #if __sizeof_ptr == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
S  #else
S    typedef unsigned int size_t;   /* see <stddef.h> */
S  #endif
S   /* the unsigned integral type of the result of the sizeof operator. */
N#endif
N
N#ifndef __cplusplus  /* wchar_t is a builtin type for C++ */
N  #if !defined(__STRICT_ANSI__)
X  #if !0L
N  /* unconditional in non-strict C for consistency of debug info */
N    #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X    #if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S      typedef unsigned int wchar_t; /* also in <stdlib.h> and <inttypes.h> */
N    #else
N      typedef unsigned short wchar_t; /* also in <stdlib.h> and <inttypes.h> */
N    #endif
N  #elif !defined(__wchar_t)
S    #define __wchar_t 1
S    #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
S      typedef unsigned int wchar_t; /* also in <stdlib.h> and <inttypes.h> */
S    #else
S      typedef unsigned short wchar_t; /* also in <stdlib.h> and <inttypes.h> */
S    #endif
S   /*
S    * An integral type whose range of values can represent distinct codes for
S    * all members of the largest extended character set specified among the
S    * supported locales; the null character shall have the code value zero and
S    * each member of the basic character set shall have a code value when used
S    * as the lone character in an integer character constant.
S    */
N  #endif
N#endif
N
N#undef NULL  /* others (e.g. <stdio.h>) also define */
N#define NULL 0
N   /* null pointer constant. */
N
N#ifdef __clang__
S  #define offsetof(t, d) __builtin_offsetof(t, d)
N#else
N  /* EDG uses __INTADDR__ to avoid errors when strict */
N  #define offsetof(t, memb) ((__CLIBNS size_t)__INTADDR__(&(((t *)0)->memb)))
N#endif
N
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 201112L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 201112L <= 199901L) || (0L && 201103L <= __cplusplus)
N  typedef long double max_align_t;
N#endif
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDDEF_DECLS */
N
N
N  #ifdef __cplusplus
S    #ifndef __STDDEF_NO_EXPORTS
S      using ::std::size_t;
S      using ::std::ptrdiff_t;
S      #if !defined(__STRICT_ANSI__) || (defined(__cplusplus) && 201103L <= __cplusplus)
S        using ::std::max_align_t;
S      #endif
S    #endif 
N  #endif /* __cplusplus */
N
N#endif
N
N/* end of stddef.h */
N
L 49 "..\..\..\..\ThirdParty\emWin\Include\AppWizard.h" 2
N
N#include "DIALOG.h"
L 1 "..\..\..\..\ThirdParty\emWin\Include\DIALOG.h" 1
N/*********************************************************************
N*                    SEGGER Microcontroller GmbH                     *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2023  SEGGER Microcontroller GmbH                *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V6.46 - Graphical user interface for embedded applications **
NemWin is protected by international copyright laws. Knowledge of the
Nsource code may not be used to write a similar product. 
NThis file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed by SEGGER Software GmbH to Nuvoton Technology Corporation
Nat the address: No. 4, Creation Rd. III, Hsinchu Science Park, Taiwan
Nfor the purposes  of  creating  libraries  for its 
NArm Cortex-A, Arm Cortex-M and  Arm9 32-bit microcontrollers, commercialized and distributed by Nuvoton Technology Corporation
Nunder  the terms and conditions  of  an  End  User  
NLicense  Agreement  supplied  with  the libraries.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NLicensing information
NLicensor:                 SEGGER Software GmbH
NLicensed to:              Nuvoton Technology Corporation, No. 4, Creation Rd. III, Hsinchu Science Park, 30077 Hsinchu City, Taiwan
NLicensed SEGGER software: emWin
NLicense number:           GUI-00735
NLicense model:            emWin License Agreement, signed February 27, 2018
NLicensed platform:        Cortex-M, Cortex-A, and ARM9 32-bit series microcontroller designed and manufactured by Nuvoton Technology Corporation.
N----------------------------------------------------------------------
NSupport and Update Agreement (SUA)
NSUA period:               2018-03-26 - 2025-09-04
NContact to extend SUA:    sales@segger.com
N----------------------------------------------------------------------
NFile        : Dialog.h
NPurpose     : Dialog box include
N--------------------END-OF-HEADER-------------------------------------
N*/
N
N#ifndef DIALOG_H
N#define DIALOG_H
N
N#include "WM.h"
L 1 "..\..\..\..\ThirdParty\emWin\Include\WM.h" 1
N/*********************************************************************
N*                    SEGGER Microcontroller GmbH                     *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2023  SEGGER Microcontroller GmbH                *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V6.46 - Graphical user interface for embedded applications **
NemWin is protected by international copyright laws. Knowledge of the
Nsource code may not be used to write a similar product. 
NThis file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed by SEGGER Software GmbH to Nuvoton Technology Corporation
Nat the address: No. 4, Creation Rd. III, Hsinchu Science Park, Taiwan
Nfor the purposes  of  creating  libraries  for its 
NArm Cortex-A, Arm Cortex-M and  Arm9 32-bit microcontrollers, commercialized and distributed by Nuvoton Technology Corporation
Nunder  the terms and conditions  of  an  End  User  
NLicense  Agreement  supplied  with  the libraries.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NLicensing information
NLicensor:                 SEGGER Software GmbH
NLicensed to:              Nuvoton Technology Corporation, No. 4, Creation Rd. III, Hsinchu Science Park, 30077 Hsinchu City, Taiwan
NLicensed SEGGER software: emWin
NLicense number:           GUI-00735
NLicense model:            emWin License Agreement, signed February 27, 2018
NLicensed platform:        Cortex-M, Cortex-A, and ARM9 32-bit series microcontroller designed and manufactured by Nuvoton Technology Corporation.
N----------------------------------------------------------------------
NSupport and Update Agreement (SUA)
NSUA period:               2018-03-26 - 2025-09-04
NContact to extend SUA:    sales@segger.com
N----------------------------------------------------------------------
NFile        : WM.h
NPurpose     : Windows manager include
N----------------------------------------------------------------------
N*/
N
N#ifndef WM_H            /* Make sure we only include it once */
N#define WM_H
N
N
N#include "GUI_ConfDefaults.h"
L 1 "..\..\..\..\ThirdParty\emWin\Include\GUI_ConfDefaults.h" 1
N/*********************************************************************
N*                    SEGGER Microcontroller GmbH                     *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2023  SEGGER Microcontroller GmbH                *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V6.46 - Graphical user interface for embedded applications **
NemWin is protected by international copyright laws. Knowledge of the
Nsource code may not be used to write a similar product. 
NThis file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed by SEGGER Software GmbH to Nuvoton Technology Corporation
Nat the address: No. 4, Creation Rd. III, Hsinchu Science Park, Taiwan
Nfor the purposes  of  creating  libraries  for its 
NArm Cortex-A, Arm Cortex-M and  Arm9 32-bit microcontrollers, commercialized and distributed by Nuvoton Technology Corporation
Nunder  the terms and conditions  of  an  End  User  
NLicense  Agreement  supplied  with  the libraries.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NLicensing information
NLicensor:                 SEGGER Software GmbH
NLicensed to:              Nuvoton Technology Corporation, No. 4, Creation Rd. III, Hsinchu Science Park, 30077 Hsinchu City, Taiwan
NLicensed SEGGER software: emWin
NLicense number:           GUI-00735
NLicense model:            emWin License Agreement, signed February 27, 2018
NLicensed platform:        Cortex-M, Cortex-A, and ARM9 32-bit series microcontroller designed and manufactured by Nuvoton Technology Corporation.
N----------------------------------------------------------------------
NSupport and Update Agreement (SUA)
NSUA period:               2018-03-26 - 2025-09-04
NContact to extend SUA:    sales@segger.com
N----------------------------------------------------------------------
NFile        : GUI_ConfDefaults.h
NPurpose     : Defaults for GUI config switches.
N---------------------------END-OF-HEADER------------------------------
N
NAttention : Do not modify this file ! If you do, you will not
N            be able do update to a later GUI version !
N
N*/
N
N#ifndef  GUI_CONFDEFAULTS_H
N#define  GUI_CONFDEFAULTS_H
N
N#include "GUIConf.h"
L 1 "..\..\..\..\ThirdParty\emWin\Config\GUIConf.h" 1
N/*********************************************************************
N*                    SEGGER Microcontroller GmbH                     *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2023  SEGGER Microcontroller GmbH                *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V6.46 - Graphical user interface for embedded applications **
NemWin is protected by international copyright laws. Knowledge of the
Nsource code may not be used to write a similar product. 
NThis file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed by SEGGER Software GmbH to Nuvoton Technology Corporation
Nat the address: No. 4, Creation Rd. III, Hsinchu Science Park, Taiwan
Nfor the purposes  of  creating  libraries  for its 
NArm Cortex-A, Arm Cortex-M and  Arm9 32-bit microcontrollers, commercialized and distributed by Nuvoton Technology Corporation
Nunder  the terms and conditions  of  an  End  User  
NLicense  Agreement  supplied  with  the libraries.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NLicensing information
NLicensor:                 SEGGER Software GmbH
NLicensed to:              Nuvoton Technology Corporation, No. 4, Creation Rd. III, Hsinchu Science Park, 30077 Hsinchu City, Taiwan
NLicensed SEGGER software: emWin
NLicense number:           GUI-00735
NLicense model:            emWin License Agreement, signed February 27, 2018
NLicensed platform:        Cortex-M, Cortex-A, and ARM9 32-bit series microcontroller designed and manufactured by Nuvoton Technology Corporation.
N----------------------------------------------------------------------
NSupport and Update Agreement (SUA)
NSUA period:               2018-03-26 - 2025-09-04
NContact to extend SUA:    sales@segger.com
N----------------------------------------------------------------------
NFile        : GUIConf.h
NPurpose     : Configures emWins abilities, fonts etc.
N----------------------------------------------------------------------
N*/
N
N#ifndef GUICONF_H
N#define GUICONF_H
N
N/*********************************************************************
N*
N*       Multi layer/display support
N*/
N#define GUI_NUM_LAYERS            4    // Maximum number of available layers
N
N/*********************************************************************
N*
N*       Multi tasking support
N*/
N#define GUI_OS                    (0)  // Compile with multitasking support
N
N/*********************************************************************
N*
N*       Configuration of touch support
N*/
N#define GUI_SUPPORT_TOUCH         (1)  // Support a touch screen (req. win-manager)
N
N/*********************************************************************
N*
N*       Default font
N*/
N#define GUI_DEFAULT_FONT          &GUI_Font6x8
N
N/*********************************************************************
N*
N*         Configuration of available packages
N*/
N#define GUI_SUPPORT_MOUSE    1    // Mouse support
N#define GUI_WINSUPPORT       1    // Use Window Manager
N#define GUI_SUPPORT_MEMDEV   1    // Use Memory Devices
N#define GUI_SUPPORT_AA       1    // Antialiasing support available
N#define GUI_SUPPORT_DEVICES  1    // Enable use of device pointers
N
N#endif  // Avoid multiple inclusion
N
N/*************************** End of file ****************************/
L 53 "..\..\..\..\ThirdParty\emWin\Include\GUI_ConfDefaults.h" 2
N
N#ifndef   GUI_SUPPORT_BIDI
N  #define GUI_SUPPORT_BIDI 1
N#endif
N
N#ifndef   GUI_USE_BIDI2
N  #define GUI_USE_BIDI2 1
N#endif
N
N#ifndef   LCD_MAX_LOG_COLORS
N  #define LCD_MAX_LOG_COLORS 256
N#else
S  #if (LCD_MAX_LOG_COLORS > 256)
S    #error The value of LCD_MAX_LOG_COLORS must be <= 256!
S  #endif
N#endif
N
N#define LCD_PIXELINDEX U32
N
N#ifndef LCD_YMAG
N  #define LCD_YMAG 1
N#endif
N#ifndef LCD_XMAG
N  #define LCD_XMAG 1
N#endif
N
N#ifndef   GUI_SIM_SUPPORT_EMBOS
N  #if (defined(_WIN64) || defined(__LP64__))
X  #if (0L || 0L)
S    #define GUI_SIM_SUPPORT_EMBOS 0
N  #else
N    #define GUI_SIM_SUPPORT_EMBOS 1
N  #endif
N#endif
N
N/**********************************************************************
N*
N*       Defaults for config switches
N*
N***********************************************************************
N*/
N
N/* ATTENTION: This define swaps the meaning of a logical color from
N   ABGR to ARGB.
N   
N   It further swaps the meaning of a transparent pixel:
N   ABGR: 0x00 means opaque, 0xFF means transparent
N   ARGB: 0x00 means transparent, 0xFF means opaque (default)
N*/
N#ifndef GUI_USE_ARGB
N  #define GUI_USE_ARGB 1
N#endif
N
N/* Define "universal pointer". Normally, this is not needed (define will expand to nothing)
N   However, on some systems (AVR - IAR compiler) it can be necessary ( -> __generic),
N   since a default pointer can access RAM only, not the built-in Flash
N*/
N#ifndef GUI_UNI_PTR
N  #define GUI_UNI_PTR /* Remains only for compatibility purpose, no longer used in emWin */
N#endif
N
N/* Define const storage. Normally, this is not needed (define will expand to const)
N   However, on some systems (AVR - IAR compiler) it can be necessary ( -> __flash const),
N   since otherwise constants are copied into RAM
N*/
N#ifndef GUI_CONST_STORAGE
N  #define GUI_CONST_STORAGE const
N#endif
N
N#ifndef GUI_USE_MEMDEV_1BPP_FOR_SCREEN
N  #define GUI_USE_MEMDEV_1BPP_FOR_SCREEN 1
N#endif
N
N#ifndef GUI_BIDI_MAX_CHARS_PER_LINE
N  #if GUI_USE_BIDI2
X  #if 1
N    #define GUI_BIDI_MAX_CHARS_PER_LINE 200
N  #else
S    #define GUI_BIDI_MAX_CHARS_PER_LINE  80
N  #endif
N#endif
N
N#ifndef GUI_WINSUPPORT
S  #define GUI_WINSUPPORT      0
N#endif
N
N#ifndef GUI_SUPPORT_TOUCH
S  #define GUI_SUPPORT_TOUCH   0
N#endif
N
N#ifndef GUI_SUPPORT_MOUSE
S  #define GUI_SUPPORT_MOUSE   0
N#endif
N
N#ifndef GUI_SUPPORT_MEMDEV
S  #define GUI_SUPPORT_MEMDEV  0
N#endif
N
N#ifndef GUI_SUPPORT_AA
S  #define GUI_SUPPORT_AA      1
N#endif
N
N#ifndef GUI_OS
S  #define GUI_OS              0
N#endif
N
N#ifndef GUI_NUM_LAYERS
S  #define GUI_NUM_LAYERS      4
N#endif
N
N#ifndef GUI_SUPPORT_CURSOR
N  #define GUI_SUPPORT_CURSOR  (GUI_SUPPORT_MOUSE | GUI_SUPPORT_TOUCH)
N#endif
N
N#ifndef   GUI_CURSOR_LAYER
N  #define GUI_CURSOR_LAYER 0
N#endif
N
N#ifndef GUI_SUPPORT_ROTATION
N  #define GUI_SUPPORT_ROTATION 1
N#endif
N
N/* In order to avoid warnings for undefined parameters */
N#ifndef GUI_USE_PARA
N  #define GUI_USE_PARA(para) (void)para
N#endif
N
N/* Default for types */
N#ifndef GUI_TIMER_TIME
N  #define GUI_TIMER_TIME int  /* default is to use 16 bits for 16 bit CPUs,
N	                           32 bits on 32 bit CPUs for timing */
N#endif
N
N/* Types used for memory allocation */
N#define GUI_ALLOC_DATATYPE   I32
N#define GUI_ALLOC_DATATYPE_U U32
N
N#ifndef   GUI_MAX_XBF_BYTES
N  #define GUI_MAX_XBF_BYTES 200
N#endif
N
N#ifndef   GUI_MEMSET
N  #define GUI_MEMSET memset
N#endif
N
N#ifndef GUI_MEMCPY
N  #define GUI_MEMCPY memcpy
N#endif
N
N#ifdef WIN32
S   #if defined(_MSC_VER)
S     //
S     // MS VS <= 2010 standard library does not include ceilf/floorf/sqrtf
S     //
S     #if (_MSC_VER <= 1600)
S       #ifndef GUI_CEIL
S         #define GUI_CEIL ceil
S       #endif
S       #ifndef GUI_FLOOR
S         #define GUI_FLOOR floor
S       #endif
S       #ifndef GUI_SQRT
S         #define GUI_SQRT sqrt
S       #endif
S     #endif
S   #endif
N#endif 
N
N#ifndef GUI_CEIL
N  #define GUI_CEIL ceilf
N#endif
N
N#ifndef GUI_FLOOR
N  #define GUI_FLOOR floorf
N#endif
N
N#ifndef GUI_SQRT
N  #define GUI_SQRT sqrtf
N#endif
N
N/* Optional custom drawing of memory devices */
N#ifndef   GUI_MEMDEV_SUPPORT_CUSTOMDRAW
N  #define GUI_MEMDEV_SUPPORT_CUSTOMDRAW 0
N#endif
N
N#endif   /* ifdef GUI_CONFDEFAULTS_H */
N
N/*************************** End of file ****************************/
L 50 "..\..\..\..\ThirdParty\emWin\Include\WM.h" 2
N#include "GUI_Type.h"      /* Needed because of typedefs only */
L 1 "..\..\..\..\ThirdParty\emWin\Include\GUI_Type.h" 1
N/*********************************************************************
N*                    SEGGER Microcontroller GmbH                     *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2023  SEGGER Microcontroller GmbH                *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V6.46 - Graphical user interface for embedded applications **
NemWin is protected by international copyright laws. Knowledge of the
Nsource code may not be used to write a similar product. 
NThis file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed by SEGGER Software GmbH to Nuvoton Technology Corporation
Nat the address: No. 4, Creation Rd. III, Hsinchu Science Park, Taiwan
Nfor the purposes  of  creating  libraries  for its 
NArm Cortex-A, Arm Cortex-M and  Arm9 32-bit microcontrollers, commercialized and distributed by Nuvoton Technology Corporation
Nunder  the terms and conditions  of  an  End  User  
NLicense  Agreement  supplied  with  the libraries.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NLicensing information
NLicensor:                 SEGGER Software GmbH
NLicensed to:              Nuvoton Technology Corporation, No. 4, Creation Rd. III, Hsinchu Science Park, 30077 Hsinchu City, Taiwan
NLicensed SEGGER software: emWin
NLicense number:           GUI-00735
NLicense model:            emWin License Agreement, signed February 27, 2018
NLicensed platform:        Cortex-M, Cortex-A, and ARM9 32-bit series microcontroller designed and manufactured by Nuvoton Technology Corporation.
N----------------------------------------------------------------------
NSupport and Update Agreement (SUA)
NSUA period:               2018-03-26 - 2025-09-04
NContact to extend SUA:    sales@segger.com
N----------------------------------------------------------------------
NFile        : GUI_Type.h
NPurpose     : Include file define the types used for GUI
N---------------------------END-OF-HEADER------------------------------
N
NAttention : Do not modify this file ! If you do, you will not
N            be able do update to a later GUI version !
N
N*/
N
N#ifndef  GUITYPE_H_INCLUDED
N#define  GUITYPE_H_INCLUDED
N
N#include "LCD.h"
L 1 "..\..\..\..\ThirdParty\emWin\Include\LCD.h" 1
N/*********************************************************************
N*                    SEGGER Microcontroller GmbH                     *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2023  SEGGER Microcontroller GmbH                *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V6.46 - Graphical user interface for embedded applications **
NemWin is protected by international copyright laws. Knowledge of the
Nsource code may not be used to write a similar product. 
NThis file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed by SEGGER Software GmbH to Nuvoton Technology Corporation
Nat the address: No. 4, Creation Rd. III, Hsinchu Science Park, Taiwan
Nfor the purposes  of  creating  libraries  for its 
NArm Cortex-A, Arm Cortex-M and  Arm9 32-bit microcontrollers, commercialized and distributed by Nuvoton Technology Corporation
Nunder  the terms and conditions  of  an  End  User  
NLicense  Agreement  supplied  with  the libraries.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NLicensing information
NLicensor:                 SEGGER Software GmbH
NLicensed to:              Nuvoton Technology Corporation, No. 4, Creation Rd. III, Hsinchu Science Park, 30077 Hsinchu City, Taiwan
NLicensed SEGGER software: emWin
NLicense number:           GUI-00735
NLicense model:            emWin License Agreement, signed February 27, 2018
NLicensed platform:        Cortex-M, Cortex-A, and ARM9 32-bit series microcontroller designed and manufactured by Nuvoton Technology Corporation.
N----------------------------------------------------------------------
NSupport and Update Agreement (SUA)
NSUA period:               2018-03-26 - 2025-09-04
NContact to extend SUA:    sales@segger.com
N----------------------------------------------------------------------
NFile        : LCD.h
NPurpose     : Declares LCD interface functions
N----------------------------------------------------------------------
N*/
N
N#ifndef LCD_H
N#define LCD_H
N
N#include "GUI_ConfDefaults.h" /* Used for GUI_CONST_STORAGE */
N#include "Global.h"
L 1 "..\..\..\..\ThirdParty\emWin\Include\Global.h" 1
N/*********************************************************************
N*                    SEGGER Microcontroller GmbH                     *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2023  SEGGER Microcontroller GmbH                *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V6.46 - Graphical user interface for embedded applications **
NemWin is protected by international copyright laws. Knowledge of the
Nsource code may not be used to write a similar product. 
NThis file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed by SEGGER Software GmbH to Nuvoton Technology Corporation
Nat the address: No. 4, Creation Rd. III, Hsinchu Science Park, Taiwan
Nfor the purposes  of  creating  libraries  for its 
NArm Cortex-A, Arm Cortex-M and  Arm9 32-bit microcontrollers, commercialized and distributed by Nuvoton Technology Corporation
Nunder  the terms and conditions  of  an  End  User  
NLicense  Agreement  supplied  with  the libraries.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NLicensing information
NLicensor:                 SEGGER Software GmbH
NLicensed to:              Nuvoton Technology Corporation, No. 4, Creation Rd. III, Hsinchu Science Park, 30077 Hsinchu City, Taiwan
NLicensed SEGGER software: emWin
NLicense number:           GUI-00735
NLicense model:            emWin License Agreement, signed February 27, 2018
NLicensed platform:        Cortex-M, Cortex-A, and ARM9 32-bit series microcontroller designed and manufactured by Nuvoton Technology Corporation.
N----------------------------------------------------------------------
NSupport and Update Agreement (SUA)
NSUA period:               2018-03-26 - 2025-09-04
NContact to extend SUA:    sales@segger.com
N----------------------------------------------------------------------
N
NFile    : Global.h
NPurpose : Global types
N          In case your application already has a Global.h, you should
N          merge the files. In order to use Segger code, the types
N          U8, U16, U32, I8, I16, I32 need to be defined in Global.h;
N          additional definitions do not hurt.
NRevision: $Rev: 32989 $
N
N-------------------------- END-OF-HEADER -----------------------------
N*/
N
N#ifndef GLOBAL_H            // Guard against multiple inclusion
N#define GLOBAL_H
N
N#define U8    unsigned char
N#define I8    signed char
N#define U16   unsigned short
N#define I16   signed short
N#if defined(__x86_64__) || defined(__aarch64__)
X#if 0L || 0L
S#define U32   unsigned int
S#define I32   int
N#else
N#define U32   unsigned long
N#define I32   signed long
N#endif
N
N//
N// CC_NO_LONG_SUPPORT can be defined to compile test
N// without long support for compilers that do not
N// support C99 and its long type.
N//
N#ifdef CC_NO_LONG_SUPPORT
S  #define PTR_ADDR  U32
N#else  // Supports long type.
N  #if defined(_MSC_VER)
X  #if 0L
S    //
S    // Microsoft VC6 and newer.
S    // Older versions exist (_MSC_VER <= 1200) but are
S    // not even officially listed by Microsoft and might
S    // not work with these defines.
S    //
S    #define U64   unsigned __int64
S    #define U128  unsigned __int128
S    #define I64   __int64
S    #define I128  __int128
S    #if (_MSC_VER <= 1200)
S      #define U64_C(x) x##UI64
S    #else
S      #define U64_C(x) x##ULL
S    #endif
N  #else
N    //
N    // C99 compliant compiler.
N    //
N    #define U64   unsigned long long
N    #define I64   signed long long
N    #define U64_C(x) x##ULL
N  #endif
N  //
N  // Types for pointer<->address conversions.
N  //
N  #if (defined(_WIN64) || defined(__LP64__))  // 64-bit symbols used by Visual Studio and GCC, maybe others as well.
X  #if (0L || 0L)  
S    #define PTR_ADDR  U64
N  #else
N    #define PTR_ADDR  U32
N  #endif
N#endif  // Supports long type.
N
N#endif                      // Avoid multiple inclusion
N
N/*************************** End of file ****************************/
L 50 "..\..\..\..\ThirdParty\emWin\Include\LCD.h" 2
N
N#if defined(__cplusplus)
X#if 0L
Sextern "C" {     /* Make sure we have C-declarations in C++ programs */
N#endif
N
N/*********************************************************************
N*
N*       Basic type defines
N*
N* The follwing are defines for types used in the LCD-driver and the
N* GUI layers on top of that. Since "C" does not provide data types of
N* fixed length which are identical on all platforms, this is done here.
N* For most 16/32 controllers, the settings will work fine. However, if
N* you have similar defines in other sections of your program, you might
N* want to change or relocate these defines, e.g. in a TYPE.h file.
N*/
N#define I16P I16              /*   signed 16 bits OR MORE ! */
N#define U16P U16              /* unsigned 16 bits OR MORE ! */
N
N/*********************************************************************
N*
N*       Settings for windows simulation
N*
N* Some settings in the configuration may conflict with the values required
N* in the Simulation. This is why we ignore the target settings for data
N* types and use the correct settings for the simulation.
N* (U32 could be defined as long, which would yield a 64 bit type on
N* the PC)
N*/
N#ifdef WIN32
S  #pragma warning( disable : 4244 )  // Disable warning messages in simulation
S  #pragma warning( disable : 4761 )  // Disable warning "integral size mismatch in argument; conversion supplied"
N#endif
N
N/*********************************************************************
N*
N*       Constants
N*/
N#define LCD_ERR0 (0x10)
N#define LCD_ERR_CONTROLLER_NOT_FOUND (LCD_ERR0+1)
N#define LCD_ERR_MEMORY               (LCD_ERR0+2)
N
N/*********************************************************************
N*
N*       Drawing modes
N*/
N#define LCD_DRAWMODE_NORMAL (0)
N#define LCD_DRAWMODE_XOR    (1<<0)
N#define LCD_DRAWMODE_TRANS  (1<<1)
N#define LCD_DRAWMODE_REV    (1<<2)
N
N/*********************************************************************
N*
N*       Typedefs
N*/
Ntypedef int LCD_DRAWMODE;
Ntypedef U32 LCD_COLOR;
Xtypedef unsigned long LCD_COLOR;
N
N/*********************************************************************
N*
N*       Data structures
N*/
Ntypedef struct { I16P x,y; } GUI_POINT;
Xtypedef struct { signed short x,y; } GUI_POINT;
Ntypedef struct { I16 x0,y0,x1,y1; } LCD_RECT;
Xtypedef struct { signed short x0,y0,x1,y1; } LCD_RECT;
N
Ntypedef struct {
N  int              NumEntries;
N  char             HasTrans;
N  const LCD_COLOR * pPalEntries;
N} LCD_LOGPALETTE;
N
N/* This is used for the simulation only ! */
Ntypedef struct {
N  int x,y;
N  unsigned char KeyStat;
N} LCD_tMouseState;
N
Ntypedef struct {
N  int               NumEntries;
N  const LCD_COLOR * pPalEntries;
N} LCD_PHYSPALETTE;
N
N/*********************************************************************
N*
N*       LCD_L0_... color conversion
N*/
Ntypedef LCD_COLOR      tLCDDEV_Index2Color  (LCD_PIXELINDEX Index);
Xtypedef LCD_COLOR      tLCDDEV_Index2Color  (unsigned long Index);
Ntypedef LCD_PIXELINDEX tLCDDEV_Color2Index  (LCD_COLOR Color);
Xtypedef unsigned long tLCDDEV_Color2Index  (LCD_COLOR Color);
Ntypedef LCD_PIXELINDEX tLCDDEV_GetIndexMask (void);
Xtypedef unsigned long tLCDDEV_GetIndexMask (void);
N
Ntypedef void tLCDDEV_Index2ColorBulk(void * pIndex, LCD_COLOR * pColor, U32 NumItems, U8 SizeOfIndex);
Xtypedef void tLCDDEV_Index2ColorBulk(void * pIndex, LCD_COLOR * pColor, unsigned long NumItems, unsigned char SizeOfIndex);
Ntypedef void tLCDDEV_Color2IndexBulk(LCD_COLOR * pColor, void * pIndex, U32 NumItems, U8 SizeOfIndex);
Xtypedef void tLCDDEV_Color2IndexBulk(LCD_COLOR * pColor, void * pIndex, unsigned long NumItems, unsigned char SizeOfIndex);
N
N/*********************************************************************
N*
N*       Color conversion API tables
N*/
Ntypedef struct {
N  tLCDDEV_Color2Index  * pfColor2Index;
N  tLCDDEV_Index2Color  * pfIndex2Color;
N  tLCDDEV_GetIndexMask * pfGetIndexMask;
N  int NoAlpha;
N  tLCDDEV_Color2IndexBulk * pfColor2IndexBulk;
N  tLCDDEV_Index2ColorBulk * pfIndex2ColorBulk;
N} LCD_API_COLOR_CONV;
N
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_0;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_1;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_1_2;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_1_4;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_1_5;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_1_8;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_1_16;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_1_24;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_2;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_4;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_5;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_6;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_8;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_16;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_1616I;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_111;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_222;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_2222;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_233;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_323;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_332;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_444_12;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_444_12_1;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_444_16;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_555;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_565;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_556;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_655;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_666;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_666_9;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_666_18;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_822216;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_84444;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_8666;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_8666_1;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_88666I;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_888;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_8888;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_8888I;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_M111;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_M1555I;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_M222;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_M2222I;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_M233;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_M323;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_M332;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_M4444I;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_M444_12;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_M444_12_1;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_M444_16;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_M555;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_M565;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_M556;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_M655;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_M666;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_M666_9;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_M666_18;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_M8565;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_M888;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_M8888;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_M8888I;
N
N#define GUICC_0         &LCD_API_ColorConv_0
N#define GUICC_1         &LCD_API_ColorConv_1
N#define GUICC_1_2       &LCD_API_ColorConv_1_2
N#define GUICC_1_4       &LCD_API_ColorConv_1_4
N#define GUICC_1_5       &LCD_API_ColorConv_1_5
N#define GUICC_1_8       &LCD_API_ColorConv_1_8
N#define GUICC_1_16      &LCD_API_ColorConv_1_16
N#define GUICC_1_24      &LCD_API_ColorConv_1_24
N#define GUICC_2         &LCD_API_ColorConv_2
N#define GUICC_4         &LCD_API_ColorConv_4
N#define GUICC_5         &LCD_API_ColorConv_5
N#define GUICC_6         &LCD_API_ColorConv_6
N#define GUICC_8         &LCD_API_ColorConv_8
N#define GUICC_16        &LCD_API_ColorConv_16
N#define GUICC_1616I     &LCD_API_ColorConv_1616I
N#define GUICC_111       &LCD_API_ColorConv_111
N#define GUICC_222       &LCD_API_ColorConv_222
N#define GUICC_2222      &LCD_API_ColorConv_2222
N#define GUICC_233       &LCD_API_ColorConv_233
N#define GUICC_323       &LCD_API_ColorConv_323
N#define GUICC_332       &LCD_API_ColorConv_332
N#define GUICC_M4444I    &LCD_API_ColorConv_M4444I
N#define GUICC_444_12    &LCD_API_ColorConv_444_12
N#define GUICC_444_12_1  &LCD_API_ColorConv_444_12_1
N#define GUICC_444_16    &LCD_API_ColorConv_444_16
N#define GUICC_555       &LCD_API_ColorConv_555
N#define GUICC_565       &LCD_API_ColorConv_565
N#define GUICC_556       &LCD_API_ColorConv_556
N#define GUICC_655       &LCD_API_ColorConv_655
N#define GUICC_666       &LCD_API_ColorConv_666
N#define GUICC_666_9     &LCD_API_ColorConv_666_9
N#define GUICC_666_18    &LCD_API_ColorConv_666_18
N#define GUICC_822216    &LCD_API_ColorConv_822216
N#define GUICC_84444     &LCD_API_ColorConv_84444
N#define GUICC_8666      &LCD_API_ColorConv_8666
N#define GUICC_8666_1    &LCD_API_ColorConv_8666_1
N#define GUICC_88666I    &LCD_API_ColorConv_88666I
N#define GUICC_888       &LCD_API_ColorConv_888
N#define GUICC_8888      &LCD_API_ColorConv_8888
N#define GUICC_8888I     &LCD_API_ColorConv_8888I
N#define GUICC_M111      &LCD_API_ColorConv_M111
N#define GUICC_M1555I    &LCD_API_ColorConv_M1555I
N#define GUICC_M222      &LCD_API_ColorConv_M222
N#define GUICC_M2222I    &LCD_API_ColorConv_M2222I
N#define GUICC_M233      &LCD_API_ColorConv_M233
N#define GUICC_M323      &LCD_API_ColorConv_M323
N#define GUICC_M332      &LCD_API_ColorConv_M332
N#define GUICC_M444_12   &LCD_API_ColorConv_M444_12
N#define GUICC_M444_12_1 &LCD_API_ColorConv_M444_12_1
N#define GUICC_M444_16   &LCD_API_ColorConv_M444_16
N#define GUICC_M555      &LCD_API_ColorConv_M555
N#define GUICC_M565      &LCD_API_ColorConv_M565
N#define GUICC_M556      &LCD_API_ColorConv_M556
N#define GUICC_M655      &LCD_API_ColorConv_M655
N#define GUICC_M666      &LCD_API_ColorConv_M666
N#define GUICC_M666_9    &LCD_API_ColorConv_M666_9
N#define GUICC_M666_18   &LCD_API_ColorConv_M666_18
N#define GUICC_M8565     &LCD_API_ColorConv_M8565
N#define GUICC_M888      &LCD_API_ColorConv_M888
N#define GUICC_M8888     &LCD_API_ColorConv_M8888
N#define GUICC_M8888I    &LCD_API_ColorConv_M8888I
N
Nvoid GUICC_M1555I_SetCustColorConv(tLCDDEV_Color2IndexBulk * pfColor2IndexBulk, tLCDDEV_Index2ColorBulk * pfIndex2ColorBulk);
Nvoid GUICC_M565_SetCustColorConv  (tLCDDEV_Color2IndexBulk * pfColor2IndexBulk, tLCDDEV_Index2ColorBulk * pfIndex2ColorBulk);
Nvoid GUICC_M4444I_SetCustColorConv(tLCDDEV_Color2IndexBulk * pfColor2IndexBulk, tLCDDEV_Index2ColorBulk * pfIndex2ColorBulk);
Nvoid GUICC_M888_SetCustColorConv  (tLCDDEV_Color2IndexBulk * pfColor2IndexBulk, tLCDDEV_Index2ColorBulk * pfIndex2ColorBulk);
Nvoid GUICC_M8888I_SetCustColorConv(tLCDDEV_Color2IndexBulk * pfColor2IndexBulk, tLCDDEV_Index2ColorBulk * pfIndex2ColorBulk);
N
N/*********************************************************************
N*
N*       Compatibility defines for older versions
N*/
N#define GUI_COLOR_CONV_1    GUICC_1
N#define GUI_COLOR_CONV_2    GUICC_2
N#define GUI_COLOR_CONV_4    GUICC_4
N#define GUI_COLOR_CONV_8666 GUICC_8666
N#define GUI_COLOR_CONV_888  GUICC_888
N#define GUI_COLOR_CONV_8888 GUICC_8888
N#define GUI_COLOR_CONV_565  GUICC_565
N#define GUI_COLOR_CONV_M565 GUICC_M565
N
N/*********************************************************************
N*
N*       LCDDEV function table
N*
N*  Below the routines which need to in an LCDDEV routine table are
N*  defined. All of these routines have to be in the low-level driver
N*  (LCD_L0) or in the memory device which can be used to replace the
N*  driver.
N*  The one exception to this is the SetClipRect routine, which would
N*  be identical for all drivers and is therefor contained in the
N*  level above (LCD).
N*/
Ntypedef void         tLCDDEV_DrawPixel    (int x, int y);
Ntypedef void         tLCDDEV_DrawHLine    (int x0, int y0,  int x1);
Ntypedef void         tLCDDEV_DrawVLine    (int x , int y0,  int y1);
Ntypedef void         tLCDDEV_FillRect     (int x0, int y0, int x1, int y1);
Ntypedef unsigned int tLCDDEV_GetPixelIndex(int x, int y);
Ntypedef void         tLCDDEV_SetPixelIndex(int x, int y, int ColorIndex);
Ntypedef void         tLCDDEV_XorPixel     (int x, int y);
Ntypedef void         tLCDDEV_FillPolygon  (const GUI_POINT * pPoints, int NumPoints, int x0, int y0);
Ntypedef void         tLCDDEV_FillPolygonAA(const GUI_POINT * pPoints, int NumPoints, int x0, int y0);
Ntypedef void         tLCDDEV_GetRect      (LCD_RECT * pRect);
Ntypedef int          tLCDDEV_Init         (void);
Ntypedef void         tLCDDEV_On           (void);
Ntypedef void         tLCDDEV_Off          (void);
Ntypedef void         tLCDDEV_SetLUTEntry  (U8 Pos, LCD_COLOR color);
Xtypedef void         tLCDDEV_SetLUTEntry  (unsigned char Pos, LCD_COLOR color);
Ntypedef void *       tLCDDEV_GetDevFunc   (int Index);
Ntypedef I32          tLCDDEV_GetDevProp   (int Index);
Xtypedef signed long          tLCDDEV_GetDevProp   (int Index);
Ntypedef void         tLCDDEV_SetOrg       (int x, int y);
N
N/*********************************************************************
N*
N*       Memory device API tables
N*/
Ntypedef struct GUI_DEVICE     GUI_DEVICE;
Ntypedef struct GUI_DEVICE_API GUI_DEVICE_API;
N
Ntypedef void tLCDDEV_DrawBitmap   (int x0, int y0, int xsize, int ysize,
N                       int BitsPerPixel, int BytesPerLine,
N                       const U8 * pData, int Diff,
X                       const unsigned char * pData, int Diff,
N                       const void * pTrans);   /* Really LCD_PIXELINDEX, but is void to avoid compiler warnings */
N
N/*********************************************************************
N*
N*       Memory device color depths
N*
N*  Description
N*    Defines the color depth of the Memory Device in bpp. The color depth of the Memory Device should be
N*    equal or greater than the required bits for the color conversion routines.
N*
N*  Additional information
N*    A Memory Device with a 1bpp color conversion (GUI_COLOR_CONV_1) for example requires at least a Memory Device with
N*    1bpp color depth. The available Memory Devices are 1bpp, 8bpp, 16bpp and 32bpp Memory Devices. So an 1bpp Memory
N*    Device should be used.
N*
N*    If using a 4 bit per pixel color conversion (GUI_COLOR_CONV_4) at least 4bpp are needed for the Memory Device. In this
N*    case an 8bpp Memory Device should be used.
N*/
N#define GUI_MEMDEV_APILIST_1  &GUI_MEMDEV_DEVICE_1    // Create Memory Device with 1bpp color depth (1 byte per 8 pixels). Use if the specified color conversion requires 1bpp.
N#define GUI_MEMDEV_APILIST_8  &GUI_MEMDEV_DEVICE_8    // Create Memory Device with 8bpp color depth (1 byte per pixel). Use if the specified color conversion requires 8bpp or less.
N#define GUI_MEMDEV_APILIST_16 &GUI_MEMDEV_DEVICE_16   // Create Memory Device with 16bpp color depth (1 U16 per pixel). Use if the specified color conversion requires more than 8 bpp (high color modes).
N#define GUI_MEMDEV_APILIST_32 &GUI_MEMDEV_DEVICE_32   // Create Memory Device with 32bpp color depth (1 U32 per pixel). Use if the specified color conversion requires more than 16 bpp (true color modes).
N
N/*********************************************************************
N*
N*       Defines for device capabilities
N*
N* The following is the list of device capabilities which can, but do
N* not have to be implemented in the driver. This way the driver can be
N* enhanced in the future without affecting the driver interface,
N* keeping older drivers compatible.
N* More DevCaps can always be added in the future, as older drivers
N* are guaranteed to return 0 for all unimplemented features or queries.
N*
N* The values below define the legal parameters to the LCD_GetDeviceCaps
N* and the LCD_GetpCapFunc routines.
N*/
N
N#define LCD_DEVCAP_XSIZE             0x01    // Quest horiz. res. of display
N#define LCD_DEVCAP_YSIZE             0x02    // Quest vert. res. of display
N#define LCD_DEVCAP_VXSIZE            0x03    // Quest vert. res. of virtual disp.*/
N#define LCD_DEVCAP_VYSIZE            0x04    // Quest vert. res. of virtual disp.*/
N#define LCD_DEVCAP_XORG              0x05    // X-origin ... usually 0
N#define LCD_DEVCAP_YORG              0x06    // Y-origin ... usually 0
N#define LCD_DEVCAP_CONTROLLER        0x07    // LCD Controller (Numerical)
N#define LCD_DEVCAP_BITSPERPIXEL      0x08    // Bits per pixel ... 1/2/4/8
N#define LCD_DEVCAP_NUMCOLORS         0x09    // Quest number of colors
N#define LCD_DEVCAP_XMAG              0x0A
N#define LCD_DEVCAP_YMAG              0x0B
N#define LCD_DEVCAP_MIRROR_X          0x0C
N#define LCD_DEVCAP_MIRROR_Y          0x0D
N#define LCD_DEVCAP_SWAP_XY           0x0E
N#define LCD_DEVCAP_SWAP_RB           0x0F
N#define LCD_DEVCAP_XSIZE_SIM         0x10
N#define LCD_DEVCAP_YSIZE_SIM         0x11
N#define LCD_DEVCAP_VXSIZE_SIM        0x12
N#define LCD_DEVCAP_VYSIZE_SIM        0x13
N#define LCD_DEVCAP_THRESHOLD         0x14    // Get threshold in pixels for calling HW function
N
Nint LCD_GetXSizeMax(void);
Nint LCD_GetYSizeMax(void);
Nint LCD_GetVXSizeMax(void);
Nint LCD_GetVYSizeMax(void);
Nint LCD_GetBitsPerPixelMax(void);
Nvoid LCD_SetDisplaySize(int xSizeDisplay, int ySizeDisplay);
Nint LCD_GetXSizeDisplay(void);
Nint LCD_GetYSizeDisplay(void);
N
Nint LCD_GetXSizeEx          (int LayerIndex);
Nint LCD_GetYSizeEx          (int LayerIndex);
Nint LCD_GetVXSizeEx         (int LayerIndex);
Nint LCD_GetVYSizeEx         (int LayerIndex);
Nint LCD_GetBitsPerPixelEx   (int LayerIndex);
NU32 LCD_GetNumColorsEx      (int LayerIndex);
Xunsigned long LCD_GetNumColorsEx      (int LayerIndex);
Nint LCD_GetXMagEx           (int LayerIndex);
Nint LCD_GetYMagEx           (int LayerIndex);
Nint LCD_GetMirrorXEx        (int LayerIndex);
Nint LCD_GetMirrorYEx        (int LayerIndex);
Nint LCD_GetSwapXYEx         (int LayerIndex);
Nint LCD_GetReversLUTEx      (int LayerIndex);
Nint LCD_GetPhysColorsInRAMEx(int LayerIndex);
N
Nint LCD_GetXSize            (void);
Nint LCD_GetYSize            (void);
Nint LCD_GetVXSize           (void);
Nint LCD_GetVYSize           (void);
Nint LCD_GetBitsPerPixel     (void);
NU32 LCD_GetNumColors        (void);
Xunsigned long LCD_GetNumColors        (void);
Nint LCD_GetXMag             (void);
Nint LCD_GetYMag             (void);
Nint LCD_GetMirrorX          (void);
Nint LCD_GetMirrorY          (void);
Nint LCD_GetSwapXY           (void);
Nint LCD_GetReversLUT        (void);
Nint LCD_GetPhysColorsInRAM  (void);
N
NI32 LCD__GetBPP      (U32 IndexMask);
Xsigned long LCD__GetBPP      (unsigned long IndexMask);
NI32 LCD__GetBPPDevice(U32 IndexMask);
Xsigned long LCD__GetBPPDevice(unsigned long IndexMask);
N
NtLCDDEV_Index2Color * LCD_GetpfIndex2ColorEx(int LayerIndex);
NtLCDDEV_Color2Index * LCD_GetpfColor2IndexEx(int LayerIndex);
N
NtLCDDEV_Color2Index * LCD_GetpfColor2Index(void);
N
Nint LCD_GetNumLayers(void);
N
NLCD_COLOR * LCD_GetPalette   (void);
NLCD_COLOR * LCD_GetPaletteEx (int LayerIndex);
Nvoid      * LCD_GetVRAMAddr  (void);
Nvoid      * LCD_GetVRAMAddrEx(int LayerIndex);
N
Nvoid (* LCD_GetDevFunc(int LayerIndex, int Item))(void);
Nint     LCD_GetHasFunc(int LayerIndex, int Item);
N
N/*********************************************************************
N*
N*       Runtime rotation of drivers
N*/
Nint  LCD_ROTATE_AddDriver             (const GUI_DEVICE_API * pDriver);
Nint  LCD_ROTATE_AddDriverEx           (const GUI_DEVICE_API * pDeviceAPI, int LayerIndex);
Nint  LCD_ROTATE_AddDriverExOrientation(const GUI_DEVICE_API * pDeviceAPI, int LayerIndex, int Orientation);
Nvoid LCD_ROTATE_Clear                 (void);
Nvoid LCD_ROTATE_ClearEx               (int LayerIndex);
Nint  LCD_ROTATE_DecSel                (void);
Nint  LCD_ROTATE_DecSelEx              (int LayerIndex);
Nint  LCD_ROTATE_GetCurrentIndex       (void);
Nint  LCD_ROTATE_GetCurrentIndexEx     (int LayerIndex);
Nint  LCD_ROTATE_GetCurrentOrientation (void);
Nint  LCD_ROTATE_GetOrientation        (int DriverIndex);
Nint  LCD_ROTATE_GetOrientationEx      (int LayerIndex, int DriverIndex);
Nint  LCD_ROTATE_GetNumDrivers         (void);
Nint  LCD_ROTATE_GetNumDriversEx       (int LayerIndex);
Nint  LCD_ROTATE_IncSel                (void);
Nint  LCD_ROTATE_IncSelEx              (int LayerIndex);
Nint  LCD_ROTATE_SetCallback           (void (* pCbOnConfig)(GUI_DEVICE *, int, int), int LayerIndex);
Nint  LCD_ROTATE_SetSel                (int Index);
Nint  LCD_ROTATE_SetSelEx              (int Index, int LayerIndex);
N
N/*********************************************************************
N*
N*       Values for requesting and setting function pointers (display driver)
N*/
N                                       /* Request of a function pointer for... */
N#define LCD_DEVFUNC_READRECT      0x01 /* ...reading a rectangular display area */
N#define LCD_DEVFUNC_SETALPHA      0x02 /* ...setting the alpha blending factor */
N#define LCD_DEVFUNC_SETPOS        0x03 /* ...setting the layer position */
N#define LCD_DEVFUNC_GETPOS        0x04 /* ...getting the layer position */
N#define LCD_DEVFUNC_SETSIZE       0x05 /* ...setting the layer size */
N#define LCD_DEVFUNC_SETVIS        0x06 /* ...setting the visibility of a layer */
N#define LCD_DEVFUNC_24BPP         0x07 /* ...drawing 24bpp bitmaps */
N#define LCD_DEVFUNC_SET_VRAM_ADDR 0x09 /* ...setting the VRAM address */
N#define LCD_DEVFUNC_SET_VSIZE     0x0A /* ...setting the VRAM size */
N#define LCD_DEVFUNC_SET_SIZE      0x0B /* ...setting the display size */
N#define LCD_DEVFUNC_INIT          0x0C /* ...initializing the display controller */
N#define LCD_DEVFUNC_CONTROLCACHE  0x0D /* ...controlling the cache */
N#define LCD_DEVFUNC_ON            0x0E /* ...switching the display on */
N#define LCD_DEVFUNC_OFF           0x0F /* ...switching the display off */
N#define LCD_DEVFUNC_SETLUTENTRY   0x10 /* ...setting a LUT entry */
N#define LCD_DEVFUNC_FILLPOLY      0x11 /* ...filling a polygon */
N#define LCD_DEVFUNC_FILLPOLYAA    0x12 /* ...filling an antialiased polygon */
N#define LCD_DEVFUNC_ALPHAMODE     0x13 /* ...setting the alpha blending mode */
N#define LCD_DEVFUNC_CHROMAMODE    0x14 /* ...setting the chroma blending mode */
N#define LCD_DEVFUNC_CHROMA        0x15 /* ...setting the chroma values */
N#define LCD_DEVFUNC_SETFUNC       0x16 /* ...setting a function pointer */
N#define LCD_DEVFUNC_REFRESH       0x17 /* ...refreshing the display */
N#define LCD_DEVFUNC_SETRECT       0x18 /* ...setting the drawing rectangle */
N#define LCD_DEVFUNC_SETTHRESHOLD  0x19 /* ...setting threshold for calling HW function */
N                                       /* Setting a function pointer for... */
N#define LCD_DEVFUNC_FILLRECT      0x1A /* ...filling a rectangular area */
N#define LCD_DEVFUNC_DRAWBMP_1BPP  0x1B /* ...drawing a 1bpp bitmap */
N#define LCD_DEVFUNC_COPYBUFFER    0x1C /* ...copying complete frame buffers */
N#define LCD_DEVFUNC_SHOWBUFFER    0x1D /* ...shows the given buffer */
N#define LCD_DEVFUNC_COPYRECT      0x1E /* ...copying a rectangular area */
N#define LCD_DEVFUNC_DRAWBMP_16BPP 0x1F /* ...drawing a 16bpp bitmap */
N#define LCD_DEVFUNC_DRAWBMP_8BPP  0x20 /* ...drawing a 8bpp bitmap */
N#define LCD_DEVFUNC_READPIXEL     0x21 /* ...reading a pixel index */
N#define LCD_DEVFUNC_READMPIXELS   0x22 /* ...reading multiple pixel indices */
N#define LCD_DEVFUNC_DRAWBMP_32BPP 0x23 /* ...drawing a 32bpp bitmap */
N#define LCD_DEVFUNC_SET_BUFFERPTR 0x24 /* ...setting an array of buffer pointers */
N#define LCD_DEVFUNC_EXIT          0x25 /* ...free memory and shut down controller */
N#define LCD_DEVFUNC_INIT_PRIVATE  0x26 /* ...initializing the display driver */
N
N/*********************************************************************
N*
N*       Values for requesting function pointers (memory devices)
N*/
N                                          /* Request of a function pointer for... */
N#define MEMDEV_DEVFUNC_WRITETOACTIVE 0x16 /* ...writing the memory device */
N
N/*********************************************************************
N*
N*       Values for requesting data
N*/
N                                       /* Request pointer to... */
N#define LCD_DEVDATA_MEMDEV        0x01 /* ...default memory device API */
N#define LCD_DEVDATA_PHYSPAL       0x02 /* ...physical palette */
N#define LCD_DEVDATA_VRAMADDR      0x03 /* ...VRAM address */
N#define LCD_DEVDATA_NEXT_PIXEL    0x04 /* ...drawing a bitmap pixel by pixel */
N
N/*********************************************************************
N*
N*       Structures for passing data to LCD_X_DisplayDriver()
N*/
Ntypedef struct {
N  void * pVRAM;
N} LCD_X_SETVRAMADDR_INFO;
N
Ntypedef struct {
N  int xPos, yPos;
N} LCD_X_SETORG_INFO;
N
Ntypedef struct {
N  LCD_COLOR Color;
N  U8 Pos;
X  unsigned char Pos;
N} LCD_X_SETLUTENTRY_INFO;
N
Ntypedef struct {
N  int xSize, ySize;
N} LCD_X_SETSIZE_INFO;
N
Ntypedef struct {
N  int xPos, yPos;
N  int xLen, yLen;
N  int BytesPerPixel;
N  U32 Off;
X  unsigned long Off;
N} LCD_X_SETPOS_INFO;
N
Ntypedef struct {
N  int Alpha;
N} LCD_X_SETALPHA_INFO;
N
Ntypedef struct {
N  int OnOff;
N} LCD_X_SETVIS_INFO;
N
Ntypedef struct {
N  int AlphaMode;
N} LCD_X_SETALPHAMODE_INFO;
N
Ntypedef struct {
N  int ChromaMode;
N} LCD_X_SETCHROMAMODE_INFO;
N
Ntypedef struct {
N  LCD_COLOR ChromaMin;
N  LCD_COLOR ChromaMax;
N} LCD_X_SETCHROMA_INFO;
N
Ntypedef struct {
N  int Index;
N} LCD_X_SHOWBUFFER_INFO;
N
N/*********************************************************************
N*
N*       Commands for LCD_X_DisplayDriver()
N*/
N#define LCD_X_INITCONTROLLER 0x01 /* Initializing the display controller */
N#define LCD_X_SETVRAMADDR    0x02 /* Setting the video RAM address */
N#define LCD_X_SETORG         0x03 /* Setting the origin within a layer */
N#define LCD_X_SETLUTENTRY    0x04 /* Setting an entry of the LUT */
N#define LCD_X_ON             0x05 /* Switching the display on */
N#define LCD_X_OFF            0x06 /* Switching the display off */
N#define LCD_X_SETSIZE        0x07 /* Setting the layer size */
N#define LCD_X_SETPOS         0x08 /* Setting the layer position */
N#define LCD_X_SETVIS         0x09 /* Setting the visibility of a layer */
N#define LCD_X_SETALPHA       0x0A /* Setting the alpha value of the layer */
N#define LCD_X_SETALPHAMODE   0x0B /* Setting the alpha blending mode */
N#define LCD_X_SETCHROMAMODE  0x0C /* Setting the chroma blending mode */
N#define LCD_X_SETCHROMA      0x0D /* Setting the chroma values */
N#define LCD_X_SHOWBUFFER     0x0E /* Switching to the given buffer */
N#define LCD_X_EXITCONTROLLER 0x0F /* Exiting the display controller */
N
Nint  LCD_X_DisplayDriver(unsigned LayerIndex, unsigned Cmd, void * pData);
Nvoid LCD_X_Config(void);
N
N/*********************************************************************
N*
N*       Get/Set layer properties
N*/
Nint  LCD_GetPosEx       (int LayerIndex, int * pxPos, int * pyPos);
Nint  LCD_OffEx          (int LayerIndex);
Nint  LCD_OnEx           (int LayerIndex);
Nint  LCD_RefreshEx      (int LayerIndex);
Nint  LCD_SetAlphaEx     (int LayerIndex, int Alpha);
Nint  LCD_SetAlphaModeEx (int LayerIndex, int AlphaMode);
Nint  LCD_SetBufferPtrEx (int LayerIndex, void ** pBufferPTR);
Nint  LCD_SetChromaEx    (int LayerIndex, LCD_COLOR ChromaMin, LCD_COLOR ChromaMax);
Nint  LCD_SetChromaModeEx(int LayerIndex, int ChromaMode);
Nint  LCD_SetDevFunc     (int LayerIndex, int IdFunc, void (* pDriverFunc)(void));
Nint  LCD_SetLUTEntryEx  (int LayerIndex, U8 Pos, LCD_COLOR Color);
Xint  LCD_SetLUTEntryEx  (int LayerIndex, unsigned char Pos, LCD_COLOR Color);
Nint  LCD_SetPosEx       (int LayerIndex, int xPos, int yPos);
Nint  LCD_SetSizeEx      (int LayerIndex, int xSize, int ySize);
Nint  LCD_SetVisEx       (int LayerIndex, int OnOff);
Nint  LCD_SetVRAMAddrEx  (int LayerIndex, void * pVRAM);
Nint  LCD_SetVSizeEx     (int LayerIndex, int xSize, int ySize);
N
Nint  LCD_GetPos         (int * pxPos, int * pyPos);
Nint  LCD_Off            (void);
Nint  LCD_On             (void);
Nint  LCD_Refresh        (void);
Nint  LCD_SetAlpha       (int Alpha);
Nint  LCD_SetAlphaMode   (int AlphaMode);
Nint  LCD_SetBufferPtr   (void ** pBufferPTR);
Nint  LCD_SetChroma      (LCD_COLOR ChromaMin, LCD_COLOR ChromaMax);
Nint  LCD_SetChromaMode  (int ChromaMode);
Nint  LCD_SetLUTEntry    (U8 Pos, LCD_COLOR Color);
Xint  LCD_SetLUTEntry    (unsigned char Pos, LCD_COLOR Color);
Nvoid LCD_SetOrg         (int xOrg, int yOrg);
Nint  LCD_SetPos         (int xPos, int yPos);
Nint  LCD_SetSize        (int xSize, int ySize);
Nint  LCD_SetVis         (int OnOff);
Nint  LCD_SetVRAMAddr    (void * pVRAM);
Nint  LCD_SetVSize       (int xSize, int ySize);
N
N/*********************************************************************
N*
N*       NEXT_PIXEL API support
N*/
Ntypedef struct {
N  int  (* pfStart)   (int x0, int y0, int x1, int y1);
N  void (* pfSetPixel)(LCD_PIXELINDEX PixelIndex);
X  void (* pfSetPixel)(unsigned long PixelIndex);
N  void (* pfNextLine)(void);
N  void (* pfEnd)     (void);
N} LCD_API_NEXT_PIXEL;
N
NLCD_API_NEXT_PIXEL * LCD_GetNextPixelAPI(void);
N
N/*********************************************************************
N*
N*      LCD_CLIP function table
N*/
Ntypedef void tLCD_HL_DrawHLine    (int x0, int y0,  int x1);
Ntypedef void tLCD_HL_DrawPixel    (int x0, int y0);
N
Ntypedef struct {
N  tLCD_HL_DrawHLine * pfDrawHLine;
N  tLCD_HL_DrawPixel * pfDrawPixel;
N} tLCD_HL_APIList;
N
Nvoid LCD_DrawHLine(int x0, int y0,  int x1);
Nvoid LCD_DrawPixel(int x0, int y0);
Nvoid LCD_DrawVLine(int x,  int y0,  int y1);
N
N
N/*********************************************************************
N*
N*       Declarations for LCD_
N*/
Nvoid LCD_SetClipRectEx(const LCD_RECT * pRect);
Nvoid LCD_SetClipRectMax(void);
N
N/* Get device capabilities (0 if not supported) */
NI32  LCD_GetDevCap  (int Index);
Xsigned long  LCD_GetDevCap  (int Index);
NI32  LCD_GetDevCapEx(int LayerIndex, int Index);
Xsigned long  LCD_GetDevCapEx(int LayerIndex, int Index);
N
N/* Initialize LCD using config-parameters */
Nint LCD_Init(void);
Nint LCD_InitColors(void);
Nint LCD_InitEx(GUI_DEVICE * pDevice, int ClearScreen);
Nint LCD_ExitEx(int LayerIndex);
N
Nvoid LCD_SetBkColor   (LCD_COLOR Color); /* Set background color */
Nvoid LCD_SetColor     (LCD_COLOR Color); /* Set foreground color */
Nvoid LCD_SetPixelIndex(int x, int y, int ColorIndex);
N
N/* Palette routines (Not available on all drivers) */
Nvoid LCD_InitLUT(void);
Nvoid LCD_SetLUTEx(int LayerIndex, const LCD_PHYSPALETTE * pPalette);
Nvoid LCD_SetLUT  (const LCD_PHYSPALETTE * pPalette);
N
NLCD_DRAWMODE LCD_SetDrawMode  (LCD_DRAWMODE dm);
Nvoid LCD_SetColorIndex(unsigned PixelIndex);
Nvoid LCD_SetBkColorIndex(unsigned PixelIndex);
Nvoid LCD_FillRect(int x0, int y0, int x1, int y1);
Ntypedef void tLCD_SetPixelAA(int x, int y, U8 Intens);
Xtypedef void tLCD_SetPixelAA(int x, int y, unsigned char Intens);
N
Nvoid LCD_SetPixelAA4_Trans  (int x, int y, U8 Intens);
Xvoid LCD_SetPixelAA4_Trans  (int x, int y, unsigned char Intens);
Nvoid LCD_SetPixelAA4_NoTrans(int x, int y, U8 Intens);
Xvoid LCD_SetPixelAA4_NoTrans(int x, int y, unsigned char Intens);
N
Nvoid LCD_SetPixelAA8_Trans  (int x, int y, U8 Intens);
Xvoid LCD_SetPixelAA8_Trans  (int x, int y, unsigned char Intens);
Nvoid LCD_SetPixelAA8_NoTrans(int x, int y, U8 Intens);
Xvoid LCD_SetPixelAA8_NoTrans(int x, int y, unsigned char Intens);
N
Nvoid LCD_AA_EnableGamma(int OnOff);
Nvoid LCD_AA_SetGamma   (U8 * pGamma);
Xvoid LCD_AA_SetGamma   (unsigned char * pGamma);
Nvoid LCD_AA_GetGamma   (U8 * pGamma);
Xvoid LCD_AA_GetGamma   (unsigned char * pGamma);
N
NLCD_COLOR    LCD_AA_MixColors16 (LCD_COLOR Color, LCD_COLOR BkColor, U8 Intens);
XLCD_COLOR    LCD_AA_MixColors16 (LCD_COLOR Color, LCD_COLOR BkColor, unsigned char Intens);
NLCD_COLOR    LCD_AA_MixColors256(LCD_COLOR Color, LCD_COLOR BkColor, U8 Intens);
XLCD_COLOR    LCD_AA_MixColors256(LCD_COLOR Color, LCD_COLOR BkColor, unsigned char Intens);
NLCD_COLOR    LCD_MixColors256   (LCD_COLOR Color, LCD_COLOR BkColor, U8 Intens);
XLCD_COLOR    LCD_MixColors256   (LCD_COLOR Color, LCD_COLOR BkColor, unsigned char Intens);
NLCD_COLOR    LCD_GetPixelColor(int x, int y);     /* Get RGB color of pixel */
Nunsigned int LCD_GetPixelIndex(int x, int y);
Nint          LCD_GetBkColorIndex (void);
Nint          LCD_GetColorIndex (void);
N#if (GUI_USE_ARGB)
X#if (1)
NU32          LCD_AA_SetOrMask(U32 OrMask);
Xunsigned long          LCD_AA_SetOrMask(unsigned long OrMask);
N#else
SU32          LCD_AA_SetAndMask(U32 AndMask);
N#endif
N
N/* Configuration */
Nint  LCD_SetMaxNumColors(unsigned MaxNumColors);
Nint  LCD_GetMaxNumColors(void);
Nvoid LCD__SetPaletteConversionHook(void (* pfPaletteConversionHook)(const LCD_LOGPALETTE * pLogPal));
N
N/*********************************************************************
N*
N*       Optional support for rotation
N*/
N#if GUI_SUPPORT_ROTATION
X#if 1
N
Ntypedef void tLCD_DrawBitmap(int x0, int y0, int xsize, int ysize,
N                             int xMul, int yMul, int BitsPerPixel, int BytesPerLine,
N                             const U8 * pPixel, const void * pTrans);
X                             const unsigned char * pPixel, const void * pTrans);
Ntypedef void tRect2TextRect (LCD_RECT * pRect);
N
Nstruct tLCD_APIList_struct {
N  tLCD_DrawBitmap   * pfDrawBitmap;
N  tRect2TextRect    * pfRect2TextRect;
N  tRect2TextRect    * pfTransformRect;
N};
N
Ntypedef struct tLCD_APIList_struct tLCD_APIList;
N
Nextern tLCD_APIList LCD_APIListCCW;
Nextern tLCD_APIList LCD_APIListCW;
Nextern tLCD_APIList LCD_APIList180;
N
N#define GUI_ROTATION   tLCD_APIList
N#define GUI_ROTATE_CCW &LCD_APIListCCW
N#define GUI_ROTATE_CW  &LCD_APIListCW
N#define GUI_ROTATE_180 &LCD_APIList180
N#define GUI_ROTATE_0   0
N
NtLCD_SetPixelAA * LCD__GetPfSetPixel(int BitsPerPixel);
N
N#endif
N
N/*********************************************************************
N*
N*       Physical color access, internally used only
N*/
Nvoid LCD__SetPhysColor(U8 Pos, LCD_COLOR Color);
Xvoid LCD__SetPhysColor(unsigned char Pos, LCD_COLOR Color);
N
N/*********************************************************************
N*
N*       Cache control
N*/
N#define LCD_CC_UNLOCK (0)    /* Default mode: Cache is transparent */
N#define LCD_CC_LOCK   (1)    /* Cache is locked, no write operations */
N#define LCD_CC_FLUSH  (2)    /* Flush cache, do not change mode */
N
Nint LCD_ControlCache  (int Cmd);
Nint LCD_ControlCacheEx(int LayerIndex, int Cmd);
N
N/*********************************************************************
N*
N*       Color conversion
N*/
NLCD_PIXELINDEX   LCD_Color2Index     (LCD_COLOR Color);
Xunsigned long   LCD_Color2Index     (LCD_COLOR Color);
NLCD_COLOR        LCD_Index2Color     (int Index);
NLCD_COLOR        LCD_Index2ColorEx   (int i, unsigned LayerIndex);
N
N/*********************************************************************
N*
N*       LCD_X_...
N*/
Nunsigned char LCD_X_Read00(void);
Nunsigned char LCD_X_Read01(void);
Nvoid LCD_X_Write00 (unsigned char c);
Nvoid LCD_X_Write01 (unsigned char c);
Nvoid LCD_X_WriteM00(unsigned char * pData, int NumBytes);
Nvoid LCD_X_WriteM01(unsigned char * pData, int NumBytes);
N
N#if defined(__cplusplus)
X#if 0L
S  }
N#endif
N
N#endif /* LCD_H */
N
N/*************************** End of file ****************************/
L 53 "..\..\..\..\ThirdParty\emWin\Include\GUI_Type.h" 2
N#include "GUIConf.h"
N
N/*********************************************************************
N*
N*       Common types
N*/
Ntypedef const char *  GUI_ConstString;
N
Ntypedef LCD_COLOR       GUI_COLOR;
Ntypedef LCD_LOGPALETTE  GUI_LOGPALETTE;
Ntypedef LCD_DRAWMODE    GUI_DRAWMODE;
Ntypedef LCD_RECT        GUI_RECT;
N
Ntypedef struct {
N  I16 xSize;
X  signed short xSize;
N  I16 ySize;
X  signed short ySize;
N} GUI_SIZE;
N
Ntypedef struct {
N  void      (* pfDraw)  (int x0,
N                         int y0,
N                         int xsize, 
N                         int ysize, 
N                         const U8 * pPixel, 
X                         const unsigned char * pPixel, 
N                         const LCD_LOGPALETTE * pLogPal, 
N                         int xMag, 
N                         int yMag);
N  GUI_COLOR (* pfIndex2Color)(LCD_PIXELINDEX Index);
X  GUI_COLOR (* pfIndex2Color)(unsigned long Index);
N  void      (* pfDrawHW)(int x0,
N                         int y0,
N                         int xsize, 
N                         int ysize, 
N                         const U8 * pPixel, 
X                         const unsigned char * pPixel, 
N                         const LCD_LOGPALETTE * pLogPal, 
N                         int xMag, 
N                         int yMag);
N  const LCD_API_COLOR_CONV * pColorConvAPI;
N} GUI_BITMAP_METHODS;
N
Ntypedef struct {
N  U16P XSize;
X  unsigned short XSize;
N  U16P YSize;
X  unsigned short YSize;
N  U16P BytesPerLine;
X  unsigned short BytesPerLine;
N  U16P BitsPerPixel;
X  unsigned short BitsPerPixel;
N  const U8 * pData;
X  const unsigned char * pData;
N  const GUI_LOGPALETTE * pPal;
N  const GUI_BITMAP_METHODS * pMethods;
N} GUI_BITMAP;
N
N/* This structure may not be changed because the data that it
N   expects is read in binary form (via any kind of interface,
N   at runtime).
N   This structure should therefor not be changed.
N*/
Ntypedef struct {
N  U16 ID;
X  unsigned short ID;
N  U16 Format;
X  unsigned short Format;
N  U16 XSize;
X  unsigned short XSize;
N  U16 YSize;
X  unsigned short YSize;
N  U16 BytesPerLine;
X  unsigned short BytesPerLine;
N  U16 BitsPerPixel;
X  unsigned short BitsPerPixel;
N  U16 NumColors;
X  unsigned short NumColors;
N  U16 HasTrans;
X  unsigned short HasTrans;
N} GUI_BITMAP_STREAM;
N
N/*********************************************************************
N*
N*       GUI_BITMAPSTREAM_PARAM
N*
N*   Description
N*     Contains a command to be used by a set hook function for
N*     GUI_DrawStreamedBitmapEx().
N*/
Ntypedef struct {
N  int    Cmd;  // Command to be executed.
N  U32    v;    // Depends on the command to be executed.
X  unsigned long    v;    
N  void * p;    // Depends on the command to be executed.
N} GUI_BITMAPSTREAM_PARAM;
N
N/*********************************************************************
N*
N*       GUI_BITMAPSTREAM_INFO
N*
N*   Description
N*     Information about a streamed bitmap.
N*/
Ntypedef struct {
N  int XSize;          // Pixel size in X of the image.
N  int YSize;          // Pixel size in Y of the image.
N  int BitsPerPixel;   // Number of bits per pixel.
N  int NumColors;      // Number of colors in case of an index based image.
N  int HasTrans;       // In case of an index based image 1 if transparency exist, 0 if not.
N} GUI_BITMAPSTREAM_INFO;
N
Ntypedef void * (* GUI_BITMAPSTREAM_CALLBACK)(GUI_BITMAPSTREAM_PARAM * pParam);
N
N/*********************************************************************
N*
N*       GUI_GRADIENT_INFO
N*
N*   Description
N*     Information used for drawing multi-color gradients.
N*
N*   Additional information
N*     The member Pos is used to define the start and end
N*     position of the colors. It defines also the size of the gradient.
N*/
Ntypedef struct {
N  U16       Pos;    // Start position of color. The next entry is the end position. The last entry
X  unsigned short       Pos;    
N                    // also defines the x1 / y1 position of the gradient, either if it's a
N                    // horizontal or vertical gradient.
N  GUI_COLOR Color;  // Color to be used.
N} GUI_GRADIENT_INFO;
N
N/*********************************************************************
N*
N*       GUI_PID_STATE
N*
N*   Description
N*     Stores the position of the pointer input device.
N*/
Ntypedef struct {
N  int x;         // Horizontal position of the PID in window coordinates.
N  int y;         // Vertical position of the PID in window coordinates.
N  U8  Pressed;   // If the message is originated by a touch screen this value can be 0
X  unsigned char  Pressed;   
N                 // (unpressed) or 1 (pressed). \n If the message is originated by a mouse each
N                 // bit represents a mouse button (0 for unpressed and 1 for pressed state):
N                 // \ti{Bit 0 represents the first button (normally the left button)}
N                 // \ti{Bit 1 represents the second button (normally the right button)}
N                 // \ti{Bit 2 represents the third button (normally the middle button)}
N                 // The remaining bits can be used for further buttons.
N  U8  Layer;     // ID of layer.
X  unsigned char  Layer;     
N} GUI_PID_STATE;
N
N/*********************************************************************
N*
N*       GUI_KEY_STATE
N*
N*   Description
N*     Data structure used to store a key state.
N*/
Ntypedef struct {
N  int Key;       // Key code.
N  int Pressed;   // 1, if the key is pressed. \n
N                 // 0, if the key is not pressed. \n
N                 // -1, if the state could not be determined.
N} GUI_KEY_STATE;
N
N/*********************************************************************
N*
N*       GUI_GIF_IMAGE_INFO
N*
N*   Description
N*     Information about a sub-image in a GIF file.
N*/
Ntypedef struct {
N  int xPos;       // X-position of the last drawn image.
N  int yPos;       // Y-position of the last drawn image.
N  int xSize;      // X-size of the last drawn image.
N  int ySize;      // Y-size of the last drawn image.
N  int Delay;      // Time in 1/100 seconds the image should be shown in a movie.
N} GUI_GIF_IMAGE_INFO;
N
N/*********************************************************************
N*
N*       GUI_GIF_INFO
N*
N*   Description
N*     Information about a sub-image in a GIF file.
N*/
Ntypedef struct {
N  int xSize;      // Pixel size in X of the image.
N  int ySize;      // Pixel size in Y of the image.
N  int NumImages;  // Number of sub-images in the file.
N} GUI_GIF_INFO;
N
N#define GUI_REGISTER_INIT GUI_REGISTER_HOOK
N#define GUI_REGISTER_EXIT GUI_REGISTER_HOOK
N
Ntypedef struct GUI_REGISTER_HOOK GUI_REGISTER_HOOK;
N
Nstruct GUI_REGISTER_HOOK {
N  void (* pfVoid)(void);
N  GUI_REGISTER_HOOK * pNext;
N};
N
Ntypedef struct {
N  void (* cbBegin)(void);
N  void (* cbEnd)  (void);
N} GUI_MULTIBUF_API;
N
Ntypedef struct {
N  void (* cbBeginEx)(int LayerIndex);
N  void (* cbEndEx)  (int LayerIndex);
N} GUI_MULTIBUF_API_EX;
N
N/*********************************************************************
N*
N*       FONT structures
N*/
N
N/* Translation list. Translates a character code into up to 2
N   indices of images to display on top of each other;
N*/
Ntypedef struct {
N  I16P c0;
X  signed short c0;
N  I16P c1;
X  signed short c1;
N} GUI_FONT_TRANSLIST;
N
Ntypedef struct {
N  U16P FirstChar;
X  unsigned short FirstChar;
N  U16P LastChar;
X  unsigned short LastChar;
N  const GUI_FONT_TRANSLIST * pList;
N} GUI_FONT_TRANSINFO;
N
Ntypedef struct {
N  U32 XSize;
X  unsigned long XSize;
N  U32 XDist;
X  unsigned long XDist;
N  U32 BytesPerLine;
X  unsigned long BytesPerLine;
N  const unsigned char * pData;
N} GUI_CHARINFO;
N
Ntypedef struct {
N  U32 XSize;
X  unsigned long XSize;
N  U32 YSize;
X  unsigned long YSize;
N  I32 XPos;
X  signed long XPos;
N  I32 YPos;
X  signed long YPos;
N  U32 XDist;
X  unsigned long XDist;
N  const unsigned char * pData;
N} GUI_CHARINFO_EXT;
N
Ntypedef struct GUI_FONT_PROP {
N  U16P First;                                  /* First character               */
X  unsigned short First;                                   
N  U16P Last;                                   /* Last character                */
X  unsigned short Last;                                    
N  const GUI_CHARINFO         * paCharInfo;     /* Address of first character    */
N  const struct GUI_FONT_PROP * pNext;          /* Pointer to next               */
N} GUI_FONT_PROP;
N
Ntypedef struct GUI_FONT_PROP_EXT {
N  U16P First;                                  /* First character               */
X  unsigned short First;                                   
N  U16P Last;                                   /* Last character                */
X  unsigned short Last;                                    
N  const GUI_CHARINFO_EXT         * paCharInfo; /* Address of first character    */
N  const struct GUI_FONT_PROP_EXT * pNext;      /* Pointer to next               */
N} GUI_FONT_PROP_EXT;
N
Ntypedef struct {
N  const unsigned char      * pData;
N  const U8                 * pTransData;
X  const unsigned char                 * pTransData;
N  const GUI_FONT_TRANSINFO * pTrans;
N  U16P                       FirstChar;
X  unsigned short                       FirstChar;
N  U16P                       LastChar;
X  unsigned short                       LastChar;
N  U32                         XSize;
X  unsigned long                         XSize;
N  U32                         XDist;
X  unsigned long                         XDist;
N  U32                         BytesPerLine;
X  unsigned long                         BytesPerLine;
N} GUI_FONT_MONO;
N
N/*********************************************************************
N*
N*       GUI_FONTINFO
N*
N*   Description
N*     This structure is used when retrieving information about a font.
N*/
Ntypedef struct {
N  U16 Flags;      // Flags that define the type of the font. Permitted values are explained in
X  unsigned short Flags;      
N                  // \ref{Font info flags}.
N  U32 Baseline;    // Height of the baseline. The baseline is the line where most, but not all
X  unsigned long Baseline;    
N                  // characters are 'placed on'. The lowest part of an 'A' is on the baseline.
N  U32 LHeight;     // Height of a lower case character such as 'a' or 'x'.
X  unsigned long LHeight;     
N  U32 CHeight;     // Height of an upper case character such as 'A' or 'X'.
X  unsigned long CHeight;     
N} GUI_FONTINFO;
N
N/*********************************************************************
N*
N*       Font info flags
N*
N*   Description
N*     These flags define of what type a font is. See the chapter
N*     \ref{Font types} for a detailed explanation of the font types.
N*/
N#define GUI_FONTINFO_FLAG_PROP    (1 << 0)    // Font is proportional.
N#define GUI_FONTINFO_FLAG_MONO    (1 << 1)    // Font is monospaced.
N#define GUI_FONTINFO_FLAG_AA      (1 << 2)    // Font is an antialiased font.
N#define GUI_FONTINFO_FLAG_AA2     (1 << 3)    // Font is an antialiased font with 2bpp anti-aliasing.
N#define GUI_FONTINFO_FLAG_AA4     (1 << 4)    // Font is an antialiased font with 4bpp anti-aliasing.
N#define GUI_FONTINFO_FLAG_PROPFRM (1 << 5)    // Font is proportional and framed.
N
N/*********************************************************************
N*
N*       UNICODE Encoding
N*/
Ntypedef U16  tGUI_GetCharCode   (const char * s);
Xtypedef unsigned short  tGUI_GetCharCode   (const char * s);
Ntypedef U16  tGUI_GetGlyph      (const char * s, int CursorPosByte, int * pByteSize);
Xtypedef unsigned short  tGUI_GetGlyph      (const char * s, int CursorPosByte, int * pByteSize);
Ntypedef int  tGUI_GetCharSize   (const char * s);
Ntypedef int  tGUI_CalcSizeOfChar(U16 Char);
Xtypedef int  tGUI_CalcSizeOfChar(unsigned short Char);
Ntypedef int  tGUI_Encode        (char * s, U16 Char);
Xtypedef int  tGUI_Encode        (char * s, unsigned short Char);
N
Ntypedef struct {
N  tGUI_GetCharCode    * pfGetCharCode;
N  tGUI_GetCharSize    * pfGetCharSize;
N  tGUI_CalcSizeOfChar * pfCalcSizeOfChar;
N  tGUI_Encode         * pfEncode;
N} GUI_UC_ENC_APILIST;
N
N/*********************************************************************
N*
N*       FONT Encoding
N*/
Ntypedef int  tGUI_GetLineDistX(const char * s, int Len);
Ntypedef int  tGUI_GetLineLen  (const char * s, int MaxLen);
Ntypedef void tGL_DispLine     (const char * s, int Len);
N
Ntypedef struct {
N  tGUI_GetLineDistX * pfGetLineDistX;
N  tGUI_GetLineLen   * pfGetLineLen;
N  tGL_DispLine      * pfDispLine;
N} tGUI_ENC_APIList;
N
Nextern const tGUI_ENC_APIList GUI_ENC_APIList_SJIS;
Nextern const tGUI_ENC_APIList GUI_ENC_APIList_EXT;
N
N/*********************************************************************
N*
N*       FONT methods
N*/
Ntypedef struct GUI_FONT GUI_FONT;
N
Ntypedef void GUI_DISPCHAR    (U16 c);
Xtypedef void GUI_DISPCHAR    (unsigned short c);
Ntypedef int  GUI_GETCHARDISTX(U16P c, int * pSizeX);
Xtypedef int  GUI_GETCHARDISTX(unsigned short c, int * pSizeX);
Ntypedef void GUI_GETFONTINFO (const GUI_FONT * pFont, GUI_FONTINFO * pfi);
Ntypedef char GUI_ISINFONT    (const GUI_FONT * pFont, U16 c);
Xtypedef char GUI_ISINFONT    (const GUI_FONT * pFont, unsigned short c);
Ntypedef int  GUI_GETCHARINFO (U16P c, GUI_CHARINFO_EXT * pInfo);
Xtypedef int  GUI_GETCHARINFO (unsigned short c, GUI_CHARINFO_EXT * pInfo);
N
N#define DECLARE_FONT(Type)                                     \
Nvoid GUI##Type##_DispChar    (U16P c);                         \
Nint  GUI##Type##_GetCharDistX(U16P c, int * pSizeX);                         \
Nvoid GUI##Type##_GetFontInfo (const GUI_FONT * pFont, GUI_FONTINFO * pfi); \
Nchar GUI##Type##_IsInFont    (const GUI_FONT * pFont, U16 c); \
Nint  GUI##Type##_GetCharInfo (U16P c, GUI_CHARINFO_EXT * pInfo)
X#define DECLARE_FONT(Type)                                     void GUI##Type##_DispChar    (U16P c);                         int  GUI##Type##_GetCharDistX(U16P c, int * pSizeX);                         void GUI##Type##_GetFontInfo (const GUI_FONT * pFont, GUI_FONTINFO * pfi); char GUI##Type##_IsInFont    (const GUI_FONT * pFont, U16 c); int  GUI##Type##_GetCharInfo (U16P c, GUI_CHARINFO_EXT * pInfo)
N
N#if defined(__cplusplus)
X#if 0L
Sextern "C" {     /* Make sure we have C-declarations in C++ programs */
N#endif
N
NDECLARE_FONT(MONO);
Xvoid GUIMONO_DispChar (unsigned short c); int GUIMONO_GetCharDistX(unsigned short c, int * pSizeX); void GUIMONO_GetFontInfo (const GUI_FONT * pFont, GUI_FONTINFO * pfi); char GUIMONO_IsInFont (const GUI_FONT * pFont, unsigned short c); int GUIMONO_GetCharInfo (unsigned short c, GUI_CHARINFO_EXT * pInfo);
NDECLARE_FONT(PROP);
Xvoid GUIPROP_DispChar (unsigned short c); int GUIPROP_GetCharDistX(unsigned short c, int * pSizeX); void GUIPROP_GetFontInfo (const GUI_FONT * pFont, GUI_FONTINFO * pfi); char GUIPROP_IsInFont (const GUI_FONT * pFont, unsigned short c); int GUIPROP_GetCharInfo (unsigned short c, GUI_CHARINFO_EXT * pInfo);
NDECLARE_FONT(PROP_EXT);
Xvoid GUIPROP_EXT_DispChar (unsigned short c); int GUIPROP_EXT_GetCharDistX(unsigned short c, int * pSizeX); void GUIPROP_EXT_GetFontInfo (const GUI_FONT * pFont, GUI_FONTINFO * pfi); char GUIPROP_EXT_IsInFont (const GUI_FONT * pFont, unsigned short c); int GUIPROP_EXT_GetCharInfo (unsigned short c, GUI_CHARINFO_EXT * pInfo);
NDECLARE_FONT(PROP_FRM);
Xvoid GUIPROP_FRM_DispChar (unsigned short c); int GUIPROP_FRM_GetCharDistX(unsigned short c, int * pSizeX); void GUIPROP_FRM_GetFontInfo (const GUI_FONT * pFont, GUI_FONTINFO * pfi); char GUIPROP_FRM_IsInFont (const GUI_FONT * pFont, unsigned short c); int GUIPROP_FRM_GetCharInfo (unsigned short c, GUI_CHARINFO_EXT * pInfo);
NDECLARE_FONT(PROPAA);
Xvoid GUIPROPAA_DispChar (unsigned short c); int GUIPROPAA_GetCharDistX(unsigned short c, int * pSizeX); void GUIPROPAA_GetFontInfo (const GUI_FONT * pFont, GUI_FONTINFO * pfi); char GUIPROPAA_IsInFont (const GUI_FONT * pFont, unsigned short c); int GUIPROPAA_GetCharInfo (unsigned short c, GUI_CHARINFO_EXT * pInfo);
NDECLARE_FONT(PROP_AA2);
Xvoid GUIPROP_AA2_DispChar (unsigned short c); int GUIPROP_AA2_GetCharDistX(unsigned short c, int * pSizeX); void GUIPROP_AA2_GetFontInfo (const GUI_FONT * pFont, GUI_FONTINFO * pfi); char GUIPROP_AA2_IsInFont (const GUI_FONT * pFont, unsigned short c); int GUIPROP_AA2_GetCharInfo (unsigned short c, GUI_CHARINFO_EXT * pInfo);
NDECLARE_FONT(PROP_AA2_EXT);
Xvoid GUIPROP_AA2_EXT_DispChar (unsigned short c); int GUIPROP_AA2_EXT_GetCharDistX(unsigned short c, int * pSizeX); void GUIPROP_AA2_EXT_GetFontInfo (const GUI_FONT * pFont, GUI_FONTINFO * pfi); char GUIPROP_AA2_EXT_IsInFont (const GUI_FONT * pFont, unsigned short c); int GUIPROP_AA2_EXT_GetCharInfo (unsigned short c, GUI_CHARINFO_EXT * pInfo);
NDECLARE_FONT(PROP_AA4);
Xvoid GUIPROP_AA4_DispChar (unsigned short c); int GUIPROP_AA4_GetCharDistX(unsigned short c, int * pSizeX); void GUIPROP_AA4_GetFontInfo (const GUI_FONT * pFont, GUI_FONTINFO * pfi); char GUIPROP_AA4_IsInFont (const GUI_FONT * pFont, unsigned short c); int GUIPROP_AA4_GetCharInfo (unsigned short c, GUI_CHARINFO_EXT * pInfo);
NDECLARE_FONT(PROP_AA4_EXT);
Xvoid GUIPROP_AA4_EXT_DispChar (unsigned short c); int GUIPROP_AA4_EXT_GetCharDistX(unsigned short c, int * pSizeX); void GUIPROP_AA4_EXT_GetFontInfo (const GUI_FONT * pFont, GUI_FONTINFO * pfi); char GUIPROP_AA4_EXT_IsInFont (const GUI_FONT * pFont, unsigned short c); int GUIPROP_AA4_EXT_GetCharInfo (unsigned short c, GUI_CHARINFO_EXT * pInfo);
N
N/* MONO: Monospaced fonts */
N#define GUI_FONTTYPE_MONO           \
N  GUIMONO_DispChar,                 \
N  GUIMONO_GetCharDistX,             \
N  GUIMONO_GetFontInfo,              \
N  GUIMONO_IsInFont,                 \
N  (GUI_GETCHARINFO *)0,             \
N  (tGUI_ENC_APIList*)0
X#define GUI_FONTTYPE_MONO             GUIMONO_DispChar,                   GUIMONO_GetCharDistX,               GUIMONO_GetFontInfo,                GUIMONO_IsInFont,                   (GUI_GETCHARINFO *)0,               (tGUI_ENC_APIList*)0
N
N/* PROP: Proportional fonts */
N#define GUI_FONTTYPE_PROP           \
N  GUIPROP_DispChar,                 \
N  GUIPROP_GetCharDistX,             \
N  GUIPROP_GetFontInfo,              \
N  GUIPROP_IsInFont,                 \
N  (GUI_GETCHARINFO *)0,             \
N  (tGUI_ENC_APIList*)0
X#define GUI_FONTTYPE_PROP             GUIPROP_DispChar,                   GUIPROP_GetCharDistX,               GUIPROP_GetFontInfo,                GUIPROP_IsInFont,                   (GUI_GETCHARINFO *)0,               (tGUI_ENC_APIList*)0
N
N/* PROP_EXT: Extended proportional fonts */
N#define GUI_FONTTYPE_PROP_EXT       \
N  GUIPROP_EXT_DispChar,             \
N  GUIPROP_EXT_GetCharDistX,         \
N  GUIPROP_EXT_GetFontInfo,          \
N  GUIPROP_EXT_IsInFont,             \
N  GUIPROP_EXT_GetCharInfo,          \
N  &GUI_ENC_APIList_EXT
X#define GUI_FONTTYPE_PROP_EXT         GUIPROP_EXT_DispChar,               GUIPROP_EXT_GetCharDistX,           GUIPROP_EXT_GetFontInfo,            GUIPROP_EXT_IsInFont,               GUIPROP_EXT_GetCharInfo,            &GUI_ENC_APIList_EXT
N
N/* PROP_FRM: Extended proportional fonts, framed */
N#define GUI_FONTTYPE_PROP_FRM       \
N  GUIPROP_FRM_DispChar,             \
N  GUIPROP_FRM_GetCharDistX,         \
N  GUIPROP_FRM_GetFontInfo,          \
N  GUIPROP_FRM_IsInFont,             \
N  (GUI_GETCHARINFO *)0,             \
N  (tGUI_ENC_APIList*)0
X#define GUI_FONTTYPE_PROP_FRM         GUIPROP_FRM_DispChar,               GUIPROP_FRM_GetCharDistX,           GUIPROP_FRM_GetFontInfo,            GUIPROP_FRM_IsInFont,               (GUI_GETCHARINFO *)0,               (tGUI_ENC_APIList*)0
N
N/* PROP: Proportional fonts SJIS */
N#define GUI_FONTTYPE_PROP_SJIS      \
N  GUIPROP_DispChar,                 \
N  GUIPROP_GetCharDistX,             \
N  GUIPROP_GetFontInfo,              \
N  GUIPROP_IsInFont,                 \
N  (GUI_GETCHARINFO *)0,             \
N  &GUI_ENC_APIList_SJIS
X#define GUI_FONTTYPE_PROP_SJIS        GUIPROP_DispChar,                   GUIPROP_GetCharDistX,               GUIPROP_GetFontInfo,                GUIPROP_IsInFont,                   (GUI_GETCHARINFO *)0,               &GUI_ENC_APIList_SJIS
N
N/* PROPAA: Proportional, antialiased fonts */
N#define GUI_FONTTYPE_PROPAA         \
N  GUIPROPAA_DispChar,               \
N  GUIPROPAA_GetCharDistX,           \
N  GUIPROPAA_GetFontInfo,            \
N  GUIPROPAA_IsInFont,               \
N  (GUI_GETCHARINFO *)0,             \
N  (tGUI_ENC_APIList*)0
X#define GUI_FONTTYPE_PROPAA           GUIPROPAA_DispChar,                 GUIPROPAA_GetCharDistX,             GUIPROPAA_GetFontInfo,              GUIPROPAA_IsInFont,                 (GUI_GETCHARINFO *)0,               (tGUI_ENC_APIList*)0
N
N/* PROP_AA2: Proportional, antialiased fonts, 2bpp */
N#define GUI_FONTTYPE_PROP_AA2       \
N  GUIPROP_AA2_DispChar,             \
N  GUIPROP_AA2_GetCharDistX,         \
N  GUIPROP_AA2_GetFontInfo,          \
N  GUIPROP_AA2_IsInFont,             \
N  (GUI_GETCHARINFO *)0,             \
N  (tGUI_ENC_APIList*)0
X#define GUI_FONTTYPE_PROP_AA2         GUIPROP_AA2_DispChar,               GUIPROP_AA2_GetCharDistX,           GUIPROP_AA2_GetFontInfo,            GUIPROP_AA2_IsInFont,               (GUI_GETCHARINFO *)0,               (tGUI_ENC_APIList*)0
N
N/* PROP_AA2_EXT: Proportional, antialiased fonts, 2bpp, extended font information */
N#define GUI_FONTTYPE_PROP_AA2_EXT   \
N  GUIPROP_AA2_EXT_DispChar,         \
N  GUIPROP_EXT_GetCharDistX,         \
N  GUIPROP_EXT_GetFontInfo,          \
N  GUIPROP_EXT_IsInFont,             \
N  GUIPROP_EXT_GetCharInfo,          \
N  &GUI_ENC_APIList_EXT
X#define GUI_FONTTYPE_PROP_AA2_EXT     GUIPROP_AA2_EXT_DispChar,           GUIPROP_EXT_GetCharDistX,           GUIPROP_EXT_GetFontInfo,            GUIPROP_EXT_IsInFont,               GUIPROP_EXT_GetCharInfo,            &GUI_ENC_APIList_EXT
N
N/* PROP_AA2: Proportional, antialiased fonts, 2bpp, SJIS encoding */
N#define GUI_FONTTYPE_PROP_AA2_SJIS  \
N  GUIPROP_AA2_DispChar,             \
N  GUIPROP_AA2_GetCharDistX,         \
N  GUIPROP_AA2_GetFontInfo,          \
N  GUIPROP_AA2_IsInFont,             \
N  (GUI_GETCHARINFO *)0,             \
N  &GUI_ENC_APIList_SJIS
X#define GUI_FONTTYPE_PROP_AA2_SJIS    GUIPROP_AA2_DispChar,               GUIPROP_AA2_GetCharDistX,           GUIPROP_AA2_GetFontInfo,            GUIPROP_AA2_IsInFont,               (GUI_GETCHARINFO *)0,               &GUI_ENC_APIList_SJIS
N
N/* PROP_AA4: Proportional, antialiased fonts, 4bpp */
N#define GUI_FONTTYPE_PROP_AA4       \
N  GUIPROP_AA4_DispChar,             \
N  GUIPROP_AA4_GetCharDistX,         \
N  GUIPROP_AA4_GetFontInfo,          \
N  GUIPROP_AA4_IsInFont,             \
N  (GUI_GETCHARINFO *)0,             \
N  (tGUI_ENC_APIList*)0
X#define GUI_FONTTYPE_PROP_AA4         GUIPROP_AA4_DispChar,               GUIPROP_AA4_GetCharDistX,           GUIPROP_AA4_GetFontInfo,            GUIPROP_AA4_IsInFont,               (GUI_GETCHARINFO *)0,               (tGUI_ENC_APIList*)0
N
N/* PROP_AA4_EXT: Proportional, antialiased fonts, 4bpp, extended font information */
N#define GUI_FONTTYPE_PROP_AA4_EXT   \
N  GUIPROP_AA4_EXT_DispChar,         \
N  GUIPROP_EXT_GetCharDistX,         \
N  GUIPROP_EXT_GetFontInfo,          \
N  GUIPROP_EXT_IsInFont,             \
N  GUIPROP_EXT_GetCharInfo,          \
N  &GUI_ENC_APIList_EXT
X#define GUI_FONTTYPE_PROP_AA4_EXT     GUIPROP_AA4_EXT_DispChar,           GUIPROP_EXT_GetCharDistX,           GUIPROP_EXT_GetFontInfo,            GUIPROP_EXT_IsInFont,               GUIPROP_EXT_GetCharInfo,            &GUI_ENC_APIList_EXT
N
N/* PROP_AA4: Proportional, antialiased fonts, 4bpp, SJIS encoding */
N#define GUI_FONTTYPE_PROP_AA4_SJIS  \
N  GUIPROP_AA4_DispChar,             \
N  GUIPROP_AA4_GetCharDistX,         \
N  GUIPROP_AA4_GetFontInfo,          \
N  GUIPROP_AA4_IsInFont,             \
N  (GUI_GETCHARINFO *)0,             \
N  &GUI_ENC_APIList_SJIS
X#define GUI_FONTTYPE_PROP_AA4_SJIS    GUIPROP_AA4_DispChar,               GUIPROP_AA4_GetCharDistX,           GUIPROP_AA4_GetFontInfo,            GUIPROP_AA4_IsInFont,               (GUI_GETCHARINFO *)0,               &GUI_ENC_APIList_SJIS
N
N#if defined(__cplusplus)
X#if 0L
S  }
N#endif
N
Nstruct GUI_FONT {
N  GUI_DISPCHAR     * pfDispChar; 
N  GUI_GETCHARDISTX * pfGetCharDistX; 
N  GUI_GETFONTINFO  * pfGetFontInfo; 
N  GUI_ISINFONT     * pfIsInFont;
N  GUI_GETCHARINFO  * pfGetCharInfo;
N  const tGUI_ENC_APIList* pafEncode;
N  U32 YSize;
X  unsigned long YSize;
N  U32 YDist;
X  unsigned long YDist;
N  U32 XMag;
X  unsigned long XMag;
N  U32 YMag;
X  unsigned long YMag;
N  union {
N    const void              * pFontData;
N    const GUI_FONT_MONO     * pMono;
N    const GUI_FONT_PROP     * pProp;
N    const GUI_FONT_PROP_EXT * pPropExt;
N  } p;
N  U32 Baseline;
X  unsigned long Baseline;
N  U32 LHeight;     /* Height of a small lower case character (a,x) */
X  unsigned long LHeight;      
N  U32 CHeight;     /* Height of a small upper case character (A,X) */
X  unsigned long CHeight;      
N};
N
N/*********************************************************************
N*
N*       GUI_KERNING_INFO
N*/
Ntypedef struct GUI_KERNING_INFO GUI_KERNING_INFO;
N
Nstruct GUI_KERNING_INFO {
N  const GUI_FONT   * pFont;
N  const U16        * pData;
X  const unsigned short        * pData;
N  U32                NumItems;
X  unsigned long                NumItems;
N  GUI_KERNING_INFO * pNext;
N};
N
N/*********************************************************************
N*
N*       Bitmap serialization (BMP)
N*/
Ntypedef void GUI_CALLBACK_VOID_U8_P(U8 Data, void * p);
Xtypedef void GUI_CALLBACK_VOID_U8_P(unsigned char Data, void * p);
N
N/*********************************************************************
N*
N*       System independent font structures (SIF)
N*/
Ntypedef struct {
N  U32 ID;           /* Font file ID */
X  unsigned long ID;            
N  U16 YSize;        /* Height of font */
X  unsigned short YSize;         
N  U16 YDist;        /* Space of font Y */
X  unsigned short YDist;         
N  U16 Baseline;     /* Index of baseline */
X  unsigned short Baseline;      
N  U16 LHeight;      /* Height of a small lower case character (a) */
X  unsigned short LHeight;       
N  U16 CHeight;      /* Height of a upper case character (A) */
X  unsigned short CHeight;       
N  U16 NumAreas;     /* Number of character areas */
X  unsigned short NumAreas;      
N} GUI_SI_FONT;
N
Ntypedef struct {
N  U16 First;        /* Index of first character */
X  unsigned short First;         
N  U16 Last;         /* Index of last character */
X  unsigned short Last;          
N} GUI_SIF_CHAR_AREA;
N
Ntypedef struct {
N  U16 XSize;        /* Size of bitmap data in X */
X  unsigned short XSize;         
N  U16 XDist;        /* Number of pixels for increment cursor in X */
X  unsigned short XDist;         
N  U16 BytesPerLine; /* Number of bytes per line */
X  unsigned short BytesPerLine;  
N  U16 Dummy;
X  unsigned short Dummy;
N  U32 OffData;      /* Offset of pixel data */
X  unsigned long OffData;       
N} GUI_SIF_CHARINFO;
N
Ntypedef struct {
N  U16 XSize;        /* Size of bitmap data in X */
X  unsigned short XSize;         
N  U16 YSize;        /* Size of bitmap data in X */
X  unsigned short YSize;         
N  I16 XOff;         /* Display offset of bitmap data in X */
X  signed short XOff;          
N  I16 YOff;         /* Display offset of bitmap data in Y */
X  signed short YOff;          
N  U16 XDist;        /* Number of pixels for increment cursor in X */
X  unsigned short XDist;         
N  U16 Dummy;
X  unsigned short Dummy;
N  U32 OffData;      /* Offset of pixel data */
X  unsigned long OffData;       
N} GUI_SIF_CHARINFO_EXT;
N
Ntypedef struct tGUI_SIF_APIList_struct {
N  GUI_DISPCHAR          * pfDispChar;
N  GUI_GETCHARDISTX      * pfGetCharDistX;
N  GUI_GETFONTINFO       * pfGetFontInfo;
N  GUI_ISINFONT          * pfIsInFont;
N  GUI_GETCHARINFO       * pfGetCharInfo;
N  const tGUI_ENC_APIList* pafEncode;
N} tGUI_SIF_APIList;
N
N#define GUI_SIF_TYPE              tGUI_SIF_APIList
N//
N// Old macros left for compatibility.
N//
N#define GUI_SIF_TYPE_PROP         &GUI_SIF_APIList_Prop
N#define GUI_SIF_TYPE_PROP_EXT     &GUI_SIF_APIList_Prop_Ext
N#define GUI_SIF_TYPE_PROP_AA2     &GUI_SIF_APIList_Prop_AA2
N#define GUI_SIF_TYPE_PROP_AA4     &GUI_SIF_APIList_Prop_AA4
N#define GUI_SIF_TYPE_PROP_AA2_EXT &GUI_SIF_APIList_Prop_AA2_EXT
N#define GUI_SIF_TYPE_PROP_AA4_EXT &GUI_SIF_APIList_Prop_AA4_EXT
N
N
N/*********************************************************************
N*
N*       SIF font types
N* 
N*  Description
N*    Available font type defines to be used by the \a{pFontType} parameter in function GUI_SIF_CreateFont().
N*/
N//
N// New macros: 'standard' renamed to 'legacy', 'extended' renamed to 'standard'.
N// Macro for framed fonts was left unchanged.
N//
N#define GUI_SIF_TYPE_PROP_LEG       GUI_SIF_TYPE_PROP            // Should be used if the parameter \a{pFont} points to a legacy proportional font.
N#define GUI_SIF_TYPE_PROP_LEG_AA2   GUI_SIF_TYPE_PROP_AA2        // Should be used if the parameter \a{pFont} points to a legacy proportional font that uses 2bpp anti-aliasing.
N#define GUI_SIF_TYPE_PROP_LEG_AA4   GUI_SIF_TYPE_PROP_AA4        // Should be used if the parameter \a{pFont} points to a legacy proportional font that uses 4bpp anti-aliasing.
N#define GUI_SIF_TYPE_PROP_FRM       &GUI_SIF_APIList_Prop_Frm    // Should be used if the parameter \a{pFont} points to a standard proportional framed font.
N#define GUI_SIF_TYPE_PROP_STD       GUI_SIF_TYPE_PROP_EXT        // Should be used if the parameter \a{pFont} points to a standard proportional font.
N#define GUI_SIF_TYPE_PROP_STD_AA2   GUI_SIF_TYPE_PROP_AA2_EXT    // Should be used if the parameter \a{pFont} points to a standard proportional font that uses 2bpp anti-aliasing.
N#define GUI_SIF_TYPE_PROP_STD_AA4   GUI_SIF_TYPE_PROP_AA4_EXT    // Should be used if the parameter \a{pFont} points to a standard proportional font that uses 4bpp anti-aliasing.
N
N
N/*********************************************************************
N*
N*       External binary font structures (XBF)
N*/
N/*********************************************************************
N*
N*       GUI_XBF_GET_DATA_FUNC
N* 
N*  Description
N*    A callback which is used for loading XBF files into RAM, e.g. from
N*    a file system.
N*    
N*    For more details about GetData functions in general, please refer
N*    to the chapter \ref{FileAccess}.
N* 
N*  Parameters
N*    Off:      Current byte offset in the file.
N*    NumBytes: Number of bytes to be read.
N*    pVoid:    [IN] Parameter is passed to the callback function when
N*                   requesting font data. It can be used for example to
N*                   pass a file handle to the callback function.
N*    pBuffer:  [IN] Pointer to a preallocated buffer where the read file data
N*                   should be written to.
N* 
N*  Return value
N*    == 0: On success.
N*    == 1: On error.
N*/
Ntypedef int GUI_XBF_GET_DATA_FUNC(U32 Off, U16 NumBytes, void * pVoid, void * pBuffer);
Xtypedef int GUI_XBF_GET_DATA_FUNC(unsigned long Off, unsigned short NumBytes, void * pVoid, void * pBuffer);
N
Ntypedef struct {
N  U16 First;                         /* First character of font */
X  unsigned short First;                          
N  U16 Last;                          /* Last character of font */
X  unsigned short Last;                           
N  void * pVoid;                      /* Void pointer passed to GetData-function */
N  GUI_XBF_GET_DATA_FUNC * pfGetData; /* Pointer to callback function */
N} GUI_XBF_DATA;
N
Ntypedef struct tGUI_XBF_APIList_struct {
N  GUI_DISPCHAR          * pfDispChar;
N  GUI_GETCHARDISTX      * pfGetCharDistX;
N  GUI_GETFONTINFO       * pfGetFontInfo;
N  GUI_ISINFONT          * pfIsInFont;
N  GUI_GETCHARINFO       * pfGetCharInfo;
N  const tGUI_ENC_APIList* pafEncode;
N} tGUI_XBF_APIList;
N
N#define GUI_XBF_TYPE              tGUI_XBF_APIList
N//
N// Old macros left for compatibility.
N//
N#define GUI_XBF_TYPE_PROP         &GUI_XBF_APIList_Prop
N#define GUI_XBF_TYPE_PROP_EXT     &GUI_XBF_APIList_Prop_Ext
N#define GUI_XBF_TYPE_PROP_AA2_EXT &GUI_XBF_APIList_Prop_AA2_Ext
N#define GUI_XBF_TYPE_PROP_AA4_EXT &GUI_XBF_APIList_Prop_AA4_Ext
N
N/*********************************************************************
N*
N*       XBF font types
N* 
N*  Description
N*    Available font type defines to be used by the \a{pFontType} parameter in function GUI_XBF_CreateFont().
N*/
N//
N// New macros: 'standard' renamed to 'legacy', 'extended' renamed to 'standard'.
N// Macro for framed fonts was left unchanged.
N//
N#define GUI_XBF_TYPE_PROP_LEG         GUI_XBF_TYPE_PROP            // Should be used if the parameter \a{pFont} points to a legacy proportional font.
N#define GUI_XBF_TYPE_PROP_FRM         &GUI_XBF_APIList_Prop_Frm    // Should be used if the parameter \a{pFont} points to a standard proportional font.
N#define GUI_XBF_TYPE_PROP_STD         GUI_XBF_TYPE_PROP_EXT        // Should be used if the parameter \a{pFont} points to a standard framed proportional font.
N#define GUI_XBF_TYPE_PROP_STD_AA2     GUI_XBF_TYPE_PROP_AA2_EXT    // Should be used if the parameter \a{pFont} points to a standard proportional font that uses 2bpp anti-aliasing.
N#define GUI_XBF_TYPE_PROP_STD_AA4     GUI_XBF_TYPE_PROP_AA4_EXT    // Should be used if the parameter \a{pFont} points to a standard proportional font that uses 4bpp anti-aliasing.
N
N/*********************************************************************
N*
N*       TrueType support (TTF)
N*/
N/*********************************************************************
N*
N*       GUI_TTF_DATA
N*
N*   Description
N*     Contains the raw data of a TTF font file.
N*/
Ntypedef struct {
N  const void * pData;      // Pointer to TTF font file in addressable memory area.
N  U32 NumBytes;            // Size of file in bytes.
X  unsigned long NumBytes;            
N} GUI_TTF_DATA;
N
N/*********************************************************************
N*
N*       GUI_TTF_CS
N*
N*   Description
N*     Stores data necessary to create a TTF font.
N*/
Ntypedef struct {
N  GUI_TTF_DATA * pTTF;     // Pointer to GUI_TTF_DATA structure which contains location and size
N                           // of font file.
N  U32 aImageTypeBuffer[4]; /* Buffer for image type structure */
X  unsigned long aImageTypeBuffer[4];  
N  int PixelHeight;         // Pixel height of new font. It means the height of the surrounding
N                           // rectangle between the glyphs 'g' anf 'f'. Please notice that it is
N                           // not the distance between two lines of text. With other words the value
N                           // returned by GUI_GetFontSizeY() is not identically with this value.
N  int FaceIndex;           // Some font files can contain more than one font face. In case of more
N                           // than one face this index specifies the zero based face index to be
N                           // used to create the font. Usually 0.
N  I32 BoldStrength;        /* Embolden strength used for the font. */
X  signed long BoldStrength;         
N  I32 aObliqueMatrix[4];   /* FT_Matrix, used for obliqueing the font. */
X  signed long aObliqueMatrix[4];    
N  U8  EmFlags;             /* Emphasis flags, used for embolding and obliqueing the font.  */
X  unsigned char  EmFlags;              
N} GUI_TTF_CS;
N
N/*********************************************************************
N*
N*       Task synchronization
N*/
Ntypedef void (* GUI_SIGNAL_EVENT_FUNC)    (void);
Ntypedef void (* GUI_WAIT_EVENT_FUNC)      (void);
Ntypedef void (* GUI_WAIT_EVENT_TIMED_FUNC)(int Period);
N
N/*********************************************************************
N*
N*       Memory management
N*/
N#ifndef     GUI_HMEM
N  #define     GUI_HMEM        I32
N#endif
N#define     GUI_HMEM_NULL     (0)
Ntypedef     GUI_HMEM      GUI_HWIN;
Xtypedef     signed long      GUI_HWIN;
Ntypedef     GUI_HMEM      GUI_HSPRITE;
Xtypedef     signed long      GUI_HSPRITE;
N
N/*********************************************************************
N*
N*       Multi touch input
N*/
N#ifndef   GUI_MTOUCH_MAX_NUM_POINTS
N  #define GUI_MTOUCH_MAX_NUM_POINTS 10
N#endif
N
N/*********************************************************************
N*
N*       GUI_MTOUCH_INPUT
N*
N*  Description
N*    Data structure used by GUI_MTOUCH_GetEvent() to store a multi touch
N*    event in.
N*/
Ntypedef struct {
N  I32 x;          // X-position in pixels of the touch point.
X  signed long x;          
N  I32 y;          // Y-position in pixels of the touch point.
X  signed long y;          
N  U32 Id;         // Unique Id, should be provided by the touch driver. Make sure that this
X  unsigned long Id;         
N                  // element is != 0.
N  U16 Flags;      // See \ref{MultiTouch flags}.
X  unsigned short Flags;      
N} GUI_MTOUCH_INPUT;
N
N/*********************************************************************
N*
N*       GUI_MTOUCH_EVENT
N*
N*  Description
N*    Data structure used by GUI_MTOUCH_GetEvent() to store a multi touch
N*    event in.
N*/
Ntypedef struct {
N  int            LayerIndex;   // Layer index of touched layer (normally 0).
N  unsigned       NumPoints;    // Number of available touch points.
N  GUI_TIMER_TIME TimeStamp;    // Time stamp in ms of that event.
X  int TimeStamp;    
N  PTR_ADDR       hInput;
X  unsigned long       hInput;
N} GUI_MTOUCH_EVENT;
N
N//
N// Used for emWinSPY with reduced data types and array sizes
N//
Ntypedef struct {
N  U8  Layer;
X  unsigned char  Layer;
N  U8  NumPoints;
X  unsigned char  NumPoints;
N  I16 ax[5];
X  signed short ax[5];
N  I16 ay[5];
X  signed short ay[5];
N  U16 aId[5];
X  unsigned short aId[5];
N  U8  aFlags[5];
X  unsigned char  aFlags[5];
N} GUI_MTOUCH_STATE;
N
Ntypedef void (* T_GUI_MTOUCH_STOREEVENT)(GUI_MTOUCH_EVENT *, GUI_MTOUCH_INPUT * pInput);
N
N/*********************************************************************
N*
N*       Hardware routines
N*/
Ntypedef struct {
N  //
N  // 8 Bit access
N  //
N  void (* pfWrite8_A0)  (U8 Data);
X  void (* pfWrite8_A0)  (unsigned char Data);
N  void (* pfWrite8_A1)  (U8 Data);
X  void (* pfWrite8_A1)  (unsigned char Data);
N  void (* pfWriteM8_A0) (U8 * pData, int NumItems);
X  void (* pfWriteM8_A0) (unsigned char * pData, int NumItems);
N  void (* pfWriteM8_A1) (U8 * pData, int NumItems);
X  void (* pfWriteM8_A1) (unsigned char * pData, int NumItems);
N  U8   (* pfRead8_A0)   (void);
X  unsigned char   (* pfRead8_A0)   (void);
N  U8   (* pfRead8_A1)   (void);
X  unsigned char   (* pfRead8_A1)   (void);
N  void (* pfReadM8_A0)  (U8 * pData, int NumItems);
X  void (* pfReadM8_A0)  (unsigned char * pData, int NumItems);
N  void (* pfReadM8_A1)  (U8 * pData, int NumItems);
X  void (* pfReadM8_A1)  (unsigned char * pData, int NumItems);
N  //
N  // 16 Bit access
N  //
N  void (* pfWrite16_A0) (U16 Data);
X  void (* pfWrite16_A0) (unsigned short Data);
N  void (* pfWrite16_A1) (U16 Data);
X  void (* pfWrite16_A1) (unsigned short Data);
N  void (* pfWriteM16_A0)(U16 * pData, int NumItems);
X  void (* pfWriteM16_A0)(unsigned short * pData, int NumItems);
N  void (* pfWriteM16_A1)(U16 * pData, int NumItems);
X  void (* pfWriteM16_A1)(unsigned short * pData, int NumItems);
N  U16  (* pfRead16_A0)  (void);
X  unsigned short  (* pfRead16_A0)  (void);
N  U16  (* pfRead16_A1)  (void);
X  unsigned short  (* pfRead16_A1)  (void);
N  void (* pfReadM16_A0) (U16 * pData, int NumItems);
X  void (* pfReadM16_A0) (unsigned short * pData, int NumItems);
N  void (* pfReadM16_A1) (U16 * pData, int NumItems);
X  void (* pfReadM16_A1) (unsigned short * pData, int NumItems);
N  //
N  // 32 Bit access
N  //
N  void (* pfWrite32_A0) (U32 Data);
X  void (* pfWrite32_A0) (unsigned long Data);
N  void (* pfWrite32_A1) (U32 Data);
X  void (* pfWrite32_A1) (unsigned long Data);
N  void (* pfWriteM32_A0)(U32 * pData, int NumItems);
X  void (* pfWriteM32_A0)(unsigned long * pData, int NumItems);
N  void (* pfWriteM32_A1)(U32 * pData, int NumItems);
X  void (* pfWriteM32_A1)(unsigned long * pData, int NumItems);
N  U32  (* pfRead32_A0)  (void);
X  unsigned long  (* pfRead32_A0)  (void);
N  U32  (* pfRead32_A1)  (void);
X  unsigned long  (* pfRead32_A1)  (void);
N  void (* pfReadM32_A0) (U32 * pData, int NumItems);
X  void (* pfReadM32_A0) (unsigned long * pData, int NumItems);
N  void (* pfReadM32_A1) (U32 * pData, int NumItems);
X  void (* pfReadM32_A1) (unsigned long * pData, int NumItems);
N  //
N  // SPI access
N  //
N  void (* pfSetCS)      (U8 NotActive);
X  void (* pfSetCS)      (unsigned char NotActive);
N  //
N  // Common routines
N  //
N  void (* pfFlushBuffer)(void);
N} GUI_PORT_API;
N
N/*********************************************************************
N*
N*       Send/Receive function for VNC and/or emWinSPY
N*/
Ntypedef int    (* GUI_tSend)  (const U8 * pData, int len, void * p);
Xtypedef int    (* GUI_tSend)  (const unsigned char * pData, int len, void * p);
Ntypedef int    (* GUI_tRecv)  (      U8 * pData, int len, void * p);
Xtypedef int    (* GUI_tRecv)  (      unsigned char * pData, int len, void * p);
N
N/*********************************************************************
N*
N*       Memory allocation replacement for emWinSPY
N*/
Ntypedef void * (* GUI_tMalloc)(unsigned int);
Ntypedef void   (* GUI_tFree)  (void *);
N
N#endif  /* GUITYPE_H_INCLUDED */
N
N/*************************** End of file ****************************/
L 51 "..\..\..\..\ThirdParty\emWin\Include\WM.h" 2
N#include "WM_GUI.h"       /* Some functions needed by GUI routines */
L 1 "..\..\..\..\ThirdParty\emWin\Include\WM_GUI.h" 1
N/*********************************************************************
N*                    SEGGER Microcontroller GmbH                     *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2023  SEGGER Microcontroller GmbH                *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V6.46 - Graphical user interface for embedded applications **
NemWin is protected by international copyright laws. Knowledge of the
Nsource code may not be used to write a similar product. 
NThis file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed by SEGGER Software GmbH to Nuvoton Technology Corporation
Nat the address: No. 4, Creation Rd. III, Hsinchu Science Park, Taiwan
Nfor the purposes  of  creating  libraries  for its 
NArm Cortex-A, Arm Cortex-M and  Arm9 32-bit microcontrollers, commercialized and distributed by Nuvoton Technology Corporation
Nunder  the terms and conditions  of  an  End  User  
NLicense  Agreement  supplied  with  the libraries.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NLicensing information
NLicensor:                 SEGGER Software GmbH
NLicensed to:              Nuvoton Technology Corporation, No. 4, Creation Rd. III, Hsinchu Science Park, 30077 Hsinchu City, Taiwan
NLicensed SEGGER software: emWin
NLicense number:           GUI-00735
NLicense model:            emWin License Agreement, signed February 27, 2018
NLicensed platform:        Cortex-M, Cortex-A, and ARM9 32-bit series microcontroller designed and manufactured by Nuvoton Technology Corporation.
N----------------------------------------------------------------------
NSupport and Update Agreement (SUA)
NSUA period:               2018-03-26 - 2025-09-04
NContact to extend SUA:    sales@segger.com
N----------------------------------------------------------------------
NFile        : WM_GUI.h
NPurpose     : Windows manager include for low level GUI routines
N----------------------------------------------------------------------
N*/
N
N#ifndef WM_GUI_H            /* Make sure we only include it once */
N#define WM_GUI_H
N
N#if defined(__cplusplus)
X#if 0L
Sextern "C" {     /* Make sure we have C-declarations in C++ programs */
N#endif
N
Nint       WM__InitIVRSearch(const GUI_RECT* pMaxRect);
Nint       WM__GetNextIVR   (void);
Nint       WM__GetOrgX_AA(void);
Nint       WM__GetOrgY_AA(void);
N
N#define WM_ITERATE_START(pRect)                   \
N  {                                               \
N    if (WM__InitIVRSearch(pRect))                 \
N      do {
X#define WM_ITERATE_START(pRect)                     {                                                   if (WM__InitIVRSearch(pRect))                       do {
N
N#define WM_ITERATE_END()                          \
N    } while (WM__GetNextIVR());                   \
N  }
X#define WM_ITERATE_END()                              } while (WM__GetNextIVR());                     }
N
N#define WM_ADDORGX(x)       (x += GUI_pContext->xOff)
N#define WM_ADDORGY(y)       (y += GUI_pContext->yOff)
N#define WM_ADDORG(x0,y0)    WM_ADDORGX(x0); WM_ADDORGY(y0)
N#define WM_ADDORGX_AA(x)    (x += WM__GetOrgX_AA())
N#define WM_ADDORGY_AA(y)    (y += WM__GetOrgY_AA())
N#define WM_ADDORG_AA(x0,y0) WM_ADDORGX_AA(x0); WM_ADDORGY_AA(y0)
N#define WM_SUBORGX(x)       (x -= GUI_pContext->xOff)
N#define WM_SUBORGY(y)       (y -= GUI_pContext->yOff)
N#define WM_SUBORG(x0,y0)    WM_SUBORGX(x0); WM_SUBORGY(y0)
N
N#if defined(__cplusplus)
X#if 0L
S  }
N#endif
N
N
N#endif   /* Avoid multiple inclusion */
N
N/*************************** End of file ****************************/
L 52 "..\..\..\..\ThirdParty\emWin\Include\WM.h" 2
N#include "GUI.h"
L 1 "..\..\..\..\ThirdParty\emWin\Include\GUI.h" 1
N/*********************************************************************
N*                    SEGGER Microcontroller GmbH                     *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2023  SEGGER Microcontroller GmbH                *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V6.46 - Graphical user interface for embedded applications **
NemWin is protected by international copyright laws. Knowledge of the
Nsource code may not be used to write a similar product. 
NThis file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed by SEGGER Software GmbH to Nuvoton Technology Corporation
Nat the address: No. 4, Creation Rd. III, Hsinchu Science Park, Taiwan
Nfor the purposes  of  creating  libraries  for its 
NArm Cortex-A, Arm Cortex-M and  Arm9 32-bit microcontrollers, commercialized and distributed by Nuvoton Technology Corporation
Nunder  the terms and conditions  of  an  End  User  
NLicense  Agreement  supplied  with  the libraries.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NLicensing information
NLicensor:                 SEGGER Software GmbH
NLicensed to:              Nuvoton Technology Corporation, No. 4, Creation Rd. III, Hsinchu Science Park, 30077 Hsinchu City, Taiwan
NLicensed SEGGER software: emWin
NLicense number:           GUI-00735
NLicense model:            emWin License Agreement, signed February 27, 2018
NLicensed platform:        Cortex-M, Cortex-A, and ARM9 32-bit series microcontroller designed and manufactured by Nuvoton Technology Corporation.
N----------------------------------------------------------------------
NSupport and Update Agreement (SUA)
NSUA period:               2018-03-26 - 2025-09-04
NContact to extend SUA:    sales@segger.com
N----------------------------------------------------------------------
NFile        : GUI.h
NPurpose     : GUI API include file
N---------------------------END-OF-HEADER------------------------------
N*/
N
N#ifndef  GUI_H
N#define  GUI_H
N
N#include <stddef.h>
N#include <string.h>   // for memset()
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\string.h" 1
N/* string.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.11 */
N/* Copyright (C) Codemist Ltd., 1988-1993.                        */
N/* Copyright 1991-1993 ARM Limited. All rights reserved.          */
N/* version 0.04 */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N */
N
N/*
N * string.h declares one type and several functions, and defines one macro
N * useful for manipulating character arrays and other objects treated as
N * character arrays. Various methods are used for determining the lengths of
N * the arrays, but in all cases a char * or void * argument points to the
N * initial (lowest addresses) character of the array. If an array is written
N * beyond the end of an object, the behaviour is undefined.
N */
N
N#ifndef __string_h
N#define __string_h
N#define __ARMCLIB_VERSION 5060019
N
N#define _ARMABI __declspec(__nothrow)
N
N  #ifndef __STRING_DECLS
N  #define __STRING_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S        namespace std {
S        #define __CLIBNS std::
S        extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N#elif !defined(__size_t)
S  #define __size_t 1
S  #if __sizeof_ptr == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
S  #else
S    typedef unsigned int size_t;   /* see <stddef.h> */
S  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
Nextern _ARMABI void *memcpy(void * __restrict /*s1*/,
Xextern __declspec(__nothrow) void *memcpy(void * __restrict  ,
N                    const void * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI void *memmove(void * /*s1*/,
Xextern __declspec(__nothrow) void *memmove(void *  ,
N                    const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. Copying takes place as if the n characters from the
N    * object pointed to by s2 are first copied into a temporary array of n
N    * characters that does not overlap the objects pointed to by s1 and s2,
N    * and then the n characters from the temporary array are copied into the
N    * object pointed to by s1.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strcpy(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcpy(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string pointed to by s2 (including the terminating nul
N    * character) into the array pointed to by s1. If copying takes place
N    * between objects that overlap, the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strncpy(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncpy(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies not more than n characters (characters that follow a null
N    * character are not copied) from the array pointed to by s2 into the array
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
N
Nextern _ARMABI char *strcat(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcat(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends a copy of the string pointed to by s2 (including the terminating
N    * null character) to the end of the string pointed to by s1. The initial
N    * character of s2 overwrites the null character at the end of s1.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strncat(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncat(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends not more than n characters (a null character and characters that
N    * follow it are not appended) from the array pointed to by s2 to the end of
N    * the string pointed to by s1. The initial character of s2 overwrites the
N    * null character at the end of s1. A terminating null character is always
N    * appended to the result.
N    * Returns: the value of s1.
N    */
N
N/*
N * The sign of a nonzero value returned by the comparison functions is
N * determined by the sign of the difference between the values of the first
N * pair of characters (both interpreted as unsigned char) that differ in the
N * objects being compared.
N */
N
Nextern _ARMABI int memcmp(const void * /*s1*/, const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int memcmp(const void *  , const void *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the first n characters of the object pointed to by s1 to the
N    * first n characters of the object pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the object pointed to by s1 is greater than, equal to, or
N    *          less than the object pointed to by s2.
N    */
Nextern _ARMABI int strcmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strncmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strcasecmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcasecmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2,
N    * case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strncasecmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncasecmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2, case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strcoll(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcoll(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2, both
N    * interpreted as appropriate to the LC_COLLATE category of the current
N    * locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2 when both are interpreted
N    *          as appropriate to the current locale.
N    */
N
Nextern _ARMABI size_t strxfrm(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) size_t strxfrm(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(2)));
N   /*
N    * transforms the string pointed to by s2 and places the resulting string
N    * into the array pointed to by s1. The transformation function is such that
N    * if the strcmp function is applied to two transformed strings, it returns
N    * a value greater than, equal to or less than zero, corresponding to the
N    * result of the strcoll function applied to the same two original strings.
N    * No more than n characters are placed into the resulting array pointed to
N    * by s1, including the terminating null character. If n is zero, s1 is
N    * permitted to be a null pointer. If copying takes place between objects
N    * that overlap, the behaviour is undefined.
N    * Returns: The length of the transformed string is returned (not including
N    *          the terminating null character). If the value returned is n or
N    *          more, the contents of the array pointed to by s1 are
N    *          indeterminate.
N    */
N
N
N#ifdef __cplusplus
Sextern _ARMABI const void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Sextern "C++" void *memchr(void * __s, int __c, size_t __n) __attribute__((__nonnull__(1)));
Sextern "C++" inline void *memchr(void * __s, int __c, size_t __n)
S    { return const_cast<void *>(memchr(const_cast<const void *>(__s), __c, __n)); }
N#else
Nextern _ARMABI void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void *memchr(const void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an unsigned char) in the
N    * initial n characters (each interpreted as unsigned char) of the object
N    * pointed to by s.
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the object.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Sextern "C++" char *strchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Sextern "C++" inline char *strchr(char * __s, int __c)
S    { return const_cast<char *>(strchr(const_cast<const char *>(__s), __c)); }
N#else
Nextern _ARMABI char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *strchr(const char *  , int  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an char) in the string
N    * pointed to by s (including the terminating null character).
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the string.
N    */
N
Nextern _ARMABI size_t strcspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strcspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters not from the string pointed to by
N    * s2. The terminating null character is not considered part of s2.
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Sextern "C++" char *strpbrk(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Sextern "C++" inline char *strpbrk(char * __s1, const char * __s2)
S    { return const_cast<char *>(strpbrk(const_cast<const char *>(__s1), __s2)); }
N#else
Nextern _ARMABI char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strpbrk(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of any
N    * character from the string pointed to by s2.
N    * Returns: returns a pointer to the character, or a null pointer if no
N    *          character form s2 occurs in s1.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Sextern "C++" char *strrchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Sextern "C++" inline char *strrchr(char * __s, int __c)
S    { return const_cast<char *>(strrchr(const_cast<const char *>(__s), __c)); }
N#else
Nextern _ARMABI char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *strrchr(const char *  , int  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the last occurence of c (converted to a char) in the string
N    * pointed to by s. The terminating null character is considered part of
N    * the string.
N    * Returns: returns a pointer to the character, or a null pointer if c does
N    *          not occur in the string.
N    */
N
Nextern _ARMABI size_t strspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters from the string pointed to by S2
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Sextern "C++" char *strstr(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Sextern "C++" inline char *strstr(char * __s1, const char * __s2)
S    { return const_cast<char *>(strstr(const_cast<const char *>(__s1), __s2)); }
N#else
Nextern _ARMABI char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strstr(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of the
N    * sequence of characters (excluding the terminating null character) in the
N    * string pointed to by s2.
N    * Returns: a pointer to the located string, or a null pointer if the string
N    *          is not found.
N    */
N
Nextern _ARMABI char *strtok(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) char *strtok(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(2)));
Nextern _ARMABI char *_strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *_strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#ifndef __STRICT_ANSI__
Nextern _ARMABI char *strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#endif
N   /*
N    * A sequence of calls to the strtok function breaks the string pointed to
N    * by s1 into a sequence of tokens, each of which is delimited by a
N    * character from the string pointed to by s2. The first call in the
N    * sequence has s1 as its first argument, and is followed by calls with a
N    * null pointer as their first argument. The separator string pointed to by
N    * s2 may be different from call to call.
N    * The first call in the sequence searches for the first character that is
N    * not contained in the current separator string s2. If no such character
N    * is found, then there are no tokens in s1 and the strtok function returns
N    * a null pointer. If such a character is found, it is the start of the
N    * first token.
N    * The strtok function then searches from there for a character that is
N    * contained in the current separator string. If no such character is found,
N    * the current token extends to the end of the string pointed to by s1, and
N    * subsequent searches for a token will fail. If such a character is found,
N    * it is overwritten by a null character, which terminates the current
N    * token. The strtok function saves a pointer to the following character,
N    * from which the next search for a token will start.
N    * Each subsequent call, with a null pointer as the value for the first
N    * argument, starts searching from the saved pointer and behaves as
N    * described above.
N    * Returns: pointer to the first character of a token, or a null pointer if
N    *          there is no token.
N    *
N    * strtok_r() is a common extension which works exactly like
N    * strtok(), but instead of storing its state in a hidden
N    * library variable, requires the user to pass in a pointer to a
N    * char * variable which will be used instead. Any sequence of
N    * calls to strtok_r() passing the same char ** pointer should
N    * behave exactly like the corresponding sequence of calls to
N    * strtok(). This means that strtok_r() can safely be used in
N    * multi-threaded programs, and also that you can tokenise two
N    * strings in parallel.
N    */
N
Nextern _ARMABI void *memset(void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void *memset(void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
N   /*
N    * copies the value of c (converted to an unsigned char) into each of the
N    * first n charactes of the object pointed to by s.
N    * Returns: the value of s.
N    */
Nextern _ARMABI char *strerror(int /*errnum*/);
Xextern __declspec(__nothrow) char *strerror(int  );
N   /*
N    * maps the error number in errnum to an error message string.
N    * Returns: a pointer to the string, the contents of which are
N    *          implementation-defined. The array pointed to shall not be
N    *          modified by the program, but may be overwritten by a
N    *          subsequent call to the strerror function.
N    */
Nextern _ARMABI size_t strlen(const char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) size_t strlen(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * computes the length of the string pointed to by s.
N    * Returns: the number of characters that precede the terminating null
N    *          character.
N    */
N
Nextern _ARMABI size_t strlcpy(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcpy(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string src into the string dst, using no more than
N    * len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src. Thus, the operation
N    * succeeded without truncation if and only if ret < len;
N    * otherwise, the value in ret tells you how big to make dst if
N    * you decide to reallocate it. (That value does _not_ include
N    * the NUL.)
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _ARMABI size_t strlcat(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcat(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * concatenates the string src to the string dst, using no more
N    * than len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src plus the original length
N    * of dst. Thus, the operation succeeded without truncation if
N    * and only if ret < len; otherwise, the value in ret tells you
N    * how big to make dst if you decide to reallocate it. (That
N    * value does _not_ include the NUL.)
N    * 
N    * If no NUL is encountered within the first len bytes of dst,
N    * then the length of dst is considered to have been equal to
N    * len for the purposes of the return value (as if there were a
N    * NUL at dst[len]). Thus, the return value in this case is len
N    * + strlen(src).
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _ARMABI void _membitcpybl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpybb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpyhl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpyhb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpywl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpywb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovebl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovebb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovehl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovehb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovewl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovewb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
N    /*
N     * Copies or moves a piece of memory from one place to another,
N     * with one-bit granularity. So you can start or finish a copy
N     * part way through a byte, and you can copy between regions
N     * with different alignment within a byte.
N     * 
N     * All these functions have the same prototype: two void *
N     * pointers for destination and source, then two integers
N     * giving the bit offset from those pointers, and finally the
N     * number of bits to copy.
N     * 
N     * Just like memcpy and memmove, the "cpy" functions copy as
N     * fast as they can in the assumption that the memory regions
N     * do not overlap, while the "move" functions cope correctly
N     * with overlap.
N     *
N     * Treating memory as a stream of individual bits requires
N     * defining a convention about what order those bits are
N     * considered to be arranged in. The above functions support
N     * multiple conventions:
N     * 
N     *  - the "bl" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in little-endian fashion, so that the LSB comes
N     *    first. (For example, membitcpybl(a,b,0,7,1) would copy
N     *    the MSB of the byte at b to the LSB of the byte at a.)
N     * 
N     *  - the "bb" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in big-endian fashion, so that the MSB comes
N     *    first.
N     * 
N     *  - the "hl" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in little-endian fashion.
N     * 
N     *  - the "hb" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in big-endian fashion.
N     * 
N     *  - the "wl" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in little-endian fashion.
N     * 
N     *  - the "wb" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in big-endian fashion.
N     */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STRING_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STRING_NO_EXPORTS
S      using ::std::size_t;
S      using ::std::memcpy;
S      using ::std::memmove;
S      using ::std::strcpy;
S      using ::std::strncpy;
S      using ::std::strcat;
S      using ::std::strncat;
S      using ::std::memcmp;
S      using ::std::strcmp;
S      using ::std::strncmp;
S      using ::std::strcasecmp;
S      using ::std::strncasecmp;
S      using ::std::strcoll;
S      using ::std::strxfrm;
S      using ::std::memchr;
S      using ::std::strchr;
S      using ::std::strcspn;
S      using ::std::strpbrk;
S      using ::std::strrchr;
S      using ::std::strspn;
S      using ::std::strstr;
S      using ::std::strtok;
S#ifndef __STRICT_ANSI__
S      using ::std::strtok_r;
S#endif
S      using ::std::_strtok_r;
S      using ::std::memset;
S      using ::std::strerror;
S      using ::std::strlen;
S      using ::std::strlcpy;
S      using ::std::strlcat;
S      using ::std::_membitcpybl;
S      using ::std::_membitcpybb;
S      using ::std::_membitcpyhl;
S      using ::std::_membitcpyhb;
S      using ::std::_membitcpywl;
S      using ::std::_membitcpywb;
S      using ::std::_membitmovebl;
S      using ::std::_membitmovebb;
S      using ::std::_membitmovehl;
S      using ::std::_membitmovehb;
S      using ::std::_membitmovewl;
S      using ::std::_membitmovewb;
S    #endif /* __STRING_NO_EXPORTS */
N  #endif /* __cplusplus */
N
N#endif
N
N/* end of string.h */
N
L 50 "..\..\..\..\ThirdParty\emWin\Include\GUI.h" 2
N
N#include "GUI_ConfDefaults.h"
N#include "GUI_Type.h"
N#include "GUI_Version.h"
L 1 "..\..\..\..\ThirdParty\emWin\Include\GUI_Version.h" 1
N/*********************************************************************
N*                    SEGGER Microcontroller GmbH                     *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2023  SEGGER Microcontroller GmbH                *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V6.46 - Graphical user interface for embedded applications **
NemWin is protected by international copyright laws. Knowledge of the
Nsource code may not be used to write a similar product. 
NThis file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed by SEGGER Software GmbH to Nuvoton Technology Corporation
Nat the address: No. 4, Creation Rd. III, Hsinchu Science Park, Taiwan
Nfor the purposes  of  creating  libraries  for its 
NArm Cortex-A, Arm Cortex-M and  Arm9 32-bit microcontrollers, commercialized and distributed by Nuvoton Technology Corporation
Nunder  the terms and conditions  of  an  End  User  
NLicense  Agreement  supplied  with  the libraries.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NLicensing information
NLicensor:                 SEGGER Software GmbH
NLicensed to:              Nuvoton Technology Corporation, No. 4, Creation Rd. III, Hsinchu Science Park, 30077 Hsinchu City, Taiwan
NLicensed SEGGER software: emWin
NLicense number:           GUI-00735
NLicense model:            emWin License Agreement, signed February 27, 2018
NLicensed platform:        Cortex-M, Cortex-A, and ARM9 32-bit series microcontroller designed and manufactured by Nuvoton Technology Corporation.
N----------------------------------------------------------------------
NSupport and Update Agreement (SUA)
NSUA period:               2018-03-26 - 2025-09-04
NContact to extend SUA:    sales@segger.com
N----------------------------------------------------------------------
NFile        : GUI_Version.h
NPurpose     : Include file defining current GUI version
N---------------------------END-OF-HEADER------------------------------
N*/
N
N#ifndef  GUI_VERSION_H
N#define  GUI_VERSION_H
N
N#define GUI_VERSION 646011
N
N#endif   /* Avoid multiple inclusion */
N
N/*************************** End of file ****************************/
L 54 "..\..\..\..\ThirdParty\emWin\Include\GUI.h" 2
N
N#if defined(__cplusplus)
X#if 0L
Sextern "C" {     /* Make sure we have C-declarations in C++ programs */
N#endif
N
N/*********************************************************************
N*
N*       Disable string function warning with newer MSVC versions
N*/
N#if defined (_MSC_VER)
X#if 0L
S  #if (_MSC_VER > 1200)
S    #pragma warning( disable : 4996)
S  #endif
N#endif
N
N/*********************************************************************
N*
N*       Numeric limits
N*/
N#define I32_MIN (-2147483647L - 1)
N#define I32_MAX   2147483647L
N
N/*********************************************************************
N*
N*       Macros, function replacement
N*/
N#define GUI_ABS(a)              (((a) < 0) ? (-(a)) : (a))
N#define GUI_COUNTOF(a)          (sizeof(a) / sizeof(a[0]))
N#define GUI_MIN(a,b)            (((a) < (b)) ? (a) : (b))
N#define GUI_MAX(a,b)            (((a) > (b)) ? (a) : (b))
N#define GUI_ZEROFILL(p, Size)   (memset(p, 0, Size))
N#define GUI_ZEROFILL_VAR(var)   (memset(&var,    0, sizeof(var)))
N#define GUI_ZEROFILL_ARR(arr)   (memset(&arr[0], 0, sizeof(arr)))
N#define GUI_ZEROFILL_PTR(ptr)   (memset(ptr,     0, sizeof(*ptr)))
N
N/*********************************************************************
N*
N*       Support for multitasking systems (locking)
N*/
Ntypedef struct GUI_CONTEXT GUI_CONTEXT;
N
N#if !GUI_OS
X#if !(0)
N  #define GUI_LOCK()
N  #define GUI_UNLOCK()
N  #define GUITASK_INIT()
N  #define GUITASK_COPY_CONTEXT()
N#else
S  void GUI_Lock(void);
S  void GUI_Unlock(void);
S  void GUITASK_Init(void);
S  void GUITASK_CopyContext(void);
S  void GUITASK_SetMaxTask(int MaxTask);
S  int  GUITASK_GetMaxTask(void);
S  GUI_CONTEXT * GUITASK_GetpContext(int Index);
S  #define GUI_LOCK()             GUI_Lock()
S  #define GUI_UNLOCK()           GUI_Unlock()
S  #define GUITASK_INIT()         GUITASK_Init()
S  #define GUITASK_COPY_CONTEXT() GUITASK_CopyContext()
N#endif
N
N/*********************************************************************
N*
N*       API table of a display driver
N*/
Nstruct GUI_DEVICE_API {
N  //
N  // Data
N  //
N  int DeviceClassIndex;
N  //
N  // Drawing functions
N  //
N  void           (* pfDrawBitmap   )(GUI_DEVICE *  pDevice,  int x0, int y0, int xsize, int ysize, int BitsPerPixel, int BytesPerLine, const U8 * pData, int Diff, const LCD_PIXELINDEX * pTrans);
X  void           (* pfDrawBitmap   )(GUI_DEVICE *  pDevice,  int x0, int y0, int xsize, int ysize, int BitsPerPixel, int BytesPerLine, const unsigned char * pData, int Diff, const unsigned long * pTrans);
N  void           (* pfDrawHLine    )(GUI_DEVICE *  pDevice,  int x0, int y0,  int x1);
N  void           (* pfDrawVLine    )(GUI_DEVICE *  pDevice,  int x , int y0,  int y1);
N  void           (* pfFillRect     )(GUI_DEVICE *  pDevice,  int x0, int y0, int x1, int y1);
N  LCD_PIXELINDEX (* pfGetPixelIndex)(GUI_DEVICE *  pDevice,  int x, int y);
X  unsigned long (* pfGetPixelIndex)(GUI_DEVICE *  pDevice,  int x, int y);
N  void           (* pfSetPixelIndex)(GUI_DEVICE *  pDevice,  int x, int y, LCD_PIXELINDEX ColorIndex);
X  void           (* pfSetPixelIndex)(GUI_DEVICE *  pDevice,  int x, int y, unsigned long ColorIndex);
N  void           (* pfXorPixel     )(GUI_DEVICE *  pDevice,  int x, int y);
N  //
N  // Set origin
N  //
N  void           (* pfSetOrg       )(GUI_DEVICE *  pDevice,  int x, int y);
N  //
N  // Request information
N  //
N  void         (*(* pfGetDevFunc)   (GUI_DEVICE ** ppDevice, int Index))(void);
N  I32            (* pfGetDevProp   )(GUI_DEVICE *  pDevice,  int Index);
X  signed long            (* pfGetDevProp   )(GUI_DEVICE *  pDevice,  int Index);
N  const void    *(* pfGetDevData   )(GUI_DEVICE *  pDevice,  int Index);
N  void           (* pfGetRect      )(GUI_DEVICE *  pDevice,  LCD_RECT * pRect);
N};
N
N/*********************************************************************
N*
N*       Device classes
N*/
Ntypedef enum {
N  DEVICE_CLASS_DRIVER = 0,
N  DEVICE_CLASS_DRIVER_MODIFIER,   // Zoom or delta-pixel modifier
N  DEVICE_CLASS_VNC,
N  DEVICE_CLASS_SPRITE,
N  DEVICE_CLASS_MEMDEV,
N  DEVICE_CLASS_ALPHA,
N  DEVICE_CLASS_AUTOALPHA,
N  DEVICE_CLASS_MEASDEV
N} DEVICE_CLASS;
N
N#define GUI_DEVICE_STAYONTOP 1
N
N/*********************************************************************
N*
N*       Display drivers
N*/
N//
N// Addresses
N//
Nextern const GUI_DEVICE_API GUIDRV_Win_API;
N//
N// Macros to be used in configuration files
N//
N#define GUIDRV_WIN32        &GUIDRV_Win_API
N
N/*********************************************************************
N*
N*       Definition of GUI_DEVICE structure
N*/
Nstruct GUI_DEVICE {
N  //
N  // Linking
N  //
N  GUI_DEVICE * pNext;
N  GUI_DEVICE * pPrev;
N  //
N  // Data
N  //
N  union {
N    GUI_HMEM hContext; // Handle of payload data like sprite- or memory device context
X    signed long hContext; 
N    void   * pContext; // Pointer for context data in a fixed block
N  } u;
N  //
N  // API pointers
N  //
N  const GUI_DEVICE_API     * pDeviceAPI;
N  const LCD_API_COLOR_CONV * pColorConvAPI;
N  U16 Flags;
X  unsigned short Flags;
N  int LayerIndex;
N};
N
Nextern const GUI_DEVICE_API GUI_MEMDEV_DEVICE_1;
Nextern const GUI_DEVICE_API GUI_MEMDEV_DEVICE_8;
Nextern const GUI_DEVICE_API GUI_MEMDEV_DEVICE_16;
Nextern const GUI_DEVICE_API GUI_MEMDEV_DEVICE_32;
N
N/*********************************************************************
N*
N*       GUI_CONTEXT
N*
N*  This structure is public for one reason only:
N*  To allow the application to save and restore the context.
N*/
Ntypedef union {
N  U8  aColorIndex8[2];
X  unsigned char  aColorIndex8[2];
N  U16 aColorIndex16[2];
X  unsigned short aColorIndex16[2];
N  U32 aColorIndex32[2];
X  unsigned long aColorIndex32[2];
N} LCD_COLORINDEX_UNION;
N
Nstruct GUI_CONTEXT {
N  //
N  // Variables in LCD module
N  //
N  LCD_COLORINDEX_UNION uLCD;
N  LCD_RECT       ClipRect;
N  U8             DrawMode;
X  unsigned char             DrawMode;
N  U8             SelLayer;
X  unsigned char             SelLayer;
N  U8             TextStyle;
X  unsigned char             TextStyle;
N  //
N  // Variables in GL module
N  //
N  GUI_RECT * pClipRect_HL;                 // High level clip rectangle ... Speed optimization so drawing routines can optimize
N  U16        PenSize;
X  unsigned short        PenSize;
N  U8         PenShape;
X  unsigned char         PenShape;
N  U8         LineStyle;
X  unsigned char         LineStyle;
N  U8         StrikeWidth;
X  unsigned char         StrikeWidth;
N  //
N  // Variables in GUICHAR module
N  //
N  const GUI_FONT * pAFont;
N  I16P LBorder;
X  signed short LBorder;
N  I16P DispPosX, DispPosY;
X  signed short DispPosX, DispPosY;
N  I16P DrawPosX, DrawPosY;
X  signed short DrawPosX, DrawPosY;
N  I16P TextMode, TextAlign;
X  signed short TextMode, TextAlign;
N  GUI_COLOR Color, BkColor;                // Required only when changing devices and for speed opt (caching)
N  //
N  // Pointer to  color indices
N  //
N  LCD_PIXELINDEX * LCD_pBkColorIndex;
X  unsigned long * LCD_pBkColorIndex;
N  LCD_PIXELINDEX * LCD_pColorIndex;
X  unsigned long * LCD_pColorIndex;
N  //
N  // Variables in WM module
N  //
N  #if GUI_WINSUPPORT
X  #if 1
N    const GUI_RECT * WM__pUserClipRect;
N    GUI_HWIN hAWin;
N    int xOff, yOff;
N    U8 WM_IsActive;
X    unsigned char WM_IsActive;
N    U8 DisableCliprect;
X    unsigned char DisableCliprect;
N    U8 ClipBKActive;
X    unsigned char ClipBKActive;
N  #endif
N  //
N  // Array of pointers to device chains
N  //
N  GUI_DEVICE * apDriver[GUI_NUM_LAYERS];
X  GUI_DEVICE * apDriver[4];
N  //
N  // Variables in MEMDEV module (with memory devices only)
N  //
N  GUI_HMEM    hDevData;
X  signed long    hDevData;
N  //
N  // Variables in Antialiasing module
N  //
N  const tLCD_HL_APIList * pLCD_HL;       // Required to reroute drawing (HLine & Pixel) to the AA module
N  U8 AA_Factor;
X  unsigned char AA_Factor;
N  U8 AA_HiResEnable;
X  unsigned char AA_HiResEnable;
N  void (* AA_pfSetPixelAA)(int x, int y, U8 Intens); // Function to be used for drawing a single pixel
X  void (* AA_pfSetPixelAA)(int x, int y, unsigned char Intens); 
N  //
N  // Used to reference and link in the copyright string for libraries.
N  //
N  const char * sCopyright;
N};
N
N/* Rename GUI_SaveContext in order to avoid crashes if wrong GUIConf is used */
N#if (GUI_WINSUPPORT == 1)
X#if (1 == 1)
N  #define GUI_SaveContext GUI_SaveContext_W
N#else
S  #define GUI_SaveContext GUI_SaveContext_
N#endif
N
N/*********************************************************************
N*
N*       Device management
N*/
NGUI_DEVICE * GUI_DEVICE_Create          (const GUI_DEVICE_API * pDeviceAPI, const LCD_API_COLOR_CONV * pColorConvAPI, U16 Flags, int LayerIndex);
XGUI_DEVICE * GUI_DEVICE_Create          (const GUI_DEVICE_API * pDeviceAPI, const LCD_API_COLOR_CONV * pColorConvAPI, unsigned short Flags, int LayerIndex);
NGUI_DEVICE * GUI_DEVICE_CreateAndLink   (const GUI_DEVICE_API * pDeviceAPI, const LCD_API_COLOR_CONV * pColorConvAPI, U16 Flags, int LayerIndex);
XGUI_DEVICE * GUI_DEVICE_CreateAndLink   (const GUI_DEVICE_API * pDeviceAPI, const LCD_API_COLOR_CONV * pColorConvAPI, unsigned short Flags, int LayerIndex);
Nvoid         GUI_DEVICE_Delete          (GUI_DEVICE * pDevice);
Nint          GUI_DEVICE_GetDeviceClassEx(int LayerIndex);
Nint          GUI_DEVICE_GetDeviceClass  (void);
Nint          GUI_DEVICE_Link            (GUI_DEVICE * pDevice);
Nvoid         GUI_DEVICE_Unlink          (GUI_DEVICE * pDevice);
NGUI_DEVICE * GUI_DEVICE__GetpDriver     (int LayerIndex);
NGUI_DEVICE * GUI_DEVICE__GetpDevice     (int LayerIndex, int DeviceClass);
N
NGUI_DEVICE * GUI_DEVICE_UnlinkTaskDevices(void);
Nvoid         GUI_DEVICE_LinkDevices      (GUI_DEVICE * pDevice);
N
N/*********************************************************************
N*
N*       GUI_DIRTYDEVICE_INFO
N*
N*   Description
N*     Information about the dirty device.
N*/
Ntypedef struct {
N  void * pData;         // Pointer to the first changed pixel.\sup{*1}
N  int    x0;            // Leftmost position of changed area.
N  int    y0;            // Topmost position of changed area.
N  int    xSize;         // Size in X of changed area.
N  int    ySize;         // Size in Y of changed area.
N  int    LineOff;       // Number of pixels (stride) from one line to the next line.\sup{*1}
N  int    BytesPerPixel; // Number of bytes required per pixel.
N  int    IsDirty;       // Indicates if dirty pixels exist.
N} GUI_DIRTYDEVICE_INFO;
N
Nint GUI_DIRTYDEVICE_Create      (void);
Nint GUI_DIRTYDEVICE_CreateEx    (int LayerIndex);
Nint GUI_DIRTYDEVICE_CreateExInfo(GUI_DIRTYDEVICE_INFO * pInfo, int LayerIndex);
Nint GUI_DIRTYDEVICE_Delete      (void);
Nint GUI_DIRTYDEVICE_DeleteEx    (int LayerIndex);
Nint GUI_DIRTYDEVICE_Fetch       (GUI_DIRTYDEVICE_INFO * pInfo);
Nint GUI_DIRTYDEVICE_FetchEx     (GUI_DIRTYDEVICE_INFO * pInfo, int LayerIndex);
N
N/*********************************************************************
N*
N*       GUI_GCACHE
N*/
N//
N// GCache modules, do not call directly!
N//
Nint GUI_GCACHE_SetMode1bpp (GUI_DEVICE * pDevice);
Nint GUI_GCACHE_SetMode4bpp (GUI_DEVICE * pDevice);
Nint GUI_GCACHE_SetMode16bpp(GUI_DEVICE * pDevice);
N
N/*********************************************************************
N*
N*       GUI_GCACHE modes
N* 
N*  Description
N*    GUI_GCACHE bit depths to be used for GUI_GCACHE_Create() and the
N*    other creation functions.
N*/
N#define GUI_GCACHE_1   (&GUI_GCACHE_SetMode1bpp)     // Use global cache with 1bpp  color depth.
N#define GUI_GCACHE_4   (&GUI_GCACHE_SetMode4bpp)     // Use global cache with 4bpp  color depth.
N#define GUI_GCACHE_16  (&GUI_GCACHE_SetMode16bpp)    // Use global cache with 16bpp color depth.
N/* emDoc stop mark */
N
N//
N// Public functions
N//
Nint GUI_GCACHE_Create      (int (* pfMode)(GUI_DEVICE *), const LCD_API_COLOR_CONV * pColorConvAPI);
Nint GUI_GCACHE_CreateEx    (int (* pfMode)(GUI_DEVICE *), const LCD_API_COLOR_CONV * pColorConvAPI, int LayerIndex);
Nint GUI_GCACHE_CreateUserEx(int (* pfMode)(GUI_DEVICE *), const LCD_API_COLOR_CONV * pColorConvAPI, int LayerIndex, void * pUserBuffer);
N//
N// Compatibility macros
N//
N#define GUI_GCACHE_1_Create(pColorConvAPI)                 GUI_GCACHE_Create  (GUI_GCACHE_1, pColorConvAPI)
N#define GUI_GCACHE_1_CreateEx(LayerIndex, pColorConvAPI)   GUI_GCACHE_CreateEx(GUI_GCACHE_1, LayerIndex, pColorConvAPI)
N#define GUI_GCACHE_4_Create(pColorConvAPI)                 GUI_GCACHE_Create  (GUI_GCACHE_4, pColorConvAPI)
N#define GUI_GCACHE_4_CreateEx(LayerIndex, pColorConvAPI)   GUI_GCACHE_CreateEx(GUI_GCACHE_4, LayerIndex, pColorConvAPI)
N
N/*********************************************************************
N*
N*       GUI_DCACHE
N*/
Nvoid GUI_DCACHE_SetClearCacheHook(void (* pFunc)(U32 LayerMask));
Xvoid GUI_DCACHE_SetClearCacheHook(void (* pFunc)(unsigned long LayerMask));
Nvoid GUI_DCACHE_Clear            (U32 LayerMask);
Xvoid GUI_DCACHE_Clear            (unsigned long LayerMask);
N
Nextern void (* GUI_DCACHE__pfClearCacheHook)(U32 LayerMask);
Xextern void (* GUI_DCACHE__pfClearCacheHook)(unsigned long LayerMask);
N
N/*********************************************************************
N*
N*       GUI_SOFTLAYER_CONFIG
N*
N*  Description
N*    Data structure used by GUI_SOFTLAYER_Enable() to configurate a
N*    soft layer.
N*/
Ntypedef struct {
N  int xPos;      // X-position.
N  int yPos;      // Y-position.
N  int xSize;     // X-size.
N  int ySize;     // Y-size.
N  int Visible;   // 1 = visible, 0 = not visible.
N} GUI_SOFTLAYER_CONFIG;
N
Nint  GUI_SOFTLAYER_Enable           (GUI_SOFTLAYER_CONFIG * pConfig, int NumLayers, GUI_COLOR CompositeColor);
Nint  GUI_SOFTLAYER_Refresh          (void);
Nvoid GUI_SOFTLAYER_SetCompositeColor(U32 Color);
Xvoid GUI_SOFTLAYER_SetCompositeColor(unsigned long Color);
Nint  GUI_SOFTLAYER_MULTIBUF_Enable  (int OnOff);
N
N/*********************************************************************
N*
N*       General routines
N*/
Nvoid             GUI_Exit                 (void);
Nconst GUI_RECT * GUI_GetClipRect          (void);
NGUI_COLOR        GUI_GetDefaultBkColor    (void);
NGUI_COLOR        GUI_GetDefaultColor      (void);
Nconst GUI_FONT * GUI_GetDefaultFont       (void);
Nint              GUI_GetScreenSizeX       (void);
Nint              GUI_GetScreenSizeY       (void);
Nconst char *     GUI_GetVersionString     (void);
Nint              GUI_Init                 (void);
Nint              GUI_IsInitialized        (void);
Nvoid             GUI_SetAfterExitHook     (void (* pFunc)(void));
Nvoid             GUI_SetAfterInitHook     (void (* pFunc)(void));
Nvoid             GUI_SetPreInitHook       (void (* pFunc)(void));
Nvoid             GUI_RegisterAfterInitHook(void (* pFunc)(void), GUI_REGISTER_INIT * pRegisterInit);
Xvoid             GUI_RegisterAfterInitHook(void (* pFunc)(void), GUI_REGISTER_HOOK * pRegisterInit);
Nvoid             GUI_RestoreContext       (const GUI_CONTEXT * pContext);
Nvoid             GUI_SaveContext          (GUI_CONTEXT * pContext);
Xvoid             GUI_SaveContext_W          (GUI_CONTEXT * pContext);
Nconst GUI_RECT * GUI_SetClipRect          (const GUI_RECT * pRect);
Nvoid             GUI_SetControlHook       (void (* pFunc)(int LayerIndex, int Cmd));
Nvoid             GUI_SetDefault           (void);
Nvoid             GUI_SetDefaultBkColor    (GUI_COLOR Color);
Nvoid             GUI_SetDefaultColor      (GUI_COLOR Color);
Nvoid             GUI_SetDefaultFont       (const GUI_FONT * pFont);
NGUI_DRAWMODE     GUI_SetDrawMode          (GUI_DRAWMODE dm);
Nvoid             GUI_SetScreenSizeX       (int xSize);
Nvoid             GUI_SetScreenSizeY       (int ySize);
Nvoid             GUI_SetRefreshHook       (void (* pFunc)(void));
Nvoid             MainTask                 (void);
N
N#define GUI_PID_SetInitFunc(x) GUI_SetAfterInitHook(x)  // Compatibility
N
N/*********************************************************************
N*
N*       Function replacement
N*/
Nvoid GUI_SetpfMemset(void * (* pFunc)(void * pDest, int c, size_t Cnt));
Nvoid GUI_SetpfMemcpy(void * (* pFunc)(void * pDest, const void * pSrc, size_t Cnt));
Nvoid GUI_SetpfStrcmp(int    (* pFunc)(const char *, const char *));
Nvoid GUI_SetpfStrlen(size_t (* pFunc)(const char *));
Nvoid GUI_SetpfStrcpy(char * (* pFunc)(char *, const char *));
N
N/*********************************************************************
N*
N*       Rectangle helper functions
N*/
Nvoid GUI_AddRect        (GUI_RECT * pDest, const GUI_RECT * pRect, int Dist);
Nint  GUI_RectsIntersect (const GUI_RECT * pr0, const GUI_RECT * pr1);
Nvoid GUI_MoveRect       (GUI_RECT * pRect, int x, int y);
Nvoid GUI_MergeRect      (GUI_RECT * pDest, const GUI_RECT * pr0, const GUI_RECT * pr1);
Nint  GUI__IntersectRects(GUI_RECT * pDest, const GUI_RECT * pr0, const GUI_RECT * pr1);
Nvoid GUI__IntersectRect (GUI_RECT * pDest, const GUI_RECT * pr0);
Nvoid GUI__ReduceRect    (GUI_RECT * pDest, const GUI_RECT * pRect, int Dist);
N
N/*********************************************************************
N*
N*       Misc helper functions
N*/
NI32              GUI__ATan2                (I32 x, I32 y, I32 * ph);
Xsigned long              GUI__ATan2                (signed long x, signed long y, signed long * ph);
NI32              GUI__ASinHQ               (I32 SinHQ);
Xsigned long              GUI__ASinHQ               (signed long SinHQ);
Nint              GUI__CompactPixelIndices  (LCD_PIXELINDEX * pBuffer, int NumPixels, int BitsPerPixel);
Xint              GUI__CompactPixelIndices  (unsigned long * pBuffer, int NumPixels, int BitsPerPixel);
Nint              GUI__CompactPixelIndicesEx(LCD_PIXELINDEX * pBuffer, int NumPixels, int BitsPerPixel, const LCD_API_COLOR_CONV * pColorConvAPI);
Xint              GUI__CompactPixelIndicesEx(unsigned long * pBuffer, int NumPixels, int BitsPerPixel, const LCD_API_COLOR_CONV * pColorConvAPI);
Nint              GUI__ConvertColor2Index   (LCD_PIXELINDEX * pBuffer, int NumPixels, int BitsPerPixel, const LCD_API_COLOR_CONV * pColorConvAPI, void * pResult);
Xint              GUI__ConvertColor2Index   (unsigned long * pBuffer, int NumPixels, int BitsPerPixel, const LCD_API_COLOR_CONV * pColorConvAPI, void * pResult);
Nvoid             GUI__Config               (void);
NGUI_HMEM         GUI__CopyText             (GUI_HMEM hItem, const char * pItem);
Xsigned long         GUI__CopyText             (signed long hItem, const char * pItem);
NI32              GUI__CosHQ                (I32 Ang1000);
Xsigned long              GUI__CosHQ                (signed long Ang1000);
Nint              GUI__DivideRound          (int a, int b);
NI32              GUI__DivideRound32        (I32 a, I32 b);
Xsigned long              GUI__DivideRound32        (signed long a, signed long b);
Nvoid             GUI__DrawTwinArc2         (int xl, int xr, int y0,         int r, GUI_COLOR ColorR0, GUI_COLOR ColorR1, GUI_COLOR ColorFill);
Nvoid             GUI__DrawTwinArc4         (int x0, int y0, int x1, int y1, int r, GUI_COLOR ColorR0, GUI_COLOR ColorR1, GUI_COLOR ColorFill);
Nvoid             GUI__ExpandPixelIndices   (void * pBuffer, int NumPixels, int BitsPerPixel);
Nvoid             GUI__ExpandPixelIndicesEx (void * pBufferSRC, void * pBufferDST, int NumPixels, int BitsPerPixel, const LCD_API_COLOR_CONV * pColorConvAPI);
Nvoid             GUI__FillTrippleArc       (int x0, int y0, int Size, GUI_COLOR ColorR0, GUI_COLOR ColorR1, GUI_COLOR ColorR2, GUI_COLOR ColorFill);
Nconst GUI_RECT * GUI__GetClipRect          (void);
Nvoid             GUI__RegisterExit         (GUI_REGISTER_EXIT * pRegisterExit);
Xvoid             GUI__RegisterExit         (GUI_REGISTER_HOOK * pRegisterExit);
Nvoid             GUI__RegisterInit         (GUI_REGISTER_INIT * pRegisterInit);
Xvoid             GUI__RegisterInit         (GUI_REGISTER_HOOK * pRegisterInit);
Nint              GUI__SetText              (GUI_HMEM * phText, const char * s);
Xint              GUI__SetText              (signed long * phText, const char * s);
NI32              GUI__SinHQ                (I32 Ang1000);
Xsigned long              GUI__SinHQ                (signed long Ang1000);
NI32              GUI__sqrt32               (I32 Square);
Xsigned long              GUI__sqrt32               (signed long Square);
Nchar           * GUI__itoa                 (int Value, char * s, int Base);
N
N
N/*********************************************************************
N*
N*       Optional function replacement
N*/
Nvoid * GUI__memcpy(void * pDest, const void * pSrc, size_t NumBytes);
Nvoid * GUI__memset(void * pDest, int c, size_t Cnt);
N
N/*********************************************************************
N*
N*       Get / Set Attributes
N*/
NGUI_COLOR GUI_GetBkColor     (void);
Nint       GUI_GetBkColorIndex(void);
NGUI_COLOR GUI_GetColor       (void);
Nint       GUI_GetColorIndex  (void);
NU8        GUI_GetLineStyle   (void);
Xunsigned char        GUI_GetLineStyle   (void);
NU16       GUI_GetPenSize     (void);
Xunsigned short       GUI_GetPenSize     (void);
NU8        GUI_GetPenShape    (void);
Xunsigned char        GUI_GetPenShape    (void);
Nunsigned  GUI_GetPixelIndex  (int x, int y);
N
Nvoid      GUI_SetBkColor     (GUI_COLOR);
Nvoid      GUI_SetColor       (GUI_COLOR);
Nvoid      GUI_SetBkColorIndex(LCD_PIXELINDEX Index);
Xvoid      GUI_SetBkColorIndex(unsigned long Index);
Nvoid      GUI_SetColorIndex  (LCD_PIXELINDEX Index);
Xvoid      GUI_SetColorIndex  (unsigned long Index);
N
NGUI_COLOR GUI_SetBlendColorEx  (GUI_COLOR Color0, GUI_COLOR Color1, U16 Intens, U16 IMax);
XGUI_COLOR GUI_SetBlendColorEx  (GUI_COLOR Color0, GUI_COLOR Color1, unsigned short Intens, unsigned short IMax);
NGUI_COLOR GUI_SetBlendColor    (GUI_COLOR Color0, GUI_COLOR Color1, U8 Intens);
XGUI_COLOR GUI_SetBlendColor    (GUI_COLOR Color0, GUI_COLOR Color1, unsigned char Intens);
NGUI_COLOR GUI_SetBlendBkColorEx(GUI_COLOR Color0, GUI_COLOR Color1, U16 Intens, U16 IMax);
XGUI_COLOR GUI_SetBlendBkColorEx(GUI_COLOR Color0, GUI_COLOR Color1, unsigned short Intens, unsigned short IMax);
NGUI_COLOR GUI_SetBlendBkColor  (GUI_COLOR Color0, GUI_COLOR Color1, U8 Intens);
XGUI_COLOR GUI_SetBlendBkColor  (GUI_COLOR Color0, GUI_COLOR Color1, unsigned char Intens);
N
NU16       GUI_SetPenSize  (U16 Size);
Xunsigned short       GUI_SetPenSize  (unsigned short Size);
NU8        GUI_SetPenShape (U8 Shape);
Xunsigned char        GUI_SetPenShape (unsigned char Shape);
NU8        GUI_SetLineStyle(U8 Style);
Xunsigned char        GUI_SetLineStyle(unsigned char Style);
N
N/* Get/Set Character used as decimal point (usually '.' or ',') */
Nchar      GUI_GetDecChar(void);
Nchar      GUI_SetDecChar(char c);
N
N/*********************************************************************
N*
N*       Color / Index related functions
N*/
NGUI_COLOR GUI_BlendColors      (GUI_COLOR Color0, GUI_COLOR Color1, U16 Intens, U16 IMax);
XGUI_COLOR GUI_BlendColors      (GUI_COLOR Color0, GUI_COLOR Color1, unsigned short Intens, unsigned short IMax);
Nint       GUI_Color2Index      (GUI_COLOR color);
NGUI_COLOR GUI_Color2VisColor   (GUI_COLOR color);
Nchar      GUI_ColorIsAvailable (GUI_COLOR color);
Nint       GUI_ColorIsOpaque    (GUI_COLOR Color);
NGUI_COLOR GUI_Index2Color      (int Index);
NU32       GUI_CalcColorDist    (GUI_COLOR Color0, GUI_COLOR  Color1);
Xunsigned long       GUI_CalcColorDist    (GUI_COLOR Color0, GUI_COLOR  Color1);
NU32       GUI_CalcVisColorError(GUI_COLOR color);
Xunsigned long       GUI_CalcVisColorError(GUI_COLOR color);
N
N/*********************************************************************
N*
N*       Error handler
N*/
Nvoid GUI_SetOnLogFunc  (void (* pFunc)(const char * s));
Nvoid GUI_SetOnWarnFunc (void (* pFunc)(const char * s));
Nvoid GUI_SetOnErrorFunc(void (* pFunc)(const char * s));
N
N/*********************************************************************
N*
N*       Logging (for debugging primarily)
N*/
Nvoid GUI_Log      (const char * s);
Nvoid GUI_Log1     (const char * s, I32 p0);
Xvoid GUI_Log1     (const char * s, signed long p0);
Nvoid GUI_Log2     (const char * s, I32 p0, I32 p1);
Xvoid GUI_Log2     (const char * s, signed long p0, signed long p1);
Nvoid GUI_Log3     (const char * s, I32 p0, I32 p1, I32 p2);
Xvoid GUI_Log3     (const char * s, signed long p0, signed long p1, signed long p2);
Nvoid GUI_Log4     (const char * s, I32 p0, I32 p1, I32 p2,I32 p3);
Xvoid GUI_Log4     (const char * s, signed long p0, signed long p1, signed long p2,signed long p3);
Nvoid GUI_Warn     (const char * s);
Nvoid GUI_Warn1    (const char * s, I32 p0);
Xvoid GUI_Warn1    (const char * s, signed long p0);
Nvoid GUI_Warn2    (const char * s, I32 p0, I32 p1);
Xvoid GUI_Warn2    (const char * s, signed long p0, signed long p1);
Nvoid GUI_Warn3    (const char * s, I32 p0, I32 p1, I32 p2);
Xvoid GUI_Warn3    (const char * s, signed long p0, signed long p1, signed long p2);
Nvoid GUI_Warn4    (const char * s, I32 p0, I32 p1, I32 p2, I32 p3);
Xvoid GUI_Warn4    (const char * s, signed long p0, signed long p1, signed long p2, signed long p3);
Nvoid GUI_ErrorOut (const char * s);
Nvoid GUI_ErrorOut1(const char * s, I32 p0);
Xvoid GUI_ErrorOut1(const char * s, signed long p0);
Nvoid GUI_ErrorOut2(const char * s, I32 p0, I32 p1);
Xvoid GUI_ErrorOut2(const char * s, signed long p0, signed long p1);
Nvoid GUI_ErrorOut3(const char * s, I32 p0, I32 p1, I32 p2);
Xvoid GUI_ErrorOut3(const char * s, signed long p0, signed long p1, signed long p2);
Nvoid GUI_ErrorOut4(const char * s, I32 p0, I32 p1, I32 p2, I32 p3);
Xvoid GUI_ErrorOut4(const char * s, signed long p0, signed long p1, signed long p2, signed long p3);
N
N/*********************************************************************
N*
N*       2d - GL
N*/
Nvoid GUI_Clear                 (void);
Nvoid GUI_ClearRect             (int x0, int y0, int x1, int y1);
Nvoid GUI_ClearRectEx           (const GUI_RECT * pRect);
Nvoid GUI_CopyRect              (int x0, int y0, int x1, int y1, int dx, int dy);
Nvoid GUI_DrawArc               (int x0, int y0, int rx, int ry, int a0, int a1);
Nvoid GUI_DrawArcHR             (int x0, int y0, int rx, int ry, int a0, int a1);
Nvoid GUI_DrawArcHREx           (int x0, int y0, int r, int a0, int a1, int c0, int c1);
Nvoid GUI_DrawBitmap            (const GUI_BITMAP * pBM, int x0, int y0);
Nvoid GUI_DrawBitmapMag         (const GUI_BITMAP * pBM, int x0, int y0, int XMul, int YMul);
Nvoid GUI_DrawBitmapEx          (const GUI_BITMAP * pBM, int x0, int y0, int xCenter, int yCenter, int xMag, int yMag);
Nvoid GUI_DrawBitmapExp         (int x0, int y0, int XSize, int YSize, int XMul,  int YMul, int BitsPerPixel, int BytesPerLine, const U8 * pData, const GUI_LOGPALETTE * pPal);
Xvoid GUI_DrawBitmapExp         (int x0, int y0, int XSize, int YSize, int XMul,  int YMul, int BitsPerPixel, int BytesPerLine, const unsigned char * pData, const GUI_LOGPALETTE * pPal);
Nvoid GUI_DrawBitmapHWAlpha     (const GUI_BITMAP * pBM, int x0, int y0);
Nvoid GUI_DrawCircle            (int x0, int y0, int r);
Nvoid GUI_DrawEllipse           (int x0, int y0, int rx, int ry);
Nvoid GUI_DrawEllipseXL         (int x0, int y0, int rx, int ry);
Nvoid GUI_DrawGradientH         (int x0, int y0, int x1, int y1, GUI_COLOR Color0, GUI_COLOR Color1);
Nvoid GUI_DrawGradientHEx       (const GUI_RECT * pRect, GUI_COLOR Color0, GUI_COLOR Color1);
Nvoid GUI_DrawGradientMH        (int x0, int y0, int y1, GUI_GRADIENT_INFO * pGradientInfo, int NumColors);
Nvoid GUI_DrawGradientMHEx      (const GUI_RECT * pRect, GUI_GRADIENT_INFO * pGradientInfo, int NumColors);
Nvoid GUI_DrawGradientMV        (int x0, int y0, int x1, GUI_GRADIENT_INFO * pGradientInfo, int NumColors);
Nvoid GUI_DrawGradientMVEx      (const GUI_RECT * pRect, GUI_GRADIENT_INFO * pGradientInfo, int NumColors);
Nvoid GUI_DrawGradientV         (int x0, int y0, int x1, int y1, GUI_COLOR Color0, GUI_COLOR Color1);
Nvoid GUI_DrawGradientVEx       (const GUI_RECT * pRect, GUI_COLOR Color0, GUI_COLOR Color1);
Nvoid GUI_DrawGradientRoundedH  (int x0, int y0, int x1, int y1, int rd, GUI_COLOR Color0, GUI_COLOR Color1);
Nvoid GUI_DrawGradientRoundedMH (int x0, int y0, int y1, int rd, GUI_GRADIENT_INFO * pGradientInfo, int NumColors);
Nvoid GUI_DrawGradientRoundedHEx(const GUI_RECT * pRect, int rd, GUI_COLOR Color0, GUI_COLOR Color1);
Nvoid GUI_DrawGradientRoundedMHEx(const GUI_RECT * pRect, int rd, GUI_GRADIENT_INFO * pGradientInfo, int NumColors);
Nvoid GUI_DrawGradientRoundedV  (int x0, int y0, int x1, int y1, int rd, GUI_COLOR Color0, GUI_COLOR Color1);
Nvoid GUI_DrawGradientRoundedMV (int x0, int y0, int x1, int rd, GUI_GRADIENT_INFO * pGradientInfo, int NumColors);
Nvoid GUI_DrawGradientRoundedVEx(const GUI_RECT * pRect, int rd, GUI_COLOR Color0, GUI_COLOR Color1);
Nvoid GUI_DrawGradientRoundedMVEx(const GUI_RECT * pRect, int rd, GUI_GRADIENT_INFO * pGradientInfo, int NumColors);
Nvoid GUI_DrawGraph             (I16 * pay, int NumPoints, int x0, int y0);
Xvoid GUI_DrawGraph             (signed short * pay, int NumPoints, int x0, int y0);
Nvoid GUI_DrawGraphEx           (I16 * pay, int NumPoints, int x0, int y0, int Numerator, int Denominator, int MirrorX);
Xvoid GUI_DrawGraphEx           (signed short * pay, int NumPoints, int x0, int y0, int Numerator, int Denominator, int MirrorX);
Nvoid GUI_DrawHLine             (int y0, int x0, int x1);
Nvoid GUI_DrawLine              (int x0, int y0, int x1, int y1);
Nvoid GUI_DrawLineRel           (int dx, int dy);
Nvoid GUI_DrawLineTo            (int x, int y);
Nvoid GUI_DrawPie               (int x0, int y0, int r, int a0, int a1, int Type);
Nvoid GUI_DrawPieHR             (int x0, int y0, int r, I32 a0, I32 a1);
Xvoid GUI_DrawPieHR             (int x0, int y0, int r, signed long a0, signed long a1);
Nvoid GUI_DrawPixel             (int x, int y);
Nvoid GUI_DrawPoint             (int x, int y);
Nvoid GUI_DrawPolygon           (const GUI_POINT * pPoints, int NumPoints, int x0, int y0);
Nvoid GUI_DrawPolyLine          (const GUI_POINT * pPoints, int NumPoints, int x0, int y0);
Nvoid GUI_DrawFocusRect         (const GUI_RECT  * pRect, int Dist);
Nvoid GUI_DrawFrame             (int x0, int y0, int x1, int y1, int Size);
Nvoid GUI_DrawFrameEx           (const GUI_RECT * pRect, int Size);
Nvoid GUI_DrawRect              (int x0, int y0, int x1, int y1);
Nvoid GUI_DrawRectEx            (const GUI_RECT * pRect);
Nvoid GUI_DrawRoundedFrame      (int x0, int y0, int x1, int y1, int r, int w);
Nvoid GUI_DrawRoundedFrameEx    (const GUI_RECT * pRect, int r, int w);
Nvoid GUI_DrawRoundedRect       (int x0, int y0, int x1, int y1, int r);
Nvoid GUI_DrawRoundedRectEx     (const GUI_RECT * pRect, int r);
Nvoid GUI_DrawVLine             (int x0, int y0, int y1);
Nvoid GUI_FillCircle            (int x0, int y0, int r);
Nvoid GUI_FillEllipse           (int x0, int y0, int rx, int ry);
Nvoid GUI_FillEllipseXL         (int x0, int y0, int rx, int ry);
Nvoid GUI_FillPolygon           (const GUI_POINT * pPoints, int NumPoints, int x0, int y0);
Nvoid GUI_FillRect              (int x0, int y0, int x1, int y1);
Nvoid GUI_FillRectEx            (const GUI_RECT * pRect);
Nvoid GUI_FillRoundedRect       (int x0, int y0, int x1, int y1, int r);
Nvoid GUI_FillRoundedRectEx     (const GUI_RECT * pRect, int r);
Nvoid GUI_GetClientRect         (GUI_RECT * pRect);
Nvoid GUI_InvertRect            (int x0, int y0, int x1, int y1);
Nvoid GUI_MoveRel               (int dx, int dy);
Nvoid GUI_MoveTo                (int x, int y);
Nvoid GUI_SetAlphaMask8888      (U32 OrMask, U32 AndMask);
Xvoid GUI_SetAlphaMask8888      (unsigned long OrMask, unsigned long AndMask);
Nvoid GUI_SetFuncFillCircle     (int (* pfFillCircle)(int x0, int y0, int r));
Nvoid GUI_SetFuncDrawCircle     (int (* pfDrawCircle)(int x0, int y0, int r));
Nvoid GUI_SetFuncDrawLine       (int (* pfDrawLine)(int x0, int y0, int x1, int y1));
Nvoid GUI_SetFuncDrawRect       (int (* pfDrawRect)(int x0, int y0, int x1, int y1));
Nvoid GUI_SetFuncFillRoundedRect(int (* pfFillRoundedRect)(int x0, int y0, int x1, int y1, int r));
Nvoid GUI_SetFuncDrawRoundedRect(int (* pfDrawRoundedRect)(int x0, int y0, int x1, int y1, int r));
Nvoid GUI_SetFuncDrawBitmapEx   (int (* pfDrawBitmapEx)(const GUI_BITMAP * pBitmap, int x0, int y0, int xMag, int yMag));
N
N
N/*********************************************************************
N*
N*       GUI_GET_DATA_FUNC
N* 
N*  Function description
N*    Abstract function type which may refer to either \uref{GUI_GET_DATA_FUNC_I}
N*    or \uref{GUI_GET_DATA_FUNC_II}.
N*
N*    It should only be used for function pointers which accept both above
N*    mentioned functions.
N*/
Ntypedef int GUI_GET_DATA_FUNC(void * p, const U8 ** ppData, unsigned NumBytes, U32 Off);
Xtypedef int GUI_GET_DATA_FUNC(void * p, const unsigned char ** ppData, unsigned NumBytes, unsigned long Off);
N
N/*********************************************************************
N*
N*       GUI_GET_DATA_FUNC_I
N* 
N*  Function description
N*    A callback which is used for loading external data into RAM.
N* 
N*    This routine must manage its own buffer to read the external data
N*    into and pass the address to this buffer to *ppData.
N* 
N*  Parameters
N*    p:        [IN]     Application defined void pointer, could be e.g.
N*                       a file handle.
N*    ppData:   [IN/OUT] This function must set ppData to point to the
N*                       location where the requested data resides in.
N*    NumBytes:          Number of requested bytes.
N*    Off:               Defines the offset to use for reading the source data.
N* 
N*  Return value
N*    The number of bytes which were actually read. If the number of read bytes does not match,
N*    the drawing function will return immediately.
N*/
Ntypedef int GUI_GET_DATA_FUNC_I(void * p, const U8 ** ppData, unsigned NumBytes, U32 Off);
Xtypedef int GUI_GET_DATA_FUNC_I(void * p, const unsigned char ** ppData, unsigned NumBytes, unsigned long Off);
N
N/*********************************************************************
N*
N*       GUI_GET_DATA_FUNC_II
N* 
N*  Function description
N*    A callback which is used for loading external data into RAM.
N* 
N*    This routine does not manage its own buffer. Instead, it receives a
N*    preallocated buffer to load the data into. The address to this buffer
N*    is *ppData.
N* 
N*  Parameters
N*    p:        [IN] Application defined void pointer, could be e.g.
N*                   a file handle.
N*    ppData:   [IN] Points to the location of the buffer address that needs
N*                   to be filled with data read by this function.
N*    NumBytes:      Number of requested bytes.
N*    Off:           Defines the offset to use for reading the source data.
N* 
N*  Return value
N*    The number of bytes which were actually read. If the number of read bytes does not match,
N*    the drawing function will return immediately.
N*/
Ntypedef int GUI_GET_DATA_FUNC_II(void * p, const U8 ** ppData, unsigned NumBytes, U32 Off);
Xtypedef int GUI_GET_DATA_FUNC_II(void * p, const unsigned char ** ppData, unsigned NumBytes, unsigned long Off);
N
N
N/*********************************************************************
N*
N*       IMAGE file support
N*/
N/*********************************************************************
N*
N*       GIF file support
N*/
N/*********************************************************************
N*
N*       GUI_GIF_GET_DATA_FUNC
N* 
N*  Description
N*    GetData function used for the GIF format, for more details see
N*    \uref{GUI_GET_DATA_FUNC_I}.
N*/
Ntypedef GUI_GET_DATA_FUNC_I    GUI_GIF_GET_DATA_FUNC;
N
Nint GUI_GIF_Draw           (const void * pGIF, U32 NumBytes,             int x0, int y0);
Xint GUI_GIF_Draw           (const void * pGIF, unsigned long NumBytes,             int x0, int y0);
Nint GUI_GIF_DrawEx         (GUI_GIF_GET_DATA_FUNC * pfGetData, void * p, int x0, int y0);
Nint GUI_GIF_DrawSub        (const void * pGIF, U32 NumBytes,             int x0, int y0, int Index);
Xint GUI_GIF_DrawSub        (const void * pGIF, unsigned long NumBytes,             int x0, int y0, int Index);
Nint GUI_GIF_DrawSubEx      (GUI_GIF_GET_DATA_FUNC * pfGetData, void * p, int x0, int y0, int Index);
Nint GUI_GIF_DrawSubScaled  (const void * pGIF, U32 NumBytes,             int x0, int y0, int Index, int Num, int Denom);
Xint GUI_GIF_DrawSubScaled  (const void * pGIF, unsigned long NumBytes,             int x0, int y0, int Index, int Num, int Denom);
Nint GUI_GIF_DrawSubScaledEx(GUI_GIF_GET_DATA_FUNC * pfGetData, void * p, int x0, int y0, int Index, int Num, int Denom);
Nint GUI_GIF_GetComment     (const void * pGIF, U32 NumBytes,             U8 * pBuffer, int MaxSize, int Index);
Xint GUI_GIF_GetComment     (const void * pGIF, unsigned long NumBytes,             unsigned char * pBuffer, int MaxSize, int Index);
Nint GUI_GIF_GetCommentEx   (GUI_GIF_GET_DATA_FUNC * pfGetData, void * p, U8 * pBuffer, int MaxSize, int Index);
Xint GUI_GIF_GetCommentEx   (GUI_GIF_GET_DATA_FUNC * pfGetData, void * p, unsigned char * pBuffer, int MaxSize, int Index);
Nint GUI_GIF_GetImageInfo   (const void * pGIF, U32 NumBytes,             GUI_GIF_IMAGE_INFO * pInfo, int Index);
Xint GUI_GIF_GetImageInfo   (const void * pGIF, unsigned long NumBytes,             GUI_GIF_IMAGE_INFO * pInfo, int Index);
Nint GUI_GIF_GetImageInfoEx (GUI_GIF_GET_DATA_FUNC * pfGetData, void * p, GUI_GIF_IMAGE_INFO * pInfo, int Index);
Nint GUI_GIF_GetInfo        (const void * pGIF, U32 NumBytes,             GUI_GIF_INFO * pInfo);
Xint GUI_GIF_GetInfo        (const void * pGIF, unsigned long NumBytes,             GUI_GIF_INFO * pInfo);
Nint GUI_GIF_GetInfoEx      (GUI_GIF_GET_DATA_FUNC * pfGetData, void * p, GUI_GIF_INFO * pInfo);
Nint GUI_GIF_GetXSize       (const void * pGIF);
Nint GUI_GIF_GetXSizeEx     (GUI_GIF_GET_DATA_FUNC * pfGetData, void * p);
Nint GUI_GIF_GetYSize       (const void * pGIF);
Nint GUI_GIF_GetYSizeEx     (GUI_GIF_GET_DATA_FUNC * pfGetData, void * p);
Nint GUI_GIF_SetFillTrans   (int OnOff);
N
N/*********************************************************************
N*
N*       BMP file support
N*/
N/*********************************************************************
N*
N*       GUI_BMP_GET_DATA_FUNC
N* 
N*  Description
N*    GetData function used for the BMP format, for more details see
N*    \uref{GUI_GET_DATA_FUNC_I}.
N*/
Ntypedef GUI_GET_DATA_FUNC_I     GUI_BMP_GET_DATA_FUNC;
N
Nint  GUI_BMP_Draw        (const void * pFileData,                      int x0, int y0);
Nint  GUI_BMP_DrawEx      (GUI_BMP_GET_DATA_FUNC * pfGetData, void * p, int x0, int y0);
Nint  GUI_BMP_DrawScaled  (const void * pFileData,                      int x0, int y0, int Num, int Denom);
Nint  GUI_BMP_DrawScaledEx(GUI_BMP_GET_DATA_FUNC * pfGetData, void * p, int x0, int y0, int Num, int Denom);
Nint  GUI_BMP_GetXSize    (const void * pFileData);
Nint  GUI_BMP_GetXSizeEx  (GUI_BMP_GET_DATA_FUNC * pfGetData, void * p);
Nint  GUI_BMP_GetYSize    (const void * pFileData);
Nint  GUI_BMP_GetYSizeEx  (GUI_BMP_GET_DATA_FUNC * pfGetData, void * p);
Nvoid GUI_BMP_EnableAlpha (void);
Nvoid GUI_BMP_EnableBE    (int OnOff);
Nvoid GUI_BMP_DisableAlpha(void);
N
N/*********************************************************************
N*
N*       PNG file support
N*/
N/*********************************************************************
N*
N*       GUI_PNG_GET_DATA_FUNC
N* 
N*  Description
N*    GetData function used for the PNG format, for more details see
N*    \uref{GUI_GET_DATA_FUNC_II}.
N*/
Ntypedef GUI_GET_DATA_FUNC_II    GUI_PNG_GET_DATA_FUNC;
N
Nint GUI_PNG_Draw      (const void * pFileData, int DataSize,        int x0, int y0);
Nint GUI_PNG_DrawEx    (GUI_PNG_GET_DATA_FUNC * pfGetData, void * p, int x0, int y0);
Nint GUI_PNG_GetXSize  (const void * pFileData, int FileSize);
Nint GUI_PNG_GetXSizeEx(GUI_PNG_GET_DATA_FUNC * pfGetData, void * p);
Nint GUI_PNG_GetYSize  (const void * pFileData, int FileSize);
Nint GUI_PNG_GetYSizeEx(GUI_PNG_GET_DATA_FUNC * pfGetData, void * p);
N
N/*********************************************************************
N*
N*       JPEG file support
N*/
N/*********************************************************************
N*
N*       GUI_JPEG_GET_DATA_FUNC
N* 
N*  Description
N*    GetData function used for the JPEG format, for more details see
N*    \uref{GUI_GET_DATA_FUNC_I}.
N*/
Ntypedef GUI_GET_DATA_FUNC_I     GUI_JPEG_GET_DATA_FUNC;
N
N/*********************************************************************
N*
N*       GUI_JPEG_INFO
N*
N*   Description
N*     Information about a JPEG image.
N*/
Ntypedef struct {
N  int XSize;       // X-size of the image.
N  int YSize;       // Y-size of the image.
N  int Progessive;  // Indicates if JPEG is progressive or not
N} GUI_JPEG_INFO;
N
Ntypedef struct GUI_JPEG_DCONTEXT GUI_JPEG_DCONTEXT;
N/*********************************************************************
N*
N*       GUI_JPEG_WRITECLIPPEDPIXELS_FUNC
N*
N*   Description
N*     Function that retrieves the decoded result of a JPEG and writes
N*     the pixels to the display.
N* 
N*   Parameters
N*     x0:            X drawing position of the JPEG.
N*     y0:            Y drawing position of the JPEG.
N*     xSize:         Width of one line.
N*     pColor:        [IN] Pointer to decoded JPEG data.
N*     pContext:      [IN] Pointer to JPEG context.
N*     pColorConvAPI: [IN] Pointer to selected color conversion API.
N* 
N*/
Ntypedef void (GUI_JPEG_WRITECLIPPEDPIXELS_FUNC)(int x0, int y0, int xSize, LCD_COLOR * pColor, GUI_JPEG_DCONTEXT * pContext, const LCD_API_COLOR_CONV * pColorConvAPI);
N
Nint                                GUI_JPEG_Draw            (const void * pFileData, int DataSize,         int x0, int y0);
Nint                                GUI_JPEG_DrawEx          (GUI_JPEG_GET_DATA_FUNC * pfGetData, void * p, int x0, int y0);
Nint                                GUI_JPEG_DrawScaled      (const void * pFileData, int DataSize,         int x0, int y0, int Num, int Denom);
Nint                                GUI_JPEG_DrawScaledEx    (GUI_JPEG_GET_DATA_FUNC * pfGetData, void * p, int x0, int y0, int Num, int Denom);
Nint                                GUI_JPEG_GetInfo         (const void * pFileData, int DataSize,         GUI_JPEG_INFO * pInfo);
Nint                                GUI_JPEG_GetInfoEx       (GUI_JPEG_GET_DATA_FUNC * pfGetData, void * p, GUI_JPEG_INFO * pInfo);
Nvoid                               GUI_JPEG_SetpfDrawEx     (int (* pfDrawEx)(GUI_JPEG_GET_DATA_FUNC * pfGetData, void * p, int x0, int y0));
NGUI_JPEG_WRITECLIPPEDPIXELS_FUNC * GUI_JPEG_SetpfWritePixels(GUI_JPEG_WRITECLIPPEDPIXELS_FUNC * pFunc);
N
N/*********************************************************************
N*
N*       SVG file support
N*/
Ntypedef GUI_HMEM    GUI_SVG_Handle;
Xtypedef signed long    GUI_SVG_Handle;
N
N/*********************************************************************
N*
N*       GUI_SVG_GET_DATA_FUNC
N* 
N*  Description
N*    GetData function used for the SVG format, for more details see
N*    \uref{GUI_GET_DATA_FUNC_II}.
N*/
Ntypedef GUI_GET_DATA_FUNC_II    GUI_SVG_GET_DATA_FUNC;
N
N/*********************************************************************
N*
N*       GUI_POINTF
N*
N*  Description
N*    Defines a point in floating point coordinates.
N*/
Ntypedef struct {
N  float x; // X coordinate in floating points.
N  float y; // Y coordinate in floating points.
N} GUI_POINTF;
N
N/*********************************************************************
N*
N*       GUI_MATRIX
N*
N*  Description
N*    A column-major 3x3 matrix used for all kinds of affine transformations.
N*
N*  Additional information
N*    emWin uses column-major matrices which means that the matrix elements
N*    are stored in columns from top to bottom and left to right.
N* 
N*    The order is the same as in OpenVG, therefore GUI_MATRIX is implicitly
N*    convertible to the 3x3 matrix type used in OpenVG.
N*/
Ntypedef struct {
N  float sx;   // The scaling factor in the x-direction.
N  float shy;  // The shearing factor in the y-direction.
N  float w0;   // Should be left as \c{0.0F} to ensure affinity.
N  float shx;  // The shearing factor in the x-direction.
N  float sy;   // Scaling factor in y.
N  float w1;   // Should be left as \c{0.0F} to ensure affinity.
N  float tx;   // The translation factor in the x-direction.
N  float ty;   // The translation factor in the y-direction. 
N  float w2;   // Should be left as \c{1.0F} to ensure affinity.
N} GUI_MATRIX;
N
Nvoid    GUI_MATRIX_Initialize   (GUI_MATRIX * pMatrix, float sx, float shx, float tx, float shy, float sy, float ty, float w0, float w1, float w2);
Nvoid    GUI_MATRIX_Identity     (GUI_MATRIX * pMatrix);
Nfloat * GUI_MATRIX_GetCellPtr   (GUI_MATRIX * pMatrix, unsigned Row, unsigned Col);
Nint     GUI_MATRIX_Equals       (const GUI_MATRIX * p0, const GUI_MATRIX * p1);
Nvoid    GUI_MATRIX_Multiply     (GUI_MATRIX * pMatrix, const GUI_MATRIX * pMult);
Nvoid    GUI_MATRIX_MultiplyPoint(const GUI_MATRIX * pMatrix, GUI_POINTF * pPoint);
Nvoid    GUI_MATRIX_Translate    (GUI_MATRIX * pMatrix, float tx, float ty);
Nvoid    GUI_MATRIX_Scale        (GUI_MATRIX * pMatrix, float sx, float sy);
Nvoid    GUI_MATRIX_Rotate       (GUI_MATRIX * pMatrix, float a);
Nvoid    GUI_MATRIX_Shear        (GUI_MATRIX * pMatrix, float shx, float shy);
N
N/*********************************************************************
N*
N*       GUI_SVG_VIEWBOX
N*
N*  Description
N*    The SVG's view box, as it is defined by the \c{viewBox} attribute
N*    in the \c{<svg>} tag.
N*/
Ntypedef struct {
N  float x;      // X position of the view box.
N  float y;      // Y position of the view box.
N  float xSize;  // Width of the view box.
N  float ySize;  // Height of the view box.
N} GUI_SVG_VIEWBOX;
N
N/*********************************************************************
N*
N*       GUI_SVG_BBOX
N*
N*  Description
N*    Boundary box of an SVG based on the currently set parameters like position,
N*    scaling, rotation, etc.
N*/
Ntypedef struct {
N  float xMin;  // Minimum X position on the display in floating point coordinates.
N  float yMin;  // Minimum Y position on the display in floating point coordinates.
N  float xMax;  // Maximum X position on the display in floating point coordinates.
N  float yMax;  // Maximum Y position on the display in floating point coordinates.
N} GUI_SVG_BBOX;
N
N/*********************************************************************
N*
N*       GUI_SVG_INFO
N*
N*  Description
N*    Information about an SVG document, generated by the \c{GUI_SVG_GetInfo...()}
N*    functions.
N* 
N*  Additional information
N*    In case the \c{"width"} and \c{"height"} attributes of the SVG are in any other
N*    unit than pixels, the dimensions will be converted into pixels internally.
N*    Therefore, the struct members Width and Height are always in pixels.
N*    The conversion from other units into pixels is done using the currently set DPI
N*    (see GUI_SVG_SetDPI()).
N*/
Ntypedef struct {
N  GUI_SVG_VIEWBOX ViewBox;  // Viewbox of the SVG, defines the coordinate range.
N  GUI_SVG_BBOX    BBox;     // Boundary box of the SVG, based on the currently set affine transformation matrix.
N  float           xSize;    // Viewport width of the SVG, defined by the \c{"width"} attribute in the \c{<svg>} tag.
N  float           ySize;    // Viewport height of the SVG, defined by the \c{"height"} attribute in the \c{<svg>} tag.
N} GUI_SVG_INFO;
N
N/*********************************************************************
N*
N*       GUI_SVG_HOOKS
N*
N*  Description
N*    Allows to hook in into various spots during the SVG drawing process.
N* 
N*    Only the desired hooks need to be set. The hooks can be set with GUI_SVG_SetHooks().
N*/
Ntypedef struct {
N  U8   (* pfPreInitDriverHook) (void);  // Called before the SVG driver is initialized. Returns 1 on error
X  unsigned char   (* pfPreInitDriverHook) (void);  
N                                        // to abort the driver initialization.
N  U8   (* pfPostInitDriverHook)(void);  // Called when the SVG driver initialization has finished. Returns 1 on error
X  unsigned char   (* pfPostInitDriverHook)(void);  
N                                        // to abort the driver initialization.
N  void (* pfDeinitDriverHook)  (void);  // Called after the SVG driver has been de-initialized.
N  void (* pfSwitchBufferHook)  (void);  // Called during the drawing process, after the drawing commands have been flushed.
N  void (* pfBeginDrawPreHook)  (void);  // Called before the initialization of the drawing process of an SVG.
N  void (* pfBeginDrawPostHook) (void);  // Called at the end of the initialization of the drawing process of an SVG.
N  void (* pfEndDrawHook)       (void);  // Called once the SVG drawing process has finished.
N} GUI_SVG_HOOKS;
N
N/*********************************************************************
N*
N*       GUI_SVG_LOAD_API_CALLBACK
N*
N*  Description
N*    Callback used to load a given routine. The callback receives the
N*    name of the routine to be loaded as a string and should return its
N*    address as a void function pointer.
N* 
N*    The main use case of this callback is to load a function from a DLL.
N* 
N*  Parameters
N*    sFunction: [IN] Name of the routine to be loaded as a zero-terminated
N*                    string.
N*  
N*  Return value
N*    Address of the function casted to a void function pointer.
N*/
Ntypedef void (* GUI_SVG_LOAD_API_CALLBACK(const char * sFunction))(void);
N
N//
N// SVG module related
N//
Nint      GUI_SVG_Enable           (int Enable);
Nvoid     GUI_SVG_EnablePNG        (void);
Nvoid     GUI_SVG_EnableJPEG       (void);
Nvoid     GUI_SVG_EnableGIF        (void);
Nvoid     GUI_SVG_EnableBMP        (void);
Nunsigned GUI_SVG_SetDPI           (unsigned NumDotsPerInch);
Nunsigned GUI_SVG_SetFileBufferSize(unsigned NumBytes);
N//
N// SVG drawing API
N//
Nint GUI_SVG_Draw               (const void * pFile, U32 FileSize, float x, float y);
Xint GUI_SVG_Draw               (const void * pFile, unsigned long FileSize, float x, float y);
Nint GUI_SVG_DrawEx             (GUI_SVG_GET_DATA_FUNC * pfGetData, void * p, float x, float y);
Nint GUI_SVG_DrawScaled         (const void * pFile, U32 FileSize, float x, float y, float Scale);
Xint GUI_SVG_DrawScaled         (const void * pFile, unsigned long FileSize, float x, float y, float Scale);
Nint GUI_SVG_DrawScaledEx       (GUI_SVG_GET_DATA_FUNC * pfGetData, void * p, float x, float y, float Scale);
Nint GUI_SVG_DrawScaledRotated  (const void * pFile, U32 FileSize, float x, float y, float Scale, float Angle);
Xint GUI_SVG_DrawScaledRotated  (const void * pFile, unsigned long FileSize, float x, float y, float Scale, float Angle);
Nint GUI_SVG_DrawScaledRotatedEx(GUI_SVG_GET_DATA_FUNC * pfGetData, void * p, float x, float y, float Scale, float Angle);
N//
N// SVG handle API
N//
NGUI_SVG_Handle GUI_SVG_Create         (const void * pFile, U32 FileSize);
XGUI_SVG_Handle GUI_SVG_Create         (const void * pFile, unsigned long FileSize);
NGUI_SVG_Handle GUI_SVG_CreateEx       (GUI_SVG_GET_DATA_FUNC * pfGetData, void * p);
Nvoid           GUI_SVG_Delete         (GUI_SVG_Handle hSVG);
Nint            GUI_SVG_DrawH          (GUI_SVG_Handle hSVG, float x, float y);
Nvoid           GUI_SVG_EnableCacheMode(GUI_SVG_Handle hSVG, int Enable);
Nvoid           GUI_SVG_Identity       (GUI_SVG_Handle hSVG);
Nint            GUI_SVG_Render         (GUI_SVG_Handle hSVG);
Nvoid           GUI_SVG_Rotate         (GUI_SVG_Handle hSVG, float Angle);
Nvoid           GUI_SVG_RotateEx       (GUI_SVG_Handle hSVG, float Angle, float x, float y);
Nvoid           GUI_SVG_Scale          (GUI_SVG_Handle hSVG, float xScale, float yScale);
Nvoid           GUI_SVG_ScaleEx        (GUI_SVG_Handle hSVG, float xScale, float yScale, float x, float y);
Nvoid           GUI_SVG_ScaleToSize    (GUI_SVG_Handle hSVG, float xSize, float ySize);
Nvoid           GUI_SVG_SetBkColor     (GUI_SVG_Handle hSVG, GUI_COLOR BkColor);
Nvoid           GUI_SVG_Transform      (GUI_SVG_Handle hSVG, const GUI_MATRIX * pMatrix);
Nvoid           GUI_SVG_Translate      (GUI_SVG_Handle hSVG, float x, float y);
N//
N// Info API
N//
Nint GUI_SVG_GetInfo  (const void * pFile, U32 FileSize, GUI_SVG_INFO * pInfo);
Xint GUI_SVG_GetInfo  (const void * pFile, unsigned long FileSize, GUI_SVG_INFO * pInfo);
Nint GUI_SVG_GetInfoEx(GUI_SVG_GET_DATA_FUNC * pfGetData, void * p, GUI_SVG_INFO * pInfo);
Nint GUI_SVG_GetInfoH (GUI_SVG_Handle hSVG, GUI_SVG_INFO * pInfo);
N
N//
N// Opaque driver type for public usage.
N//
Ntypedef void  GUI_SVG_DRIVER_STRUCT;
N
N/*********************************************************************
N*
N*       GUI_SVG_DRIVER
N* 
N*  Description
N*    All available SVG drivers for run-time usage with the GUI_SVG_DRIVER_... routines.
N*/
Ntypedef const GUI_SVG_DRIVER_STRUCT * (GUI_SVG_DRIVER)(void);
N
N// 
N// The pointer passed to identify a driver is a function
N// so that only the directly referenced drivers are linked.
N//
N#define GUI_SVG_DRIVER_OPENVG    (&GUI_SVG_DRIVER_OpenVG)
N#define GUI_SVG_DRIVER_VGLITE    (&GUI_SVG_DRIVER_VGLite)
N#define GUI_SVG_DRIVER_NEMAVG    (&GUI_SVG_DRIVER_NemaVG)
N#define GUI_SVG_DRIVER_NANOVG    (&GUI_SVG_DRIVER_NanoVG)
N
N//
N// Not to be documented, above defines are documented.
N//
Nconst GUI_SVG_DRIVER_STRUCT * GUI_SVG_DRIVER_OpenVG(void);
Nconst GUI_SVG_DRIVER_STRUCT * GUI_SVG_DRIVER_VGLite(void);
Nconst GUI_SVG_DRIVER_STRUCT * GUI_SVG_DRIVER_NemaVG(void);
Nconst GUI_SVG_DRIVER_STRUCT * GUI_SVG_DRIVER_NanoVG(void);
N//
N// GUI_SVG_DRIVER API
N//
Nvoid             GUI_SVG_DRIVER_BindAPI       (GUI_SVG_DRIVER * pDriver, const void * pAPI);
Nvoid             GUI_SVG_DRIVER_BindDynamicAPI(GUI_SVG_DRIVER * pDriver, void * pAPI, GUI_SVG_LOAD_API_CALLBACK * cbLoadFunction);
NGUI_SVG_DRIVER * GUI_SVG_DRIVER_GetSelected   (void);
Nint              GUI_SVG_DRIVER_HasBoundAPI   (GUI_SVG_DRIVER * pDriver);
Nint              GUI_SVG_DRIVER_Select        (GUI_SVG_DRIVER * pDriver);
Nvoid             GUI_SVG_DRIVER_SetHooks      (GUI_SVG_DRIVER * pDriver, const GUI_SVG_HOOKS * pHooks);
N//
N// Compatability macros
N//
N#define GUI_SVG_SetHooks(pHooks)                           GUI_SVG_DRIVER_SetHooks(GUI_SVG_DRIVER_GetSelected(), pHooks)
N#define GUI_SVG_SetAPI_VGLite(pAPI)                        GUI_SVG_DRIVER_BindAPI(GUI_SVG_DRIVER_VGLITE, pAPI); \
N                                                           GUI_SVG_DRIVER_Select(GUI_SVG_DRIVER_VGLITE)
X#define GUI_SVG_SetAPI_VGLite(pAPI)                        GUI_SVG_DRIVER_BindAPI(GUI_SVG_DRIVER_VGLITE, pAPI);                                                            GUI_SVG_DRIVER_Select(GUI_SVG_DRIVER_VGLITE)
N#define GUI_SVG_SetAPI_OpenVG(pAPI)                        GUI_SVG_DRIVER_BindAPI(GUI_SVG_DRIVER_OPENVG, pAPI); \
N                                                           GUI_SVG_DRIVER_Select(GUI_SVG_DRIVER_OPENVG)
X#define GUI_SVG_SetAPI_OpenVG(pAPI)                        GUI_SVG_DRIVER_BindAPI(GUI_SVG_DRIVER_OPENVG, pAPI);                                                            GUI_SVG_DRIVER_Select(GUI_SVG_DRIVER_OPENVG)
N#define GUI_SVG_LoadAPI_OpenVG(pOpenVG, pEGL, cbLoad)      if (pOpenVG) {                                   \
N                                                             (pOpenVG)->pEGL = pEGL;                        \
N                                                             GUI_SVG_DRIVER_BindDynamicAPI(GUI_SVG_DRIVER_OPENVG, pOpenVG, cbLoad); \
N                                                             GUI_SVG_DRIVER_Select(GUI_SVG_DRIVER_OPENVG);  \
N                                                           }
X#define GUI_SVG_LoadAPI_OpenVG(pOpenVG, pEGL, cbLoad)      if (pOpenVG) {                                                                                                (pOpenVG)->pEGL = pEGL;                                                                                     GUI_SVG_DRIVER_BindDynamicAPI(GUI_SVG_DRIVER_OPENVG, pOpenVG, cbLoad);                                                              GUI_SVG_DRIVER_Select(GUI_SVG_DRIVER_OPENVG);                                                             }
N
N/*********************************************************************
N*
N*       GUI_TIMER module
N*/
N#define GUI_TIMER_CF_WINDOW (1 << 0)
N#define GUI_TIMER_CF_CURSOR (1 << 1)
N
Ntypedef GUI_HMEM GUI_TIMER_HANDLE;
Xtypedef signed long GUI_TIMER_HANDLE;
N
Ntypedef struct {
N  GUI_TIMER_TIME   Time;
X  int   Time;
N  PTR_ADDR         Context;
X  unsigned long         Context;
N  GUI_TIMER_HANDLE hTimer;
N} GUI_TIMER_MESSAGE;
N
Ntypedef void GUI_TIMER_CALLBACK(/*const*/ GUI_TIMER_MESSAGE* pTM);
N
NGUI_TIMER_HANDLE GUI_TIMER_Create   (GUI_TIMER_CALLBACK * cb, GUI_TIMER_TIME Time, PTR_ADDR Context, U16 Flags);
XGUI_TIMER_HANDLE GUI_TIMER_Create   (GUI_TIMER_CALLBACK * cb, int Time, unsigned long Context, unsigned short Flags);
Nvoid             GUI_TIMER_Delete   (GUI_TIMER_HANDLE hObj);
N
N/* Methods changing properties */
NGUI_TIMER_TIME GUI_TIMER_GetPeriod(GUI_TIMER_HANDLE hObj);
Xint GUI_TIMER_GetPeriod(GUI_TIMER_HANDLE hObj);
Nvoid           GUI_TIMER_SetPeriod(GUI_TIMER_HANDLE hObj, GUI_TIMER_TIME Period);
Xvoid           GUI_TIMER_SetPeriod(GUI_TIMER_HANDLE hObj, int Period);
Nvoid           GUI_TIMER_SetDelay (GUI_TIMER_HANDLE hObj, GUI_TIMER_TIME Delay);
Xvoid           GUI_TIMER_SetDelay (GUI_TIMER_HANDLE hObj, int Delay);
Nvoid           GUI_TIMER_Restart  (GUI_TIMER_HANDLE hObj);
Nint            GUI_TIMER_GetFlag  (GUI_TIMER_HANDLE hObj, int Flag); /* Not to be documented */
Nint            GUI_TIMER_Exec     (void);
N
N/*********************************************************************
N*
N*       MOVIE file support
N*/
N/*********************************************************************
N*
N*       Movie notifications
N*
N*   Description
N*     Notifications sent to the movie's callback function. The
N*     callback function can be set with GUI_MOVIE_SetpfNotify().
N*/
N#define GUI_MOVIE_NOTIFICATION_PREDRAW  0    // Sent immediately before a frame is drawn.
N#define GUI_MOVIE_NOTIFICATION_POSTDRAW 1    // Sent immediately after a frame is drawn.
N#define GUI_MOVIE_NOTIFICATION_START    2    // Sent when starting to play a movie.
N#define GUI_MOVIE_NOTIFICATION_STOP     3    // Sent when the movie has stopped.
N#define GUI_MOVIE_NOTIFICATION_DELETE   4    // Sent when the movie has been deleted.
N
Ntypedef GUI_HMEM GUI_MOVIE_HANDLE;
Xtypedef signed long GUI_MOVIE_HANDLE;
N
Ntypedef void GUI_MOVIE_FUNC(GUI_MOVIE_HANDLE hMovie, int Notification, U32 CurrentFrame);
Xtypedef void GUI_MOVIE_FUNC(GUI_MOVIE_HANDLE hMovie, int Notification, unsigned long CurrentFrame);
N
N/*********************************************************************
N*
N*       GUI_MOVIE_INFO
N*
N*   Description
N*     Information about a movie.
N*/
Ntypedef struct {
N  int xSize;         // Horizontal resolution of the movie in pixels.
N  int ySize;         // Vertical resolution of the movie in pixels.
N  int msPerFrame;    // Period of one frame in ms.
N  U32 NumFrames;     // Number of frames of the movie file.
X  unsigned long NumFrames;     
N} GUI_MOVIE_INFO;
N
N/*********************************************************************
N*
N*       GUI_MOVIE_GET_DATA_FUNC
N* 
N*  Description
N*    GetData function used for emWin movie files (EMF), for more details see
N*    \uref{GUI_GET_DATA_FUNC_II}.
N*/
Ntypedef  GUI_GET_DATA_FUNC_II    GUI_MOVIE_GET_DATA_FUNC;
N
NGUI_MOVIE_HANDLE GUI_MOVIE_Create         (const void * pFileData, U32 FileSize, GUI_MOVIE_FUNC * pfNotify);
XGUI_MOVIE_HANDLE GUI_MOVIE_Create         (const void * pFileData, unsigned long FileSize, GUI_MOVIE_FUNC * pfNotify);
NGUI_MOVIE_HANDLE GUI_MOVIE_CreateEx       (GUI_MOVIE_GET_DATA_FUNC * pfGetData, void * pParam, GUI_MOVIE_FUNC * pfNotify);
Nint              GUI_MOVIE_Delete         (GUI_MOVIE_HANDLE hMovie);
Nvoid             GUI_MOVIE_DrawFrame      (GUI_MOVIE_HANDLE hMovie, int Index, int x, int y);
NU32              GUI_MOVIE_GetFrameIndex  (GUI_MOVIE_HANDLE hMovie);
Xunsigned long              GUI_MOVIE_GetFrameIndex  (GUI_MOVIE_HANDLE hMovie);
Nint              GUI_MOVIE_GetInfo        (const void * pFileData, U32 FileSize, GUI_MOVIE_INFO * pInfo);
Xint              GUI_MOVIE_GetInfo        (const void * pFileData, unsigned long FileSize, GUI_MOVIE_INFO * pInfo);
Nint              GUI_MOVIE_GetInfoEx      (GUI_MOVIE_GET_DATA_FUNC * pfGetData, void * pParam, GUI_MOVIE_INFO * pInfo);
Nint              GUI_MOVIE_GetInfoH       (GUI_MOVIE_HANDLE hMovie, GUI_MOVIE_INFO * pInfo);
Nint              GUI_MOVIE_GetNumFrames   (GUI_MOVIE_HANDLE hMovie);
Nint              GUI_MOVIE_GetPos         (GUI_MOVIE_HANDLE hMovie, int * pxPos, int * pyPos, int * pxSize, int * pySize);
Nint              GUI_MOVIE_GotoFrame      (GUI_MOVIE_HANDLE hMovie, U32 Frame);
Xint              GUI_MOVIE_GotoFrame      (GUI_MOVIE_HANDLE hMovie, unsigned long Frame);
Nint              GUI_MOVIE_IsPlaying      (GUI_MOVIE_HANDLE hMovie);
Nint              GUI_MOVIE_Pause          (GUI_MOVIE_HANDLE hMovie);
Nint              GUI_MOVIE_Play           (GUI_MOVIE_HANDLE hMovie);
Nint              GUI_MOVIE_SetPeriod      (GUI_MOVIE_HANDLE hMovie, unsigned Period);
Nvoid             GUI_MOVIE_SetpfNotify    (GUI_MOVIE_FUNC * pfNotify);
Nint              GUI_MOVIE_SetPos         (GUI_MOVIE_HANDLE hMovie, int xPos, int yPos);
Nvoid             GUI_MOVIE_SetSecondHandle(GUI_MOVIE_HANDLE hMovie, void * pParamTable);
Nint              GUI_MOVIE_Show           (GUI_MOVIE_HANDLE hMovie, int xPos, int yPos, int DoLoop);
N
Nvoid             GUI_MOVIE__OnTimeSlice (GUI_MOVIE_HANDLE hMovie, int Run, int DeactivateWM);
Nint              GUI_MOVIE__Play        (GUI_MOVIE_HANDLE hMovie, GUI_TIMER_CALLBACK * cbTimer, int DoLoop, GUI_HMEM hExtra);
Xint              GUI_MOVIE__Play        (GUI_MOVIE_HANDLE hMovie, GUI_TIMER_CALLBACK * cbTimer, int DoLoop, signed long hExtra);
Nint              GUI_MOVIE__Pause       (GUI_MOVIE_HANDLE hMovie, int ShowFrame, int DeactivateWM);
Nvoid             GUI_MOVIE__SetTimerFlag(GUI_MOVIE_HANDLE hMovie);
NGUI_MOVIE_HANDLE GUI_MOVIE__CreateUser  (GUI_MOVIE_GET_DATA_FUNC * pfGetData, void * pParam, GUI_MOVIE_FUNC * pfNotify, void * pVoid);
Nvoid           * GUI_MOVIE__GetUserData (GUI_MOVIE_HANDLE hMovie);
Nvoid             GUI_MOVIE__SetUserData (GUI_MOVIE_HANDLE hMovie, void * pVoid);
N
N/*********************************************************************
N*
N*       Splines
N*/
NGUI_HMEM GUI_SPLINE_Create  (const int * px, const int * py, unsigned NumPoints);
Xsigned long GUI_SPLINE_Create  (const int * px, const int * py, unsigned NumPoints);
Nvoid     GUI_SPLINE_Draw    (GUI_HMEM hSpline, int x, int y);
Xvoid     GUI_SPLINE_Draw    (signed long hSpline, int x, int y);
Nvoid     GUI_SPLINE_Delete  (GUI_HMEM hSpline);
Xvoid     GUI_SPLINE_Delete  (signed long hSpline);
NI16      GUI_SPLINE_GetY    (GUI_HMEM hSpline, unsigned Index, float * py);
Xsigned short      GUI_SPLINE_GetY    (signed long hSpline, unsigned Index, float * py);
Nunsigned GUI_SPLINE_GetXSize(GUI_HMEM hSpline);
Xunsigned GUI_SPLINE_GetXSize(signed long hSpline);
Nvoid     GUI_SPLINE_DrawAA  (GUI_HMEM hSpline, int x, int y, unsigned Width);
Xvoid     GUI_SPLINE_DrawAA  (signed long hSpline, int x, int y, unsigned Width);
N
N/*********************************************************************
N*
N*       Cursor routines
N*/
N#define GUI_CURSOR_SHOW 0
N#define GUI_CURSOR_HIDE 1
N
Ntypedef struct {
N  const GUI_BITMAP  * pBitmap;
N  int                 xHot;
N  int                 yHot;
N} GUI_CURSOR;
N
N/*********************************************************************
N*
N*       GUI_CURSOR_ANIM
N*
N*  Description
N*    Structure that stores information about a cursor animation used by GUI_CURSOR_SelectAnim().
N*
N*  Additional information
N*    The bitmaps addressed by ppBM need to fulfill with the following requirements:
N*    
N*    \item They need to have exactly the same X- and Y-size.
N*    \item They should not be compressed.
N*    \item They need to be transparent.
N*    \item They need to be palette based bitmaps with 1, 2, 4 or 8bpp.
N*
N*    Other bitmaps or insufficient memory cause the function to fail.
N*
N*    The pPeriod is only required if the periods for the images are different. If the same
N*    period should be used for all images Period should be used instead of pPeriod. In
N*    this case pPeriod should be \c{NULL}.
N*
N*    xHot and yHot determine the hot spot position of the cursor. This means the relative
N*    position in X and Y from the upper left corner of the image to the position of the
N*    pointer input device.
N*
N*    Customized cursors can be realized by passing a pointer to a custom defined
N*    GUI_CURSOR_ANIM structure.
N*/
Ntypedef struct {
N  const GUI_BITMAP ** ppBm;       // Pointer to an array of pointers to bitmaps to be used for the animated cursor.
N  int                 xHot;       // X-position of hot spot. Details can be found below.
N  int                 yHot;       // Y-position of hot spot. Details can be found below.
N  unsigned            Period;     // Period to be used to switch between the images.
N  const unsigned    * pPeriod;    // Pointer to an array containing the periods to be used to switch between the images.
N  int                 NumItems;   // Number of images used for the animation.
N} GUI_CURSOR_ANIM;
N
N#if GUI_SUPPORT_CURSOR
X#if (1 | (1))
N  int                GUI_CURSOR_GetState     (void);
N  int                GUI_CURSOR_GetStateEx   (int Layer);
N  void               GUI_CURSOR_Hide         (void);
N  void               GUI_CURSOR_HideEx       (int Layer);
N  const GUI_CURSOR * GUI_CURSOR_Select       (const GUI_CURSOR * pCursor);
N  const GUI_CURSOR * GUI_CURSOR_SelectEx     (const GUI_CURSOR * pCursor, int Layer);
N  int                GUI_CURSOR_SelectAnim   (const GUI_CURSOR_ANIM * pCursorAnim);
N  int                GUI_CURSOR_SelectAnimEx (const GUI_CURSOR_ANIM * pCursorAnim, int LayerIndex);
N  int                GUI_CURSOR_SetBitmap    (const GUI_BITMAP * pBM);
N  int                GUI_CURSOR_SetBitmapEx  (const GUI_BITMAP * pBM, int Layer);
N  void               GUI_CURSOR_SetPosition  (int x, int y);
N  void               GUI_CURSOR_SetPositionEx(int xNewPos, int yNewPos, int Layer);
N  void               GUI_CURSOR_Show         (void);
N  void               GUI_CURSOR_ShowEx       (int Layer);
N  GUI_HSPRITE        GUI_CURSOR__GetSpriteEx (int LayerIndex, int * pxPos, int * pyPos);
N  void               GUI_CURSOR__SetSpriteEx (GUI_HSPRITE hSprite, const GUI_CURSOR * pCursor, int LayerIndex);
N#else
S  #define GUI_CURSOR_Show();
S  #define GUI_CURSOR_Clear();
N#endif
N
N/*********************************************************************
N*
N*       Sprite support
N*/
N#define GUI_SPRITE_CF_STAYONTOP (1 << 0)
N#define GUI_SPRITE_CF_SHOW      (1 << 1)
N
N#define GUI_SPRITE_SHOW 0
N#define GUI_SPRITE_HIDE 1
N
NGUI_HSPRITE GUI_SPRITE__CreateEx           (const GUI_BITMAP * pBM, int x, int y, int Layer, U16 Flags); /* Not to be documented, only used by cursor modul */
XGUI_HSPRITE GUI_SPRITE__CreateEx           (const GUI_BITMAP * pBM, int x, int y, int Layer, unsigned short Flags);  
Nvoid        GUI_SPRITE__SetCallback        (GUI_HSPRITE hSprite, GUI_HMEM hContext, void (* pCB)(GUI_HSPRITE, int));
Xvoid        GUI_SPRITE__SetCallback        (GUI_HSPRITE hSprite, signed long hContext, void (* pCB)(GUI_HSPRITE, int));
NGUI_HSPRITE GUI_SPRITE_Create              (const GUI_BITMAP * pBM, int x, int y);
NGUI_HSPRITE GUI_SPRITE_CreateAnim          (const GUI_BITMAP ** ppBm, int x, int y, unsigned Period, const unsigned * pPeriod, int NumItems);
NGUI_HSPRITE GUI_SPRITE_CreateEx            (const GUI_BITMAP * pBM, int x, int y, int Layer);
NGUI_HSPRITE GUI_SPRITE_CreateExAnim        (const GUI_BITMAP ** ppBm, int x, int y, unsigned Period, const unsigned * pPeriod, int NumItems, int LayerIndex);
NGUI_HSPRITE GUI_SPRITE_CreateHidden        (const GUI_BITMAP * pBM, int x, int y);
NGUI_HSPRITE GUI_SPRITE_CreateHiddenEx      (const GUI_BITMAP * pBM, int x, int y, int Layer);
Nvoid        GUI_SPRITE_Delete              (GUI_HSPRITE hSprite);
Nint         GUI_SPRITE_GetState            (GUI_HSPRITE hSprite);
Nvoid        GUI_SPRITE_Hide                (GUI_HSPRITE hSprite);
Nint         GUI_SPRITE_SetBitmap           (GUI_HSPRITE hSprite, const GUI_BITMAP * pBM);
Nint         GUI_SPRITE_SetBitmapAndPosition(GUI_HSPRITE hSprite, const GUI_BITMAP * pBM, int x, int y);
Nint         GUI_SPRITE_SetLoop             (GUI_HSPRITE hSprite, int OnOff);
Nvoid        GUI_SPRITE_SetPosition         (GUI_HSPRITE hSprite, int x, int y);
Nint         GUI_SPRITE_StartAnim           (GUI_HSPRITE hSprite);
Nint         GUI_SPRITE_StopAnim            (GUI_HSPRITE hSprite);
Nvoid        GUI_SPRITE_Show                (GUI_HSPRITE hSprite);
N
N/*********************************************************************
N*
N*       Cursors and their bitmaps
N*/
Nextern GUI_CONST_STORAGE GUI_CURSOR GUI_CursorArrowS,  GUI_CursorArrowSI;
Xextern const GUI_CURSOR GUI_CursorArrowS,  GUI_CursorArrowSI;
Nextern GUI_CONST_STORAGE GUI_CURSOR GUI_CursorArrowM,  GUI_CursorArrowMI;
Xextern const GUI_CURSOR GUI_CursorArrowM,  GUI_CursorArrowMI;
Nextern GUI_CONST_STORAGE GUI_CURSOR GUI_CursorArrowL,  GUI_CursorArrowLI;
Xextern const GUI_CURSOR GUI_CursorArrowL,  GUI_CursorArrowLI;
Nextern GUI_CONST_STORAGE GUI_CURSOR GUI_CursorCrossS,  GUI_CursorCrossSI;
Xextern const GUI_CURSOR GUI_CursorCrossS,  GUI_CursorCrossSI;
Nextern GUI_CONST_STORAGE GUI_CURSOR GUI_CursorCrossM,  GUI_CursorCrossMI;
Xextern const GUI_CURSOR GUI_CursorCrossM,  GUI_CursorCrossMI;
Nextern GUI_CONST_STORAGE GUI_CURSOR GUI_CursorCrossL,  GUI_CursorCrossLI;
Xextern const GUI_CURSOR GUI_CursorCrossL,  GUI_CursorCrossLI;
Nextern GUI_CONST_STORAGE GUI_CURSOR GUI_CursorHeaderM, GUI_CursorHeaderMI;
Xextern const GUI_CURSOR GUI_CursorHeaderM, GUI_CursorHeaderMI;
Nextern GUI_CONST_STORAGE GUI_CURSOR_ANIM GUI_CursorAnimHourglassM;
Xextern const GUI_CURSOR_ANIM GUI_CursorAnimHourglassM;
N
N/*********************************************************************
N*
N*       GUI_WRAPMODE
N*
N*  Description
N*    Configuration how text will be wrapped.
N*
N*  Additional information
N*    If word wrapping should be performed and the given rectangle is too small for a word, char
N*    wrapping is executed at this word.
N*/
Ntypedef enum {
N  GUI_WRAPMODE_NONE,   // No wrapping will be performed.
N  GUI_WRAPMODE_WORD,   // Text is wrapped word wise.
N  GUI_WRAPMODE_CHAR    // Text is wrapped char wise.
N} GUI_WRAPMODE;
N
N/*********************************************************************
N*
N*       Text related routines
N*/
Nvoid  GUI_DispCEOL                  (void);
Nvoid  GUI_DispChar                  (U16 c);
Xvoid  GUI_DispChar                  (unsigned short c);
Nvoid  GUI_DispCharAt                (U16 c, I16P x, I16P y);
Xvoid  GUI_DispCharAt                (unsigned short c, signed short x, signed short y);
Nvoid  GUI_DispChars                 (U16 c, int Cnt);
Xvoid  GUI_DispChars                 (unsigned short c, int Cnt);
Nvoid  GUI_DispNextLine              (void);
Nvoid  GUI_DispString                (const char * s);
Nvoid  GUI_DispStringAt              (const char * s, int x, int y);
Nvoid  GUI_DispStringAtCEOL          (const char * s, int x, int y);
Nvoid  GUI_DispStringHCenterAt       (const char * s, int x, int y);
Nvoid  GUI__DispStringInRect         (const char * s, GUI_RECT * pRect, int TextAlign, int MaxNumChars);
Nvoid  GUI_DispStringInRect          (const char * s, GUI_RECT * pRect, int TextAlign);
N#if GUI_SUPPORT_ROTATION
X#if 1
Nvoid  GUI_DispStringInRectEx        (const char * s, GUI_RECT * pRect, int TextAlign, int MaxLen, const GUI_ROTATION * pLCD_Api);
Xvoid  GUI_DispStringInRectEx        (const char * s, GUI_RECT * pRect, int TextAlign, int MaxLen, const tLCD_APIList * pLCD_Api);
N#endif
Nvoid  GUI_DispStringInRectMax       (const char * s, GUI_RECT * pRect, int TextAlign, int MaxLen); /* Not to be doc. */
Nvoid  GUI_DispStringInRectWrap      (const char * s, GUI_RECT * pRect, int TextAlign, GUI_WRAPMODE WrapMode); /* Not to be doc. */
N#if GUI_SUPPORT_ROTATION
X#if 1
Nvoid  GUI_DispStringInRectWrapEx    (const char * s, GUI_RECT * pRect, int TextAlign, GUI_WRAPMODE WrapMode, const GUI_ROTATION * pLCD_Api);
Xvoid  GUI_DispStringInRectWrapEx    (const char * s, GUI_RECT * pRect, int TextAlign, GUI_WRAPMODE WrapMode, const tLCD_APIList * pLCD_Api);
N#endif
Nvoid  GUI_DispStringLen             (const char * s, int Len);
NU16   GUI_GetCharFromPos            (const char * pText, int x, int * pIndex);
Xunsigned short   GUI_GetCharFromPos            (const char * pText, int x, int * pIndex);
Nconst GUI_FONT * GUI_GetFallbackFont(U16 c);
Xconst GUI_FONT * GUI_GetFallbackFont(unsigned short c);
Nvoid  GUI_GetTextExtend             (GUI_RECT* pRect, const char * s, int Len);
Nint   GUI_GetYAdjust                (void);
Nint   GUI_GetDispPosX               (void);
Nint   GUI_GetDispPosY               (void);
Nconst GUI_FONT * GUI_GetFont        (void);
Nint   GUI_GetCharDistX              (U16 c);
Xint   GUI_GetCharDistX              (unsigned short c);
Nint   GUI_GetCharDistXEx            (U16 c, int * pSizeX);
Xint   GUI_GetCharDistXEx            (unsigned short c, int * pSizeX);
Nint   GUI_GetStringDistX            (const char * s);
Nint   GUI_GetStringDistXEx          (const char * s, int n);
NGUI_DRAWMODE GUI_GetDrawMode        (void);
Nint   GUI_GetFontDistY              (void);
Nint   GUI_GetFontSizeY              (void);
Nvoid  GUI_GetFontInfo               (const GUI_FONT * pFont, GUI_FONTINFO * pfi);
Nvoid  GUI_GetOrg                    (int * px, int * py);
Nint   GUI_GetYSizeOfFont            (const GUI_FONT * pFont);
Nint   GUI_GetYDistOfFont            (const GUI_FONT * pFont);
Nint   GUI_GetTextAlign              (void);
Nint   GUI_GetTextMode               (void);
Nchar  GUI_IsInFont                  (const GUI_FONT * pFont, U16 c);
Xchar  GUI_IsInFont                  (const GUI_FONT * pFont, unsigned short c);
NU8    GUI_SetClearTextRectMode      (unsigned OnOff);
Xunsigned char    GUI_SetClearTextRectMode      (unsigned OnOff);
Nconst GUI_FONT * GUI_SetFallbackFont(const GUI_FONT * pNewFont);
Nvoid  GUI_SetFuncGetFallbackFont    (const GUI_FONT * (* pfcbGetFallbackFont)(U16 c));
Xvoid  GUI_SetFuncGetFallbackFont    (const GUI_FONT * (* pfcbGetFallbackFont)(unsigned short c));
Nint   GUI_SetTextAlign              (int Align);
Nint   GUI_SetTextMode               (int Mode);
Nchar  GUI_SetTextStyle              (char Style);
Nint   GUI_SetLBorder                (int x);
NU8    GUI_SetStrikeWidth            (U8 StrikeWidth);
Xunsigned char    GUI_SetStrikeWidth            (unsigned char StrikeWidth);
Nconst GUI_FONT * GUI_SetFont        (const GUI_FONT * pNewFont);
Nchar  GUI_GotoXY                    (int x, int y);
Nchar  GUI_GotoX                     (int x);
Nchar  GUI_GotoY                     (int y);
Nvoid  GUI_ShowMissingCharacters     (int OnOff);
Nint   GUI_GetShowMissingCharacters  (void);
Nint   GUI_WrapGetNumLines           (const char * pText, int xSize, GUI_WRAPMODE WrapMode);
Nint   GUI_WrapGetPositions          (const char * pText, int xSize, GUI_WRAPMODE WrapMode, int * aPos, int NumItems);
Nvoid  GUI_WrapSetSeparators         (const U16 * pSep, int NumSeps);
Xvoid  GUI_WrapSetSeparators         (const unsigned short * pSep, int NumSeps);
N
Nint   GUI_GetLeadingBlankCols       (U16 c);
Xint   GUI_GetLeadingBlankCols       (unsigned short c);
Nint   GUI_GetTrailingBlankCols      (U16 c);
Xint   GUI_GetTrailingBlankCols      (unsigned short c);
Nint   GUI_GetLeadingBlankRows       (U16 c);
Xint   GUI_GetLeadingBlankRows       (unsigned short c);
Nint   GUI_GetTrailingBlankRows      (U16 c);
Xint   GUI_GetTrailingBlankRows      (unsigned short c);
N
N/*********************************************************************
N*
N*       System independent fonts (SIF)
N*/
Nvoid GUI_SIF_CreateFont(const void * pFontData, GUI_FONT * pFont, const GUI_SIF_TYPE * pFontType);
Xvoid GUI_SIF_CreateFont(const void * pFontData, GUI_FONT * pFont, const tGUI_SIF_APIList * pFontType);
Nvoid GUI_SIF_DeleteFont(GUI_FONT * pFont);
N
N/*********************************************************************
N*
N*       External binary fonts (XBF)
N*/
Nint  GUI_XBF_CreateFont(GUI_FONT * pFont, GUI_XBF_DATA * pXBF, const GUI_XBF_TYPE * pFontType, GUI_XBF_GET_DATA_FUNC * pfGetData, void * pVoid);
Xint  GUI_XBF_CreateFont(GUI_FONT * pFont, GUI_XBF_DATA * pXBF, const tGUI_XBF_APIList * pFontType, GUI_XBF_GET_DATA_FUNC * pfGetData, void * pVoid);
Nvoid GUI_XBF_DeleteFont(GUI_FONT * pFont);
N
N#define GUI_XBF_HEADER_SIZE    18
N#define GUI_XBF_TABLEITEM_SIZE (sizeof(U32) + sizeof(U16))
N
N/*********************************************************************
N*
N*       FreeType engine
N*/
Nvoid GUI_FT_DestroyCache       (void);
Nvoid GUI_FT_Done               (void);
Nvoid GUI_FT_GetMeasurementChars(U16 * pLowerHeight, U16 * pUpperHeight);
Xvoid GUI_FT_GetMeasurementChars(unsigned short * pLowerHeight, unsigned short * pUpperHeight);
Nvoid GUI_FT_SetCacheSize       (unsigned MaxFaces, unsigned MaxSizes, U32 MaxBytes);
Xvoid GUI_FT_SetCacheSize       (unsigned MaxFaces, unsigned MaxSizes, unsigned long MaxBytes);
Nvoid GUI_FT_SetMeasurementChars(U16 LowerHeight, U16 UpperHeight);
Xvoid GUI_FT_SetMeasurementChars(unsigned short LowerHeight, unsigned short UpperHeight);
N
N/*********************************************************************
N*
N*       FreeType compability macros
N*/
N#define GUI_TTF_DestroyCache()                             GUI_FT_DestroyCache()
N#define GUI_TTF_Done()                                     GUI_FT_Done()
N#define GUI_TTF_SetCacheSize(MaxFaces, MaxSizes, MaxBytes) GUI_FT_SetCacheSize(MaxFaces, MaxSizes, MaxBytes)
N
N/*********************************************************************
N*
N*       TrueType support (TTF)
N*/
Nvoid GUI_TTF_AddRowBottom  (GUI_FONT * pFont, int NumRows);
Nvoid GUI_TTF_AddRowTop     (GUI_FONT * pFont, int NumRows);
Nint  GUI_TTF_CreateFont    (GUI_FONT * pFont, GUI_TTF_CS * pCS);
Nint  GUI_TTF_CreateFontAA  (GUI_FONT * pFont, GUI_TTF_CS * pCS);
Nint  GUI_TTF_EmboldenFont  (GUI_FONT * pFont, U8 Embolden);
Xint  GUI_TTF_EmboldenFont  (GUI_FONT * pFont, unsigned char Embolden);
Nint  GUI_TTF_EmboldenFontEx(GUI_FONT * pFont, I32 Strength);
Xint  GUI_TTF_EmboldenFontEx(GUI_FONT * pFont, signed long Strength);
Nint  GUI_TTF_EnableKerning (GUI_FONT * pFont, int OnOff);
Nint  GUI_TTF_GetFamilyName (GUI_FONT * pFont, char * pBuffer, int NumBytes);
Nint  GUI_TTF_GetStyleName  (GUI_FONT * pFont, char * pBuffer, int NumBytes);
Nint  GUI_TTF_ObliqueFont   (GUI_FONT * pFont, U8 Oblique);
Xint  GUI_TTF_ObliqueFont   (GUI_FONT * pFont, unsigned char Oblique);
Nint  GUI_TTF_ObliqueFontEx (GUI_FONT * pFont, I32 Angle);
Xint  GUI_TTF_ObliqueFontEx (GUI_FONT * pFont, signed long Angle);
N
N/*********************************************************************
N*
N*       Glyph Bitmap Distribution Format support (BDF)
N*/
Nint GUI_BDF_CreateFont      (GUI_FONT * pFont, const U8 * pData, U32 Size);
Xint GUI_BDF_CreateFont      (GUI_FONT * pFont, const unsigned char * pData, unsigned long Size);
Nint GUI_BDF_DeleteFont      (GUI_FONT * pFont);
Nint GUI_BDF_EmboldenFont    (GUI_FONT * pFont, U8 Embolden);
Xint GUI_BDF_EmboldenFont    (GUI_FONT * pFont, unsigned char Embolden);
Nint GUI_BDF_EmboldenFontEx  (GUI_FONT * pFont, I32 Strength);
Xint GUI_BDF_EmboldenFontEx  (GUI_FONT * pFont, signed long Strength);
Nint GUI_BDF_GetFamilyName   (GUI_FONT * pFont, char * pBuffer, int NumBytes);
Nint GUI_BDF_GetStyleName    (GUI_FONT * pFont, char * pBuffer, int NumBytes);
Nint GUI_BDF_SetLetterSpacing(GUI_FONT * pFont, int Spacing);
N
N/*********************************************************************
N*
N*       Kerning
N*/
Nvoid               GUI_AttachKerning (const GUI_FONT * pFont, GUI_KERNING_INFO * pInfo, const U16 * pData, U32 NumItems);
Xvoid               GUI_AttachKerning (const GUI_FONT * pFont, GUI_KERNING_INFO * pInfo, const unsigned short * pData, unsigned long NumItems);
Nint                GUI_DetachKerning (const GUI_FONT * pFont);
NGUI_KERNING_INFO * GUI_GetKerning    (const GUI_FONT * pFont);                    // Not to be documented
NI16                GUI_GetKerningDist(GUI_KERNING_INFO * pInfo, U16 cl, U16 cr);  // Not to be documented
Xsigned short                GUI_GetKerningDist(GUI_KERNING_INFO * pInfo, unsigned short cl, unsigned short cr);  
N
N/*********************************************************************
N*
N*       Resource file support
N*/
N/*********************************************************************
N*
N*       GUI_LANG_GET_DATA_FUNC
N* 
N*  Description
N*    GetData function used for the language module, for more details see
N*    \uref{GUI_GET_DATA_FUNC_II}.
N*/
Ntypedef GUI_GET_DATA_FUNC_II     GUI_LANG_GET_DATA_FUNC;
N
Nvoid         GUI_LANG_Clear            (void);
Nint          GUI_LANG_GetLang          (void);
Nint          GUI_LANG_GetNumItems      (int IndexLang);
Nconst char * GUI_LANG_GetText          (int IndexText);
Nint          GUI_LANG_GetTextBuffered  (int IndexText, char * pBuffer, int SizeOfBuffer);
Nint          GUI_LANG_GetTextBufferedEx(int IndexText, int IndexLang, char * pBuffer, int SizeOfBuffer);
Nconst char * GUI_LANG_GetTextEx        (int IndexText, int IndexLang);
Nint          GUI_LANG_GetTextLen       (int IndexText);
Nint          GUI_LANG_GetTextLenEx     (int IndexText, int IndexLang);
Nint          GUI_LANG_LoadCSV          (U8 * pFileData, U32 FileSize);
Xint          GUI_LANG_LoadCSV          (unsigned char * pFileData, unsigned long FileSize);
Nint          GUI_LANG_LoadCSVEx        (GUI_LANG_GET_DATA_FUNC * pfGetData, void * p);
Nint          GUI_LANG_LoadText         (U8 * pFileData, U32 FileSize, int IndexLang);
Xint          GUI_LANG_LoadText         (unsigned char * pFileData, unsigned long FileSize, int IndexLang);
Nint          GUI_LANG_LoadTextEx       (GUI_LANG_GET_DATA_FUNC * pfGetData, void * p, int IndexLang);
Nint          GUI_LANG_SetLang          (int IndexLang);
Nunsigned     GUI_LANG_SetMaxNumLang    (unsigned MaxNumLang);
NU16          GUI_LANG_SetSep           (U16 Sep);
Xunsigned short          GUI_LANG_SetSep           (unsigned short Sep);
N
N/*********************************************************************
N*
N*       Unicode support
N*/
Nint  GUI_UC_ConvertUC2UTF8(const U16 * s, int Len, char * pBuffer, int BufferSize);
Xint  GUI_UC_ConvertUC2UTF8(const unsigned short * s, int Len, char * pBuffer, int BufferSize);
Nint  GUI_UC_ConvertUTF82UC(const char * s, int Len, U16 * pBuffer, int BufferSize);
Xint  GUI_UC_ConvertUTF82UC(const char * s, int Len, unsigned short * pBuffer, int BufferSize);
Nint  GUI_UC_EnableBIDI    (int OnOff);
Nint  GUI_UC_EnableThai    (int OnOff);
Nint  GUI_UC_Encode        (char * s, U16 Char);
Xint  GUI_UC_Encode        (char * s, unsigned short Char);
Nint  GUI_UC_GetCharSize   (const char * s);
NU16  GUI_UC_GetCharCode   (const char * s);
Xunsigned short  GUI_UC_GetCharCode   (const char * s);
Nvoid GUI_UC_SetEncodeNone (void);
Nvoid GUI_UC_SetEncodeSJIS (void);
Nvoid GUI_UC_SetEncodeUTF8 (void);
N
N// Only available with GB2312 encoding
N// Start
Nvoid NVT_GUI_GB_SetEncodeGB2312 (void);
Nvoid NVT_GUI_SetASCIIOffset     (U32 u32GB2312FontDataAddress, U32 u32Offset);
Xvoid NVT_GUI_SetASCIIOffset     (unsigned long u32GB2312FontDataAddress, unsigned long u32Offset);
Nvoid NVT_GUI_SetGB2312Offset    (U32 u32GB2312FontDataAddress, U32 u32Offset);
Xvoid NVT_GUI_SetGB2312Offset    (unsigned long u32GB2312FontDataAddress, unsigned long u32Offset);
N// End
N
Nvoid GUI_UC_SetBaseDir    (int Dir);  // Only available with new version of BIDI algorithm (GUI_USE_BIDI2 == 1)
Nint  GUI_UC_GetBaseDir    (void);     // Only available with new version of BIDI algorithm (GUI_USE_BIDI2 == 1)
N
Nvoid GUI_UC_DispString(const U16 * s);
Xvoid GUI_UC_DispString(const unsigned short * s);
Nvoid GUI_UC2DB (U16 Code, U8 * pOut);
Xvoid GUI_UC2DB (unsigned short Code, unsigned char * pOut);
NU16  GUI_DB2UC (U8 Byte0, U8 Byte1);
Xunsigned short  GUI_DB2UC (unsigned char Byte0, unsigned char Byte1);
N
N/*********************************************************************
N*
N*       Bidi support
N*/
N#define GUI_BIDI_BASEDIR_LTR  0
N#define GUI_BIDI_BASEDIR_RTL  1
N#define GUI_BIDI_BASEDIR_AUTO 2
N
N#define GUI_BIDI_LOG2VIS_CALC     0
N#define GUI_BIDI_LOG2VIS_GETCACHE 1
N
N/*********************************************************************
N*
N*       Drawing of binary, decimal and hexadecimal values
N*/
Nvoid GUI_DispBin      (U32  v, U8 Len);
Xvoid GUI_DispBin      (unsigned long  v, unsigned char Len);
Nvoid GUI_DispBinAt    (U32  v, I16P x, I16P y, U8 Len);
Xvoid GUI_DispBinAt    (unsigned long  v, signed short x, signed short y, unsigned char Len);
Nvoid GUI_DispDec      (I32 v, U8 Len);
Xvoid GUI_DispDec      (signed long v, unsigned char Len);
Nvoid GUI_DispDecAt    (I32 v, I16P x, I16P y, U8 Len);
Xvoid GUI_DispDecAt    (signed long v, signed short x, signed short y, unsigned char Len);
Nvoid GUI_DispDecMin   (I32 v);
Xvoid GUI_DispDecMin   (signed long v);
Nvoid GUI_DispDecShift (I32 v, U8 Len, U8 Shift);
Xvoid GUI_DispDecShift (signed long v, unsigned char Len, unsigned char Shift);
Nvoid GUI_DispDecSpace (I32 v, U8 MaxDigits);
Xvoid GUI_DispDecSpace (signed long v, unsigned char MaxDigits);
Nvoid GUI_DispHex      (U32 v, U8 Len);
Xvoid GUI_DispHex      (unsigned long v, unsigned char Len);
Nvoid GUI_DispHexAt    (U32 v, I16P x, I16P y, U8 Len);
Xvoid GUI_DispHexAt    (unsigned long v, signed short x, signed short y, unsigned char Len);
Nvoid GUI_DispSDec     (I32 v, U8 Len);
Xvoid GUI_DispSDec     (signed long v, unsigned char Len);
Nvoid GUI_DispSDecShift(I32 v, U8 Len, U8 Shift);
Xvoid GUI_DispSDecShift(signed long v, unsigned char Len, unsigned char Shift);
N
N/*********************************************************************
N*
N*       Drawing of floating point values
N*/
Nvoid GUI_DispFloat    (float v, char Len);
Nvoid GUI_DispFloatFix (float v, char Len, char Fract);
Nvoid GUI_DispFloatMin (float v, char Fract);
Nvoid GUI_DispSFloatFix(float v, char Len, char Fract);
Nvoid GUI_DispSFloatMin(float v, char Fract);
N
N/*********************************************************************
N*
N*       Dynamic memory management
N*/
Ntypedef struct {
N  U32 TotalBytes;
X  unsigned long TotalBytes;
N  U32 FreeBytes;
X  unsigned long FreeBytes;
N  U32 UsedBytes;
X  unsigned long UsedBytes;
N  U32 AllocSize;
X  unsigned long AllocSize;
N  U32 NumFixedBytes;
X  unsigned long NumFixedBytes;
N  U32 MaxUsedBytes;
X  unsigned long MaxUsedBytes;
N} GUI_ALLOC_INFO;
N
NGUI_ALLOC_DATATYPE GUI_ALLOC_GetNumFreeBlocks(void);
Xsigned long GUI_ALLOC_GetNumFreeBlocks(void);
NGUI_ALLOC_DATATYPE GUI_ALLOC_GetNumFreeBytes (void);
Xsigned long GUI_ALLOC_GetNumFreeBytes (void);
NGUI_ALLOC_DATATYPE GUI_ALLOC_GetNumUsedBlocks(void);
Xsigned long GUI_ALLOC_GetNumUsedBlocks(void);
NGUI_ALLOC_DATATYPE GUI_ALLOC_GetNumUsedBytes (void);
Xsigned long GUI_ALLOC_GetNumUsedBytes (void);
NGUI_ALLOC_DATATYPE GUI_ALLOC_GetMaxUsedBytes (void);
Xsigned long GUI_ALLOC_GetMaxUsedBytes (void);
N
Nvoid * GUI_ALLOC_calloc (size_t NumItems, size_t Size);
Nvoid   GUI_ALLOC_free   (void * p);
Nvoid * GUI_ALLOC_malloc (size_t Size);
Nvoid * GUI_ALLOC_realloc(void * p, size_t NewSize);
N
Nvoid GUI_ALLOC_GetMemInfo  (GUI_ALLOC_INFO * pInfo);
Nvoid GUI_ALLOC_SuppressPeak(int OnOff);
N
NGUI_HMEM           GUI_ALLOC_AllocInit       (const void * pInitData, GUI_ALLOC_DATATYPE Size);
Xsigned long           GUI_ALLOC_AllocInit       (const void * pInitData, signed long Size);
NGUI_HMEM           GUI_ALLOC_AllocNoInit     (GUI_ALLOC_DATATYPE size);
Xsigned long           GUI_ALLOC_AllocNoInit     (signed long size);
NGUI_HMEM           GUI_ALLOC_AllocZero       (GUI_ALLOC_DATATYPE size);
Xsigned long           GUI_ALLOC_AllocZero       (signed long size);
Nvoid               GUI_ALLOC_AssignMemory    (void * p, U32 NumBytes);
Xvoid               GUI_ALLOC_AssignMemory    (void * p, unsigned long NumBytes);
Nvoid               GUI_ALLOC_Free            (GUI_HMEM  hMem);
Xvoid               GUI_ALLOC_Free            (signed long  hMem);
Nvoid               GUI_ALLOC_FreeFixedBlock  (void * p);
Nvoid               GUI_ALLOC_FreePtrArray    (GUI_HMEM * pArray, int NumElems);
Xvoid               GUI_ALLOC_FreePtrArray    (signed long * pArray, int NumElems);
Nvoid               GUI_ALLOC_FreePtr         (GUI_HMEM * phMem);
Xvoid               GUI_ALLOC_FreePtr         (signed long * phMem);
Nvoid *             GUI_ALLOC_GetFixedBlock   (GUI_ALLOC_DATATYPE Size);
Xvoid *             GUI_ALLOC_GetFixedBlock   (signed long Size);
NGUI_ALLOC_DATATYPE GUI_ALLOC_GetMaxSize      (void);
Xsigned long GUI_ALLOC_GetMaxSize      (void);
NGUI_ALLOC_DATATYPE GUI_ALLOC_GetSize         (GUI_HMEM  hMem);
Xsigned long GUI_ALLOC_GetSize         (signed long  hMem);
Nvoid *             GUI_ALLOC_h2p             (GUI_HMEM  hMem);
Xvoid *             GUI_ALLOC_h2p             (signed long  hMem);
NGUI_HMEM           GUI_ALLOC_p2h             (void * p);
Xsigned long           GUI_ALLOC_p2h             (void * p);
Nvoid               GUI_ALLOC_Lock            (void);
Nvoid *             GUI_ALLOC_LockH           (GUI_HMEM  hMem);
Xvoid *             GUI_ALLOC_LockH           (signed long  hMem);
NGUI_HMEM           GUI_ALLOC_Realloc         (GUI_HMEM hOld, int NewSize);
Xsigned long           GUI_ALLOC_Realloc         (signed long hOld, int NewSize);
NGUI_ALLOC_DATATYPE GUI_ALLOC_RequestSize     (void);
Xsigned long GUI_ALLOC_RequestSize     (void);
Nvoid               GUI_ALLOC_SetAvBlockSize  (U32 BlockSize);
Xvoid               GUI_ALLOC_SetAvBlockSize  (unsigned long BlockSize);
Nvoid               GUI_ALLOC_SetShortOfRAM   (void (* pfOnShortOfRAM)(void));
Nvoid               GUI_ALLOC_Unlock          (void);
Nvoid *             GUI_ALLOC_UnlockH         (void ** pp);
N//const void *     GUI_ALLOC_UnlockC         (const void ** pp);
Nvoid               GUI_ALLOC_UnlockC         (const void ** pp);
Nint                GUI_ALLOC_SetMaxPercentage(int MaxPercentage);
Nvoid               GUI_ALLOC_Exit            (void);
N
N/*********************************************************************
N*
N*       Memory device flags
N*
N*  Description
N*    Flags to be used for the creation of a memory device.
N*/
N#define GUI_MEMDEV_HASTRANS       0    // Default: The Memory Device is created with a transparency flag which ensures that the background will be drawn correctly.
N#define GUI_MEMDEV_NOTRANS  (1 << 0)   // Creates a Memory Device without transparency. The user must make sure that the background is drawn correctly.
N                                       // This way the Memory Device can be used for non-rectangular areas. An other advantage is the higher speed: Using this
N                                       // flag accelerates the Memory Device approx. by 30 - 50%.
N/* (ignore - emDoc should stop here) */
N
Ntypedef GUI_HMEM GUI_MEMDEV_Handle;
Xtypedef signed long GUI_MEMDEV_Handle;
Ntypedef void     GUI_CALLBACK_VOID_P        (void * p);
Ntypedef int      GUI_ANIMATION_CALLBACK_FUNC(int TimeRem, void * pVoid);
Ntypedef void     GUI_DRAWMEMDEV_16BPP_FUNC  (void * pDst, const void * pSrc, int xSize, int ySize, int BytesPerLineDst, int BytesPerLineSrc);
N
N#define GUI_DRAWMEMDEV_FUNC GUI_DRAWMEMDEV_16BPP_FUNC
N
Ntypedef void GUI_DRAWBITMAP_FUNC (int LayerIndex, int x, int y, const void * p, int xSize, int ySize, int BytesPerLine);
N
Nint GUI_SetFuncDrawAlpha(GUI_DRAWMEMDEV_FUNC * pfDrawMemdevFunc, GUI_DRAWBITMAP_FUNC * pfDrawBitmapFunc);
Xint GUI_SetFuncDrawAlpha(GUI_DRAWMEMDEV_16BPP_FUNC * pfDrawMemdevFunc, GUI_DRAWBITMAP_FUNC * pfDrawBitmapFunc);
Nint GUI_SetFuncDrawM565 (GUI_DRAWMEMDEV_FUNC * pfDrawMemdevFunc, GUI_DRAWBITMAP_FUNC * pfDrawBitmapFunc);
Xint GUI_SetFuncDrawM565 (GUI_DRAWMEMDEV_16BPP_FUNC * pfDrawMemdevFunc, GUI_DRAWBITMAP_FUNC * pfDrawBitmapFunc);
Nint GUI_SetFuncDrawA8   (GUI_DRAWMEMDEV_FUNC * pfDrawMemdevFunc, GUI_DRAWBITMAP_FUNC * pfDrawBitmapFunc);
Xint GUI_SetFuncDrawA8   (GUI_DRAWMEMDEV_16BPP_FUNC * pfDrawMemdevFunc, GUI_DRAWBITMAP_FUNC * pfDrawBitmapFunc);
N
Nextern GUI_ANIMATION_CALLBACK_FUNC * GUI_MEMDEV__pCbAnimation;
Nextern void                        * GUI_MEMDEV__pVoid;
N
Nextern void (* GUI_MEMDEV__pfMEMDEV_Write)    (GUI_MEMDEV_Handle hMem);
Nextern void (* GUI_MEMDEV__pfMEMDEV_CopyToLCD)(GUI_MEMDEV_Handle hMem);
N
Ntypedef struct {
N  GUI_RECT rView, rPrev;
N  char FirstCall;
N} GUI_AUTODEV;
N
Ntypedef struct {
N  char DrawFixed;
N  char IsMeasurement;
N} GUI_AUTODEV_INFO;
N
Nint  GUI_MEMDEV_CreateAuto(GUI_AUTODEV * pAutoDev);
Nvoid GUI_MEMDEV_DeleteAuto(GUI_AUTODEV * pAutoDev);
Nint  GUI_MEMDEV_DrawAuto  (GUI_AUTODEV * pAutoDev, GUI_AUTODEV_INFO * pAutoDevInfo, GUI_CALLBACK_VOID_P * pfDraw, void * pData);
N
N/* Create a memory device which is compatible to the selected LCD */
NGUI_MEMDEV_Handle GUI_MEMDEV_Create       (int x0, int y0, int xSize, int ySize);
NGUI_MEMDEV_Handle GUI_MEMDEV_CreateCopy   (GUI_MEMDEV_Handle hMemSrc);
NGUI_MEMDEV_Handle GUI_MEMDEV_CreateEx     (int x0, int y0, int xSize, int ySize, int Flags);
NGUI_MEMDEV_Handle GUI_MEMDEV_CreateFixed  (int x0, int y0, int xSize, int ySize, int Flags,
N                                           const GUI_DEVICE_API     * pDeviceAPI,
N                                           const LCD_API_COLOR_CONV * pColorConvAPI);
NGUI_MEMDEV_Handle GUI_MEMDEV_CreateFixed32(int x0, int y0, int xSize, int ySize);
N
Nvoid                       GUI_MEMDEV_Clear               (GUI_MEMDEV_Handle hMem);
Nint                        GUI_MEMDEV_ClearAlpha          (GUI_MEMDEV_Handle hMemData, GUI_MEMDEV_Handle hMemMask);
Nvoid                       GUI_MEMDEV_CopyFromLCD         (GUI_MEMDEV_Handle hMem);
Nvoid                       GUI_MEMDEV_CopyFromLCDAA       (GUI_MEMDEV_Handle hMem);
Nint                        GUI_MEMDEV_CopyRect            (GUI_MEMDEV_Handle hMemSrc, GUI_MEMDEV_Handle hMemDst, const GUI_RECT * pRectSrc, int xDst, int yDst);
Nvoid                       GUI_MEMDEV_CopyToLCD           (GUI_MEMDEV_Handle hMem);
Nvoid                       GUI_MEMDEV_CopyToLCDAA         (GUI_MEMDEV_Handle hMem);
Nvoid                       GUI_MEMDEV_CopyToLCDAt         (GUI_MEMDEV_Handle hMem, int x, int y);
Nint                        GUI_MEMDEV_CompareWithLCD      (GUI_MEMDEV_Handle hMem, int * px, int * py, int * pExp, int * pAct);
Nvoid                       GUI_MEMDEV_Delete              (GUI_MEMDEV_Handle MemDev);
Nvoid                       GUI_MEMDEV_DrawBitmap32HQHR    (const GUI_BITMAP * pBm, int x0HR, int y0HR);
Nvoid                       GUI_MEMDEV_DrawPerspectiveX    (GUI_MEMDEV_Handle hMem, int x, int y, int h0, int h1, int dx, int dy);
Nvoid                       GUI_MEMDEV_DrawDevice32HQHR    (GUI_MEMDEV_Handle hMemSrc, I32 x0HR, int y0HR);
Xvoid                       GUI_MEMDEV_DrawDevice32HQHR    (GUI_MEMDEV_Handle hMemSrc, signed long x0HR, int y0HR);
Nvoid                       GUI_MEMDEV_Fill32              (GUI_MEMDEV_Handle hMem, U32 Value);
Xvoid                       GUI_MEMDEV_Fill32              (GUI_MEMDEV_Handle hMem, unsigned long Value);
Nint                        GUI_MEMDEV_GetXPos             (GUI_MEMDEV_Handle hMem);
Nint                        GUI_MEMDEV_GetXSize            (GUI_MEMDEV_Handle hMem);
Nint                        GUI_MEMDEV_GetYPos             (GUI_MEMDEV_Handle hMem);
Nint                        GUI_MEMDEV_GetYSize            (GUI_MEMDEV_Handle hMem);
Nvoid                       GUI_MEMDEV_MarkDirty           (GUI_MEMDEV_Handle hMem, int x0, int y0, int x1, int y1);
Nvoid                       GUI_MEMDEV_ReduceYSize         (GUI_MEMDEV_Handle hMem, int YSize);
Nvoid                       GUI_MEMDEV_Rotate              (GUI_MEMDEV_Handle hSrc, GUI_MEMDEV_Handle hDst, int dx, int dy, int a, int Mag);
Nvoid                       GUI_MEMDEV_RotateAlpha         (GUI_MEMDEV_Handle hSrc, GUI_MEMDEV_Handle hDst, int dx, int dy, int a, int Mag, U8 Alpha);
Xvoid                       GUI_MEMDEV_RotateAlpha         (GUI_MEMDEV_Handle hSrc, GUI_MEMDEV_Handle hDst, int dx, int dy, int a, int Mag, unsigned char Alpha);
Nvoid                       GUI_MEMDEV_RotateHR            (GUI_MEMDEV_Handle hSrc, GUI_MEMDEV_Handle hDst, I32 dx, I32 dy, int a, int Mag);
Xvoid                       GUI_MEMDEV_RotateHR            (GUI_MEMDEV_Handle hSrc, GUI_MEMDEV_Handle hDst, signed long dx, signed long dy, int a, int Mag);
Nvoid                       GUI_MEMDEV_RotateHQ            (GUI_MEMDEV_Handle hSrc, GUI_MEMDEV_Handle hDst, int dx, int dy, int a, int Mag);
Nvoid                       GUI_MEMDEV_RotateHQAlpha       (GUI_MEMDEV_Handle hSrc, GUI_MEMDEV_Handle hDst, int dx, int dy, int a, int Mag, U8 Alpha);
Xvoid                       GUI_MEMDEV_RotateHQAlpha       (GUI_MEMDEV_Handle hSrc, GUI_MEMDEV_Handle hDst, int dx, int dy, int a, int Mag, unsigned char Alpha);
Nvoid                       GUI_MEMDEV_RotateHQHR          (GUI_MEMDEV_Handle hSrc, GUI_MEMDEV_Handle hDst, I32 dx, I32 dy, int a, int Mag);
Xvoid                       GUI_MEMDEV_RotateHQHR          (GUI_MEMDEV_Handle hSrc, GUI_MEMDEV_Handle hDst, signed long dx, signed long dy, int a, int Mag);
Nvoid                       GUI_MEMDEV_RotateHQT           (GUI_MEMDEV_Handle hSrc, GUI_MEMDEV_Handle hDst, int dx, int dy, int a, int Mag);
Nvoid                       GUI_MEMDEV_RotateHQTI          (GUI_MEMDEV_Handle hSrc, GUI_MEMDEV_Handle hDst, int dx, int dy, int a, int Mag);
NGUI_MEMDEV_Handle          GUI_MEMDEV_Select              (GUI_MEMDEV_Handle hMem);  /* Select (activate) a particular memory device. */
Nvoid                       GUI_MEMDEV_SetOrg              (GUI_MEMDEV_Handle hMem, int x0, int y0);
Nvoid                       GUI_MEMDEV_WriteAt             (GUI_MEMDEV_Handle hMem, int x, int y);
Nvoid                       GUI_MEMDEV_Write               (GUI_MEMDEV_Handle hMem);
Nvoid                       GUI_MEMDEV_WriteAlphaAt        (GUI_MEMDEV_Handle hMem, int Alpha, int x, int y);
Nvoid                       GUI_MEMDEV_WriteAlpha          (GUI_MEMDEV_Handle hMem, int Alpha);
Nvoid                       GUI_MEMDEV_WriteExAt           (GUI_MEMDEV_Handle hMem, int x, int y, int xMag, int yMag, int Alpha);
Nvoid                       GUI_MEMDEV_WriteEx             (GUI_MEMDEV_Handle hMem, int xMag, int yMag, int Alpha);
Nvoid                       GUI_MEMDEV_WriteOpaque         (GUI_MEMDEV_Handle hMem);
Nvoid                       GUI_MEMDEV_WriteOpaqueAt       (GUI_MEMDEV_Handle hMem, int x, int y);
Nint                        GUI_MEMDEV_Draw                (GUI_RECT * pRect, GUI_CALLBACK_VOID_P * pfDraw, void * pData, int NumLines, int Flags);
Nvoid *                     GUI_MEMDEV_GetDataPtr          (GUI_MEMDEV_Handle hMem);
Nvoid                       GUI_MEMDEV_SetColorConv        (GUI_MEMDEV_Handle hMem, const LCD_API_COLOR_CONV * pColorConvAPI);
Nconst LCD_API_COLOR_CONV * GUI_MEMDEV_GetColorConv        (GUI_MEMDEV_Handle hMemDev);
Nint                        GUI_MEMDEV_GetBitsPerPixel     (GUI_MEMDEV_Handle hMemDev);
NGUI_MEMDEV_Handle          GUI_MEMDEV_GetSelMemdev        (void);
Nint                        GUI_MEMDEV_FadeInDevices       (GUI_MEMDEV_Handle hMem0, GUI_MEMDEV_Handle hMem1, int Period);
Nint                        GUI_MEMDEV_FadeOutDevices      (GUI_MEMDEV_Handle hMem0, GUI_MEMDEV_Handle hMem1, int Period);
Nvoid                       GUI_MEMDEV_SerializeBMP        (GUI_MEMDEV_Handle hDev, GUI_CALLBACK_VOID_U8_P * pfSerialize, void * p);
Nvoid                       GUI_MEMDEV_SerializeExBMP      (GUI_MEMDEV_Handle hDev, GUI_CALLBACK_VOID_U8_P * pfSerialize, void * p, int xPos, int yPos, int xSize, int ySize);
Nvoid                       GUI_MEMDEV_SetAnimationCallback(GUI_ANIMATION_CALLBACK_FUNC * pCbAnimation, void * pVoid);
Nint                        GUI_MEMDEV_PunchOutDevice      (GUI_MEMDEV_Handle hMemData, GUI_MEMDEV_Handle hMemMask);
Nvoid                       GUI_MEMDEV_SetTimePerFrame     (unsigned TimePerFrame);
Nint                        GUI_MEMDEV_MULTIBUF_Enable     (int OnOff);
N
N/* Private functions */
Nvoid                       GUI_MEMDEV__ClearCanvas        (void);
Nvoid                       GUI_MEMDEV__ClearCanvasEx      (U8 SetActive);
Xvoid                       GUI_MEMDEV__ClearCanvasEx      (unsigned char SetActive);
Nvoid                       GUI_MEMDEV__FadeDevice         (GUI_MEMDEV_Handle hMemWin, GUI_MEMDEV_Handle hMemBk, GUI_MEMDEV_Handle hMemDst, U8 Intens);
Xvoid                       GUI_MEMDEV__FadeDevice         (GUI_MEMDEV_Handle hMemWin, GUI_MEMDEV_Handle hMemBk, GUI_MEMDEV_Handle hMemDst, unsigned char Intens);
Nvoid                       GUI_MEMDEV__FadeDeviceEx       (GUI_MEMDEV_Handle hMemWin, GUI_MEMDEV_Handle hMemBk, GUI_MEMDEV_Handle hMemDst, U8 Intens, int xPosWin, int yPosWin);
Xvoid                       GUI_MEMDEV__FadeDeviceEx       (GUI_MEMDEV_Handle hMemWin, GUI_MEMDEV_Handle hMemBk, GUI_MEMDEV_Handle hMemDst, unsigned char Intens, int xPosWin, int yPosWin);
Nvoid                       GUI_MEMDEV__Rotate             (GUI_MEMDEV_Handle hSrc, GUI_MEMDEV_Handle hDst, int dx, int dy, int a, int Mag, U32 Mask);
Xvoid                       GUI_MEMDEV__Rotate             (GUI_MEMDEV_Handle hSrc, GUI_MEMDEV_Handle hDst, int dx, int dy, int a, int Mag, unsigned long Mask);
Nvoid                       GUI_MEMDEV__RotateHR           (GUI_MEMDEV_Handle hSrc, GUI_MEMDEV_Handle hDst, I32 dx, I32 dy, int a, int Mag, U32 Mask);
Xvoid                       GUI_MEMDEV__RotateHR           (GUI_MEMDEV_Handle hSrc, GUI_MEMDEV_Handle hDst, signed long dx, signed long dy, int a, int Mag, unsigned long Mask);
NU8                         GUI_MEMDEV__SetCanvas          (GUI_MEMDEV_Handle hMem);
Xunsigned char                         GUI_MEMDEV__SetCanvas          (GUI_MEMDEV_Handle hMem);
N
Nvoid  GUI_SelectLCD(void);
N
N/* Blurring, dithering and blending */
NGUI_MEMDEV_Handle GUI_MEMDEV_CreateBlurredDevice32  (GUI_MEMDEV_Handle hMem, U8 Depth);
XGUI_MEMDEV_Handle GUI_MEMDEV_CreateBlurredDevice32  (GUI_MEMDEV_Handle hMem, unsigned char Depth);
NGUI_MEMDEV_Handle GUI_MEMDEV_CreateBlurredDevice32HQ(GUI_MEMDEV_Handle hMem, U8 Depth);
XGUI_MEMDEV_Handle GUI_MEMDEV_CreateBlurredDevice32HQ(GUI_MEMDEV_Handle hMem, unsigned char Depth);
NGUI_MEMDEV_Handle GUI_MEMDEV_CreateBlurredDevice32LQ(GUI_MEMDEV_Handle hMem, U8 Depth);
XGUI_MEMDEV_Handle GUI_MEMDEV_CreateBlurredDevice32LQ(GUI_MEMDEV_Handle hMem, unsigned char Depth);
Nvoid              GUI_MEMDEV_SetBlurHQ              (void);
Nvoid              GUI_MEMDEV_SetBlurLQ              (void);
Nint               GUI_MEMDEV_BlendColor32           (GUI_MEMDEV_Handle hMem, U32 BlendColor, U8 BlendIntens);
Xint               GUI_MEMDEV_BlendColor32           (GUI_MEMDEV_Handle hMem, unsigned long BlendColor, unsigned char BlendIntens);
Nint               GUI_MEMDEV_Dither32               (GUI_MEMDEV_Handle hMem, const LCD_API_COLOR_CONV * pColorConvAPI);
N
N/* Optional custom drawing of 16bpp memory devices */
Nvoid GUI_MEMDEV_SetDrawMemdev16bppFunc(GUI_DRAWMEMDEV_16BPP_FUNC * pfDrawMemdev16bppFunc);
N
N/* Custom rotate function */
Nvoid GUI_MEMDEV_SetRotateFuncLR(int (* pfRotate)(GUI_MEMDEV_Handle hSrc, GUI_MEMDEV_Handle hDst, int dx, int dy, int a, int Mag));
Nvoid GUI_MEMDEV_SetRotateFuncHR(int (* pfRotate)(GUI_MEMDEV_Handle hSrc, GUI_MEMDEV_Handle hDst, int dx, int dy, int a, int Mag));
N
Nvoid GUI_MEMDEV_SetBlendFunc(int (* pfBlend)(GUI_MEMDEV_Handle hMem, GUI_COLOR Color, U8 BlendIntens));
Xvoid GUI_MEMDEV_SetBlendFunc(int (* pfBlend)(GUI_MEMDEV_Handle hMem, GUI_COLOR Color, unsigned char BlendIntens));
N
N
N/*********************************************************************
N*
N*       GUI_DTA_GET_DATA_FUNC
N* 
N*  Description
N*    GetData function used for streamed bitmaps (DTA), for more details see
N*    \uref{GUI_GET_DATA_FUNC_II}.
N*/
Ntypedef GUI_GET_DATA_FUNC_II     GUI_DTA_GET_DATA_FUNC;
N
N
N/*********************************************************************
N*
N*       Memory bitmaps
N*/
Ntypedef struct {
N  U8     Cmd;
X  unsigned char     Cmd;
N  int    xSize;
N  int    ySize;
N  void * pExtra;
N} GUI_MBITMAP_PARAM;
N
Ntypedef struct {
N  GUI_BITMAP Bitmap;
N  void *     pExtra;
N  void *     pData;
N} GUI_MBITMAP;
N
Ntypedef int               GUI_MBITMAP_DRAW_IMAGE   (const void * p, int Size, GUI_MBITMAP_PARAM * pPara);
Ntypedef int               GUI_MBITMAP_DRAW_IMAGE_EX(GUI_GET_DATA_FUNC * pfGetData, void * p, GUI_MBITMAP_PARAM * pPara);
Ntypedef GUI_MEMDEV_Handle GUI_MBITMAP_CREATE_MEMDEV(int xSize, int ySize, void * pExtra);
Ntypedef void              GUI_MBITMAP_DELETE_MEMDEV(GUI_MEMDEV_Handle hMem, void * pExtra);
N
Ntypedef struct {
N  GUI_MBITMAP_CREATE_MEMDEV * pfCreateMemdev;
N  GUI_MBITMAP_DELETE_MEMDEV * pfDeleteMemdev;
N  void *                      pExtra;
N} GUI_MBITMAP_CONFIG;
N
N//
N// GUI_MBITMAP prototypes
N//
NGUI_MBITMAP * GUI_MBITMAP_Create        (GUI_MBITMAP_DRAW_IMAGE * pFuncDraw, const void * pData, int SizeOfData);
NGUI_MBITMAP * GUI_MBITMAP_CreateEx      (GUI_MBITMAP_DRAW_IMAGE_EX * pFuncDrawEx, GUI_GET_DATA_FUNC * pfGetData, void * p);
NGUI_MBITMAP * GUI_MBITMAP_CreateUser    (GUI_MBITMAP_DRAW_IMAGE * pFuncDraw, const void * pData, int SizeOfData, int xSize, int ySize, GUI_MBITMAP_CONFIG * pConfig);
NGUI_MBITMAP * GUI_MBITMAP_CreateUserEx  (GUI_MBITMAP_DRAW_IMAGE_EX * pFuncDrawEx, GUI_GET_DATA_FUNC * pfGetData, void * p, int xSize, int ySize, GUI_MBITMAP_CONFIG * pConfig);
Nvoid          GUI_MBITMAP_Delete        (GUI_MBITMAP * pMBitmap);
Nvoid          GUI_MBITMAP_SetColorFormat(const GUI_DEVICE_API * pDeviceAPI, const LCD_API_COLOR_CONV * pColorConvAPI);
N
N//
N// Drawing functions
N//
N#define GUI_MBITMAP_DRAW_FUNC(TYPE)     int GUI_MBITMAP_Draw##TYPE(const void * p, int Size, GUI_MBITMAP_PARAM * pPara);
N#define GUI_MBITMAP_DRAW_FUNC_EX(TYPE)  int GUI_MBITMAP_Draw##TYPE##Ex(GUI_##TYPE##_GET_DATA_FUNC * pfGetData, void * p, GUI_MBITMAP_PARAM * pPara);
N
N//
N// Create prototypes
N//
NGUI_MBITMAP_DRAW_FUNC(Bitmap)
Xint GUI_MBITMAP_DrawBitmap(const void * p, int Size, GUI_MBITMAP_PARAM * pPara);
NGUI_MBITMAP_DRAW_FUNC(BMP)
Xint GUI_MBITMAP_DrawBMP(const void * p, int Size, GUI_MBITMAP_PARAM * pPara);
NGUI_MBITMAP_DRAW_FUNC(DTA)
Xint GUI_MBITMAP_DrawDTA(const void * p, int Size, GUI_MBITMAP_PARAM * pPara);
NGUI_MBITMAP_DRAW_FUNC(GIF)
Xint GUI_MBITMAP_DrawGIF(const void * p, int Size, GUI_MBITMAP_PARAM * pPara);
NGUI_MBITMAP_DRAW_FUNC(JPEG)
Xint GUI_MBITMAP_DrawJPEG(const void * p, int Size, GUI_MBITMAP_PARAM * pPara);
NGUI_MBITMAP_DRAW_FUNC(PNG)
Xint GUI_MBITMAP_DrawPNG(const void * p, int Size, GUI_MBITMAP_PARAM * pPara);
NGUI_MBITMAP_DRAW_FUNC(SVG)
Xint GUI_MBITMAP_DrawSVG(const void * p, int Size, GUI_MBITMAP_PARAM * pPara);
NGUI_MBITMAP_DRAW_FUNC_EX(BMP)
Xint GUI_MBITMAP_DrawBMPEx(GUI_BMP_GET_DATA_FUNC * pfGetData, void * p, GUI_MBITMAP_PARAM * pPara);
NGUI_MBITMAP_DRAW_FUNC_EX(DTA)
Xint GUI_MBITMAP_DrawDTAEx(GUI_DTA_GET_DATA_FUNC * pfGetData, void * p, GUI_MBITMAP_PARAM * pPara);
NGUI_MBITMAP_DRAW_FUNC_EX(GIF)
Xint GUI_MBITMAP_DrawGIFEx(GUI_GIF_GET_DATA_FUNC * pfGetData, void * p, GUI_MBITMAP_PARAM * pPara);
NGUI_MBITMAP_DRAW_FUNC_EX(JPEG)
Xint GUI_MBITMAP_DrawJPEGEx(GUI_JPEG_GET_DATA_FUNC * pfGetData, void * p, GUI_MBITMAP_PARAM * pPara);
NGUI_MBITMAP_DRAW_FUNC_EX(PNG)
Xint GUI_MBITMAP_DrawPNGEx(GUI_PNG_GET_DATA_FUNC * pfGetData, void * p, GUI_MBITMAP_PARAM * pPara);
NGUI_MBITMAP_DRAW_FUNC_EX(SVG)
Xint GUI_MBITMAP_DrawSVGEx(GUI_SVG_GET_DATA_FUNC * pfGetData, void * p, GUI_MBITMAP_PARAM * pPara);
N
N//
N//  Allow drawing types are:
N//   "Bitmap"
N//   "BMP"  - "BMPEx"
N//   "DTA"  - "DTAEx"
N//   "GIF"  - "GIFEx"
N//   "JPEG" - "JPEGEx"
N//   "PNG"  - "PNGEx"
N//   "SVG"  - "SVGEx"
N//
N#define GUI_MBITMAP_DRAW(TYPE)   GUI_MBITMAP_Draw##TYPE
N
N#define GUI_MBITMAP_BITMAP  GUI_MBITMAP_DRAW(Bitmap)
N#define GUI_MBITMAP_BMP     GUI_MBITMAP_DRAW(BMP)
N#define GUI_MBITMAP_DTA     GUI_MBITMAP_DRAW(DTA)
N#define GUI_MBITMAP_GIF     GUI_MBITMAP_DRAW(GIF)
N#define GUI_MBITMAP_JPEG    GUI_MBITMAP_DRAW(JPEG)
N#define GUI_MBITMAP_PNG     GUI_MBITMAP_DRAW(PNG)
N#define GUI_MBITMAP_SVG     GUI_MBITMAP_DRAW(SVG)
N#define GUI_MBITMAP_BMP_EX  GUI_MBITMAP_DRAW(BMPEx)
N#define GUI_MBITMAP_DTA_EX  GUI_MBITMAP_DRAW(DTAEx)
N#define GUI_MBITMAP_GIF_EX  GUI_MBITMAP_DRAW(GIFEx)
N#define GUI_MBITMAP_JPEG_EX GUI_MBITMAP_DRAW(JPEGEx)
N#define GUI_MBITMAP_PNG_EX  GUI_MBITMAP_DRAW(PNGEx)
N#define GUI_MBITMAP_SVG_EX  GUI_MBITMAP_DRAW(SVGEx)
N
N//
N// Conversion macro from GUI_MBITMAP to GUI_BITMAP
N//
N#define GUI_MBITMAP_2BITMAP(x)      ((GUI_BITMAP *)x)
N
N//
N// Commands used by drawing functions
N//
N#define GUI_MBITMAP_CMD_XSIZE  (0)
N#define GUI_MBITMAP_CMD_YSIZE  (1)
N#define GUI_MBITMAP_CMD_DRAW   (2)
N
N/*********************************************************************
N*
N*       Emscripten related 
N*/
N
N/*********************************************************************
N*
N*       GUI_EMSCRIPTEN_DATE
N*/
Ntypedef struct {
N  int Year;    // Year (e.g. 2024)
N  int Month;   // Month (January == 1, February == 2, ...)
N  int Day;     // Day of the month (1st day of month == 1)
N  int Weekday; // Day of the week (Monday == 1, Tuesday == 2, ...)
N  int Hour;    // Hour (valid range: [0-23]).
N  int Minute;  // Minute (valid range: [0-59]).
N  int Second;  // Second (valid range: [0-59]).
N} GUI_EMSCRIPTEN_DATE;
N
Nvoid GUI_EMSCRIPTEN_GetNow        (GUI_EMSCRIPTEN_DATE * pDate);
Nvoid GUI_EMSCRIPTEN_GetNowTimezone(GUI_EMSCRIPTEN_DATE * pDate, const char * sTimezone);
N
N/*********************************************************************
N*
N*       Alpha blending
N*/
N/*********************************************************************
N*
N*       GUI_ALPHA_STATE
N*
N*   Description
N*     Used for storing the alpha value with GUI_SetUserAlpha().
N*/
Ntypedef struct {
N  U32 UserAlpha;   // Alpha value to be used.
X  unsigned long UserAlpha;   
N} GUI_ALPHA_STATE;
N
N#define GUI_MAKE_ALPHA(Alpha, Color)  ((U32)(((U32)Alpha << 24) | (Color & 0xFFFFFF)))
N
Nunsigned     GUI_EnableAlpha          (unsigned OnOff);
NU32          GUI_RestoreUserAlpha     (GUI_ALPHA_STATE * pAlphaState);
Xunsigned long          GUI_RestoreUserAlpha     (GUI_ALPHA_STATE * pAlphaState);
NU8           GUI_GetAlphaEx           (int LayerIndex);
Xunsigned char           GUI_GetAlphaEx           (int LayerIndex);
NU8           GUI_GetAlpha             (void);
Xunsigned char           GUI_GetAlpha             (void);
Nunsigned     GUI_SetAlpha             (U8 Alpha);
Xunsigned     GUI_SetAlpha             (unsigned char Alpha);
NU32          GUI_SetUserAlpha         (GUI_ALPHA_STATE * pAlphaState, U32 UserAlpha);
Xunsigned long          GUI_SetUserAlpha         (GUI_ALPHA_STATE * pAlphaState, unsigned long UserAlpha);
Nvoid      (* GUI_SetFuncAlphaBlending (void (* pfAlphaBlending)(LCD_COLOR *, LCD_COLOR *, LCD_COLOR *, U32)))
Xvoid      (* GUI_SetFuncAlphaBlending (void (* pfAlphaBlending)(LCD_COLOR *, LCD_COLOR *, LCD_COLOR *, unsigned long)))
N                                                               (LCD_COLOR *, LCD_COLOR *, LCD_COLOR *, U32);
X                                                               (LCD_COLOR *, LCD_COLOR *, LCD_COLOR *, unsigned long);
NLCD_COLOR (* GUI_SetFuncMixColors     (LCD_COLOR (* pFunc)(LCD_COLOR Color, LCD_COLOR BkColor, U8 Intens)))
XLCD_COLOR (* GUI_SetFuncMixColors     (LCD_COLOR (* pFunc)(LCD_COLOR Color, LCD_COLOR BkColor, unsigned char Intens)))
N                                                          (LCD_COLOR Color, LCD_COLOR BkColor, U8 Intens);
X                                                          (LCD_COLOR Color, LCD_COLOR BkColor, unsigned char Intens);
Nvoid      (* GUI_SetFuncMixColorsBulk (void (* pFunc)(U32 * pFG, U32 * pBG, U32 * pDst, unsigned OffFG, unsigned OffBG, unsigned OffDest, unsigned xSize, unsigned ySize, U8 Intens)))
Xvoid      (* GUI_SetFuncMixColorsBulk (void (* pFunc)(unsigned long * pFG, unsigned long * pBG, unsigned long * pDst, unsigned OffFG, unsigned OffBG, unsigned OffDest, unsigned xSize, unsigned ySize, unsigned char Intens)))
N                                                     (U32 * pFG, U32 * pBG, U32 * pDst, unsigned OffFG, unsigned OffBG, unsigned OffDest, unsigned xSize, unsigned ySize, U8 Intens);
X                                                     (unsigned long * pFG, unsigned long * pBG, unsigned long * pDst, unsigned OffFG, unsigned OffBG, unsigned OffDest, unsigned xSize, unsigned ySize, unsigned char Intens);
Nunsigned     GUI_PreserveTrans        (unsigned OnOff);
Nvoid         GUI_AlphaEnableFillRectHW(int OnOff);
N
N
N/*********************************************************************
N*
N*       Multi layer support
N*/
Nunsigned GUI_SelectLayer(unsigned Index);
Nunsigned GUI_GetSelLayer(void);
N
Nint  GUI_SetLayerPosEx  (unsigned Index, int xPos, int yPos);
Nint  GUI_SetLayerSizeEx (unsigned Index, int xSize, int ySize);
Nint  GUI_SetLayerVisEx  (unsigned Index, int OnOff);
Nint  GUI_SetLayerAlphaEx(unsigned Index, int Alpha);
Nint  GUI_GetLayerPosEx  (unsigned Index, int * pxPos, int * pyPos);
N
Nvoid     GUI_AssignCursorLayer(unsigned Index, unsigned CursorLayer);
Nunsigned GUI_GetCursorLayer   (unsigned Index);
N
N/*********************************************************************
N*
N*       Multiple buffers and display origin
N*/
Nvoid GUI_SetOrg(int x, int y);
N
Nvoid GUI_MULTIBUF_Begin          (void);
Nvoid GUI_MULTIBUF_BeginEx        (int LayerIndex);
Nvoid GUI_MULTIBUF_End            (void);
Nvoid GUI_MULTIBUF_EndEx          (int LayerIndex);
Nvoid GUI_MULTIBUF_Config         (int NumBuffers);
Nvoid GUI_MULTIBUF_ConfigEx       (int LayerIndex, int NumBuffers);
Nvoid GUI_MULTIBUF_Confirm        (int Index);
Nvoid GUI_MULTIBUF_ConfirmEx      (int LayerIndex, int BufferIndex);
Nint  GUI_MULTIBUF_GetNumBuffers  (void);
Nint  GUI_MULTIBUF_GetNumBuffersEx(int LayerIndex);
Nvoid GUI_MULTIBUF_SetLayerMask   (U32 LayerMask);
Xvoid GUI_MULTIBUF_SetLayerMask   (unsigned long LayerMask);
Nvoid GUI_MULTIBUF_UseSingleBuffer(void);
N
N/*********************************************************************
N*
N*       emWinSPY
N*/
Nint  GUI_SPY_Process       (GUI_tSend pfSend, GUI_tRecv pfRecv, void * pConnectInfo);
Nvoid GUI_SPY_SetProcessFunc(int (* pProcess)(U8, void *));
Xvoid GUI_SPY_SetProcessFunc(int (* pProcess)(unsigned char, void *));
Nvoid GUI_SPY_SetMemHandler (GUI_tMalloc pMalloc, GUI_tFree pFree);
Nint  GUI_SPY_StartServer   (void);
Nint  GUI_SPY_StartServerEx (int (* pGUI_SPY_X_StartServer)(void));
Nint  GUI_SPY_X_StartServer (void);
N
N/*********************************************************************
N*
N*       Barcode types
N*
N*  Description
N*    Type of barcode to be drawn.
N*/
N#define GUI_BARCODE_ITF 0   // \b{Interleaved 2 of 5 (ITF)} which can display an even amount of digits.
N#define GUI_BARCODE_128 1   // \b{Code128} which can display all 128 ASCII characters.
N
Nint GUI_BARCODE_Draw    (int xPos, int yPos, int ModuleSize, int ySize, int Type, const char * sBarcode);
Nint GUI_BARCODE_GetXSize(int Type, int ModuleSize, const char * sBarcode);
N
N/*********************************************************************
N*
N*       ECC levels for QR codes
N*
N*  Description
N*    Error correction level to be used by the Reed-Solomon error correction
N*    for a QR code.
N*/
N#define GUI_QR_ECLEVEL_L 0   // About 7% or less errors can be corrected.
N#define GUI_QR_ECLEVEL_M 1   // About 15% or less errors can be corrected.
N#define GUI_QR_ECLEVEL_Q 2   // About 25% or less errors can be corrected.
N#define GUI_QR_ECLEVEL_H 3   // About 30% or less errors can be corrected.
N
N/*********************************************************************
N*
N*       GUI_QR_INFO
N*
N*   Description
N*     Information about a QR code.
N*/
Ntypedef struct {
N  int Version;   // Version according to QR code documentation.
N  int Width;     // Number of 'Modules'.
N  int Size;      // Size of bitmap in pixels.
N} GUI_QR_INFO;
N
NGUI_HMEM GUI_QR_Create      (const char * pText, int PixelSize, int EccLevel, int Version);
Xsigned long GUI_QR_Create      (const char * pText, int PixelSize, int EccLevel, int Version);
NGUI_HMEM GUI_QR_CreateFramed(const char * pText, int PixelSize, int EccLevel, int Version);
Xsigned long GUI_QR_CreateFramed(const char * pText, int PixelSize, int EccLevel, int Version);
Nvoid     GUI_QR_Draw        (GUI_HMEM hQR, int xPos, int yPos);
Xvoid     GUI_QR_Draw        (signed long hQR, int xPos, int yPos);
Nvoid     GUI_QR_GetInfo     (GUI_HMEM hQR, GUI_QR_INFO * pInfo);
Xvoid     GUI_QR_GetInfo     (signed long hQR, GUI_QR_INFO * pInfo);
Nvoid     GUI_QR_Delete      (GUI_HMEM hQR);
Xvoid     GUI_QR_Delete      (signed long hQR);
N
N/*********************************************************************
N*
N*       Basics for animations
N*/
N#define ANIM_LINEAR     GUI_ANIM__Linear
N#define ANIM_ACCEL      GUI_ANIM__Accel
N#define ANIM_DECEL      GUI_ANIM__Decel
N#define ANIM_ACCELDECEL GUI_ANIM__AccelDecel
N
N/*********************************************************************
N*
N*       Animation states
N*
N*   Description
N*     Describes the current state of an animation. Sent with the
N*     \a{State} member of the GUI_ANIM_INFO structure to an animation callback.
N*/
N#define GUI_ANIM_START   0   // First execution.
N#define GUI_ANIM_RUNNING 1   // Passed to all items which are not the first and not the last.
N#define GUI_ANIM_END     2   // Last execution.
N
N/*********************************************************************
N*
N*       GUI_ANIM_RANGE
N*/
N#ifndef   GUI_ANIM_RANGE
N  #define GUI_ANIM_RANGE 32767
N#endif
N
Ntypedef GUI_HMEM GUI_ANIM_HANDLE;
Xtypedef signed long GUI_ANIM_HANDLE;
N
Ntypedef I32 (* GUI_ANIM_GETPOS_FUNC)(GUI_TIMER_TIME ts, GUI_TIMER_TIME te, GUI_TIMER_TIME tNow);
Xtypedef signed long (* GUI_ANIM_GETPOS_FUNC)(int ts, int te, int tNow);
N
N/*********************************************************************
N*
N*       GUI_ANIM_INFO
N*
N*   Description
N*     Contains information about the current state of an animation.
N*/
Ntypedef struct {
N  int Pos;                // Position value calculated by the selected position calculation routine.
N  int State;              // State of the animation. See \ref{Animation states} for valid values.
N  GUI_ANIM_HANDLE hAnim;  // Handle of the animation object.
N  GUI_TIMER_TIME Period;  // Period of the animation object.
X  int Period;  
N  unsigned Index;         // Item index
N} GUI_ANIM_INFO;
N
Ntypedef void GUI_ANIMATION_FUNC(GUI_ANIM_INFO * pInfo, void * pVoid);
N
NI32 GUI_ANIM__Linear    (GUI_TIMER_TIME ts, GUI_TIMER_TIME te, GUI_TIMER_TIME tNow);
Xsigned long GUI_ANIM__Linear    (int ts, int te, int tNow);
NI32 GUI_ANIM__Decel     (GUI_TIMER_TIME ts, GUI_TIMER_TIME te, GUI_TIMER_TIME tNow);
Xsigned long GUI_ANIM__Decel     (int ts, int te, int tNow);
NI32 GUI_ANIM__Accel     (GUI_TIMER_TIME ts, GUI_TIMER_TIME te, GUI_TIMER_TIME tNow);
Xsigned long GUI_ANIM__Accel     (int ts, int te, int tNow);
NI32 GUI_ANIM__AccelDecel(GUI_TIMER_TIME ts, GUI_TIMER_TIME te, GUI_TIMER_TIME tNow);
Xsigned long GUI_ANIM__AccelDecel(int ts, int te, int tNow);
N
Nint             GUI_ANIM_AddItem          (GUI_ANIM_HANDLE hAnim, GUI_TIMER_TIME ts, GUI_TIMER_TIME te, GUI_ANIM_GETPOS_FUNC pfGetPos, void * pVoid, GUI_ANIMATION_FUNC * pfAnim);
Xint             GUI_ANIM_AddItem          (GUI_ANIM_HANDLE hAnim, int ts, int te, GUI_ANIM_GETPOS_FUNC pfGetPos, void * pVoid, GUI_ANIMATION_FUNC * pfAnim);
Nint             GUI_ANIM_AddItemById      (I16 Id,                GUI_TIMER_TIME ts, GUI_TIMER_TIME te, GUI_ANIM_GETPOS_FUNC pfGetPos, void * pVoid, GUI_ANIMATION_FUNC * pfAnim);
Xint             GUI_ANIM_AddItemById      (signed short Id,                int ts, int te, GUI_ANIM_GETPOS_FUNC pfGetPos, void * pVoid, GUI_ANIMATION_FUNC * pfAnim);
NGUI_ANIM_HANDLE GUI_ANIM_Create           (GUI_TIMER_TIME Period, unsigned MinTimePerFrame, void * pVoid, void (* pfSlice)(int, void *));
XGUI_ANIM_HANDLE GUI_ANIM_Create           (int Period, unsigned MinTimePerFrame, void * pVoid, void (* pfSlice)(int, void *));
NGUI_ANIM_HANDLE GUI_ANIM_CreateWithId     (GUI_TIMER_TIME Period, unsigned MinTimePerSlice, void * pVoid, void (* pfSlice)(int, void *), I16 Id);
XGUI_ANIM_HANDLE GUI_ANIM_CreateWithId     (int Period, unsigned MinTimePerSlice, void * pVoid, void (* pfSlice)(int, void *), signed short Id);
Nvoid            GUI_ANIM_Delete           (GUI_ANIM_HANDLE hAnim);
Nint             GUI_ANIM_DeleteById       (I16 Id);
Xint             GUI_ANIM_DeleteById       (signed short Id);
Nvoid            GUI_ANIM_DeleteAll        (void);
NGUI_ANIM_HANDLE GUI_ANIM_Get              (I16 Id);
XGUI_ANIM_HANDLE GUI_ANIM_Get              (signed short Id);
Nvoid          * GUI_ANIM_GetData          (GUI_ANIM_HANDLE hAnim);
Nvoid          * GUI_ANIM_GetItemDataLocked(GUI_ANIM_HANDLE hAnim, unsigned Index);
NGUI_ANIM_HANDLE GUI_ANIM_GetFirst         (void);
Nvoid          * GUI_ANIM_GetItemData      (GUI_ANIM_HANDLE hAnim, unsigned Index);
NGUI_ANIM_HANDLE GUI_ANIM_GetNext          (GUI_ANIM_HANDLE hAnim);
Nint             GUI_ANIM_GetNumItems      (GUI_ANIM_HANDLE hAnim);
NGUI_TIMER_TIME  GUI_ANIM_GetPeriod        (GUI_ANIM_HANDLE hAnim);
Xint  GUI_ANIM_GetPeriod        (GUI_ANIM_HANDLE hAnim);
Nint             GUI_ANIM_Exec             (GUI_ANIM_HANDLE hAnim);
Nint             GUI_ANIM_IsRunning        (GUI_ANIM_HANDLE hAnim);
Nvoid            GUI_ANIM_SetData          (GUI_ANIM_HANDLE hAnim, void * pVoid);
Nint             GUI_ANIM_SetItemData      (GUI_ANIM_HANDLE hAnim, unsigned Index, const void * pVoid, U32 NumBytes);
Xint             GUI_ANIM_SetItemData      (GUI_ANIM_HANDLE hAnim, unsigned Index, const void * pVoid, unsigned long NumBytes);
Nvoid            GUI_ANIM_Start            (GUI_ANIM_HANDLE hAnim);
Nint             GUI_ANIM_StartExId        (I16 Id,                int NumLoops, void (* pfOnDelete)(void * pVoid));
Xint             GUI_ANIM_StartExId        (signed short Id,                int NumLoops, void (* pfOnDelete)(void * pVoid));
Nvoid            GUI_ANIM_StartEx          (GUI_ANIM_HANDLE hAnim, int NumLoops, void (* pfOnDelete)(void * pVoid));
Nvoid            GUI_ANIM_Stop             (GUI_ANIM_HANDLE hAnim);
Nint             GUI_ANIM_StopById         (I16 Id);
Xint             GUI_ANIM_StopById         (signed short Id);
N
N/*********************************************************************
N*
N*       YUV device
N*/
Nint   GUI_YUV_Create        (void);
Nint   GUI_YUV_CreateEx      (int LayerIndex, unsigned Period);
Nint   GUI_YUV_Delete        (void);
Nint   GUI_YUV_DeleteEx      (int LayerIndex);
NU32 * GUI_YUV_GetpData      (U32 * pSize);
Xunsigned long * GUI_YUV_GetpData      (unsigned long * pSize);
NU32 * GUI_YUV_GetpDataEx    (int LayerIndex, U32 * pSize);
Xunsigned long * GUI_YUV_GetpDataEx    (int LayerIndex, unsigned long * pSize);
Nvoid  GUI_YUV_InvalidateArea(int x, int y, int xSize, int ySize);
Nint   GUI_YUV_SetPeriodEx   (int LayerIndex, unsigned Period);
Nint   GUI_YUV_SetPeriod     (unsigned Period);
N
N/*********************************************************************
N*
N*       Display orientation
N*/
N/*********************************************************************
N*
N*       GUI_ORIENTATION_API
N*/
Ntypedef struct {
N  void           (* pfDrawBitmap   )(GUI_DEVICE * pDevice, int x0, int y0, int xsize, int ysize, int BitsPerPixel, int BytesPerLine, const U8 * pData, int Diff, const LCD_PIXELINDEX * pTrans);
X  void           (* pfDrawBitmap   )(GUI_DEVICE * pDevice, int x0, int y0, int xsize, int ysize, int BitsPerPixel, int BytesPerLine, const unsigned char * pData, int Diff, const unsigned long * pTrans);
N  void           (* pfDrawHLine    )(GUI_DEVICE * pDevice, int x0, int y0,  int x1);
N  void           (* pfDrawVLine    )(GUI_DEVICE * pDevice, int x , int y0,  int y1);
N  void           (* pfFillRect     )(GUI_DEVICE * pDevice, int x0, int y0, int x1, int y1);
N  LCD_PIXELINDEX (* pfGetPixelIndex)(GUI_DEVICE * pDevice, int x, int y);
X  unsigned long (* pfGetPixelIndex)(GUI_DEVICE * pDevice, int x, int y);
N  void           (* pfSetPixelIndex)(GUI_DEVICE * pDevice, int x, int y, LCD_PIXELINDEX ColorIndex);
X  void           (* pfSetPixelIndex)(GUI_DEVICE * pDevice, int x, int y, unsigned long ColorIndex);
N  void           (* pfXorPixel     )(GUI_DEVICE * pDevice, int x, int y);
N  int            BytesPerPixel;
N} GUI_ORIENTATION_API;
N
Nextern const GUI_ORIENTATION_API GUI_OrientationAPI_C0;
Nextern const GUI_ORIENTATION_API GUI_OrientationAPI_C8;
Nextern const GUI_ORIENTATION_API GUI_OrientationAPI_C16;
Nextern const GUI_ORIENTATION_API GUI_OrientationAPI_C32;
N
N#define GUI_ORIENTATION_C0  &GUI_OrientationAPI_C0
N#define GUI_ORIENTATION_C8  &GUI_OrientationAPI_C8
N#define GUI_ORIENTATION_C16 &GUI_OrientationAPI_C16
N#define GUI_ORIENTATION_C32 &GUI_OrientationAPI_C32
N
Nint  GUI_SetOrientation        (int Orientation);
Nint  GUI_SetOrientationEx      (int Orientation, int LayerIndex);
Nint  GUI_SetOrientationExCached(int Orientation, int LayerIndex, const GUI_ORIENTATION_API * pAPI);
Nvoid GUI_OrientationEnableTouch(void);
N
N/*********************************************************************
N*
N*       Measure device: GUI_MEASDEV
N*/
Ntypedef GUI_HMEM GUI_MEASDEV_Handle;
Xtypedef signed long GUI_MEASDEV_Handle;
N
NGUI_MEASDEV_Handle GUI_MEASDEV_Create (void);
Nvoid               GUI_MEASDEV_Delete (GUI_MEASDEV_Handle hMemDev);
Nvoid               GUI_MEASDEV_Select (GUI_MEASDEV_Handle hMem);
Nvoid               GUI_MEASDEV_GetRect(GUI_MEASDEV_Handle hMem, GUI_RECT * pRect);
Nvoid               GUI_MEASDEV_ClearRect(GUI_MEASDEV_Handle hMem);
N
N/*********************************************************************
N*
N*       Polygon helpers
N*/
Nvoid GUI_RotatePolygon (GUI_POINT * pDest, const GUI_POINT * pSrc, int NumPoints, float Angle);
Nvoid GUI_MagnifyPolygon(GUI_POINT * pDest, const GUI_POINT * pSrc, int NumPoints, int Mag);
Nvoid GUI_EnlargePolygon(GUI_POINT * pDest, const GUI_POINT * pSrc, int NumPoints, int Len);
N
N/*********************************************************************
N*
N*       Streamed bitmaps
N*/
N#define GUI_BITMAPSTREAM_GET_BUFFER     1
N#define GUI_BITMAPSTREAM_RELEASE_BUFFER 2
N#define GUI_BITMAPSTREAM_MODIFY_PALETTE 3
N
N#define DECLARE_CREATE_FROM_STREAM(ID) int GUI_CreateBitmapFromStream##ID(GUI_BITMAP * pBMP, GUI_LOGPALETTE * pPAL, const void * p);
N
NDECLARE_CREATE_FROM_STREAM(IDX)
Xint GUI_CreateBitmapFromStreamIDX(GUI_BITMAP * pBMP, GUI_LOGPALETTE * pPAL, const void * p);
NDECLARE_CREATE_FROM_STREAM(RLE1)
Xint GUI_CreateBitmapFromStreamRLE1(GUI_BITMAP * pBMP, GUI_LOGPALETTE * pPAL, const void * p);
NDECLARE_CREATE_FROM_STREAM(RLE4)
Xint GUI_CreateBitmapFromStreamRLE4(GUI_BITMAP * pBMP, GUI_LOGPALETTE * pPAL, const void * p);
NDECLARE_CREATE_FROM_STREAM(RLE8)
Xint GUI_CreateBitmapFromStreamRLE8(GUI_BITMAP * pBMP, GUI_LOGPALETTE * pPAL, const void * p);
NDECLARE_CREATE_FROM_STREAM(565)
Xint GUI_CreateBitmapFromStream565(GUI_BITMAP * pBMP, GUI_LOGPALETTE * pPAL, const void * p);
NDECLARE_CREATE_FROM_STREAM(M565)
Xint GUI_CreateBitmapFromStreamM565(GUI_BITMAP * pBMP, GUI_LOGPALETTE * pPAL, const void * p);
NDECLARE_CREATE_FROM_STREAM(555)
Xint GUI_CreateBitmapFromStream555(GUI_BITMAP * pBMP, GUI_LOGPALETTE * pPAL, const void * p);
NDECLARE_CREATE_FROM_STREAM(M555)
Xint GUI_CreateBitmapFromStreamM555(GUI_BITMAP * pBMP, GUI_LOGPALETTE * pPAL, const void * p);
NDECLARE_CREATE_FROM_STREAM(A565)
Xint GUI_CreateBitmapFromStreamA565(GUI_BITMAP * pBMP, GUI_LOGPALETTE * pPAL, const void * p);
NDECLARE_CREATE_FROM_STREAM(AM565)
Xint GUI_CreateBitmapFromStreamAM565(GUI_BITMAP * pBMP, GUI_LOGPALETTE * pPAL, const void * p);
NDECLARE_CREATE_FROM_STREAM(A555)
Xint GUI_CreateBitmapFromStreamA555(GUI_BITMAP * pBMP, GUI_LOGPALETTE * pPAL, const void * p);
NDECLARE_CREATE_FROM_STREAM(AM555)
Xint GUI_CreateBitmapFromStreamAM555(GUI_BITMAP * pBMP, GUI_LOGPALETTE * pPAL, const void * p);
NDECLARE_CREATE_FROM_STREAM(RLE16)
Xint GUI_CreateBitmapFromStreamRLE16(GUI_BITMAP * pBMP, GUI_LOGPALETTE * pPAL, const void * p);
NDECLARE_CREATE_FROM_STREAM(RLEM16)
Xint GUI_CreateBitmapFromStreamRLEM16(GUI_BITMAP * pBMP, GUI_LOGPALETTE * pPAL, const void * p);
NDECLARE_CREATE_FROM_STREAM(24)
Xint GUI_CreateBitmapFromStream24(GUI_BITMAP * pBMP, GUI_LOGPALETTE * pPAL, const void * p);
NDECLARE_CREATE_FROM_STREAM(A8)
Xint GUI_CreateBitmapFromStreamA8(GUI_BITMAP * pBMP, GUI_LOGPALETTE * pPAL, const void * p);
NDECLARE_CREATE_FROM_STREAM(Alpha)
Xint GUI_CreateBitmapFromStreamAlpha(GUI_BITMAP * pBMP, GUI_LOGPALETTE * pPAL, const void * p);
NDECLARE_CREATE_FROM_STREAM(M8888I)
Xint GUI_CreateBitmapFromStreamM8888I(GUI_BITMAP * pBMP, GUI_LOGPALETTE * pPAL, const void * p);
NDECLARE_CREATE_FROM_STREAM(RLEAlpha)
Xint GUI_CreateBitmapFromStreamRLEAlpha(GUI_BITMAP * pBMP, GUI_LOGPALETTE * pPAL, const void * p);
NDECLARE_CREATE_FROM_STREAM(RLE32)
Xint GUI_CreateBitmapFromStreamRLE32(GUI_BITMAP * pBMP, GUI_LOGPALETTE * pPAL, const void * p);
NDECLARE_CREATE_FROM_STREAM(444_12)
Xint GUI_CreateBitmapFromStream444_12(GUI_BITMAP * pBMP, GUI_LOGPALETTE * pPAL, const void * p);
NDECLARE_CREATE_FROM_STREAM(M444_12)
Xint GUI_CreateBitmapFromStreamM444_12(GUI_BITMAP * pBMP, GUI_LOGPALETTE * pPAL, const void * p);
NDECLARE_CREATE_FROM_STREAM(444_12_1)
Xint GUI_CreateBitmapFromStream444_12_1(GUI_BITMAP * pBMP, GUI_LOGPALETTE * pPAL, const void * p);
NDECLARE_CREATE_FROM_STREAM(M444_12_1)
Xint GUI_CreateBitmapFromStreamM444_12_1(GUI_BITMAP * pBMP, GUI_LOGPALETTE * pPAL, const void * p);
NDECLARE_CREATE_FROM_STREAM(444_16)
Xint GUI_CreateBitmapFromStream444_16(GUI_BITMAP * pBMP, GUI_LOGPALETTE * pPAL, const void * p);
NDECLARE_CREATE_FROM_STREAM(M444_16)
Xint GUI_CreateBitmapFromStreamM444_16(GUI_BITMAP * pBMP, GUI_LOGPALETTE * pPAL, const void * p);
N
Nint  GUI_CreateBitmapFromStream       (GUI_BITMAP * pBMP, GUI_LOGPALETTE * pPAL, const void * p);
Nvoid GUI_DrawStreamedBitmap           (const void * p, int x, int y);
Nvoid GUI_DrawStreamedBitmapAuto       (const void * p, int x, int y);
Nint  GUI_DrawStreamedBitmapEx         (GUI_DTA_GET_DATA_FUNC * pfGetData, const void * p, int x, int y);
Nint  GUI_DrawStreamedBitmapExAuto     (GUI_DTA_GET_DATA_FUNC * pfGetData, const void * p, int x, int y);
Nint  GUI_DrawStreamedBitmapIDXEx      (GUI_DTA_GET_DATA_FUNC * pfGetData, const void * p, int x, int y);
Nint  GUI_DrawStreamedBitmap444_12Ex   (GUI_DTA_GET_DATA_FUNC * pfGetData, const void * p, int x, int y);
Nint  GUI_DrawStreamedBitmapM444_12Ex  (GUI_DTA_GET_DATA_FUNC * pfGetData, const void * p, int x, int y);
Nint  GUI_DrawStreamedBitmap444_12_1Ex (GUI_DTA_GET_DATA_FUNC * pfGetData, const void * p, int x, int y);
Nint  GUI_DrawStreamedBitmapM444_12_1Ex(GUI_DTA_GET_DATA_FUNC * pfGetData, const void * p, int x, int y);
Nint  GUI_DrawStreamedBitmap444_16Ex   (GUI_DTA_GET_DATA_FUNC * pfGetData, const void * p, int x, int y);
Nint  GUI_DrawStreamedBitmapM444_16Ex  (GUI_DTA_GET_DATA_FUNC * pfGetData, const void * p, int x, int y);
Nint  GUI_DrawStreamedBitmap555Ex      (GUI_DTA_GET_DATA_FUNC * pfGetData, const void * p, int x, int y);
Nint  GUI_DrawStreamedBitmapM555Ex     (GUI_DTA_GET_DATA_FUNC * pfGetData, const void * p, int x, int y);
Nint  GUI_DrawStreamedBitmap565Ex      (GUI_DTA_GET_DATA_FUNC * pfGetData, const void * p, int x, int y);
Nint  GUI_DrawStreamedBitmapM565Ex     (GUI_DTA_GET_DATA_FUNC * pfGetData, const void * p, int x, int y);
Nint  GUI_DrawStreamedBitmapA555Ex     (GUI_DTA_GET_DATA_FUNC * pfGetData, const void * p, int x, int y);
Nint  GUI_DrawStreamedBitmapAM555Ex    (GUI_DTA_GET_DATA_FUNC * pfGetData, const void * p, int x, int y);
Nint  GUI_DrawStreamedBitmapA565Ex     (GUI_DTA_GET_DATA_FUNC * pfGetData, const void * p, int x, int y);
Nint  GUI_DrawStreamedBitmapAM565Ex    (GUI_DTA_GET_DATA_FUNC * pfGetData, const void * p, int x, int y);
Nint  GUI_DrawStreamedBitmap24Ex       (GUI_DTA_GET_DATA_FUNC * pfGetData, const void * p, int x, int y);
Nint  GUI_DrawStreamedBitmap8888Ex     (GUI_DTA_GET_DATA_FUNC * pfGetData, const void * p, int x, int y);
Nint  GUI_DrawStreamedBitmapM8888IEx   (GUI_DTA_GET_DATA_FUNC * pfGetData, const void * p, int x, int y);
Nint  GUI_DrawStreamedBitmapRLE1Ex     (GUI_DTA_GET_DATA_FUNC * pfGetData, const void * p, int x, int y);
Nint  GUI_DrawStreamedBitmapRLE4Ex     (GUI_DTA_GET_DATA_FUNC * pfGetData, const void * p, int x, int y);
Nint  GUI_DrawStreamedBitmapRLE8Ex     (GUI_DTA_GET_DATA_FUNC * pfGetData, const void * p, int x, int y);
Nint  GUI_DrawStreamedBitmapRLE16Ex    (GUI_DTA_GET_DATA_FUNC * pfGetData, const void * p, int x, int y);
Nint  GUI_DrawStreamedBitmapRLEM16Ex   (GUI_DTA_GET_DATA_FUNC * pfGetData, const void * p, int x, int y);
Nint  GUI_DrawStreamedBitmapRLE32Ex    (GUI_DTA_GET_DATA_FUNC * pfGetData, const void * p, int x, int y);
Nvoid GUI_GetStreamedBitmapInfo        (const void * p, GUI_BITMAPSTREAM_INFO * pInfo);
Nint  GUI_GetStreamedBitmapInfoEx      (GUI_DTA_GET_DATA_FUNC * pfGetData, const void * p, GUI_BITMAPSTREAM_INFO * pInfo);
Nvoid GUI_SetStreamedBitmapHook        (GUI_BITMAPSTREAM_CALLBACK pfStreamedBitmapHook);
N
Nvoid LCD__RLE1_SetFunc (GUI_DTA_GET_DATA_FUNC * pfGetData, void * pVoid, U32 Off, const LCD_LOGPALETTE * pLogPal);
Xvoid LCD__RLE1_SetFunc (GUI_DTA_GET_DATA_FUNC * pfGetData, void * pVoid, unsigned long Off, const LCD_LOGPALETTE * pLogPal);
Nvoid LCD__RLE4_SetFunc (GUI_DTA_GET_DATA_FUNC * pfGetData, void * pVoid, U32 Off, const LCD_LOGPALETTE * pLogPal);
Xvoid LCD__RLE4_SetFunc (GUI_DTA_GET_DATA_FUNC * pfGetData, void * pVoid, unsigned long Off, const LCD_LOGPALETTE * pLogPal);
Nvoid LCD__RLE8_SetFunc (GUI_DTA_GET_DATA_FUNC * pfGetData, void * pVoid, U32 Off, const LCD_LOGPALETTE * pLogPal);
Xvoid LCD__RLE8_SetFunc (GUI_DTA_GET_DATA_FUNC * pfGetData, void * pVoid, unsigned long Off, const LCD_LOGPALETTE * pLogPal);
Nvoid LCD__RLE16_SetFunc(GUI_DTA_GET_DATA_FUNC * pfGetData, void * pVoid, U32 Off);
Xvoid LCD__RLE16_SetFunc(GUI_DTA_GET_DATA_FUNC * pfGetData, void * pVoid, unsigned long Off);
Nvoid LCD__RLE32_SetFunc(GUI_DTA_GET_DATA_FUNC * pfGetData, void * pVoid, U32 Off);
Xvoid LCD__RLE32_SetFunc(GUI_DTA_GET_DATA_FUNC * pfGetData, void * pVoid, unsigned long Off);
N
N/*********************************************************************
N*
N*       BMP-export
N*/
Nvoid GUI_BMP_Serialize     (GUI_CALLBACK_VOID_U8_P * pfSerialize, void * p);
Nvoid GUI_BMP_SerializeEx   (GUI_CALLBACK_VOID_U8_P * pfSerialize, int x0, int y0, int xSize, int ySize, void * p);
Nvoid GUI_BMP_SerializeExBpp(GUI_CALLBACK_VOID_U8_P * pfSerialize, int x0, int y0, int xSize, int ySize, void * p, int BitsPerPixel);
N
Nvoid GUI_BMP__WriteBitmapHeader(GUI_CALLBACK_VOID_U8_P * pfSerialize, int xSize, int ySize, void * p, int BitsPerPixel, int BytesPerLine, int BytesPerPixel, int NumColors, int Padding);
N
N/*********************************************************************
N*
N*       Time / execution related routines
N*/
Nvoid           GUI_Delay       (int Period);
NGUI_TIMER_TIME GUI_GetTime     (void);
Xint GUI_GetTime     (void);
Nint            GUI_GetTimeSlice(void);
Nint            GUI_Exec        (void);        /* Execute all jobs ... Return 0 if nothing was done. */
Nint            GUI_Exec1       (void);        /* Execute one job  ... Return 0 if nothing was done. */
Nvoid           GUI_SetTimeSlice(int TimeSlice);
N
N/*********************************************************************
N*
N*       MessageBox
N*/
Nint     GUI_MessageBox   (const char * sMessage, const char * sCaption, int Flags);
N#define GUI_MESSAGEBOX_CF_MOVEABLE (1 << 0)
N#define GUI_MESSAGEBOX_CF_MODAL    (1 << 1)
N
N#define GUI_MB_OK                20
N#define GUI_MB_WARNING           21
N
N/*********************************************************************
N*
N*       Anti Aliasing
N*/
N#define GUI_AA_TRANS   0  // Foreground color mixed up with current content of framebuffer
N#define GUI_AA_NOTRANS 1  // Foreground color mixed up with current background color
N
Nvoid GUI_AA_DisableHiRes      (void);
Nvoid GUI_AA_EnableHiRes       (void);
Nint  GUI_AA_IsHiResEnabled    (void);
Nvoid GUI_AA_DrawPie           (int x0, int y0, int r, I32 a0, I32 a1);
Xvoid GUI_AA_DrawPie           (int x0, int y0, int r, signed long a0, signed long a1);
Nint  GUI_AA_GetFactor         (void);
Nvoid GUI_AA_SetFactor         (int Factor);
Nvoid GUI_AA_DrawArc           (int x0, int y0, int rx, int ry, int a0, int a1);
Nvoid GUI_AA_DrawArcHR         (int x0, int y0, int rx, int ry, I32 a0, I32 a1);
Xvoid GUI_AA_DrawArcHR         (int x0, int y0, int rx, int ry, signed long a0, signed long a1);
Nvoid GUI_AA_DrawArcEx         (int mx, int my, int r, I32 a0, I32 a1, int c0, int c1);
Xvoid GUI_AA_DrawArcEx         (int mx, int my, int r, signed long a0, signed long a1, int c0, int c1);
Nvoid GUI_AA_DrawCircle        (int x0, int y0, int r);  // Currently not implemented, only for Dave2D
Nvoid GUI_AA_DrawLine          (int x0, int y0, int x1, int y1);
Nvoid GUI_AA_DrawPolyOutline   (const GUI_POINT * pSrc, int NumPoints, int Thickness, int x, int y);
Nvoid GUI_AA_DrawRoundedFrame  (int x0, int y0, int x1, int y1, int r);
Nvoid GUI_AA_DrawRoundedFrameEx(const GUI_RECT * pRect, int r);
Nvoid GUI_AA_DrawRoundedRect   (int x0, int y0, int x1, int y1, int r);
Nvoid GUI_AA_DrawRoundedRectEx (const GUI_RECT * pRect, int r);
Nvoid GUI_AA_FillCircle        (int x0, int y0, int r);
Nvoid GUI_AA_FillEllipse       (int x0, int y0, int rx, int ry);
Nvoid GUI_AA_FillEllipseXL     (int x0, int y0, int rx, int ry);
Nvoid GUI_AA_FillPolygon       (const GUI_POINT * pPoints, int NumPoints, int x0, int y0);
Nint  GUI_AA_FillRoundedRect   (int x0, int y0, int x1, int y1, int r);
Nint  GUI_AA_FillRoundedRectEx (const GUI_RECT * pRect, int r);
Nvoid GUI_AA_SetBufferSize     (int BufferSize);
Nint  GUI_AA_SetDrawMode       (int Mode);
Nvoid GUI_AA_SetpfDrawCharAA4  (int (* pfDrawChar)(int LayerIndex, int x, int y, U8 const * p, int xSize, int ySize, int BytesPerLine));
Xvoid GUI_AA_SetpfDrawCharAA4  (int (* pfDrawChar)(int LayerIndex, int x, int y, unsigned char const * p, int xSize, int ySize, int BytesPerLine));
Nvoid GUI_AA_SetGammaAA4       (U8 * pGamma);
Xvoid GUI_AA_SetGammaAA4       (unsigned char * pGamma);
Nvoid GUI_AA_GetGammaAA4       (U8 * pGamma);
Xvoid GUI_AA_GetGammaAA4       (unsigned char * pGamma);
Nvoid GUI_AA_EnableGammaAA4    (int OnOff);
N
Nvoid GUI_AA_SetFuncDrawArc        (int (* pfDrawArc)    (int x0, int y0, int rx, int ry, I32 a0, I32 a1));
Xvoid GUI_AA_SetFuncDrawArc        (int (* pfDrawArc)    (int x0, int y0, int rx, int ry, signed long a0, signed long a1));
Nvoid GUI_AA_SetFuncDrawCircle     (int (* pfDrawCircle) (int x0, int y0, int r));
Nvoid GUI_AA_SetFuncDrawLine       (int (* pfDrawLine)   (int x0, int y0, int x1, int y1));
Nvoid GUI_AA_SetFuncDrawPolyOutline(int (* pfDrawPolyOutline)(const GUI_POINT * pSrc, int NumPoints, int Thickness, int x, int y));
Nvoid GUI_AA_SetFuncFillCircle     (int (* pfFillCircle) (int x0, int y0, int r));
Nvoid GUI_AA_SetFuncFillPolygon    (int (* pfFillPolygon)(const GUI_POINT * pPoints, int NumPoints, int x0, int y0));
N
N//
N// Compatibility macros
N//
N#define GUI_AA_PreserveTrans(OnOff)                                           GUI_PreserveTrans(OnOff)
N#define GUI_AA_DrawPolyOutlineEx(pSrc, NumPoints, Thickness, x, y, pBuffer)   GUI_AA_DrawPolyOutline(pSrc, NumPoints, Thickness, x, y)
N
N
N/*********************************************************************
N*
N*       Keyboard
N*/
N/* Message layer */
Nvoid GUI_StoreKeyMsg(int Key, int Pressed);
Nvoid GUI_SendKeyMsg (int Key, int Pressed);
Nint  GUI_PollKeyMsg (void);
Nvoid GUI_GetKeyState(GUI_KEY_STATE * pState);
N
Nvoid GUI_KEY__SetHook(void (* pfHook)(const GUI_KEY_STATE *));
N
N/* Application layer */
Nint  GUI_GetKey(void);
Nint  GUI_WaitKey(void);
Nvoid GUI_StoreKey(int c);
Nvoid GUI_ClearKeyBuffer(void);
Nint  GUI_GetKeyPressed(void);
N
N/*********************************************************************
N*
N*       Task synchronization
N*/
Nvoid GUI_WaitEvent            (void);
Nvoid GUI_SignalEvent          (void);
Nvoid GUI_SetSignalEventFunc   (GUI_SIGNAL_EVENT_FUNC     pfSignalEvent);
Nvoid GUI_SetWaitEventFunc     (GUI_WAIT_EVENT_FUNC       pfWaitEvent);
Nvoid GUI_SetWaitEventTimedFunc(GUI_WAIT_EVENT_TIMED_FUNC pfWaitEventTimed);
N
N/*********************************************************************
N*
N*       PID  (Pointer input device ... mouse/touch)
N*/
N#define GUI_PID_RegisterHook GUI_PID_RegisterPreHook
Nvoid GUI_PID_StoreState      (const GUI_PID_STATE * pState);
Nint  GUI_PID_GetState        (      GUI_PID_STATE * pState);
Nvoid GUI_PID_GetCurrentState (      GUI_PID_STATE * pState);
Nint  GUI_PID_IsEmpty         (void);
Nint  GUI_PID_IsPressed       (void);
Nvoid GUI_PID_RegisterPreHook (GUI_REGISTER_HOOK * pRegisterHook);
Nvoid GUI_PID_SetHook         (void (* pfHook)(      GUI_PID_STATE *));  // Public
Nvoid GUI_PID__SetHook        (void (* pfHook)(const GUI_PID_STATE *));  // Private
Nvoid GUI_PID__OrientationHook(GUI_PID_STATE * pState);                  // Private
Nvoid GUI_PID_RegisterReadHook(GUI_REGISTER_HOOK * pRegisterReadHook);
NU8   GUI_PID__BlockInput     (int OnOff);                               // Private
Xunsigned char   GUI_PID__BlockInput     (int OnOff);                               
NU8   GUI_PID__IsInputBlocked (void);                                    // Private
Xunsigned char   GUI_PID__IsInputBlocked (void);                                    
N
N/*********************************************************************
N*
N*       Mouse, generic
N*/
Nint  GUI_MOUSE_GetState  (      GUI_PID_STATE * pState);
Nvoid GUI_MOUSE_StoreState(const GUI_PID_STATE * pState);
N
N/*********************************************************************
N*
N*       TOUCH screen, generic
N*/
Nint  GUI_TOUCH_GetLayer     (void);
Nint  GUI_TOUCH_GetState     (GUI_PID_STATE * pState);
Nvoid GUI_TOUCH_GetUnstable  (int * px, int * py);  /* for diagnostics only */
Nvoid GUI_TOUCH_SetLayer     (int Layer);
Nvoid GUI_TOUCH_StoreState   (int x, int y);
Nvoid GUI_TOUCH_StoreStateEx (const GUI_PID_STATE * pState);
Nvoid GUI_TOUCH_StoreUnstable(int x, int y);
N
N/*********************************************************************
N*
N*       Mouse, PS2 driver
N*/
Nvoid GUI_MOUSE_DRIVER_PS2_Init(void);               /* optional */
Nvoid GUI_MOUSE_DRIVER_PS2_OnRx(unsigned char Data);
N
N/*********************************************************************
N*
N*       TOUCH screen, analog driver
N*/
Nint  GUI_TOUCH_CalcCoefficients (int NumPoints, int * pxRef, int * pyRef, int * pxSample, int * pySample, int xSize, int ySize);
Nint  GUI_TOUCH_Calibrate        (int Coord, int Log0, int Log1, int Phys0, int Phys1);
Nint  GUI_TOUCH_CalibratePoint   (int * px, int * py);
Nvoid GUI_TOUCH_EnableCalibration(int OnOff);
Nvoid GUI_TOUCH_Exec             (void);
Nint  GUI_TOUCH_GetxPhys         (void);    /* for diagnostics only */
Nint  GUI_TOUCH_GetyPhys         (void);    /* for diagnostics only */
Nvoid GUI_TOUCH_SetCalibration   (int (* pFunc)(int *, int *)); /* Not to be documented */
Nvoid GUI_TOUCH_SetOrientation   (unsigned Orientation);
Nint  GUI_TOUCH_TransformPoint   (int * px, int * py);          /* Not to be documented */
N
N/*********************************************************************
N*
N*       TOUCH: imports
N*
N* Please note: The following functions are required by the module.
N* They need to be part of your application software (or rather, part
N* of the hardware-layer of your software).
N*/
Nvoid GUI_TOUCH_X_ActivateX(void);
Nvoid GUI_TOUCH_X_ActivateY(void);
Nvoid GUI_TOUCH_X_Disable  (void);
Nint  GUI_TOUCH_X_MeasureX (void);
Nint  GUI_TOUCH_X_MeasureY (void);
N
N/*********************************************************************
N*
N*       LCD: Palette conversion table
N*
N* Please note: These functions were originally in GUI_Private.h but
N* were also used in several LCDConf.c. Since GUI_Private.h is not
N* shipped any more with object code we moved these functions here.
N*/
NLCD_PIXELINDEX * LCD_GetpPalConvTable        (const LCD_LOGPALETTE * pLogPal);
Xunsigned long * LCD_GetpPalConvTable        (const LCD_LOGPALETTE * pLogPal);
NLCD_PIXELINDEX * LCD_GetpPalConvTableUncached(const LCD_LOGPALETTE * pLogPal);
Xunsigned long * LCD_GetpPalConvTableUncached(const LCD_LOGPALETTE * pLogPal);
NLCD_PIXELINDEX * LCD_GetpPalConvTableBM      (const LCD_LOGPALETTE * pLogPal, const GUI_BITMAP * pBitmap, int LayerIndex);
Xunsigned long * LCD_GetpPalConvTableBM      (const LCD_LOGPALETTE * pLogPal, const GUI_BITMAP * pBitmap, int LayerIndex);
N// Setting a function for converting a color palette to an array of index values
Nvoid GUI_SetFuncGetpPalConvTable(LCD_PIXELINDEX * (* pFunc)(const LCD_LOGPALETTE * pLogPal, const GUI_BITMAP * pBitmap, int LayerIndex));
Xvoid GUI_SetFuncGetpPalConvTable(unsigned long * (* pFunc)(const LCD_LOGPALETTE * pLogPal, const GUI_BITMAP * pBitmap, int LayerIndex));
N
N/*********************************************************************
N*
N*       GUI_X_
N*
N* Externals, to be defined by application
N*
N* The externals defined below should be defined by the
N* application. They are per default contained in the module
N* GUI_X.c.
N* Note that a lot if not all of these are not required in most target
N* systems.
N* For this module, samples are available for configurations
N* with or without operating system.
N*/
N//
N// Configuration
N//
Nvoid GUI_X_Config(void);
Nvoid GUI_X_Init  (void);
N
N//
N// Timing routines
N//
NGUI_TIMER_TIME GUI_X_GetTime(void);
Xint GUI_X_GetTime(void);
Nvoid           GUI_X_Delay  (int Period);
N
N//
N// Multitask routines - required only if multitasking is used (#define GUI_OS 1)
N//
Nvoid GUI_X_Unlock   (void);
Nvoid GUI_X_Lock     (void);
NU32  GUI_X_GetTaskId(void);
Xunsigned long  GUI_X_GetTaskId(void);
Nvoid GUI_X_InitOS   (void);
N
N//
N// Event driving (optional with multitasking)
N//
Nvoid GUI_X_ExecIdle      (void);
Nvoid GUI_X_WaitEvent     (void);
Nvoid GUI_X_WaitEventTimed(int Period);
Nvoid GUI_X_SignalEvent   (void);
N
N//
N// Recording (logs/warnings and errors) - required only for higher levels
N//
Nvoid GUI_X_Log     (const char * s);
Nvoid GUI_X_Warn    (const char * s);
Nvoid GUI_X_ErrorOut(const char * s);
N
N/*********************************************************************
N*
N*       Constants for fonts and bitmaps
N*/
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethodsRLE1;
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethodsRLE1Ex;
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethodsRLE4;
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethodsRLE4Ex;
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethodsRLE8;
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethodsRLE8_Stream;
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethodsRLE8Ex;
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethodsRLE16;
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethodsRLE16_Stream;
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethodsRLE16Ex;
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethodsRLEM16;
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethodsRLEM16_Stream;
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethodsRLEM16Ex;
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethodsRLE32;
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethodsRLE32Ex;
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethodsRLEAlpha;
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethodsA8;
N
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethods444_12;
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethodsM444_12;
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethods444_12_1;
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethodsM444_12_1;
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethods444_16;
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethodsM444_16;
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethods555;
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethodsM555;
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethods565;
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethodsM565;
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethods24;
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethods888;
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethodsM888;
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethods8888;
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethodsM8888I;
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethodsA565;
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethodsAM565;
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethodsA555;
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethodsAM555;
N
N#define GUI_COMPRESS_RLE1 0  // Used to initialize GUI_BITMAP struct if saved with the Bitmap Converter as RLE bitmap
N#define GUI_COMPRESS_RLE4 0  // Used to initialize GUI_BITMAP struct if saved with the Bitmap Converter as RLE bitmap
N#define GUI_COMPRESS_RLE8 0  // Used to initialize GUI_BITMAP struct if saved with the Bitmap Converter as RLE bitmap
N
N#define GUI_DRAW_RLE1          &GUI_BitmapMethodsRLE1           /* Method table ! */
N#define GUI_DRAW_RLE4          &GUI_BitmapMethodsRLE4           /* Method table ! */
N#define GUI_DRAW_RLE8          &GUI_BitmapMethodsRLE8           /* Method table ! */
N#define GUI_DRAW_RLE8_Stream   &GUI_BitmapMethodsRLE8_Stream    /* Method table ! */
N#define GUI_DRAW_RLE16         &GUI_BitmapMethodsRLE16          /* Method table ! */
N#define GUI_DRAW_RLE16_Stream  &GUI_BitmapMethodsRLE16_Stream   /* Method table ! */
N#define GUI_DRAW_RLEM16        &GUI_BitmapMethodsRLEM16         /* Method table ! */
N#define GUI_DRAW_RLEM16_Stream &GUI_BitmapMethodsRLEM16_Stream  /* Method table ! */
N#define GUI_DRAW_RLE32         &GUI_BitmapMethodsRLE32          /* Method table ! */
N#define GUI_DRAW_RLEALPHA      &GUI_BitmapMethodsRLEAlpha       /* Method table ! */
N#define GUI_DRAW_A8            &GUI_BitmapMethodsA8             /* Method table ! */
N 
N#define GUI_DRAW_BMP444_12     &GUI_BitmapMethods444_12         /* Method table ! */
N#define GUI_DRAW_BMPM444_12    &GUI_BitmapMethodsM444_12        /* Method table ! */
N#define GUI_DRAW_BMP444_12_1   &GUI_BitmapMethods444_12_1       /* Method table ! */
N#define GUI_DRAW_BMPM444_12_1  &GUI_BitmapMethodsM444_12_1      /* Method table ! */
N#define GUI_DRAW_BMP444_16     &GUI_BitmapMethods444_16         /* Method table ! */
N#define GUI_DRAW_BMPM444_16    &GUI_BitmapMethodsM444_16        /* Method table ! */
N#define GUI_DRAW_BMP555        &GUI_BitmapMethods555            /* Method table ! */
N#define GUI_DRAW_BMPM555       &GUI_BitmapMethodsM555           /* Method table ! */
N#define GUI_DRAW_BMP565        &GUI_BitmapMethods565            /* Method table ! */
N#define GUI_DRAW_BMPM565       &GUI_BitmapMethodsM565           /* Method table ! */
N#define GUI_DRAW_BMP24         &GUI_BitmapMethods24             /* Method table ! */
N#define GUI_DRAW_BMP888        &GUI_BitmapMethods888            /* Method table ! */
N#define GUI_DRAW_BMPM888       &GUI_BitmapMethodsM888           /* Method table ! */
N#define GUI_DRAW_BMP8888       &GUI_BitmapMethods8888           /* Method table ! */
N#define GUI_DRAW_BMPM8888I     &GUI_BitmapMethodsM8888I         /* Method table ! */
N#define GUI_DRAW_BMPA555       &GUI_BitmapMethodsA555           /* Method table ! */
N#define GUI_DRAW_BMPAM555      &GUI_BitmapMethodsAM555          /* Method table ! */
N#define GUI_DRAW_BMPA565       &GUI_BitmapMethodsA565           /* Method table ! */
N#define GUI_DRAW_BMPAM565      &GUI_BitmapMethodsAM565          /* Method table ! */
N
Nextern const tGUI_SIF_APIList GUI_SIF_APIList_Prop;
Nextern const tGUI_SIF_APIList GUI_SIF_APIList_Prop_Ext;
Nextern const tGUI_SIF_APIList GUI_SIF_APIList_Prop_Frm;
Nextern const tGUI_SIF_APIList GUI_SIF_APIList_Prop_AA2;
Nextern const tGUI_SIF_APIList GUI_SIF_APIList_Prop_AA4;
Nextern const tGUI_SIF_APIList GUI_SIF_APIList_Prop_AA2_EXT;
Nextern const tGUI_SIF_APIList GUI_SIF_APIList_Prop_AA4_EXT;
N
Nextern const tGUI_XBF_APIList GUI_XBF_APIList_Prop;
Nextern const tGUI_XBF_APIList GUI_XBF_APIList_Prop_Ext;
Nextern const tGUI_XBF_APIList GUI_XBF_APIList_Prop_Frm;
Nextern const tGUI_XBF_APIList GUI_XBF_APIList_Prop_AA2_Ext;
Nextern const tGUI_XBF_APIList GUI_XBF_APIList_Prop_AA4_Ext;
N
N/*********************************************************************
N*
N*       GUI_KEY_...
N*
N* These ID values are basically meant to be used with widgets
N* Note that we have chosen the values to be close to existing
N* "standards", so do not change them unless forced to.
N*
N*/
N#define GUI_KEY_BACKSPACE         8         /* ASCII: BACKSPACE Crtl-H */
N#define GUI_KEY_TAB               9         /* ASCII: TAB       Crtl-I */
N#define GUI_KEY_BACKTAB           10
N#define GUI_KEY_ENTER             13        /* ASCII: ENTER     Crtl-M */
N#define GUI_KEY_ALT               15
N#define GUI_KEY_LEFT              16
N#define GUI_KEY_UP                17
N#define GUI_KEY_RIGHT             18
N#define GUI_KEY_DOWN              19
N#define GUI_KEY_PGUP              20
N#define GUI_KEY_PGDOWN            21
N#define GUI_KEY_HOME              23
N#define GUI_KEY_END               24
N#define GUI_KEY_SHIFT             25
N#define GUI_KEY_CONTROL           26
N#define GUI_KEY_ESCAPE            27        /* ASCII: ESCAPE    0x1b   */
N#define GUI_KEY_INSERT            29
N#define GUI_KEY_DELETE            30
N#define GUI_KEY_SPACE             32
N
N#define GUI_KEY_F1                40
N#define GUI_KEY_F2                41
N
N/*********************************************************************
N*
N*       Dialog item IDs
N*
N*  The IDs below are arbitrary values. They just have to be unique
N*  within the dialog.
N*
N*  If you use your own Ids, we recommend to use values above GUI_ID_USER.
N*/
N#define GUI_ID_OK                1
N#define GUI_ID_CANCEL            2
N#define GUI_ID_YES               3
N#define GUI_ID_NO                4
N#define GUI_ID_CLOSE             5
N#define GUI_ID_HELP              6
N#define GUI_ID_MAXIMIZE          7
N#define GUI_ID_MINIMIZE          8
N
N#define GUI_ID_VSCROLL    0xFE
N#define GUI_ID_HSCROLL    0xFF
N
N#define GUI_ID_VSCROLLER  0xFFE
N#define GUI_ID_HSCROLLER  0xFFF
N
N#define GUI_ID_EDIT0      0x100
N#define GUI_ID_EDIT1      0x101
N#define GUI_ID_EDIT2      0x102
N#define GUI_ID_EDIT3      0x103
N#define GUI_ID_EDIT4      0x104
N#define GUI_ID_EDIT5      0x105
N#define GUI_ID_EDIT6      0x106
N#define GUI_ID_EDIT7      0x107
N#define GUI_ID_EDIT8      0x108
N#define GUI_ID_EDIT9      0x109
N
N#define GUI_ID_LISTBOX0   0x110
N#define GUI_ID_LISTBOX1   0x111
N#define GUI_ID_LISTBOX2   0x112
N#define GUI_ID_LISTBOX3   0x113
N#define GUI_ID_LISTBOX4   0x114
N#define GUI_ID_LISTBOX5   0x115
N#define GUI_ID_LISTBOX6   0x116
N#define GUI_ID_LISTBOX7   0x117
N#define GUI_ID_LISTBOX8   0x118
N#define GUI_ID_LISTBOX9   0x119
N
N#define GUI_ID_CHECK0     0x120
N#define GUI_ID_CHECK1     0x121
N#define GUI_ID_CHECK2     0x122
N#define GUI_ID_CHECK3     0x123
N#define GUI_ID_CHECK4     0x124
N#define GUI_ID_CHECK5     0x125
N#define GUI_ID_CHECK6     0x126
N#define GUI_ID_CHECK7     0x127
N#define GUI_ID_CHECK8     0x128
N#define GUI_ID_CHECK9     0x129
N
N#define GUI_ID_SLIDER0    0x130
N#define GUI_ID_SLIDER1    0x131
N#define GUI_ID_SLIDER2    0x132
N#define GUI_ID_SLIDER3    0x133
N#define GUI_ID_SLIDER4    0x134
N#define GUI_ID_SLIDER5    0x135
N#define GUI_ID_SLIDER6    0x136
N#define GUI_ID_SLIDER7    0x137
N#define GUI_ID_SLIDER8    0x138
N#define GUI_ID_SLIDER9    0x139
N
N#define GUI_ID_SCROLLBAR0 0x140
N#define GUI_ID_SCROLLBAR1 0x141
N#define GUI_ID_SCROLLBAR2 0x142
N#define GUI_ID_SCROLLBAR3 0x143
N#define GUI_ID_SCROLLBAR4 0x144
N#define GUI_ID_SCROLLBAR5 0x145
N#define GUI_ID_SCROLLBAR6 0x146
N#define GUI_ID_SCROLLBAR7 0x147
N#define GUI_ID_SCROLLBAR8 0x148
N#define GUI_ID_SCROLLBAR9 0x149
N
N#define GUI_ID_RADIO0     0x150
N#define GUI_ID_RADIO1     0x151
N#define GUI_ID_RADIO2     0x152
N#define GUI_ID_RADIO3     0x153
N#define GUI_ID_RADIO4     0x154
N#define GUI_ID_RADIO5     0x155
N#define GUI_ID_RADIO6     0x156
N#define GUI_ID_RADIO7     0x157
N#define GUI_ID_RADIO8     0x158
N#define GUI_ID_RADIO9     0x159
N
N#define GUI_ID_TEXT0      0x160
N#define GUI_ID_TEXT1      0x161
N#define GUI_ID_TEXT2      0x162
N#define GUI_ID_TEXT3      0x163
N#define GUI_ID_TEXT4      0x164
N#define GUI_ID_TEXT5      0x165
N#define GUI_ID_TEXT6      0x166
N#define GUI_ID_TEXT7      0x167
N#define GUI_ID_TEXT8      0x168
N#define GUI_ID_TEXT9      0x169
N
N#define GUI_ID_BUTTON0    0x170
N#define GUI_ID_BUTTON1    0x171
N#define GUI_ID_BUTTON2    0x172
N#define GUI_ID_BUTTON3    0x173
N#define GUI_ID_BUTTON4    0x174
N#define GUI_ID_BUTTON5    0x175
N#define GUI_ID_BUTTON6    0x176
N#define GUI_ID_BUTTON7    0x177
N#define GUI_ID_BUTTON8    0x178
N#define GUI_ID_BUTTON9    0x179
N
N#define GUI_ID_DROPDOWN0  0x180
N#define GUI_ID_DROPDOWN1  0x181
N#define GUI_ID_DROPDOWN2  0x182
N#define GUI_ID_DROPDOWN3  0x183
N#define GUI_ID_DROPDOWN4  0x184
N#define GUI_ID_DROPDOWN5  0x185
N#define GUI_ID_DROPDOWN6  0x186
N#define GUI_ID_DROPDOWN7  0x187
N#define GUI_ID_DROPDOWN8  0x188
N#define GUI_ID_DROPDOWN9  0x189
N
N#define GUI_ID_MULTIEDIT0 0x190
N#define GUI_ID_MULTIEDIT1 0x191
N#define GUI_ID_MULTIEDIT2 0x192
N#define GUI_ID_MULTIEDIT3 0x193
N#define GUI_ID_MULTIEDIT4 0x194
N#define GUI_ID_MULTIEDIT5 0x195
N#define GUI_ID_MULTIEDIT6 0x196
N#define GUI_ID_MULTIEDIT7 0x197
N#define GUI_ID_MULTIEDIT8 0x198
N#define GUI_ID_MULTIEDIT9 0x199
N
N#define GUI_ID_LISTVIEW0  0x200
N#define GUI_ID_LISTVIEW1  0x201
N#define GUI_ID_LISTVIEW2  0x202
N#define GUI_ID_LISTVIEW3  0x203
N#define GUI_ID_LISTVIEW4  0x204
N#define GUI_ID_LISTVIEW5  0x205
N#define GUI_ID_LISTVIEW6  0x206
N#define GUI_ID_LISTVIEW7  0x207
N#define GUI_ID_LISTVIEW8  0x208
N#define GUI_ID_LISTVIEW9  0x209
N
N#define GUI_ID_PROGBAR0   0x210
N#define GUI_ID_PROGBAR1   0x211
N#define GUI_ID_PROGBAR2   0x212
N#define GUI_ID_PROGBAR3   0x213
N#define GUI_ID_PROGBAR4   0x214
N#define GUI_ID_PROGBAR5   0x215
N#define GUI_ID_PROGBAR6   0x216
N#define GUI_ID_PROGBAR7   0x217
N#define GUI_ID_PROGBAR8   0x218
N#define GUI_ID_PROGBAR9   0x219
N
N#define GUI_ID_GRAPH0     0x220
N#define GUI_ID_GRAPH1     0x221
N#define GUI_ID_GRAPH2     0x222
N#define GUI_ID_GRAPH3     0x223
N#define GUI_ID_GRAPH4     0x224
N#define GUI_ID_GRAPH5     0x225
N#define GUI_ID_GRAPH6     0x226
N#define GUI_ID_GRAPH7     0x227
N#define GUI_ID_GRAPH8     0x228
N#define GUI_ID_GRAPH9     0x229
N
N#define GUI_ID_MULTIPAGE0 0x230
N#define GUI_ID_MULTIPAGE1 0x231
N#define GUI_ID_MULTIPAGE2 0x232
N#define GUI_ID_MULTIPAGE3 0x233
N#define GUI_ID_MULTIPAGE4 0x234
N#define GUI_ID_MULTIPAGE5 0x235
N#define GUI_ID_MULTIPAGE6 0x236
N#define GUI_ID_MULTIPAGE7 0x237
N#define GUI_ID_MULTIPAGE8 0x238
N#define GUI_ID_MULTIPAGE9 0x239
N
N#define GUI_ID_TREEVIEW0  0x240
N#define GUI_ID_TREEVIEW1  0x241
N#define GUI_ID_TREEVIEW2  0x242
N#define GUI_ID_TREEVIEW3  0x243
N#define GUI_ID_TREEVIEW4  0x244
N#define GUI_ID_TREEVIEW5  0x245
N#define GUI_ID_TREEVIEW6  0x246
N#define GUI_ID_TREEVIEW7  0x247
N#define GUI_ID_TREEVIEW8  0x248
N#define GUI_ID_TREEVIEW9  0x249
N
N#define GUI_ID_ICONVIEW0  0x250
N#define GUI_ID_ICONVIEW1  0x251
N#define GUI_ID_ICONVIEW2  0x252
N#define GUI_ID_ICONVIEW3  0x253
N#define GUI_ID_ICONVIEW4  0x254
N#define GUI_ID_ICONVIEW5  0x255
N#define GUI_ID_ICONVIEW6  0x256
N#define GUI_ID_ICONVIEW7  0x257
N#define GUI_ID_ICONVIEW8  0x258
N#define GUI_ID_ICONVIEW9  0x259
N
N#define GUI_ID_LISTWHEEL0 0x260
N#define GUI_ID_LISTWHEEL1 0x261
N#define GUI_ID_LISTWHEEL2 0x262
N#define GUI_ID_LISTWHEEL3 0x263
N#define GUI_ID_LISTWHEEL4 0x264
N#define GUI_ID_LISTWHEEL5 0x265
N#define GUI_ID_LISTWHEEL6 0x266
N#define GUI_ID_LISTWHEEL7 0x267
N#define GUI_ID_LISTWHEEL8 0x268
N#define GUI_ID_LISTWHEEL9 0x269
N
N#define GUI_ID_IMAGE0     0x270
N#define GUI_ID_IMAGE1     0x271
N#define GUI_ID_IMAGE2     0x272
N#define GUI_ID_IMAGE3     0x273
N#define GUI_ID_IMAGE4     0x274
N#define GUI_ID_IMAGE5     0x275
N#define GUI_ID_IMAGE6     0x276
N#define GUI_ID_IMAGE7     0x277
N#define GUI_ID_IMAGE8     0x278
N#define GUI_ID_IMAGE9     0x279
N
N#define GUI_ID_SPINBOX0   0x280
N#define GUI_ID_SPINBOX1   0x281
N#define GUI_ID_SPINBOX2   0x282
N#define GUI_ID_SPINBOX3   0x283
N#define GUI_ID_SPINBOX4   0x284
N#define GUI_ID_SPINBOX5   0x285
N#define GUI_ID_SPINBOX6   0x286
N#define GUI_ID_SPINBOX7   0x287
N#define GUI_ID_SPINBOX8   0x288
N#define GUI_ID_SPINBOX9   0x289
N
N#define GUI_ID_CALENDAR0  0x290
N#define GUI_ID_CALENDAR1  0x291
N#define GUI_ID_CALENDAR2  0x292
N#define GUI_ID_CALENDAR3  0x293
N#define GUI_ID_CALENDAR4  0x294
N#define GUI_ID_CALENDAR5  0x295
N#define GUI_ID_CALENDAR6  0x296
N#define GUI_ID_CALENDAR7  0x297
N#define GUI_ID_CALENDAR8  0x298
N#define GUI_ID_CALENDAR9  0x299
N
N#define GUI_ID_KNOB0      0x300
N#define GUI_ID_KNOB1      0x301
N#define GUI_ID_KNOB2      0x302
N#define GUI_ID_KNOB3      0x303
N#define GUI_ID_KNOB4      0x304
N#define GUI_ID_KNOB5      0x305
N#define GUI_ID_KNOB6      0x306
N#define GUI_ID_KNOB7      0x307
N#define GUI_ID_KNOB8      0x308
N#define GUI_ID_KNOB9      0x309
N
N#define GUI_ID_ROTARY0    0x310
N#define GUI_ID_ROTARY1    0x311
N#define GUI_ID_ROTARY2    0x312
N#define GUI_ID_ROTARY3    0x313
N#define GUI_ID_ROTARY4    0x314
N#define GUI_ID_ROTARY5    0x315
N#define GUI_ID_ROTARY6    0x316
N#define GUI_ID_ROTARY7    0x317
N#define GUI_ID_ROTARY8    0x318
N#define GUI_ID_ROTARY9    0x319
N
N#define GUI_ID_SWIPELIST0 0x320
N#define GUI_ID_SWIPELIST1 0x321
N#define GUI_ID_SWIPELIST2 0x322
N#define GUI_ID_SWIPELIST3 0x323
N#define GUI_ID_SWIPELIST4 0x324
N#define GUI_ID_SWIPELIST5 0x325
N#define GUI_ID_SWIPELIST6 0x326
N#define GUI_ID_SWIPELIST7 0x327
N#define GUI_ID_SWIPELIST8 0x328
N#define GUI_ID_SWIPELIST9 0x329
N
N#define GUI_ID_SWITCH0    0x330
N#define GUI_ID_SWITCH1    0x331
N#define GUI_ID_SWITCH2    0x332
N#define GUI_ID_SWITCH3    0x333
N#define GUI_ID_SWITCH4    0x334
N#define GUI_ID_SWITCH5    0x335
N#define GUI_ID_SWITCH6    0x336
N#define GUI_ID_SWITCH7    0x337
N#define GUI_ID_SWITCH8    0x338
N#define GUI_ID_SWITCH9    0x339
N
N#define GUI_ID_GAUGE0     0x340
N#define GUI_ID_GAUGE1     0x341
N#define GUI_ID_GAUGE2     0x342
N#define GUI_ID_GAUGE3     0x343
N#define GUI_ID_GAUGE4     0x344
N#define GUI_ID_GAUGE5     0x345
N#define GUI_ID_GAUGE6     0x346
N#define GUI_ID_GAUGE7     0x347
N#define GUI_ID_GAUGE8     0x348
N#define GUI_ID_GAUGE9     0x349
N
N#define GUI_ID_QRCODE0    0x350
N#define GUI_ID_QRCODE1    0x351
N#define GUI_ID_QRCODE2    0x352
N#define GUI_ID_QRCODE3    0x353
N#define GUI_ID_QRCODE4    0x354
N#define GUI_ID_QRCODE5    0x355
N#define GUI_ID_QRCODE6    0x356
N#define GUI_ID_QRCODE7    0x357
N#define GUI_ID_QRCODE8    0x358
N#define GUI_ID_QRCODE9    0x359
N
N#define GUI_ID_KEYBOARD0  0x360
N#define GUI_ID_KEYBOARD1  0x361
N#define GUI_ID_KEYBOARD2  0x362
N#define GUI_ID_KEYBOARD3  0x363
N#define GUI_ID_KEYBOARD4  0x364
N#define GUI_ID_KEYBOARD5  0x365
N#define GUI_ID_KEYBOARD6  0x366
N#define GUI_ID_KEYBOARD7  0x367
N#define GUI_ID_KEYBOARD8  0x368
N#define GUI_ID_KEYBOARD9  0x369
N
N#define GUI_ID_ANIM0      0x370
N#define GUI_ID_ANIM1      0x371
N#define GUI_ID_ANIM2      0x372
N#define GUI_ID_ANIM3      0x373
N#define GUI_ID_ANIM4      0x374
N#define GUI_ID_ANIM5      0x375
N#define GUI_ID_ANIM6      0x376
N#define GUI_ID_ANIM7      0x377
N#define GUI_ID_ANIM8      0x378
N#define GUI_ID_ANIM9      0x379
N
N#define GUI_ID_SCROLLER0  0x380
N#define GUI_ID_SCROLLER1  0x381
N#define GUI_ID_SCROLLER2  0x382
N#define GUI_ID_SCROLLER3  0x383
N#define GUI_ID_SCROLLER4  0x384
N#define GUI_ID_SCROLLER5  0x385
N#define GUI_ID_SCROLLER6  0x386
N#define GUI_ID_SCROLLER7  0x387
N#define GUI_ID_SCROLLER8  0x388
N#define GUI_ID_SCROLLER9  0x389
N
N#define GUI_ID_WHEEL0     0x390
N#define GUI_ID_WHEEL1     0x391
N#define GUI_ID_WHEEL2     0x392
N#define GUI_ID_WHEEL3     0x393
N#define GUI_ID_WHEEL4     0x394
N#define GUI_ID_WHEEL5     0x395
N#define GUI_ID_WHEEL6     0x396
N#define GUI_ID_WHEEL7     0x397
N#define GUI_ID_WHEEL8     0x398
N#define GUI_ID_WHEEL9     0x399
N
N#define GUI_ID_MOVIE0     0x400
N#define GUI_ID_MOVIE1     0x401
N#define GUI_ID_MOVIE2     0x402
N#define GUI_ID_MOVIE3     0x403
N#define GUI_ID_MOVIE4     0x404
N#define GUI_ID_MOVIE5     0x405
N#define GUI_ID_MOVIE6     0x406
N#define GUI_ID_MOVIE7     0x407
N#define GUI_ID_MOVIE8     0x408
N#define GUI_ID_MOVIE9     0x409
N
N#define GUI_ID_TICKER0    0x410
N#define GUI_ID_TICKER1    0x411
N#define GUI_ID_TICKER2    0x412
N#define GUI_ID_TICKER3    0x413
N#define GUI_ID_TICKER4    0x414
N#define GUI_ID_TICKER5    0x415
N#define GUI_ID_TICKER6    0x416
N#define GUI_ID_TICKER7    0x417
N#define GUI_ID_TICKER8    0x418
N#define GUI_ID_TICKER9    0x419
N
N#define GUI_ID_USER       0x800
N
N/*********************************************************************
N*
N*       Mouse buttons
N*/
N#define GUI_LBUTTON (1 << 0) /* Left button */
N#define GUI_RBUTTON (1 << 1) /* Right button */
N#define GUI_MBUTTON (1 << 2) /* Middle button */
N#define GUI_DBUTTON (1 << 7) /* Double-click button */
N
N/*********************************************************************
N*
N*       Text style flags
N*
N*  Description
N*    Text style how a text will be displayed.
N*/
N#define GUI_TS_NORMAL           (0)        // Renders text normal (default).
N#define GUI_TS_UNDERLINE        (1 << 0)   // Renders text underlined.
N#define GUI_TS_STRIKETHRU       (1 << 1)   // Renders text in strike through type.
N#define GUI_TS_OVERLINE         (1 << 2)   // Renders text in overline type.
N
N/*********************************************************************
N*
N*       Line styles
N*
N*  Description
N*    Style how a line is drawn.
N*/
N#define GUI_LS_SOLID        (0)    // Lines are drawn solid (default).
N#define GUI_LS_DASH         (1)    // Lines are drawn dashed.
N#define GUI_LS_DOT          (2)    // Lines are drawn dotted.
N#define GUI_LS_DASHDOT      (3)    // Lines are drawn alternating with dashes and dots.
N#define GUI_LS_DASHDOTDOT   (4)    // Lines are drawn alternating with dashes and double dots.
N
N/*********************************************************************
N*
N*       Pen shapes
N*/
N#define GUI_PS_ROUND        (0)
N#define GUI_PS_FLAT         (1)
N#define GUI_PS_SQUARE       (2)
N
N/*********************************************************************
N*
N*       Standard colors
N*/
N#define GUI_INVALID_COLOR ((((U32)GUI_TRANS_BYTE) << 24) | 0x00ABCDEFul)  /* Invalid color (transparency + determined color) */
N
N#if (GUI_USE_ARGB)
X#if (1)
N  #define GUI_MAKE_COLOR(ABGR)  (((((U32)ABGR) & 0xFF000000ul) ^ 0xFF000000ul) | ((((U32)ABGR) & 0x00FF0000ul) >> 16) | (((U32)ABGR) & 0x0000FF00ul) | ((((U32)ABGR) & 0x000000FFul) << 16))
N  #define GUI_MAKE_TRANS(Alpha) (255 - (Alpha))
N#else
S  #define GUI_MAKE_COLOR(ABGR)  (ABGR)
S  #define GUI_MAKE_TRANS(Alpha) (Alpha)
N#endif
N
N#if (GUI_USE_ARGB)
X#if (1)
N  #define GUI_TRANS_BYTE 0x00
N#else
S  #define GUI_TRANS_BYTE 0xFF
N#endif
N
N#define GUI_BLUE          GUI_MAKE_COLOR(0x00FF0000)
N#define GUI_GREEN         GUI_MAKE_COLOR(0x0000FF00)
N#define GUI_RED           GUI_MAKE_COLOR(0x000000FF)
N#define GUI_CYAN          GUI_MAKE_COLOR(0x00FFFF00)
N#define GUI_MAGENTA       GUI_MAKE_COLOR(0x00FF00FF)
N#define GUI_YELLOW        GUI_MAKE_COLOR(0x0000FFFF)
N#define GUI_LIGHTBLUE     GUI_MAKE_COLOR(0x00FF8080)
N#define GUI_LIGHTGREEN    GUI_MAKE_COLOR(0x0080FF80)
N#define GUI_LIGHTRED      GUI_MAKE_COLOR(0x008080FF)
N#define GUI_LIGHTCYAN     GUI_MAKE_COLOR(0x00FFFF80)
N#define GUI_LIGHTMAGENTA  GUI_MAKE_COLOR(0x00FF80FF)
N#define GUI_LIGHTYELLOW   GUI_MAKE_COLOR(0x0080FFFF)
N#define GUI_DARKBLUE      GUI_MAKE_COLOR(0x00800000)
N#define GUI_DARKGREEN     GUI_MAKE_COLOR(0x00008000)
N#define GUI_DARKRED       GUI_MAKE_COLOR(0x00000080)
N#define GUI_DARKCYAN      GUI_MAKE_COLOR(0x00808000)
N#define GUI_DARKMAGENTA   GUI_MAKE_COLOR(0x00800080)
N#define GUI_DARKYELLOW    GUI_MAKE_COLOR(0x00008080)
N#define GUI_WHITE         GUI_MAKE_COLOR(0x00FFFFFF)
N#define GUI_LIGHTGRAY     GUI_MAKE_COLOR(0x00D3D3D3)
N#define GUI_GRAY          GUI_MAKE_COLOR(0x00808080)
N#define GUI_DARKGRAY      GUI_MAKE_COLOR(0x00404040)
N#define GUI_BLACK         GUI_MAKE_COLOR(0x00000000)
N#define GUI_BROWN         GUI_MAKE_COLOR(0x002A2AA5)
N#define GUI_ORANGE        GUI_MAKE_COLOR(0x0000A5FF)
N#define GUI_PINK          GUI_MAKE_COLOR(0x00C00FFC)
N
N#define GUI_TRANSPARENT   GUI_MAKE_COLOR(0xFF000000)
N
N#define GUI_GRAY_3F       GUI_MAKE_COLOR(0x003F3F3F)
N#define GUI_GRAY_50       GUI_MAKE_COLOR(0x00505050)
N#define GUI_GRAY_55       GUI_MAKE_COLOR(0x00555555)
N#define GUI_GRAY_60       GUI_MAKE_COLOR(0x00606060)
N#define GUI_GRAY_7C       GUI_MAKE_COLOR(0x007C7C7C)
N#define GUI_GRAY_9A       GUI_MAKE_COLOR(0x009A9A9A)
N#define GUI_GRAY_AA       GUI_MAKE_COLOR(0x00AAAAAA)
N#define GUI_GRAY_C0       GUI_MAKE_COLOR(0x00C0C0C0)
N#define GUI_GRAY_C8       GUI_MAKE_COLOR(0x00C8C8C8)
N#define GUI_GRAY_D0       GUI_MAKE_COLOR(0x00D0D0D0)
N#define GUI_GRAY_E7       GUI_MAKE_COLOR(0x00E7E7E7)
N
N#define GUI_BLUE_98       GUI_MAKE_COLOR(0x00980000)
N
N/*********************************************************************
N*
N*       MultiTouch-Support
N*/
N/*********************************************************************
N*
N*       MultiTouch flags
N*
N*  Description
N*    Data structure used by GUI_MTOUCH_GetEvent() to store a multi touch
N*    event in.
N*/
N#define GUI_MTOUCH_FLAG_DOWN (1 << 0)    // New touch point has touched the surface.
N#define GUI_MTOUCH_FLAG_MOVE (1 << 1)    // Touch point has been moved.
N#define GUI_MTOUCH_FLAG_UP   (1 << 2)    // Touch point has released the surface.
N
N/*********************************************************************
N*
N*       Variables
N*/
Nextern T_GUI_MTOUCH_STOREEVENT GUI_MTOUCH__pStoreEvent;
N
N/*********************************************************************
N*
N*       Interface
N*/
Nvoid GUI_MTOUCH_Enable          (int OnOff);
Nint  GUI_MTOUCH_GetEvent        (GUI_MTOUCH_EVENT * pEvent);
Nint  GUI_MTOUCH_GetTouchInput   (GUI_MTOUCH_EVENT * pEvent, GUI_MTOUCH_INPUT * pBuffer, unsigned Index);
Nint  GUI_MTOUCH_IsEmpty         (void);
Nvoid GUI_MTOUCH_SetOrientation  (int Orientation);
Nvoid GUI_MTOUCH_SetOrientationEx(int Orientation, int LayerIndex);
Nvoid GUI_MTOUCH_StoreEvent      (GUI_MTOUCH_EVENT * pEvent, GUI_MTOUCH_INPUT * pInput);
N
N/*********************************************************************
N*
N*       Axis values
N* 
N*  Description
N*    Defines to distinguish between the X and Y axis. Used in various
N*    emWin functions.
N*/
N#define GUI_COORD_X     0     // X axis.
N#define GUI_COORD_Y     1     // Y axis.
N
N/*********************************************************************
N*
N*       Horizontal / Vertical
N*/
N#define GUI_HORIZONTAL (1 << GUI_COORD_X)
N#define GUI_VERTICAL   (1 << GUI_COORD_Y)
N
N/*********************************************************************
N*
N*       Addresses of standard fonts
N*/
N//
N// Proportional fonts
N//
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font8_ASCII,        GUI_Font8_1;
Xextern const GUI_FONT GUI_Font8_ASCII,        GUI_Font8_1;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font10S_ASCII,      GUI_Font10S_1;
Xextern const GUI_FONT GUI_Font10S_ASCII,      GUI_Font10S_1;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font10_ASCII,       GUI_Font10_1;
Xextern const GUI_FONT GUI_Font10_ASCII,       GUI_Font10_1;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font13_ASCII,       GUI_Font13_1;
Xextern const GUI_FONT GUI_Font13_ASCII,       GUI_Font13_1;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font13B_ASCII,      GUI_Font13B_1;
Xextern const GUI_FONT GUI_Font13B_ASCII,      GUI_Font13B_1;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font13H_ASCII,      GUI_Font13H_1;
Xextern const GUI_FONT GUI_Font13H_ASCII,      GUI_Font13H_1;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font13HB_ASCII,     GUI_Font13HB_1;
Xextern const GUI_FONT GUI_Font13HB_ASCII,     GUI_Font13HB_1;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font16_ASCII,       GUI_Font16_1,       GUI_Font16_HK,    GUI_Font16_1HK;
Xextern const GUI_FONT GUI_Font16_ASCII,       GUI_Font16_1,       GUI_Font16_HK,    GUI_Font16_1HK;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font16B_ASCII,      GUI_Font16B_1;
Xextern const GUI_FONT GUI_Font16B_ASCII,      GUI_Font16B_1;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font20_ASCII,       GUI_Font20_1;
Xextern const GUI_FONT GUI_Font20_ASCII,       GUI_Font20_1;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font20B_ASCII,      GUI_Font20B_1;
Xextern const GUI_FONT GUI_Font20B_ASCII,      GUI_Font20B_1;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font24_ASCII,       GUI_Font24_1;
Xextern const GUI_FONT GUI_Font24_ASCII,       GUI_Font24_1;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font24B_ASCII,      GUI_Font24B_1;
Xextern const GUI_FONT GUI_Font24B_ASCII,      GUI_Font24B_1;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font32_ASCII,       GUI_Font32_1;
Xextern const GUI_FONT GUI_Font32_ASCII,       GUI_Font32_1;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font32B_ASCII,      GUI_Font32B_1;
Xextern const GUI_FONT GUI_Font32B_ASCII,      GUI_Font32B_1;
N
N//
N// Proportional fonts, framed
N//
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font20F_ASCII;
Xextern const GUI_FONT GUI_Font20F_ASCII;
N
N//
N// Monospaced
N//
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font4x6;
Xextern const GUI_FONT GUI_Font4x6;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font6x8,            GUI_Font6x9;
Xextern const GUI_FONT GUI_Font6x8,            GUI_Font6x9;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font6x8_ASCII,      GUI_Font6x8_1;
Xextern const GUI_FONT GUI_Font6x8_ASCII,      GUI_Font6x8_1;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font8x8,            GUI_Font8x9;
Xextern const GUI_FONT GUI_Font8x8,            GUI_Font8x9;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font8x8_ASCII,      GUI_Font8x8_1;
Xextern const GUI_FONT GUI_Font8x8_ASCII,      GUI_Font8x8_1;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font8x10_ASCII;
Xextern const GUI_FONT GUI_Font8x10_ASCII;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font8x12_ASCII;
Xextern const GUI_FONT GUI_Font8x12_ASCII;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font8x13_ASCII,     GUI_Font8x13_1;
Xextern const GUI_FONT GUI_Font8x13_ASCII,     GUI_Font8x13_1;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font8x15B_ASCII,    GUI_Font8x15B_1;
Xextern const GUI_FONT GUI_Font8x15B_ASCII,    GUI_Font8x15B_1;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font8x16,           GUI_Font8x17,       GUI_Font8x18;
Xextern const GUI_FONT GUI_Font8x16,           GUI_Font8x17,       GUI_Font8x18;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font8x16x1x2,       GUI_Font8x16x2x2,   GUI_Font8x16x3x3;
Xextern const GUI_FONT GUI_Font8x16x1x2,       GUI_Font8x16x2x2,   GUI_Font8x16x3x3;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font8x16_ASCII,     GUI_Font8x16_1;
Xextern const GUI_FONT GUI_Font8x16_ASCII,     GUI_Font8x16_1;
N
N//
N// Digits
N//
Nextern GUI_CONST_STORAGE GUI_FONT GUI_FontD24x32;
Xextern const GUI_FONT GUI_FontD24x32;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_FontD32;
Xextern const GUI_FONT GUI_FontD32;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_FontD36x48;
Xextern const GUI_FONT GUI_FontD36x48;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_FontD48;
Xextern const GUI_FONT GUI_FontD48;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_FontD48x64;
Xextern const GUI_FONT GUI_FontD48x64;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_FontD64;
Xextern const GUI_FONT GUI_FontD64;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_FontD60x80;
Xextern const GUI_FONT GUI_FontD60x80;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_FontD80;
Xextern const GUI_FONT GUI_FontD80;
N
N//
N// Comic fonts
N//
Nextern GUI_CONST_STORAGE GUI_FONT GUI_FontComic18B_ASCII, GUI_FontComic18B_1;
Xextern const GUI_FONT GUI_FontComic18B_ASCII, GUI_FontComic18B_1;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_FontComic24B_ASCII, GUI_FontComic24B_1;
Xextern const GUI_FONT GUI_FontComic24B_ASCII, GUI_FontComic24B_1;
N
N/*********************************************************************
N*
N*       Macros to be used
N*/
N//
N// Proportional fonts
N//
N#define GUI_FONT_8_ASCII        &GUI_Font8_ASCII
N#define GUI_FONT_8_1            &GUI_Font8_1
N#define GUI_FONT_10S_ASCII      &GUI_Font10S_ASCII
N#define GUI_FONT_10S_1          &GUI_Font10S_1
N#define GUI_FONT_10_ASCII       &GUI_Font10_ASCII
N#define GUI_FONT_10_1           &GUI_Font10_1
N#define GUI_FONT_13_ASCII       &GUI_Font13_ASCII
N#define GUI_FONT_13_1           &GUI_Font13_1
N#define GUI_FONT_13B_ASCII      &GUI_Font13B_ASCII
N#define GUI_FONT_13B_1          &GUI_Font13B_1
N#define GUI_FONT_13H_ASCII      &GUI_Font13H_ASCII
N#define GUI_FONT_13H_1          &GUI_Font13H_1
N#define GUI_FONT_13HB_ASCII     &GUI_Font13HB_ASCII
N#define GUI_FONT_13HB_1         &GUI_Font13HB_1
N#define GUI_FONT_16_ASCII       &GUI_Font16_ASCII
N#define GUI_FONT_16_1           &GUI_Font16_1
N#define GUI_FONT_16_HK          &GUI_Font16_HK
N#define GUI_FONT_16_1HK         &GUI_Font16_1HK
N#define GUI_FONT_16B_ASCII      &GUI_Font16B_ASCII
N#define GUI_FONT_16B_1          &GUI_Font16B_1
N#define GUI_FONT_20_ASCII       &GUI_Font20_ASCII
N#define GUI_FONT_20_1           &GUI_Font20_1
N#define GUI_FONT_20B_ASCII      &GUI_Font20B_ASCII
N#define GUI_FONT_20B_1          &GUI_Font20B_1
N#define GUI_FONT_24_ASCII       &GUI_Font24_ASCII
N#define GUI_FONT_24_1           &GUI_Font24_1
N#define GUI_FONT_24B_ASCII      &GUI_Font24B_ASCII
N#define GUI_FONT_24B_1          &GUI_Font24B_1
N#define GUI_FONT_32_ASCII       &GUI_Font32_ASCII
N#define GUI_FONT_32_1           &GUI_Font32_1
N#define GUI_FONT_32B_ASCII      &GUI_Font32B_ASCII
N#define GUI_FONT_32B_1          &GUI_Font32B_1
N
N//
N// Proportional fonts, framed
N//
N#define GUI_FONT_20F_ASCII      &GUI_Font20F_ASCII
N
N//
N// Monospaced
N//
N#define GUI_FONT_4X6            &GUI_Font4x6
N#define GUI_FONT_6X8            &GUI_Font6x8
N#define GUI_FONT_6X8_ASCII      &GUI_Font6x8_ASCII
N#define GUI_FONT_6X8_1          &GUI_Font6x8_1
N#define GUI_FONT_6X9            &GUI_Font6x9
N#define GUI_FONT_8X8            &GUI_Font8x8
N#define GUI_FONT_8X8_ASCII      &GUI_Font8x8_ASCII
N#define GUI_FONT_8X8_1          &GUI_Font8x8_1
N#define GUI_FONT_8X9            &GUI_Font8x9
N#define GUI_FONT_8X10_ASCII     &GUI_Font8x10_ASCII
N#define GUI_FONT_8X12_ASCII     &GUI_Font8x12_ASCII
N#define GUI_FONT_8X13_ASCII     &GUI_Font8x13_ASCII
N#define GUI_FONT_8X13_1         &GUI_Font8x13_1
N#define GUI_FONT_8X15B_ASCII    &GUI_Font8x15B_ASCII
N#define GUI_FONT_8X15B_1        &GUI_Font8x15B_1
N#define GUI_FONT_8X16           &GUI_Font8x16
N#define GUI_FONT_8X17           &GUI_Font8x17
N#define GUI_FONT_8X18           &GUI_Font8x18
N#define GUI_FONT_8X16X1X2       &GUI_Font8x16x1x2
N#define GUI_FONT_8X16X2X2       &GUI_Font8x16x2x2
N#define GUI_FONT_8X16X3X3       &GUI_Font8x16x3x3
N#define GUI_FONT_8X16_ASCII     &GUI_Font8x16_ASCII
N#define GUI_FONT_8X16_1         &GUI_Font8x16_1
N
N//
N// Digits
N//
N#define GUI_FONT_D24X32         &GUI_FontD24x32
N#define GUI_FONT_D32            &GUI_FontD32
N#define GUI_FONT_D36X48         &GUI_FontD36x48
N#define GUI_FONT_D48            &GUI_FontD48
N#define GUI_FONT_D48X64         &GUI_FontD48x64
N#define GUI_FONT_D64            &GUI_FontD64
N#define GUI_FONT_D60X80         &GUI_FontD60x80
N#define GUI_FONT_D80            &GUI_FontD80
N
N//
N// Comic fonts
N//
N#define GUI_FONT_COMIC18B_ASCII &GUI_FontComic18B_ASCII
N#define GUI_FONT_COMIC18B_1     &GUI_FontComic18B_1
N#define GUI_FONT_COMIC24B_ASCII &GUI_FontComic24B_ASCII
N#define GUI_FONT_COMIC24B_1     &GUI_FontComic24B_1
N
N/*********************************************************************
N*
N*       Text and drawing modes
N*
N* These defines come in two flavors: the long version (.._DRAWMODE_..)
N* and the short ones (.._DM_..). They are identical, feel free to use
N* which ever one you like best.
N*/
N#define GUI_DRAWMODE_NORMAL  LCD_DRAWMODE_NORMAL
N#define GUI_DRAWMODE_XOR     LCD_DRAWMODE_XOR
N#define GUI_DRAWMODE_TRANS   LCD_DRAWMODE_TRANS
N#define GUI_DRAWMODE_REV     LCD_DRAWMODE_REV
N#define GUI_DM_NORMAL        LCD_DRAWMODE_NORMAL
N#define GUI_DM_XOR           LCD_DRAWMODE_XOR
N#define GUI_DM_TRANS         LCD_DRAWMODE_TRANS
N#define GUI_DM_REV           LCD_DRAWMODE_REV
N
N#define GUI_TEXTMODE_NORMAL  LCD_DRAWMODE_NORMAL
N#define GUI_TEXTMODE_XOR     LCD_DRAWMODE_XOR
N#define GUI_TEXTMODE_TRANS   LCD_DRAWMODE_TRANS
N#define GUI_TEXTMODE_REV     LCD_DRAWMODE_REV
N#define GUI_TM_NORMAL        LCD_DRAWMODE_NORMAL
N#define GUI_TM_XOR           LCD_DRAWMODE_XOR
N#define GUI_TM_TRANS         LCD_DRAWMODE_TRANS
N#define GUI_TM_REV           LCD_DRAWMODE_REV
N
N/* Text alignment flags, horizontal */
N#define GUI_TA_LEFT       (0)
N#define GUI_TA_HORIZONTAL (3u)
N#define GUI_TA_RIGHT      (1u)
N#define GUI_TA_CENTER     (2u)
N#define GUI_TA_HCENTER    GUI_TA_CENTER  /* easier to remember :-)  */
N
N/* Text alignment flags, vertical */
N#define GUI_TA_TOP        (0)
N#define GUI_TA_VERTICAL   (3u << 2)
N#define GUI_TA_BOTTOM     (1u << 2)
N#define GUI_TA_BASELINE   (2u << 2)
N#define GUI_TA_VCENTER    (3u << 2)
N
N/* General alignment flags */
N#define GUI_ALIGN_LEFT       GUI_TA_LEFT
N#define GUI_ALIGN_HCENTER    GUI_TA_HCENTER
N#define GUI_ALIGN_RIGHT      GUI_TA_RIGHT
N#define GUI_ALIGN_TOP        GUI_TA_TOP
N#define GUI_ALIGN_VCENTER    GUI_TA_VCENTER
N#define GUI_ALIGN_BOTTOM     GUI_TA_BOTTOM
N#define GUI_ALIGN_HORIZONTAL GUI_TA_HORIZONTAL
N#define GUI_ALIGN_VERTICAL   GUI_TA_VERTICAL
N#define GUI_ALIGN_CENTER     (GUI_TA_HCENTER | GUI_TA_VCENTER)
N
N/* General orientation flags */
N#define GUI_MIRROR_X (1u)
N#define GUI_MIRROR_Y (1u << 1)
N#define GUI_SWAP_XY  (1u << 2)
N
N#define GUI_ROTATION_0     (0)
N#define GUI_ROTATION_CW    (GUI_MIRROR_X | GUI_SWAP_XY)
N#define GUI_ROTATION_180   (GUI_MIRROR_X | GUI_MIRROR_Y)
N#define GUI_ROTATION_CCW   (GUI_MIRROR_Y | GUI_SWAP_XY)
N#define GUI_ROTATION_LEFT  (1u << 3)
N#define GUI_ROTATION_RIGHT (1u << 4)
N
N/*********************************************************************
N*
N*       Min/Max coordinates
N*
N* Define minimum and maximum coordinates in x and y
N*/
N#define GUI_XMIN -16383
N#define GUI_XMAX  16383
N#define GUI_YMIN -16383
N#define GUI_YMAX  16383
N
N/*********************************************************************
N*
N*       Defines for constants
N*/
N#define ________ 0x0
N#define _______X 0x1
N#define ______X_ 0x2
N#define ______XX 0x3
N#define _____X__ 0x4
N#define _____X_X 0x5
N#define _____XX_ 0x6
N#define _____XXX 0x7
N#define ____X___ 0x8
N#define ____X__X 0x9
N#define ____X_X_ 0xa
N#define ____X_XX 0xb
N#define ____XX__ 0xc
N#define ____XX_X 0xd
N#define ____XXX_ 0xe
N#define ____XXXX 0xf
N#define ___X____ 0x10
N#define ___X___X 0x11
N#define ___X__X_ 0x12
N#define ___X__XX 0x13
N#define ___X_X__ 0x14
N#define ___X_X_X 0x15
N#define ___X_XX_ 0x16
N#define ___X_XXX 0x17
N#define ___XX___ 0x18
N#define ___XX__X 0x19
N#define ___XX_X_ 0x1a
N#define ___XX_XX 0x1b
N#define ___XXX__ 0x1c
N#define ___XXX_X 0x1d
N#define ___XXXX_ 0x1e
N#define ___XXXXX 0x1f
N#define __X_____ 0x20
N#define __X____X 0x21
N#define __X___X_ 0x22
N#define __X___XX 0x23
N#define __X__X__ 0x24
N#define __X__X_X 0x25
N#define __X__XX_ 0x26
N#define __X__XXX 0x27
N#define __X_X___ 0x28
N#define __X_X__X 0x29
N#define __X_X_X_ 0x2a
N#define __X_X_XX 0x2b
N#define __X_XX__ 0x2c
N#define __X_XX_X 0x2d
N#define __X_XXX_ 0x2e
N#define __X_XXXX 0x2f
N#define __XX____ 0x30
N#define __XX___X 0x31
N#define __XX__X_ 0x32
N#define __XX__XX 0x33
N#define __XX_X__ 0x34
N#define __XX_X_X 0x35
N#define __XX_XX_ 0x36
N#define __XX_XXX 0x37
N#define __XXX___ 0x38
N#define __XXX__X 0x39
N#define __XXX_X_ 0x3a
N#define __XXX_XX 0x3b
N#define __XXXX__ 0x3c
N#define __XXXX_X 0x3d
N#define __XXXXX_ 0x3e
N#define __XXXXXX 0x3f
N#define _X______ 0x40
N#define _X_____X 0x41
N#define _X____X_ 0x42
N#define _X____XX 0x43
N#define _X___X__ 0x44
N#define _X___X_X 0x45
N#define _X___XX_ 0x46
N#define _X___XXX 0x47
N#define _X__X___ 0x48
N#define _X__X__X 0x49
N#define _X__X_X_ 0x4a
N#define _X__X_XX 0x4b
N#define _X__XX__ 0x4c
N#define _X__XX_X 0x4d
N#define _X__XXX_ 0x4e
N#define _X__XXXX 0x4f
N#define _X_X____ 0x50
N#define _X_X___X 0x51
N#define _X_X__X_ 0x52
N#define _X_X__XX 0x53
N#define _X_X_X__ 0x54
N#define _X_X_X_X 0x55
N#define _X_X_XX_ 0x56
N#define _X_X_XXX 0x57
N#define _X_XX___ 0x58
N#define _X_XX__X 0x59
N#define _X_XX_X_ 0x5a
N#define _X_XX_XX 0x5b
N#define _X_XXX__ 0x5c
N#define _X_XXX_X 0x5d
N#define _X_XXXX_ 0x5e
N#define _X_XXXXX 0x5f
N#define _XX_____ 0x60
N#define _XX____X 0x61
N#define _XX___X_ 0x62
N#define _XX___XX 0x63
N#define _XX__X__ 0x64
N#define _XX__X_X 0x65
N#define _XX__XX_ 0x66
N#define _XX__XXX 0x67
N#define _XX_X___ 0x68
N#define _XX_X__X 0x69
N#define _XX_X_X_ 0x6a
N#define _XX_X_XX 0x6b
N#define _XX_XX__ 0x6c
N#define _XX_XX_X 0x6d
N#define _XX_XXX_ 0x6e
N#define _XX_XXXX 0x6f
N#define _XXX____ 0x70
N#define _XXX___X 0x71
N#define _XXX__X_ 0x72
N#define _XXX__XX 0x73
N#define _XXX_X__ 0x74
N#define _XXX_X_X 0x75
N#define _XXX_XX_ 0x76
N#define _XXX_XXX 0x77
N#define _XXXX___ 0x78
N#define _XXXX__X 0x79
N#define _XXXX_X_ 0x7a
N#define _XXXX_XX 0x7b
N#define _XXXXX__ 0x7c
N#define _XXXXX_X 0x7d
N#define _XXXXXX_ 0x7e
N#define _XXXXXXX 0x7f
N#define X_______ 0x80
N#define X______X 0x81
N#define X_____X_ 0x82
N#define X_____XX 0x83
N#define X____X__ 0x84
N#define X____X_X 0x85
N#define X____XX_ 0x86
N#define X____XXX 0x87
N#define X___X___ 0x88
N#define X___X__X 0x89
N#define X___X_X_ 0x8a
N#define X___X_XX 0x8b
N#define X___XX__ 0x8c
N#define X___XX_X 0x8d
N#define X___XXX_ 0x8e
N#define X___XXXX 0x8f
N#define X__X____ 0x90
N#define X__X___X 0x91
N#define X__X__X_ 0x92
N#define X__X__XX 0x93
N#define X__X_X__ 0x94
N#define X__X_X_X 0x95
N#define X__X_XX_ 0x96
N#define X__X_XXX 0x97
N#define X__XX___ 0x98
N#define X__XX__X 0x99
N#define X__XX_X_ 0x9a
N#define X__XX_XX 0x9b
N#define X__XXX__ 0x9c
N#define X__XXX_X 0x9d
N#define X__XXXX_ 0x9e
N#define X__XXXXX 0x9f
N#define X_X_____ 0xa0
N#define X_X____X 0xa1
N#define X_X___X_ 0xa2
N#define X_X___XX 0xa3
N#define X_X__X__ 0xa4
N#define X_X__X_X 0xa5
N#define X_X__XX_ 0xa6
N#define X_X__XXX 0xa7
N#define X_X_X___ 0xa8
N#define X_X_X__X 0xa9
N#define X_X_X_X_ 0xaa
N#define X_X_X_XX 0xab
N#define X_X_XX__ 0xac
N#define X_X_XX_X 0xad
N#define X_X_XXX_ 0xae
N#define X_X_XXXX 0xaf
N#define X_XX____ 0xb0
N#define X_XX___X 0xb1
N#define X_XX__X_ 0xb2
N#define X_XX__XX 0xb3
N#define X_XX_X__ 0xb4
N#define X_XX_X_X 0xb5
N#define X_XX_XX_ 0xb6
N#define X_XX_XXX 0xb7
N#define X_XXX___ 0xb8
N#define X_XXX__X 0xb9
N#define X_XXX_X_ 0xba
N#define X_XXX_XX 0xbb
N#define X_XXXX__ 0xbc
N#define X_XXXX_X 0xbd
N#define X_XXXXX_ 0xbe
N#define X_XXXXXX 0xbf
N#define XX______ 0xc0
N#define XX_____X 0xc1
N#define XX____X_ 0xc2
N#define XX____XX 0xc3
N#define XX___X__ 0xc4
N#define XX___X_X 0xc5
N#define XX___XX_ 0xc6
N#define XX___XXX 0xc7
N#define XX__X___ 0xc8
N#define XX__X__X 0xc9
N#define XX__X_X_ 0xca
N#define XX__X_XX 0xcb
N#define XX__XX__ 0xcc
N#define XX__XX_X 0xcd
N#define XX__XXX_ 0xce
N#define XX__XXXX 0xcf
N#define XX_X____ 0xd0
N#define XX_X___X 0xd1
N#define XX_X__X_ 0xd2
N#define XX_X__XX 0xd3
N#define XX_X_X__ 0xd4
N#define XX_X_X_X 0xd5
N#define XX_X_XX_ 0xd6
N#define XX_X_XXX 0xd7
N#define XX_XX___ 0xd8
N#define XX_XX__X 0xd9
N#define XX_XX_X_ 0xda
N#define XX_XX_XX 0xdb
N#define XX_XXX__ 0xdc
N#define XX_XXX_X 0xdd
N#define XX_XXXX_ 0xde
N#define XX_XXXXX 0xdf
N#define XXX_____ 0xe0
N#define XXX____X 0xe1
N#define XXX___X_ 0xe2
N#define XXX___XX 0xe3
N#define XXX__X__ 0xe4
N#define XXX__X_X 0xe5
N#define XXX__XX_ 0xe6
N#define XXX__XXX 0xe7
N#define XXX_X___ 0xe8
N#define XXX_X__X 0xe9
N#define XXX_X_X_ 0xea
N#define XXX_X_XX 0xeb
N#define XXX_XX__ 0xec
N#define XXX_XX_X 0xed
N#define XXX_XXX_ 0xee
N#define XXX_XXXX 0xef
N#define XXXX____ 0xf0
N#define XXXX___X 0xf1
N#define XXXX__X_ 0xf2
N#define XXXX__XX 0xf3
N#define XXXX_X__ 0xf4
N#define XXXX_X_X 0xf5
N#define XXXX_XX_ 0xf6
N#define XXXX_XXX 0xf7
N#define XXXXX___ 0xf8
N#define XXXXX__X 0xf9
N#define XXXXX_X_ 0xfa
N#define XXXXX_XX 0xfb
N#define XXXXXX__ 0xfc
N#define XXXXXX_X 0xfd
N#define XXXXXXX_ 0xfe
N#define XXXXXXXX 0xff
N
N/*********************************************************************
N*
N*       Compatibility with older versions
N*/
N#define GUI_DispString_UC      GUI_UC_DispString
N#define TOUCH_X_ActivateX      GUI_TOUCH_X_ActivateX
N#define TOUCH_X_ActivateY      GUI_TOUCH_X_ActivateY
N#define TOUCH_X_Disable        GUI_TOUCH_X_Disable
N#define TOUCH_X_MeasureX       GUI_TOUCH_X_MeasureX
N#define TOUCH_X_MeasureY       GUI_TOUCH_X_MeasureY
N#define GUI_SelLayer           GUI_SelectLayer
N#define GUI_MEMDEV_FadeDevices GUI_MEMDEV_FadeInDevices
N#if defined(__cplusplus)
X#if 0L
S}
N#endif
N
N#endif   /* ifdef GUI_H */
N
N/*************************** End of file ****************************/
L 53 "..\..\..\..\ThirdParty\emWin\Include\WM.h" 2
N
N#if defined(__cplusplus)
X#if 0L
Sextern "C" {     /* Make sure we have C-declarations in C++ programs */
N#endif
N
N/* Static memory devices */
N#ifndef   WM_SUPPORT_STATIC_MEMDEV
N  #define WM_SUPPORT_STATIC_MEMDEV GUI_SUPPORT_MEMDEV
N#endif
N
N/* Support for transparency. Switching it off makes Wm smaller and faster */
N#ifndef   WM_SUPPORT_TRANSPARENCY
N  #define WM_SUPPORT_TRANSPARENCY 1 /* Should be defined outside of GUI_WINSUPPORT because of '#if GUI_WINSUPPORT && WM_SUPPORT_TRANSPARENCY' in some files */
N#endif
N
N/* This is for tests only. It will fill the invalid area of a window.
N   Can be used for debugging. */
N#ifndef WM_SUPPORT_DIAG
N  #ifdef WIN32   /* In simulation */
S    #define WM_SUPPORT_DIAG GUI_WINSUPPORT
N  #else
N    #define WM_SUPPORT_DIAG 0
N  #endif
N#endif
N
N/* Make sure we actually have configured windows. If we have not,
N  there is no point for a windows manager and it will therefor not
N  generate any code !
N*/
N
N#if GUI_WINSUPPORT
X#if 1
N
N/*********************************************************************
N*
N*       Config defaults
N*/
N#ifndef   WM_ASSERT
N  #define WM_ASSERT(expr) GUI_DEBUG_ASSERT(expr)
N#endif
N
N/* Allow older API calls */
N#ifndef   WM_COMPATIBLE_MODE
N  #define WM_COMPATIBLE_MODE 1
N#endif
N
N/* Send a message if visibility of a window has changed */
N#ifndef   WM_SUPPORT_NOTIFY_VIS_CHANGED
N  #define WM_SUPPORT_NOTIFY_VIS_CHANGED 0
N#endif
N
N#ifndef   WM_SUPPORT_CPP
N  #if defined (_MSC_VER)
X  #if 0L
S    #define WM_SUPPORT_CPP 1
N  #else
N    #define WM_SUPPORT_CPP 0
N  #endif
N#endif
N
N/* Different return value of WM_Exec() and WM_Exec1() */
N#ifndef   WM_EXEC_RET_VAL
N  #define WM_EXEC_RET_VAL 0
N#endif
N
N/* Static memory devices */
N#ifndef   WM_SMD_PERIOD
N  #define WM_SMD_PERIOD 3000
N#endif
N#ifndef   WM_SMD_LIMIT
N  #define WM_SMD_LIMIT 60
N#endif
N
N/*********************************************************************
N*
N*       Locking macros
N*/
N#define WM_LOCK()   GUI_LOCK()
N#define WM_UNLOCK() GUI_UNLOCK()
N
N/*********************************************************************
N*
N*       Validate window handles
N*/
N#ifndef WM_VALIDATE_HANDLE
N  #define WM_VALIDATE_HANDLE  (0)
N#endif
N
N#if WM_VALIDATE_HANDLE
X#if (0)
S  #define WM_LOCK_H(hWin) (WM_Obj *)WM__LockValid(hWin)
N#else
N  #define WM_LOCK_H(hWin) (WM_Obj *)GUI_LOCK_H(hWin)
N#endif
N
N/*********************************************************************
N*
N*       Data types
N*/
Ntypedef struct WM_WINDOW_INFO WM_WINDOW_INFO;
N
Nstruct WM_WINDOW_INFO {
N  GUI_HMEM hWin;
X  signed long hWin;
N  GUI_HMEM hParent;
X  signed long hParent;
N  GUI_HMEM hFirstChild;
X  signed long hFirstChild;
N  GUI_HMEM hNext;
X  signed long hNext;
N  GUI_RECT Rect;
N  U32      Status;
X  unsigned long      Status;
N  U32      DebugId;
X  unsigned long      DebugId;
N  WM_WINDOW_INFO * pNext;
N};
N
N/*********************************************************************
N*
N*       WM_KEY_INFO
N*
N*   Description
N*     Contains information about a pressed key.
N*/
Ntypedef struct {
N  int Key;         // The key which has been pressed.
N  int PressedCnt;  // >0 if the key has been pressed, 0 if the key has been released.
N} WM_KEY_INFO;
N
N/*********************************************************************
N*
N*       WM_SCROLL_STATE
N*
N*   Description
N*     Saves the scrollstate of a scrollbar.
N*/
Ntypedef struct {
N  int NumItems;    // Number of items.
N  int v;           // Current value.
N  int PageSize;    // Number of items visible on one page.
N} WM_SCROLL_STATE;
N
Ntypedef struct {
N  int Done;
N  int ReturnValue;
N} WM_DIALOG_STATUS;
N
N/*********************************************************************
N*
N*       WM_PID_STATE_CHANGED_INFO
N*
N*   Description
N*     Information about the changed PID state. Sent to a window with
N*     the \uref{WM_PID_STATE_CHANGED} message.
N*/
Ntypedef struct {
N  int x;          // Horizontal position of the PID in window coordinates.
N  int y;          // Vertical position of the PID in window coordinates.
N  U8  State;      // Pressed state (> 0 if PID is pressed).
X  unsigned char  State;      
N  U8  StatePrev;  // Previous pressed state.
X  unsigned char  StatePrev;  
N} WM_PID_STATE_CHANGED_INFO;
N
N/*********************************************************************
N*
N*       WM_MOTION_INFO
N*
N*   Description
N*     Contains information about a move with motion support.
N*/
Ntypedef struct {
N  U8              Cmd;         // Command. See \ref{Motion messages}.
X  unsigned char              Cmd;         
N  U8              FinalMove;   // Set to 1 on the final moving operation.
X  unsigned char              FinalMove;   
N  U8              StopMotion;  // Can be set to 1 to stop motion immediately.
X  unsigned char              StopMotion;  
N  U8              IsDragging;  // Is set to 1 if the PID is pressed, 0 if released.
X  unsigned char              IsDragging;  
N  int             dx;          // Distance in X to be used to move the window.
N  int             dy;          // Distance in Y to be used to move the window.
N  int             da;          // Distance in 1/10 degrees to be used to move an item.
N  int             xPos;        // Used to return the current position in X for custom moving operations.
N  int             yPos;        // Used to return the current position in Y for custom moving operations.
N  int             Period;      // Duration of the moving operation after the PID has been released.
N  int             SnapX;       // Raster size in X for snapping operations, 0 if no snapping is required.
N  int             SnapY;       // Raster size in Y for snapping operations, 0 if no snapping is required.
N  U8              IsOutside;   // If motion is managed by window.
X  unsigned char              IsOutside;   
N  unsigned        Overlap;     // Overlapping distance allowed for dragging operations.
N  U32             Flags;       // To be used to enable motion support.
X  unsigned long             Flags;       
N  GUI_PID_STATE * pState;
N  GUI_HMEM        hContext;
X  signed long        hContext;
N  int             Dest;
N} WM_MOTION_INFO;
N
N/*********************************************************************
N*
N*       WM_ZOOM_INFO
N*
N*  Description
N*    Structure used for scaling and panning windows.
N*
N*  Additional information
N*    The factor is shifted by 16 bits to be able to achieve a smooth result. The native size
N*    needs to be passed by the application to the WM because otherwise it is not possible
N*    to get the exact size of the window in unscaled state.
N*/
Ntypedef struct {
N  I32       FactorMin;    // Minimum factor to be used (<< 16).
X  signed long       FactorMin;    
N  I32       FactorMax;    // Maximum factor to be used (<< 16).
X  signed long       FactorMax;    
N  U32       xSize;        // Native xSize of window to be zoomed in pixels.
X  unsigned long       xSize;        
N  U32       ySize;        // Native ySize of window to be zoomed in pixels.
X  unsigned long       ySize;        
N  U32       xSizeParent;  /* xSize of parent window.                                  */
X  unsigned long       xSizeParent;   
N  U32       ySizeParent;  /* ySize of parent window.                                  */
X  unsigned long       ySizeParent;   
N  I32       Factor0;      /* Primary factor when starting zoom gesture (<< 16).       */
X  signed long       Factor0;       
N  int       xPos0;        /* Primary window position in x when starting the gesture.  */
N  int       yPos0;        /* Primary window position in y when starting the gesture.  */
N  GUI_POINT Center0;      /* Primary center point when starting the gesture.          */
N} WM_ZOOM_INFO;
N
N/*********************************************************************
N*
N*       WM_GESTURE_INFO
N*
N*  Description
N*    Stores the information about a gesture.
N*/
Ntypedef struct {
N  int            Flags;      // Information regarding gesture type. See \ref{MultiTouch gesture flags}.
N  GUI_POINT      Point;      // Relative movement to be processed by the application.
N  GUI_POINT      Center;     // Center point for zooming.
N  I32            Angle;      // Relative angle difference to be processed by the application.
X  signed long            Angle;      
N  I32            Factor;     // When starting a zoom gesture the application has to set the element to the initial value for the gesture. After that during
X  signed long            Factor;     
N                             // the gesture it contains the updated value to be processed by the application.
N  WM_ZOOM_INFO * pZoomInfo;  // Pointer to be set to a valid location of a WM_ZOOM_INFO structure. The application should keep sure, that the
N                             // location remains valid during the gesture.
N} WM_GESTURE_INFO;
N
N/*********************************************************************
N*
N*       WM_MOVE_INFO
N*
N*   Description
N*     Stores the distance of a window move operation.
N*/
Ntypedef struct {
N  int dx;   // Difference between old and new position on the X-axis.
N  int dy;   // Difference between old and new position on the Y-axis.
N} WM_MOVE_INFO;
N
N/*********************************************************************
N*
N*       MultiTouch gesture flags
N*
N*   Description
N*     Flags used for processing gesture input.
N*/
N#define WM_GF_BEGIN  (1 << 0)  // This flag is set when sending the first message for the gesture.
N#define WM_GF_END    (1 << 1)  // Set when releasing a touch point at the end of a gesture.
N#define WM_GF_PAN    (1 << 2)  // A panning gesture is detected. The element "Point" of WM_GESTURE_INFO contains the relative movement in pixels to be processed by the application.
N#define WM_GF_ZOOM   (1 << 3)  // Zooming is active. When starting a zooming gesture the element "Factor" of WM_GESTURE_INFO has to be set to the initial value to be used by the gesture.
N                               // During the gesture the same element contains the updated value to be processed by the application. If movement should be considered simultaneously the element "Point" contains also the relative movement.
N#define WM_GF_ROTATE (1 << 4)  // Rotation is active. The element "Angle" of WM_GESTURE_INFO contains the relative movement in degrees (<< 16) to be processed by the application.
N                               // To be able to achieve a smooth rotation the value is passed in 1/65536 degrees. If movement should be considered simultaneously the element "Point" contains also the relative movement.
N#define WM_GF_DTAP   (1 << 5)
N
N/*********************************************************************
N*
N*       Messages Ids
N*
N* The following is the list of windows messages.
N*/
N#define WM_CREATE                   0x0001  /* The first message received, right after client has actually been created */
N#define WM_MOVE                     0x0003  /* window has been moved (Same as WIN32) */
N
N#define WM_SIZE                     0x0005  /* Is sent to a window after its size has changed (Same as WIN32, do not change !) */
N
N#define WM_DELETE                   11      /* Delete (Destroy) command: This tells the client to free its data strutures since the window
N                                               it is associates with no longer exists.*/
N#define WM_TOUCH                    0x0240  /* Touch screen message */
N#define WM_TOUCH_CHILD              13      /* Touch screen message to ancestors */
N#define WM_KEY                      14      /* Key has been pressed */
N
N#define WM_PAINT                    0x000F  /* Repaint window (because content is (partially) invalid */
N
N#if GUI_SUPPORT_MOUSE
X#if 1
N#define WM_MOUSEOVER                16      /* Mouse has moved, no key pressed */
N#define WM_MOUSEOVER_END            18      /* Mouse has moved, no key pressed */
N#endif
N
N#define WM_PID_STATE_CHANGED        17      /* Pointer input device state has changed */
N
N#define WM_GET_INSIDE_RECT          20      /* get inside rectangle: client rectangle minus pixels lost to effect */
N#define WM_GET_ID                   21      /* Get id of widget */
N#define WM_SET_ID                   22      /* Set id of widget */
N#define WM_GET_CLIENT_WINDOW        23      /* Get window handle of client window. Default is the same as window */
N#define WM_CAPTURE_RELEASED         24      /* Let window know that mouse capture is over */
N
N#define WM_INIT_DIALOG              29      /* Inform dialog that it is ready for init */
N
N#define WM_SET_FOCUS                30      /* Inform window that it has gotten or lost the focus */
N#define WM_GET_ACCEPT_FOCUS         31      /* Find out if window can accept the focus */
N#define WM_NOTIFY_CHILD_HAS_FOCUS   32      /* Sent to parent when child receives / loses focus */
N
N#define WM_NOTIFY_OWNER_KEY         33      /* Some widgets (e.g. listbox) notify owner when receiving key messages */
N
N#define WM_GET_BKCOLOR              34      /* Return back ground color (only frame window and similar) */
N#define WM_GET_SCROLL_STATE         35      /* Query state of scroll bar */
N
N#define WM_SET_SCROLL_STATE         36      /* Set scroll info ... only effective for scrollbars */
N
N#define WM_NOTIFY_CLIENTCHANGE      37      /* Client area may have changed */
N#define WM_NOTIFY_PARENT            38      /* Notify parent. Information is detailed as notification code */
N#define WM_NOTIFY_PARENT_REFLECTION 39      /* Notify parent reflection.
N                                               Sometimes send back as a result of the WM_NOTIFY_PARENT message
N                                               to let child react on behalf of its parent.
N                                               Information is detailed as notification code */
N#define WM_NOTIFY_ENABLE            40      /* Enable or disable widget */
N#define WM_NOTIFY_VIS_CHANGED       41      /* Visibility of a window has or may have changed */
N
N#define WM_HANDLE_DIALOG_STATUS     42      /* Set or get dialog status */
N#define WM_GET_RADIOGROUP           43      /* Send to all siblings and children of a radio control when
N                                               selection changed */
N#define WM_MENU                     44      /* Send to owner window of menu widget */
N#define WM_SCREENSIZE_CHANGED       45      /* Send to all windows when size of screen has changed */
N#define WM_PRE_PAINT                46      /* Send to a window before it receives a WM_PAINT message */
N#define WM_POST_PAINT               47      /* Send to a window after (the last) WM_PAINT message */
N
N#define WM_MOTION                   48      /* Automatic motion messages */
N
N#define WM_GET_WINDOW_ID            49      /* Return widget type specific Id (DebugId) */
N
N#define WM_PRE_BANDING              50      /* Send before starting banding process */
N#define WM_POST_BANDING             51      /* Send after finishing banding process */
N
N#define WM_USER_DATA                52      /* Send immediately after setting user data */
N#define WM_SET_CALLBACK             53      /* Send immediately after setting user data */
N
N#define WM_GET_OFFSET               54      /* Return alignment offset */
N
N#define WM_GET_CONTENT_RECT         55      /* Get content rectangle, e.g. for LISTVIEW: InsideRect minus the HEADER */
N
N#define WM_GESTURE                  0x0119  /* Gesture message */
N
N#define WM_TIMER                    0x0113  /* Timer has expired              (Keep the same as WIN32) */
N#define WM_WIDGET                   0x0300  /* 256 messages reserved for Widget messages */
N#define WM_USER                     0x0400  /* Reserved for user messages ... (Keep the same as WIN32) */
N
N#define APPW_MSG                    0x1000  /* 256 messages reserved for AppWizard messages */
N
N/*********************************************************************
N*
N*       Motion messages
N*
N*  Description
N*    Commands sent with a WM_MOTION message. The command can be found
N*    in the member \c{Cmd} of the WM_MOTION_INFO structure.
N*
N*  Additional information
N*    More information about these commands can be read under
N*    \ref{WM_MOTION message and WM_MOTION_INFO}.
N*/
N#define WM_MOTION_INIT       0   // Sent to a window to initiate a motion operation.
N#define WM_MOTION_MOVE       1   // Sent to a window to achieve custom moving operations.
N#define WM_MOTION_GETPOS     2   // Sent to get the current position of custom moving operations.
N#define WM_MOTION_GETCONTEXT 3
N#define WM_MOTION_GETDEST    4   // Sent to receive the desired position to move to
N#define WM_MOTION_GETSNAP    5   // Sent to receive the nearest snap position
N#define WM_MOTION_SETCONTEXT 6
N
N/*********************************************************************
N*
N*       Motion flags
N*
N*  Description
N*    Flags for motion support. The flags are supposed to be OR-combined
N*    with the member \c{Flags} of the WM_MOTION_INFO structure.
N*/
N#define WM_MOTION_MANAGE_BY_WINDOW   (1 << 0)   // Window movement is managed by window itself.
N
N/*********************************************************************
N*
N*       Motion overlap flags
N*
N*  Description
N*    Flags for setting overlap behavior of widgets. The overlap will
N*    come into effect if a distance has been set.
N*/
N#define WM_MOTION_OVERLAP_TOP        (1 << 4)   // Overlap will be active at the top edge of the widget.
N#define WM_MOTION_OVERLAP_BOTTOM     (1 << 5)   // Overlap will be active at the bottom edge of the widget.
N#define WM_MOTION_OVERLAP_LEFT       (1 << 6)   // Overlap will be active at the left edge of the widget.
N#define WM_MOTION_OVERLAP_RIGHT      (1 << 7)   // Overlap will be active at the right edge of the widget.
N
N/*********************************************************************
N*
N*       Notification codes
N*
N*  Description
N*    List of all notifications sent by the Window Manager. A notification
N*    code is sent with a WM_NOTIFY_PARENT message and can be read with
N*    \c{pMsg->Data.v}.
N*/
N#define WM_NOTIFICATION_CLICKED                   1      // This notification message will be sent when the window has been clicked.
N#define WM_NOTIFICATION_RELEASED                  2      // This notification message will be sent when a clicked widget has been released.
N#define WM_NOTIFICATION_MOVED_OUT                 3      // This notification message will be sent when the pointer was moved out of the window while it is clicked.
N#define WM_NOTIFICATION_SEL_CHANGED               4      // This notification message will be sent when the selection of a widget has changed.
N#define WM_NOTIFICATION_VALUE_CHANGED             5      // This notification message will be sent when a widget specific value has changed.
N#define WM_NOTIFICATION_SCROLLBAR_ADDED           6      // This notification message will be sent when a SCROLLBAR widget has been added to the window.
N#define WM_NOTIFICATION_CHILD_DELETED             7      // This notification message will be sent from a window to its parent before it is deleted.
N#define WM_NOTIFICATION_GOT_FOCUS                 8      // This notification message will be sent once a window receives and accepts the focus.
N#define WM_NOTIFICATION_LOST_FOCUS                9      // This notification message will be sent when the window has lost the focus.
N#define WM_NOTIFICATION_SCROLL_CHANGED           10      // This notification message will be sent when the scroll position of an attached SCROLLBAR widget has changed.
N#define WM_NOTIFICATION_SCROLLER_ADDED           16      // This notification message will be sent when a SCROLLER widget has been added to the window.
N#define WM_NOTIFICATION_OVERLAP_TOP_ENTERED      17      // This notification message will be sent when the top overlap area of a widget was entered.
N#define WM_NOTIFICATION_OVERLAP_BOTTOM_ENTERED   18      // This notification message will be sent when the bottom overlap area of a widget was entered.
N#define WM_NOTIFICATION_OVERLAP_LEFT_ENTERED     19      // This notification message will be sent when the left overlap area of a widget was entered.
N#define WM_NOTIFICATION_OVERLAP_RIGHT_ENTERED    20      // This notification message will be sent when the right overlap area of a widget was entered.
N#define WM_NOTIFICATION_OVERLAP_RELEASED         21      // This notification message will be sent when the overlap area of a widget was entered and has been released.
N#define WM_NOTIFICATION_STARTED                  22      // This notification message will be sent when a widget has been started.
N#define WM_NOTIFICATION_STOPPED                  23      // This notification message will be sent when a widget has been stopped.
N
N/* not documented */
N#define WM_NOTIFICATION_MOTION_STOPPED           11
N#define WM_NOTIFICATION_SET                      12
N#define WM_NOTIFICATION_CLEAR                    13
N#define WM_NOTIFICATION_TEXT_CHANGED             14
N#define WM_NOTIFICATION_ENTER_PRESSED            15
N
N#define WM_NOTIFICATION_WIDGET                   30      /* Space for widget defined notifications */
N#define WM_NOTIFICATION_USER                     40      /* Space for  application (user) defined notifications */
N
N/*********************************************************************
N*
N*       Memory management
N*/
N#define WM_HWIN        GUI_HWIN
N#define WM_HWIN_NULL   GUI_HMEM_NULL
N#define WM_HMEM        GUI_HMEM
N#define WM_HMEM_NULL   GUI_HMEM_NULL
N#define WM_HTIMER      GUI_HMEM
N
N/*********************************************************************
N*
N*       Window defines
N*/
N#define WM_HBKWIN      WM_GetDesktopWindow()                /* Handle of background window */
N#define WM_UNATTACHED  ((WM_HMEM) - 1)                      /* Do not attach to a window */
N
N/*********************************************************************
N*
N*       Window create flags
N*
N*  Description
N*    Flags that define a window upon creation.
N*    These flags can be passed to the create window
N*    function as flag-parameter. The flags are combinable using the
N*    binary OR-operator.
N*/
N#define WM_CF_HASTRANS         (1UL << 0)  // Has transparency flag. Must be defined for windows whose client area is not entirely filled.
N                                           // To set this flag after the window has been created the function WM_SetTransState() should be used.
N#define WM_CF_HIDE             (0UL << 1)  // Hide window after creation (default).
N#define WM_CF_SHOW             (1UL << 1)  // Show window after creation.
N#define WM_CF_MEMDEV           (1UL << 2)  // Automatically use a Memory Device for drawing. This will avoid flickering and also improve the
N                                           // output speed in most cases, as clipping is simplified. The Window Manager creates a Memory
N                                           // Device for the current window according to the configured color depth and window size. The
N                                           // Memory Device is deleted immediately after the drawing process was finished. \n 
N                                           // In order to draw images into a remaining Memory Device the IMAGE widget can be used with the
N                                           // creation flag IMAGE_CF_MEMDEV. Details can be found in the section \ref{IMAGE: Image widget}.
N                                           // Note that the Memory Device package is required (and needs to be enabled in the configuration)
N                                           // in order to be able to use this flag. If Memory Devices are not enabled, this flag is ignored.
N#define WM_CF_STAYONTOP        (1UL << 3)  // Make sure window stays on top of all siblings created without this flag.
N#define WM_CF_DISABLED         (1UL << 4)  // Window is disabled after creation. This means it receives no PID (mouse and touch) input.
N#define WM_CF_ACTIVATE         (1UL << 5)  /* Is (re)used as WM_SF_INVALID */
N#define WM_CF_FGND             (0UL << 6)  // Put window in foreground after creation (default).
N#define WM_CF_BGND             (1UL << 6)  // Put window in background after creation.
N#define WM_CF_ANCHOR_RIGHT     (1UL << 7)  // Anchors the right edge of the new window relative to the right edge of the parent window. If
N                                           // the position of the parent windows right edge will be adjusted due to a size change, the
N                                           // position of new window will also be adjusted.
N#define WM_CF_ANCHOR_BOTTOM    (1UL << 8)  // Anchors the bottom edge of the new window relative to the bottom edge of the parent window. If
N                                           // the position of the parent windows bottom edge will be adjusted due to a size change, the
N                                           // position of new window will also be adjusted.
N#define WM_CF_ANCHOR_LEFT      (1UL << 9)  // Anchors the left edge of the new window relative to the left edge of the parent window (default).
N                                           // If the position of the parent windows left edge will be adjusted due to a size change,
N                                           // the position of new window will also be adjusted.
N#define WM_CF_ANCHOR_TOP       (1UL << 10) // Anchors the top edge of the new window relative to the top edge of the parent window (default).
N                                           // If the position of the parent windows top edge will be adjusted due to a size change, the
N                                           // position of new window will also be adjusted.
N#define WM_CF_CONST_OUTLINE    (1UL << 11) // This flag is an optimization for transparent windows. It gives the Window Manager a chance
N                                           // to optimize redrawing and invalidation of transparent windows. A transparent window is normally
N                                           // redrawn as part of the background, which is less efficient than redrawing the window separately.
N                                           // However, this flag may NOT be used if the window has semi transparency (alpha blending /
N                                           // anti-aliasing with background) or the outline (the shape) changes with the window's states.
N                                           // To set this flag after the window has been created the function WM_SetTransState() should be used.
N#define WM_CF_LATE_CLIP        (1UL << 12) // This flag can be used to tell the WM that the clipping should be done in the drawing routines
N                                           // (late clipping). The default behavior of the WM is early clipping. That means that the clipping
N                                           // rectangle will be calculated before a WM_PAINT message will be sent to a window. In dependence
N                                           // of other existing windows it might be necessary to send more than one WM_PAINT message to a window.
N                                           // If using WM_CF_LATE_CLIP the WM makes sure only one message will be sent to an invalid window and
N                                           // the clipping will be done by the drawing routines. The \c{Sample} folder of emWin contains the
N                                           // example \c{WM_LateClipping.c} to show the effect.
N#define WM_CF_MEMDEV_ON_REDRAW (1UL << 13) // Equals WM_CF_MEMDEV with the difference that the according window is drawn the first time without
N                                           // using a Memory Device. The WM will automatically use a Memory Device for redrawing. This flag can
N                                           // be used as a replacement of WM_CF_MEMDEV. It typically accelerates the initial rendering of the
N                                           // window, but maintains the advantage of flicker free updates.
N#define WM_SF_INVALID_DRAW     (1UL << 14) /* Tells the WM to redraw the window using the static memory device */
N#define WM_SF_DELETE           (1UL << 15) /* The window will be deleted on the next time WM_Exec() is called */
N#define WM_CF_STATIC           (1UL << 16) // A static memory device is used for drawing. That means if a window with this flag receives a
N                                           // WM_PAINT message, emWin first checks if a static memory device exists. If not, it will be created
N                                           // and the content of the window/widget will be (pre)rendered in the memory device. If such a window
N                                           // is moved to a new position, only the already existing memory needs to be drawn at the new position.
N                                           // This kind of drawing a window could improve the performance a lot, but needs a large amount of RAM.
N#define WM_CF_MOTION_X         (1UL << 17) // Window can be moved automatically in X axis.
N#define WM_CF_MOTION_Y         (1UL << 18) // Window can be moved automatically in Y axis.
N#define WM_CF_GESTURE          (1UL << 19) // Marks the window to be able to receive gesture messages. This requires gesture support.
N#define WM_CF_ZOOM             (1UL << 20) // Window can be scaled automatically by multi-touch gesture input.
N#define WM_CF_MOTION_R         (1UL << 21) // This enables the window to be rotated.
N#define WM_CF_UNTOUCHABLE      (1UL << 22) // A window created with this flag routes its touch input to its parent. This makes a window 'untouchable'.
N#define WM_CF_APPWIZARD        (1UL << 23) /* Window is an AppWizard object */
N#define WM_CF_MEMDEV_CLIPPING  (1UL << 24) // Reactivates the window manager when drawing into memory devices created via WM_CF_MEMDEV. Otherwise
N                                           // it can happen that invisible windows (e.g. a window covered completely by another window) still draws
N                                           // its content into a memory device but the memory device doesn't get drawn to the LCD. With this flag
N                                           // these unnecessary drawing operations can be avoided. Attention, if there is a non transparent window
N                                           // in the foreground, which is smaller than the window in the back, tiling will be used and multiple paint
N                                           // events into the memory device will be performed!
N
N/*********************************************************************
N*
N*       Window manager types
N*/
Ntypedef struct WM_Obj     WM_Obj;
Ntypedef struct WM_MESSAGE WM_MESSAGE;
N
Ntypedef void WM_CALLBACK( WM_MESSAGE * pMsg);
N
N/*********************************************************************
N*
N*       WM_MESSAGE
N*
N*   Description
N*     Contains the data for a message sent by a window.
N*/
Nstruct WM_MESSAGE {
N  int MsgId;               // Type of message.
N  WM_HWIN hWin;            // Destination window.
X  GUI_HWIN hWin;            
N  WM_HWIN hWinSrc;         // Source window.
X  GUI_HWIN hWinSrc;         
N  union {
N    const void * p;        // Message-specific const data pointer.
N    void * pData;          // Message-specific data pointer.
N    int v;                 // Message-specific data value.
N    PTR_ADDR u;
X    unsigned long u;
N    GUI_COLOR Color;
N    void (* pFunc)(void);
N  } Data;
N};
N
Nstruct WM_Obj {
N  GUI_RECT Rect;        /* Outer dimensions of window */
N  GUI_RECT InvalidRect; /* Invalid rectangle */
N  WM_CALLBACK* cb;      /* Ptr to notification callback */
N  WM_HWIN hNextLin;     /* Next window in linear list */
X  GUI_HWIN hNextLin;      
N  WM_HWIN hParent;
X  GUI_HWIN hParent;
N  WM_HWIN hFirstChild;
X  GUI_HWIN hFirstChild;
N  WM_HWIN hNext;
X  GUI_HWIN hNext;
N  #if WM_SUPPORT_STATIC_MEMDEV
X  #if 1
N    GUI_MEMDEV_Handle hMem; /* Static memory device */
N  #endif
N  U32 Status;           /* Status flags */
X  unsigned long Status;            
N  #if WM_SUPPORT_CPP
X  #if 0
S    void * ObjPtr;
N  #endif
N};
N
Ntypedef void WM_tfPollPID(void);
Ntypedef void WM_tfForEach(WM_HWIN hWin, void * pData);
Xtypedef void WM_tfForEach(GUI_HWIN hWin, void * pData);
N
Ntypedef void (* WM_tfInvalidateParent)  (const GUI_RECT * pInvalidRect, WM_HWIN hParent, WM_HWIN hStop);
Xtypedef void (* WM_tfInvalidateParent)  (const GUI_RECT * pInvalidRect, GUI_HWIN hParent, GUI_HWIN hStop);
Ntypedef void (* WM_tfInvalidateDrawFunc)(WM_HWIN hWin);
Xtypedef void (* WM_tfInvalidateDrawFunc)(GUI_HWIN hWin);
Ntypedef int  (* WM_tfPaint1Func)        (WM_HWIN hWin);
Xtypedef int  (* WM_tfPaint1Func)        (GUI_HWIN hWin);
N
Ntypedef struct {
N  WM_HMEM  hTimer;
X  signed long  hTimer;
N  WM_HWIN  hWin;
X  GUI_HWIN  hWin;
N  int      UserId;
N} WM_TIMER_OBJ;
N
N/*********************************************************************
N*
N*       General control routines
N*/
Nvoid WM_Activate  (void);
Nvoid WM_Deactivate(void);
Nvoid WM_Init      (void);
Nint  WM_Exec      (void);    /* Execute all jobs ... Return 0 if nothing was done. */
Nint  WM_Exec1     (void);    // Execute only one job
NU32  WM_SetCreateFlags(U32 Flags);
Xunsigned long  WM_SetCreateFlags(unsigned long Flags);
NWM_tfPollPID * WM_SetpfPollPID(WM_tfPollPID * pf);
N
N/*********************************************************************
N*
N*       Window manager interface
N*/
Nvoid    WM_AttachWindow              (WM_HWIN hWin, WM_HWIN hParent);
Xvoid    WM_AttachWindow              (GUI_HWIN hWin, GUI_HWIN hParent);
Nvoid    WM_AttachWindowAt            (WM_HWIN hWin, WM_HWIN hParent, int x, int y);
Xvoid    WM_AttachWindowAt            (GUI_HWIN hWin, GUI_HWIN hParent, int x, int y);
Nint     WM_CheckScrollPos            (WM_SCROLL_STATE * pScrollState, int Pos, int LowerDist, int UpperDist); /* not to be documented (may change in future version) */
Nvoid    WM_ClrHasTrans               (WM_HWIN hWin);
Xvoid    WM_ClrHasTrans               (GUI_HWIN hWin);
NWM_HWIN WM_CreateWindow              (int x0, int y0, int xSize, int ySize, U32 Style, WM_CALLBACK * cb, int NumExtraBytes);
XGUI_HWIN WM_CreateWindow              (int x0, int y0, int xSize, int ySize, unsigned long Style, WM_CALLBACK * cb, int NumExtraBytes);
NWM_HWIN WM_CreateWindowAsChild       (int x0, int y0, int xSize, int ySize, WM_HWIN hWinParent, U32 Style, WM_CALLBACK* cb, int NumExtraBytes);
XGUI_HWIN WM_CreateWindowAsChild       (int x0, int y0, int xSize, int ySize, GUI_HWIN hWinParent, unsigned long Style, WM_CALLBACK* cb, int NumExtraBytes);
Nvoid    WM_DeleteWindow              (WM_HWIN hWin);
Xvoid    WM_DeleteWindow              (GUI_HWIN hWin);
Nvoid    WM_DeleteWindowSecure        (WM_HWIN hWin);
Xvoid    WM_DeleteWindowSecure        (GUI_HWIN hWin);
Nvoid    WM_DetachWindow              (WM_HWIN hWin);
Xvoid    WM_DetachWindow              (GUI_HWIN hWin);
Nvoid    WM_EnableGestures            (WM_HWIN hWin, int OnOff);
Xvoid    WM_EnableGestures            (GUI_HWIN hWin, int OnOff);
Nint     WM_GetHasTrans               (WM_HWIN hWin);
Xint     WM_GetHasTrans               (GUI_HWIN hWin);
NWM_HWIN WM_GetFocusedWindow          (void);
XGUI_HWIN WM_GetFocusedWindow          (void);
Nint     WM_GetInvalidRect            (WM_HWIN hWin, GUI_RECT * pRect);
Xint     WM_GetInvalidRect            (GUI_HWIN hWin, GUI_RECT * pRect);
Nint     WM_GetStayOnTop              (WM_HWIN hWin);
Xint     WM_GetStayOnTop              (GUI_HWIN hWin);
Nvoid    WM_HideWindow                (WM_HWIN hWin);
Xvoid    WM_HideWindow                (GUI_HWIN hWin);
Nvoid    WM_InvalidateArea            (const GUI_RECT * pRect);
Nvoid    WM_InvalidateRect            (WM_HWIN hWin, const GUI_RECT * pRect);
Xvoid    WM_InvalidateRect            (GUI_HWIN hWin, const GUI_RECT * pRect);
Nvoid    WM_InvalidateWindow          (WM_HWIN hWin);
Xvoid    WM_InvalidateWindow          (GUI_HWIN hWin);
Nvoid    WM_InvalidateWindowAndDescsEx(WM_HWIN hWin, const GUI_RECT * pInvalidRect, U16 Flags);
Xvoid    WM_InvalidateWindowAndDescsEx(GUI_HWIN hWin, const GUI_RECT * pInvalidRect, unsigned short Flags);
Nvoid    WM_InvalidateWindowAndDescs  (WM_HWIN hWin);    /* not to be documented (may change in future version) */
Xvoid    WM_InvalidateWindowAndDescs  (GUI_HWIN hWin);     
Nint     WM_IsEnabled                 (WM_HWIN hObj);
Xint     WM_IsEnabled                 (GUI_HWIN hObj);
Nchar    WM_IsCompletelyCovered       (WM_HWIN hWin);    /* Checks if the window is completely covered by other windows */
Xchar    WM_IsCompletelyCovered       (GUI_HWIN hWin);     
Nchar    WM_IsCompletelyVisible       (WM_HWIN hWin);    /* Is the window completely visible ? */
Xchar    WM_IsCompletelyVisible       (GUI_HWIN hWin);     
Nint     WM_IsFocusable               (WM_HWIN hWin);
Xint     WM_IsFocusable               (GUI_HWIN hWin);
Nint     WM_IsUntouchable             (WM_HWIN hWin);
Xint     WM_IsUntouchable             (GUI_HWIN hWin);
Nint     WM_IsVisible                 (WM_HWIN hWin);
Xint     WM_IsVisible                 (GUI_HWIN hWin);
Nint     WM_IsWindow                  (WM_HWIN hWin);    /* Check validity */
Xint     WM_IsWindow                  (GUI_HWIN hWin);     
Nvoid    WM_Rect2Screen               (WM_HWIN hWin, GUI_RECT * pRect);
Xvoid    WM_Rect2Screen               (GUI_HWIN hWin, GUI_RECT * pRect);
Nvoid    WM_Rect2Client               (WM_HWIN hWin, GUI_RECT * pRect);
Xvoid    WM_Rect2Client               (GUI_HWIN hWin, GUI_RECT * pRect);
Nvoid    WM_SetAnchor                 (WM_HWIN hWin, U16 AnchorFlags);
Xvoid    WM_SetAnchor                 (GUI_HWIN hWin, unsigned short AnchorFlags);
Nvoid    WM_SetHasTrans               (WM_HWIN hWin);
Xvoid    WM_SetHasTrans               (GUI_HWIN hWin);
Nvoid    WM_SetId                     (WM_HWIN hObj, int Id);
Xvoid    WM_SetId                     (GUI_HWIN hObj, int Id);
Nvoid    WM_SetStayOnTop              (WM_HWIN hWin, int OnOff);
Xvoid    WM_SetStayOnTop              (GUI_HWIN hWin, int OnOff);
Nvoid    WM_SetTransState             (WM_HWIN hWin, unsigned State);
Xvoid    WM_SetTransState             (GUI_HWIN hWin, unsigned State);
Nint     WM_SetUntouchable            (WM_HWIN hWin, int OnOff);
Xint     WM_SetUntouchable            (GUI_HWIN hWin, int OnOff);
Nvoid    WM_ShowWindow                (WM_HWIN hWin);
Xvoid    WM_ShowWindow                (GUI_HWIN hWin);
Nvoid    WM_ValidateRect              (WM_HWIN hWin, const GUI_RECT * pRect);
Xvoid    WM_ValidateRect              (GUI_HWIN hWin, const GUI_RECT * pRect);
Nvoid    WM_ValidateWindow            (WM_HWIN hWin);
Xvoid    WM_ValidateWindow            (GUI_HWIN hWin);
Nvoid    WM_XY2Screen                 (WM_HWIN hWin, int * px, int * py);
Xvoid    WM_XY2Screen                 (GUI_HWIN hWin, int * px, int * py);
Nvoid    WM_XY2Client                 (WM_HWIN hWin, int * px, int * py);
Xvoid    WM_XY2Client                 (GUI_HWIN hWin, int * px, int * py);
N
N#define WM_GetFocussedWindow WM_GetFocusedWindow
N#define WM_IsFocussable      WM_IsFocusable
N
N/* Gesture support */
Nvoid WM_GESTURE_Enable  (int OnOff);
Nint  WM_GESTURE_EnableEx(int OnOff, int MaxFactor);
Nvoid WM_GESTURE_Exec    (void);
NI32  WM_GESTURE_SetThresholdAngle(I32 ThresholdAngle);
Xsigned long  WM_GESTURE_SetThresholdAngle(signed long ThresholdAngle);
NI32  WM_GESTURE_SetThresholdDist (I32 ThresholdDist);
Xsigned long  WM_GESTURE_SetThresholdDist (signed long ThresholdDist);
N
N/* Motion support */
Nvoid     WM_MOTION_Enable          (int OnOff);
Nvoid     WM_MOTION_SetMovement     (WM_HWIN hWin, int Axis, I32 Speed, I32 Dist);
Xvoid     WM_MOTION_SetMovement     (GUI_HWIN hWin, int Axis, signed long Speed, signed long Dist);
Nvoid     WM_MOTION_SetMotion       (WM_HWIN hWin, int Axis, I32 Speed, I32 Deceleration);
Xvoid     WM_MOTION_SetMotion       (GUI_HWIN hWin, int Axis, signed long Speed, signed long Deceleration);
Nvoid     WM_MOTION_SetMoveable     (WM_HWIN hWin, U32 Flags, int OnOff);
Xvoid     WM_MOTION_SetMoveable     (GUI_HWIN hWin, unsigned long Flags, int OnOff);
Nvoid     WM_MOTION_SetDeceleration (WM_HWIN hWin, int Axis, I32 Deceleration);
Xvoid     WM_MOTION_SetDeceleration (GUI_HWIN hWin, int Axis, signed long Deceleration);
Nunsigned WM_MOTION_SetDefaultPeriod(unsigned Period);
Nvoid     WM_MOTION_SetSpeed        (WM_HWIN hWin, int Axis, I32 Velocity);
Xvoid     WM_MOTION_SetSpeed        (GUI_HWIN hWin, int Axis, signed long Velocity);
Nvoid     WM_MOTION_SetMinMotion    (unsigned MinMotion);
Nvoid     WM_MOTION_SetThreshold    (unsigned Threshold);
N
N/* Motion support, private interface */
NWM_HMEM WM_MOTION__CreateContext(void);
Xsigned long WM_MOTION__CreateContext(void);
Nvoid    WM_MOTION__DeleteContext(WM_HMEM hContext);
Xvoid    WM_MOTION__DeleteContext(signed long hContext);
NWM_HMEM WM_MOTION__GetContext   (WM_HWIN hWin);
Xsigned long WM_MOTION__GetContext   (GUI_HWIN hWin);
Nvoid    WM_MOTION__SetContext   (WM_HWIN hWin, WM_HMEM hContext);
Xvoid    WM_MOTION__SetContext   (GUI_HWIN hWin, signed long hContext);
Nint     WM_MOTION__IsActive     (void);
N
N/* Motion support, private function(s) */
Nvoid     WM__SetMotionCallback (void(* cbMotion) (GUI_PID_STATE * pState, void * p));
N
N/* Static memory devices */
N#if (GUI_SUPPORT_MEMDEV)
X#if (1)
N  #define GUI_MEMDEV_EDGE_LEFT   0
N  #define GUI_MEMDEV_EDGE_RIGHT  1
N  #define GUI_MEMDEV_EDGE_TOP    2
N  #define GUI_MEMDEV_EDGE_BOTTOM 3
N
N  int               GUI_MEMDEV_BlendWinBk       (WM_HWIN hWin, int Period, U32 BlendColor, U8 BlendIntens);
X  int               GUI_MEMDEV_BlendWinBk       (GUI_HWIN hWin, int Period, unsigned long BlendColor, unsigned char BlendIntens);
N  int               GUI_MEMDEV_BlurAndBlendWinBk(WM_HWIN hWin, int Period, U8 BlurDepth, U32 BlendColor, U8 BlendIntens);
X  int               GUI_MEMDEV_BlurAndBlendWinBk(GUI_HWIN hWin, int Period, unsigned char BlurDepth, unsigned long BlendColor, unsigned char BlendIntens);
N  int               GUI_MEMDEV_BlurWinBk        (WM_HWIN hWin, int Period, U8 BlurDepth);
X  int               GUI_MEMDEV_BlurWinBk        (GUI_HWIN hWin, int Period, unsigned char BlurDepth);
N  void              GUI_MEMDEV_CreateStatic     (WM_HWIN hWin);
X  void              GUI_MEMDEV_CreateStatic     (GUI_HWIN hWin);
N  GUI_MEMDEV_Handle GUI_MEMDEV_CreateWindowDevice(WM_HWIN hWin);
X  GUI_MEMDEV_Handle GUI_MEMDEV_CreateWindowDevice(GUI_HWIN hWin);
N  int               GUI_MEMDEV_FadeInWindow     (WM_HWIN hWin, int Period);
X  int               GUI_MEMDEV_FadeInWindow     (GUI_HWIN hWin, int Period);
N  int               GUI_MEMDEV_FadeOutWindow    (WM_HWIN hWin, int Period);
X  int               GUI_MEMDEV_FadeOutWindow    (GUI_HWIN hWin, int Period);
N  GUI_MEMDEV_Handle GUI_MEMDEV_GetStaticDevice  (WM_HWIN hWin);
X  GUI_MEMDEV_Handle GUI_MEMDEV_GetStaticDevice  (GUI_HWIN hWin);
N  GUI_MEMDEV_Handle GUI_MEMDEV_GetWindowDevice  (WM_HWIN hWin);
X  GUI_MEMDEV_Handle GUI_MEMDEV_GetWindowDevice  (GUI_HWIN hWin);
N  int               GUI_MEMDEV_MoveInWindow     (WM_HWIN hWin, int x, int y, int a180, int Period);
X  int               GUI_MEMDEV_MoveInWindow     (GUI_HWIN hWin, int x, int y, int a180, int Period);
N  int               GUI_MEMDEV_MoveOutWindow    (WM_HWIN hWin, int x, int y, int a180, int Period);
X  int               GUI_MEMDEV_MoveOutWindow    (GUI_HWIN hWin, int x, int y, int a180, int Period);
N  int               GUI_MEMDEV_Paint1Static     (WM_HWIN hWin);                                     /* not to be documented */
X  int               GUI_MEMDEV_Paint1Static     (GUI_HWIN hWin);                                      
N  int               GUI_MEMDEV_ShiftInWindow    (WM_HWIN hWin, int Period, int Direction);
X  int               GUI_MEMDEV_ShiftInWindow    (GUI_HWIN hWin, int Period, int Direction);
N  int               GUI_MEMDEV_ShiftOutWindow   (WM_HWIN hWin, int Period, int Direction);
X  int               GUI_MEMDEV_ShiftOutWindow   (GUI_HWIN hWin, int Period, int Direction);
N  int               GUI_MEMDEV_SwapWindow       (WM_HWIN hWin, int Period, int Edge);
X  int               GUI_MEMDEV_SwapWindow       (GUI_HWIN hWin, int Period, int Edge);
N
N  void              GUI_MEMDEV__CreateStatic    (WM_HWIN hWin);
X  void              GUI_MEMDEV__CreateStatic    (GUI_HWIN hWin);
N#endif
N
N/* Move/resize windows */
Nvoid WM_MoveWindow                (WM_HWIN hWin, int dx, int dy);
Xvoid WM_MoveWindow                (GUI_HWIN hWin, int dx, int dy);
Nvoid WM_ResizeWindow              (WM_HWIN hWin, int dx, int dy);
Xvoid WM_ResizeWindow              (GUI_HWIN hWin, int dx, int dy);
Nvoid WM_MoveTo                    (WM_HWIN hWin, int x, int y);
Xvoid WM_MoveTo                    (GUI_HWIN hWin, int x, int y);
Nvoid WM_MoveChildTo               (WM_HWIN hWin, int x, int y);
Xvoid WM_MoveChildTo               (GUI_HWIN hWin, int x, int y);
Nvoid WM_SetSize                   (WM_HWIN hWin, int XSize, int YSize);
Xvoid WM_SetSize                   (GUI_HWIN hWin, int XSize, int YSize);
Nvoid WM_SetWindowPos              (WM_HWIN hWin, int xPos, int yPos, int xSize, int ySize);
Xvoid WM_SetWindowPos              (GUI_HWIN hWin, int xPos, int yPos, int xSize, int ySize);
Nint  WM_SetXSize                  (WM_HWIN hWin, int xSize);
Xint  WM_SetXSize                  (GUI_HWIN hWin, int xSize);
Nint  WM_SetYSize                  (WM_HWIN hWin, int ySize);
Xint  WM_SetYSize                  (GUI_HWIN hWin, int ySize);
Nint  WM_SetScrollbarH             (WM_HWIN hWin, int OnOff); /* not to be documented (may change in future version) */
Xint  WM_SetScrollbarH             (GUI_HWIN hWin, int OnOff);  
Nint  WM_SetScrollbarV             (WM_HWIN hWin, int OnOff); /* not to be documented (may change in future version) */
Xint  WM_SetScrollbarV             (GUI_HWIN hWin, int OnOff);  
N
N
N/*********************************************************************
N*
N*       ToolTip period indexes
N*
N*   Description
N*     Period indexes for ToolTip related routines.
N*/
N#define WM_TOOLTIP_PI_FIRST 0    // Period to be used the first time the PID is hovered over a tool. The ToolTip appears after the
N                                 // PID has not moved for at least this period. Default is 1000 ms.
N#define WM_TOOLTIP_PI_SHOW  1    // Period to be used for showing the ToolTip. The ToolTip disappears after the PID remains for
N                                 // at least this period without moving. Default is 5000 ms.
N#define WM_TOOLTIP_PI_NEXT  2    // Period to be used if the PID hovers over a tool of the same parent as before. The ToolTip
N                                 // appears after the PID is not moved for at least this period. Default is 50 ms.
N
N/*********************************************************************
N*
N*       ToolTip color indexes
N*
N*   Description
N*     Color indexes for ToolTip related routines.
N*/
N#define WM_TOOLTIP_CI_BK    0   // Color to be used for the background.
N#define WM_TOOLTIP_CI_FRAME 1   // Color to be used for the thin frame.
N#define WM_TOOLTIP_CI_TEXT  2   // Color to be used for the text.
N
Ntypedef WM_HMEM WM_TOOLTIP_HANDLE;
Xtypedef signed long WM_TOOLTIP_HANDLE;
N
N/*********************************************************************
N*
N*       TOOLTIP_INFO
N*
N*   Description
N*     Contains the information about a ToolTip.
N*/
Ntypedef struct {
N  int          Id;     // Id of the ToolTip.
N  const char * pText;  // String containing the text of the ToolTip.
N} TOOLTIP_INFO;
N
Nint               WM_TOOLTIP_AddTool         (WM_TOOLTIP_HANDLE hToolTip, WM_HWIN hTool, const char * pText);
Xint               WM_TOOLTIP_AddTool         (WM_TOOLTIP_HANDLE hToolTip, GUI_HWIN hTool, const char * pText);
NWM_TOOLTIP_HANDLE WM_TOOLTIP_Create          (WM_HWIN hDlg, const TOOLTIP_INFO * pInfo, unsigned NumItems);
XWM_TOOLTIP_HANDLE WM_TOOLTIP_Create          (GUI_HWIN hDlg, const TOOLTIP_INFO * pInfo, unsigned NumItems);
Nvoid              WM_TOOLTIP_Delete          (WM_TOOLTIP_HANDLE hToolTip);
NGUI_COLOR         WM_TOOLTIP_SetDefaultColor (unsigned Index, GUI_COLOR Color);
Nconst GUI_FONT *  WM_TOOLTIP_SetDefaultFont  (const GUI_FONT * pFont);
Nunsigned          WM_TOOLTIP_SetDefaultPeriod(unsigned Index, unsigned Period);
N
N/* ToolTip support, private */
Nvoid WM__SetToolTipCallback(void(* cbToolTip)(GUI_PID_STATE * pState, WM_HWIN));
Xvoid WM__SetToolTipCallback(void(* cbToolTip)(GUI_PID_STATE * pState, GUI_HWIN));
N
N/* Timer */
N#ifdef GUI_X_CREATE_TIMER
S  int  WM_CreateTimer    (WM_HWIN hWin, int UserID, int Period, int Mode); /* not to be documented (may change in future version) */
S  void WM_DeleteTimer    (WM_HWIN hWin, int UserId); /* not to be documented (may change in future version) */
N#else
N  WM_HMEM WM_CreateTimer (WM_HWIN hWin, int UserID, int Period, int Mode); /* not to be documented (may change in future version) */
X  signed long WM_CreateTimer (GUI_HWIN hWin, int UserID, int Period, int Mode);  
N  void    WM_DeleteTimer (WM_HMEM hTimer); /* not to be documented (may change in future version) */
X  void    WM_DeleteTimer (signed long hTimer);  
N  void    WM_RestartTimer(WM_HMEM hTimer, int Period);
X  void    WM_RestartTimer(signed long hTimer, int Period);
N#endif
Nint WM_GetTimerId(WM_HTIMER hTimer);
Xint WM_GetTimerId(signed long hTimer);
N
N/* Diagnostics */
Nint WM_GetNumWindows(void);
Nint WM_GetNumInvalidWindows(void);
N
N/* Scroll state related functions */
Nvoid WM_CheckScrollBounds(WM_SCROLL_STATE * pScrollState); /* not to be documented (may change in future version) */
Nint  WM_GetScrollPosH    (WM_HWIN hWin);
Xint  WM_GetScrollPosH    (GUI_HWIN hWin);
Nint  WM_GetScrollPosV    (WM_HWIN hWin);
Xint  WM_GetScrollPosV    (GUI_HWIN hWin);
Nvoid WM_SetScrollPosH    (WM_HWIN hWin, unsigned ScrollPos);
Xvoid WM_SetScrollPosH    (GUI_HWIN hWin, unsigned ScrollPos);
Nvoid WM_SetScrollPosV    (WM_HWIN hWin, unsigned ScrollPos);
Xvoid WM_SetScrollPosV    (GUI_HWIN hWin, unsigned ScrollPos);
Nint  WM_SetScrollValue   (WM_SCROLL_STATE * pScrollState, int v); /* not to be documented (may change in future version) */
N
N/* Get / Set (new) callback function */
NWM_CALLBACK * WM_SetCallback(WM_HWIN hWin, WM_CALLBACK * cb);
XWM_CALLBACK * WM_SetCallback(GUI_HWIN hWin, WM_CALLBACK * cb);
NWM_CALLBACK * WM_GetCallback(WM_HWIN hWin);
XWM_CALLBACK * WM_GetCallback(GUI_HWIN hWin);
N
N/* Get size/origin of a window */
Nvoid      WM_GetClientRect           (GUI_RECT * pRect);
Nvoid      WM_GetClientRectEx         (WM_HWIN hWin, GUI_RECT * pRect);
Xvoid      WM_GetClientRectEx         (GUI_HWIN hWin, GUI_RECT * pRect);
Nvoid      WM_GetContentRect          (GUI_RECT * pRect);
Nvoid      WM_GetContentRectEx        (WM_HWIN hWin, GUI_RECT * pRect);
Xvoid      WM_GetContentRectEx        (GUI_HWIN hWin, GUI_RECT * pRect);
Nvoid      WM_GetInsideRect           (GUI_RECT * pRect);
Nvoid      WM_GetInsideRectEx         (WM_HWIN hWin, GUI_RECT * pRect);
Xvoid      WM_GetInsideRectEx         (GUI_HWIN hWin, GUI_RECT * pRect);
Nvoid      WM_GetInsideRectExScrollbar(WM_HWIN hWin, GUI_RECT * pRect); /* not to be documented (may change in future version) */
Xvoid      WM_GetInsideRectExScrollbar(GUI_HWIN hWin, GUI_RECT * pRect);  
Nvoid      WM_GetWindowRect           (GUI_RECT * pRect);
Nvoid      WM_GetWindowRectEx         (WM_HWIN hWin, GUI_RECT * pRect);
Xvoid      WM_GetWindowRectEx         (GUI_HWIN hWin, GUI_RECT * pRect);
Nint       WM_GetOrgX                 (void);
Nint       WM_GetOrgY                 (void);
Nint       WM_GetWindowOrgX           (WM_HWIN hWin);
Xint       WM_GetWindowOrgX           (GUI_HWIN hWin);
Nint       WM_GetWindowOrgY           (WM_HWIN hWin);
Xint       WM_GetWindowOrgY           (GUI_HWIN hWin);
Nint       WM_GetWindowSizeX          (WM_HWIN hWin);
Xint       WM_GetWindowSizeX          (GUI_HWIN hWin);
Nint       WM_GetWindowSizeY          (WM_HWIN hWin);
Xint       WM_GetWindowSizeY          (GUI_HWIN hWin);
NWM_HWIN   WM_GetFirstChild           (WM_HWIN hWin);
XGUI_HWIN   WM_GetFirstChild           (GUI_HWIN hWin);
NWM_HWIN   WM_GetNextSibling          (WM_HWIN hWin);
XGUI_HWIN   WM_GetNextSibling          (GUI_HWIN hWin);
NWM_HWIN   WM_GetParent               (WM_HWIN hWin);
XGUI_HWIN   WM_GetParent               (GUI_HWIN hWin);
NWM_HWIN   WM_GetPrevSibling          (WM_HWIN hWin);
XGUI_HWIN   WM_GetPrevSibling          (GUI_HWIN hWin);
Nint       WM_GetId                   (WM_HWIN hWin);
Xint       WM_GetId                   (GUI_HWIN hWin);
NWM_HWIN   WM_GetScrollbarV           (WM_HWIN hWin);
XGUI_HWIN   WM_GetScrollbarV           (GUI_HWIN hWin);
NWM_HWIN   WM_GetScrollbarH           (WM_HWIN hWin);
XGUI_HWIN   WM_GetScrollbarH           (GUI_HWIN hWin);
NWM_HWIN   WM_GetScrollerV            (WM_HWIN hWin);
XGUI_HWIN   WM_GetScrollerV            (GUI_HWIN hWin);
NWM_HWIN   WM_GetScrollerH            (WM_HWIN hWin);
XGUI_HWIN   WM_GetScrollerH            (GUI_HWIN hWin);
NWM_HWIN   WM_GetScrollPartner        (WM_HWIN hWin);
XGUI_HWIN   WM_GetScrollPartner        (GUI_HWIN hWin);
NWM_HWIN   WM_GetClientWindow         (WM_HWIN hObj);
XGUI_HWIN   WM_GetClientWindow         (GUI_HWIN hObj);
NGUI_COLOR WM_GetBkColor              (WM_HWIN hObj);
XGUI_COLOR WM_GetBkColor              (GUI_HWIN hObj);
N
N/* Change Z-Order of windows */
Nvoid WM_BringToBottom(WM_HWIN hWin);
Xvoid WM_BringToBottom(GUI_HWIN hWin);
Nvoid WM_BringToTop   (WM_HWIN hWin);
Xvoid WM_BringToTop   (GUI_HWIN hWin);
Nvoid WM_BringBehind  (WM_HWIN hWinFore, WM_HWIN hWinBack);
Xvoid WM_BringBehind  (GUI_HWIN hWinFore, GUI_HWIN hWinBack);
N
NGUI_COLOR WM_SetDesktopColor  (GUI_COLOR Color);
NGUI_COLOR WM_SetDesktopColorEx(GUI_COLOR Color, unsigned int LayerIndex);
Nvoid      WM_SetDesktopColors (GUI_COLOR Color);
N
N/* Select window used for drawing operations */
NWM_HWIN WM_SelectWindow           (WM_HWIN  hWin);
XGUI_HWIN WM_SelectWindow           (GUI_HWIN  hWin);
NWM_HWIN WM_GetActiveWindow        (void);
XGUI_HWIN WM_GetActiveWindow        (void);
Nvoid    WM_Paint                  (WM_HWIN hObj);
Xvoid    WM_Paint                  (GUI_HWIN hObj);
Nvoid    WM_Update                 (WM_HWIN hWin);
Xvoid    WM_Update                 (GUI_HWIN hWin);
Nvoid    WM_PaintWindowAndDescs    (WM_HWIN hWin);
Xvoid    WM_PaintWindowAndDescs    (GUI_HWIN hWin);
Nvoid    WM_UpdateWindowAndDescs   (WM_HWIN hWin);
Xvoid    WM_UpdateWindowAndDescs   (GUI_HWIN hWin);
N
N/* Get foreground/background windows */
NWM_HWIN WM_GetDesktopWindow  (void);
XGUI_HWIN WM_GetDesktopWindow  (void);
NWM_HWIN WM_GetDesktopWindowEx(unsigned int LayerIndex);
XGUI_HWIN WM_GetDesktopWindowEx(unsigned int LayerIndex);
N
N/* Reduce clipping area of a window */
Nconst GUI_RECT * WM_SetUserClipRect(const GUI_RECT * pRect);
Nvoid             WM_SetDefault     (void);
N
N/* Use of memory devices */
Nvoid WM_EnableMemdev              (WM_HWIN hWin);
Xvoid WM_EnableMemdev              (GUI_HWIN hWin);
Nvoid WM_DisableMemdev             (WM_HWIN hWin);
Xvoid WM_DisableMemdev             (GUI_HWIN hWin);
N
N/* Automatic use of multiple buffers */
Nint WM_MULTIBUF_Enable  (int OnOff);
Nint WM_MULTIBUF_EnableEx(int OnOff, U32 LayerMask);
Xint WM_MULTIBUF_EnableEx(int OnOff, unsigned long LayerMask);
N
Nextern const GUI_MULTIBUF_API * WM_MULTIBUF__pAPI;
N
Ntypedef void (* T_WM_EXEC_GESTURE)(void);
N
Nextern T_WM_EXEC_GESTURE WM__pExecGestures;
N
N/* ... */
Nint WM_OnKey(int Key, int Pressed);
N
N/* Modal related functions */
Nvoid    WM_MakeModal(WM_HWIN hWin);
Xvoid    WM_MakeModal(GUI_HWIN hWin);
NWM_HWIN WM_GetModalWindow(void);
XGUI_HWIN WM_GetModalWindow(void);
Nint     WM_SetModalLayer(int LayerIndex);
Nint     WM_GetModalLayer(void);
N
N/*********************************************************************
N*
N*       Message related functions
N*
N*  Please note that some of these functions do not yet show up in the
N*  documentation, as they should not be required by application program.
N*/
Nvoid      WM_NotifyParent         (WM_HWIN hWin, int Notification);
Xvoid      WM_NotifyParent         (GUI_HWIN hWin, int Notification);
Nvoid      WM_SendMessage          (WM_HWIN hWin, WM_MESSAGE * p);
Xvoid      WM_SendMessage          (GUI_HWIN hWin, WM_MESSAGE * p);
Nvoid      WM_SendMessageNoPara    (WM_HWIN hWin, int MsgId);             /* not to be documented (may change in future */
Xvoid      WM_SendMessageNoPara    (GUI_HWIN hWin, int MsgId);              
Nvoid      WM_DefaultProc          (WM_MESSAGE * pMsg);
Nint       WM_BroadcastMessage     (WM_MESSAGE * pMsg);
Nvoid      WM_SetScrollState       (WM_HWIN hWin, const WM_SCROLL_STATE * pState);
Xvoid      WM_SetScrollState       (GUI_HWIN hWin, const WM_SCROLL_STATE * pState);
Nvoid      WM_SetEnableState       (WM_HWIN hItem, int State);
Xvoid      WM_SetEnableState       (GUI_HWIN hItem, int State);
Nvoid      WM_SendToParent         (WM_HWIN hWin, WM_MESSAGE * pMsg);
Xvoid      WM_SendToParent         (GUI_HWIN hWin, WM_MESSAGE * pMsg);
Nint       WM_HasFocus             (WM_HWIN hWin);
Xint       WM_HasFocus             (GUI_HWIN hWin);
Nint       WM_SetFocus             (WM_HWIN hWin);
Xint       WM_SetFocus             (GUI_HWIN hWin);
NWM_HWIN   WM_SetFocusOnNextChild  (WM_HWIN hParent);     /* Set the focus to the next child */
XGUI_HWIN   WM_SetFocusOnNextChild  (GUI_HWIN hParent);      
NWM_HWIN   WM_SetFocusOnPrevChild  (WM_HWIN hParent);     /* Set the focus to the previous child */
XGUI_HWIN   WM_SetFocusOnPrevChild  (GUI_HWIN hParent);      
NWM_HWIN   WM_GetDialogItem        (WM_HWIN hWin, int Id);
XGUI_HWIN   WM_GetDialogItem        (GUI_HWIN hWin, int Id);
Nvoid      WM_EnableWindow         (WM_HWIN hWin);
Xvoid      WM_EnableWindow         (GUI_HWIN hWin);
Nvoid      WM_DisableWindow        (WM_HWIN hWin);
Xvoid      WM_DisableWindow        (GUI_HWIN hWin);
Nvoid      WM_GetScrollState       (WM_HWIN hObj, WM_SCROLL_STATE * pScrollState);
Xvoid      WM_GetScrollState       (GUI_HWIN hObj, WM_SCROLL_STATE * pScrollState);
NWM_HWIN   WM_GetChild             (WM_HWIN hWin, int Id);
XGUI_HWIN   WM_GetChild             (GUI_HWIN hWin, int Id);
N
N/*********************************************************************
N*
N*       Managing user data
N*/
Nint       WM_GetUserData   (WM_HWIN hWin, void * pDest, int SizeOfBuffer);
Xint       WM_GetUserData   (GUI_HWIN hWin, void * pDest, int SizeOfBuffer);
Nint       WM_SetUserData   (WM_HWIN hWin, const void * pSrc, int SizeOfBuffer);
Xint       WM_SetUserData   (GUI_HWIN hWin, const void * pSrc, int SizeOfBuffer);
Nint       WM__GetUserDataEx(WM_HWIN hWin, void * pDest, int NumBytes, int SizeOfObject);
Xint       WM__GetUserDataEx(GUI_HWIN hWin, void * pDest, int NumBytes, int SizeOfObject);
Nint       WM__SetUserDataEx(WM_HWIN hWin, const void * pSrc, int NumBytes, int SizeOfObject);
Xint       WM__SetUserDataEx(GUI_HWIN hWin, const void * pSrc, int NumBytes, int SizeOfObject);
N
N/*********************************************************************
N*
N*       Capturing input focus
N*/
Nint     WM_HasCaptured   (WM_HWIN hWin);
Xint     WM_HasCaptured   (GUI_HWIN hWin);
NWM_HWIN WM_GetCapture    (int * pAutoRelease);
XGUI_HWIN WM_GetCapture    (int * pAutoRelease);
Nvoid    WM_SetCapture    (WM_HWIN hObj, int AutoRelease);
Xvoid    WM_SetCapture    (GUI_HWIN hObj, int AutoRelease);
Nvoid    WM_SetCaptureMove(WM_HWIN hWin, const GUI_PID_STATE * pState, int MinVisibility, int LimitTop); /* Not yet documented */
Xvoid    WM_SetCaptureMove(GUI_HWIN hWin, const GUI_PID_STATE * pState, int MinVisibility, int LimitTop);  
Nvoid    WM_ReleaseCapture(void);
N
N/*********************************************************************
N*
N*       Misc routines
N*/
Nint       WM_HandlePID      (void);
NWM_HWIN   WM_Screen2hWin    (int x, int y);
XGUI_HWIN   WM_Screen2hWin    (int x, int y);
NWM_HWIN   WM_Screen2hWinEx  (WM_HWIN hStop, int x, int y);
XGUI_HWIN   WM_Screen2hWinEx  (GUI_HWIN hStop, int x, int y);
Nvoid      WM_ForEachDesc    (WM_HWIN hWin, WM_tfForEach * pcb, void * pData);
Xvoid      WM_ForEachDesc    (GUI_HWIN hWin, WM_tfForEach * pcb, void * pData);
Nvoid      WM_SetScreenSize  (int xSize, int ySize);
Nint       WM_PollSimMsg     (void);
Nint       WM_GetWindowInfo  (WM_WINDOW_INFO * pInfo, int FirstWindow);
Nvoid      WM_EnablePID      (int OnOff);
Nint       WM_IsEnabledPID   (void);
N
N/*********************************************************************
N*
N*       Diagnostics routines
N*/
N#if (WM_SUPPORT_DIAG)
X#if (0)
Svoid WM_DIAG_EnableInvalidationColoring(int OnOff);
N#endif
N
N/*********************************************************************
N*
N*       Macros for compatibility with older versions
N*/
N#if WM_COMPATIBLE_MODE
X#if 1
N  #define WM_HideWin        WM_HideWindow
N  #define WM_ShowWin        WM_ShowWindow
N  #define WM_ExecIdle       WM_Exec
N  #define WM_ExecIdle1      WM_Exec1
N  #define WM_Invalidate     WM_InvalidateWindow
N  #define WM_GetXSize       WM_GetWindowSizeX
N  #define WM_GetYSize       WM_GetWindowSizeY
N  #define WM_SetUserClipArea WM_SetUserClipRect
N#endif
N
N#endif   /* GUI_WINSUPPORT */
N
N#if defined(__cplusplus)
X#if 0L
S}
N#endif
N
N#endif   /* WM_H */
N
N/*************************** End of file ****************************/
L 49 "..\..\..\..\ThirdParty\emWin\Include\DIALOG.h" 2
N
N#include "BUTTON.h"
L 1 "..\..\..\..\ThirdParty\emWin\Include\BUTTON.h" 1
N/*********************************************************************
N*                    SEGGER Microcontroller GmbH                     *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2023  SEGGER Microcontroller GmbH                *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V6.46 - Graphical user interface for embedded applications **
NemWin is protected by international copyright laws. Knowledge of the
Nsource code may not be used to write a similar product. 
NThis file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed by SEGGER Software GmbH to Nuvoton Technology Corporation
Nat the address: No. 4, Creation Rd. III, Hsinchu Science Park, Taiwan
Nfor the purposes  of  creating  libraries  for its 
NArm Cortex-A, Arm Cortex-M and  Arm9 32-bit microcontrollers, commercialized and distributed by Nuvoton Technology Corporation
Nunder  the terms and conditions  of  an  End  User  
NLicense  Agreement  supplied  with  the libraries.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NLicensing information
NLicensor:                 SEGGER Software GmbH
NLicensed to:              Nuvoton Technology Corporation, No. 4, Creation Rd. III, Hsinchu Science Park, 30077 Hsinchu City, Taiwan
NLicensed SEGGER software: emWin
NLicense number:           GUI-00735
NLicense model:            emWin License Agreement, signed February 27, 2018
NLicensed platform:        Cortex-M, Cortex-A, and ARM9 32-bit series microcontroller designed and manufactured by Nuvoton Technology Corporation.
N----------------------------------------------------------------------
NSupport and Update Agreement (SUA)
NSUA period:               2018-03-26 - 2025-09-04
NContact to extend SUA:    sales@segger.com
N----------------------------------------------------------------------
NFile        : BUTTON.h
NPurpose     : BUTTON public header file (API)
N--------------------END-OF-HEADER-------------------------------------
N*/
N
N#ifndef BUTTON_H
N#define BUTTON_H
N
N#include "WM.h"
N#include "DIALOG_Type.h"      /* Req. for Create indirect data structure */
L 1 "..\..\..\..\ThirdParty\emWin\Include\DIALOG_Type.h" 1
N/*********************************************************************
N*                    SEGGER Microcontroller GmbH                     *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2023  SEGGER Microcontroller GmbH                *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V6.46 - Graphical user interface for embedded applications **
NemWin is protected by international copyright laws. Knowledge of the
Nsource code may not be used to write a similar product. 
NThis file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed by SEGGER Software GmbH to Nuvoton Technology Corporation
Nat the address: No. 4, Creation Rd. III, Hsinchu Science Park, Taiwan
Nfor the purposes  of  creating  libraries  for its 
NArm Cortex-A, Arm Cortex-M and  Arm9 32-bit microcontrollers, commercialized and distributed by Nuvoton Technology Corporation
Nunder  the terms and conditions  of  an  End  User  
NLicense  Agreement  supplied  with  the libraries.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NLicensing information
NLicensor:                 SEGGER Software GmbH
NLicensed to:              Nuvoton Technology Corporation, No. 4, Creation Rd. III, Hsinchu Science Park, 30077 Hsinchu City, Taiwan
NLicensed SEGGER software: emWin
NLicense number:           GUI-00735
NLicense model:            emWin License Agreement, signed February 27, 2018
NLicensed platform:        Cortex-M, Cortex-A, and ARM9 32-bit series microcontroller designed and manufactured by Nuvoton Technology Corporation.
N----------------------------------------------------------------------
NSupport and Update Agreement (SUA)
NSUA period:               2018-03-26 - 2025-09-04
NContact to extend SUA:    sales@segger.com
N----------------------------------------------------------------------
NFile        : DIALOG_Type.h
NPurpose     : Dialog box include
N--------------------END-OF-HEADER-------------------------------------
N*/
N
N#ifndef DIALOG_TYPE_H
N#define DIALOG_TYPE_H
N
N#include "WM.h"
N
N#if GUI_WINSUPPORT
X#if 1
N
N#if defined(__cplusplus)
X#if 0L
S  extern "C" {        // Make sure we have C-declarations in C++ programs
N#endif
N
N/*********************************************************************
N*
N*       Types
N*
N**********************************************************************
N*/
Ntypedef struct  GUI_WIDGET_CREATE_INFO_struct GUI_WIDGET_CREATE_INFO;
Ntypedef WM_HWIN GUI_WIDGET_CREATE_FUNC        (const GUI_WIDGET_CREATE_INFO * pCreate, WM_HWIN hWin, int x0, int y0, WM_CALLBACK * cb);
Xtypedef GUI_HWIN GUI_WIDGET_CREATE_FUNC        (const GUI_WIDGET_CREATE_INFO * pCreate, GUI_HWIN hWin, int x0, int y0, WM_CALLBACK * cb);
N
N/*********************************************************************
N*
N*       Structures
N*
N**********************************************************************
N*/
Nstruct GUI_WIDGET_CREATE_INFO_struct {
N  GUI_WIDGET_CREATE_FUNC * pfCreateIndirect;
N  const char             * pName;            // Text ... Not used on all widgets
N  I16                      Id;               // ID ... should be unique in a dialog
X  signed short                      Id;               
N  I16                      x0;               // x position
X  signed short                      x0;               
N  I16                      y0;               // y position
X  signed short                      y0;               
N  I16                      xSize;            // x size
X  signed short                      xSize;            
N  I16                      ySize;            // y size
X  signed short                      ySize;            
N  U32                      Flags;            // Widget specific create flags (opt.)
X  unsigned long                      Flags;            
N  I32                      Para;             // Widget specific parameter (opt.)
X  signed long                      Para;             
N  U32                      NumExtraBytes;    // Number of extra bytes usable with <WIDGET>_SetUserData & <WIDGET>_GetUserData
X  unsigned long                      NumExtraBytes;    
N};
N
N/*********************************************************************
N*
N*       Public API functions
N*
N**********************************************************************
N*/
NWM_HWIN            GUI_CreateDialogBox   (const GUI_WIDGET_CREATE_INFO * paWidget, int NumWidgets, WM_CALLBACK * cb, WM_HWIN hParent, int x0, int y0);
XGUI_HWIN            GUI_CreateDialogBox   (const GUI_WIDGET_CREATE_INFO * paWidget, int NumWidgets, WM_CALLBACK * cb, GUI_HWIN hParent, int x0, int y0);
Nvoid               GUI_EndDialog         (WM_HWIN hWin, int r);
Xvoid               GUI_EndDialog         (GUI_HWIN hWin, int r);
Nint                GUI_ExecDialogBox     (const GUI_WIDGET_CREATE_INFO * paWidget, int NumWidgets, WM_CALLBACK * cb, WM_HWIN hParent, int x0, int y0);
Xint                GUI_ExecDialogBox     (const GUI_WIDGET_CREATE_INFO * paWidget, int NumWidgets, WM_CALLBACK * cb, GUI_HWIN hParent, int x0, int y0);
Nint                GUI_ExecCreatedDialog (WM_HWIN hDialog);
Xint                GUI_ExecCreatedDialog (GUI_HWIN hDialog);
NWM_DIALOG_STATUS * GUI_GetDialogStatusPtr(WM_HWIN hDialog);                                    // Not to be documented
XWM_DIALOG_STATUS * GUI_GetDialogStatusPtr(GUI_HWIN hDialog);                                    
Nvoid               GUI_SetDialogStatusPtr(WM_HWIN hDialog, WM_DIALOG_STATUS * pDialogStatus);  // Not to be documented
Xvoid               GUI_SetDialogStatusPtr(GUI_HWIN hDialog, WM_DIALOG_STATUS * pDialogStatus);  
N
N/*********************************************************************
N*
N*       Obsolete
N*/
NLCD_COLOR          DIALOG_GetBkColor(void);
NLCD_COLOR          DIALOG_SetBkColor(LCD_COLOR BkColor);
N
N#if defined(__cplusplus)
X#if 0L
S  }
N#endif
N
N#endif  // GUI_WINSUPPORT
N#endif  // DIALOG_TYPE_H
N
N/*************************** End of file ****************************/
L 50 "..\..\..\..\ThirdParty\emWin\Include\BUTTON.h" 2
N#include "WIDGET.h"
L 1 "..\..\..\..\ThirdParty\emWin\Include\WIDGET.h" 1
N/*********************************************************************
N*                    SEGGER Microcontroller GmbH                     *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2023  SEGGER Microcontroller GmbH                *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V6.46 - Graphical user interface for embedded applications **
NemWin is protected by international copyright laws. Knowledge of the
Nsource code may not be used to write a similar product. 
NThis file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed by SEGGER Software GmbH to Nuvoton Technology Corporation
Nat the address: No. 4, Creation Rd. III, Hsinchu Science Park, Taiwan
Nfor the purposes  of  creating  libraries  for its 
NArm Cortex-A, Arm Cortex-M and  Arm9 32-bit microcontrollers, commercialized and distributed by Nuvoton Technology Corporation
Nunder  the terms and conditions  of  an  End  User  
NLicense  Agreement  supplied  with  the libraries.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NLicensing information
NLicensor:                 SEGGER Software GmbH
NLicensed to:              Nuvoton Technology Corporation, No. 4, Creation Rd. III, Hsinchu Science Park, 30077 Hsinchu City, Taiwan
NLicensed SEGGER software: emWin
NLicense number:           GUI-00735
NLicense model:            emWin License Agreement, signed February 27, 2018
NLicensed platform:        Cortex-M, Cortex-A, and ARM9 32-bit series microcontroller designed and manufactured by Nuvoton Technology Corporation.
N----------------------------------------------------------------------
NSupport and Update Agreement (SUA)
NSUA period:               2018-03-26 - 2025-09-04
NContact to extend SUA:    sales@segger.com
N----------------------------------------------------------------------
NFile        : WIDGET.h
NPurpose     : Widget interface
N---------------------------END-OF-HEADER------------------------------
N*/
N
N#ifndef WIDGET_H        /* Avoid multiple inclusion  */
N#define WIDGET_H
N
N#if defined(__cplusplus)
X#if 0L
Sextern "C" {     /* Make sure we have C-declarations in C++ programs */
N#endif
N
N#include "WM.h"  /* Window manager, including some internals, which speed things up */
N#include "GUI_Debug.h"
L 1 "..\..\..\..\ThirdParty\emWin\Include\GUI_Debug.h" 1
N/*********************************************************************
N*                    SEGGER Microcontroller GmbH                     *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2023  SEGGER Microcontroller GmbH                *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V6.46 - Graphical user interface for embedded applications **
NemWin is protected by international copyright laws. Knowledge of the
Nsource code may not be used to write a similar product. 
NThis file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed by SEGGER Software GmbH to Nuvoton Technology Corporation
Nat the address: No. 4, Creation Rd. III, Hsinchu Science Park, Taiwan
Nfor the purposes  of  creating  libraries  for its 
NArm Cortex-A, Arm Cortex-M and  Arm9 32-bit microcontrollers, commercialized and distributed by Nuvoton Technology Corporation
Nunder  the terms and conditions  of  an  End  User  
NLicense  Agreement  supplied  with  the libraries.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NLicensing information
NLicensor:                 SEGGER Software GmbH
NLicensed to:              Nuvoton Technology Corporation, No. 4, Creation Rd. III, Hsinchu Science Park, 30077 Hsinchu City, Taiwan
NLicensed SEGGER software: emWin
NLicense number:           GUI-00735
NLicense model:            emWin License Agreement, signed February 27, 2018
NLicensed platform:        Cortex-M, Cortex-A, and ARM9 32-bit series microcontroller designed and manufactured by Nuvoton Technology Corporation.
N----------------------------------------------------------------------
NSupport and Update Agreement (SUA)
NSUA period:               2018-03-26 - 2025-09-04
NContact to extend SUA:    sales@segger.com
N----------------------------------------------------------------------
NFile        : GUI_Debug.h
NPurpose     : Debug macros
N----------------------------------------------------------------------
N   Debug macros for logging
N
N In the GUI Simulation, all output is transferred into the log window.
N*/
N
N#ifndef GUI_DEBUG_H
N#define GUI_DEBUG_H
N
N#include <stddef.h>
N
N#include "GUI.h"
N
N#define GUI_DEBUG_LEVEL_NOCHECK       0  /* No run time checks are performed */
N#define GUI_DEBUG_LEVEL_CHECK_PARA    1  /* Parameter checks are performed to avoid crashes */
N#define GUI_DEBUG_LEVEL_CHECK_ALL     2  /* Parameter checks and consistency checks are performed */
N#define GUI_DEBUG_LEVEL_LOG_ERRORS    3  /* Errors are recorded */
N#define GUI_DEBUG_LEVEL_LOG_WARNINGS  4  /* Errors & Warnings are recorded */
N#define GUI_DEBUG_LEVEL_LOG_ALL       5  /* Errors, Warnings and Messages are recorded. */
N
N#ifndef GUI_DEBUG_LEVEL
N  #ifdef WIN32
S    #define GUI_DEBUG_LEVEL GUI_DEBUG_LEVEL_LOG_WARNINGS  /* Simulation should log all warnings */
N  #else
N    #define GUI_DEBUG_LEVEL GUI_DEBUG_LEVEL_NOCHECK       /* For most targets, min. size is important */
N  #endif
N#endif
N
N#define GUI_LOCK_H(hMem)   GUI_ALLOC_LockH(hMem)
N#define GUI_UNLOCK_H(pMem) GUI_ALLOC_UnlockH((void **)&pMem)
N#define GUI_UNLOCK_C(pMem) GUI_ALLOC_UnlockC((const void **)&pMem)
N
N/*******************************************************************
N*
N*               Commandline
N*
N********************************************************************
N*/
N
N#ifdef WIN32
S  #define GUI_DEBUG_GETCMDLINE() SIM_GetCmdLine()
N#else
N  #define GUI_DEBUG_GETCMDLINE() 0
N#endif
N
N/*******************************************************************
N*
N*               Error macros
N*
N********************************************************************
N*/
N
N/* Make sure the macros are actually defined */
N
N#if GUI_DEBUG_LEVEL >= GUI_DEBUG_LEVEL_LOG_ERRORS
X#if 0 >= 3
S  #define GUI_DEBUG_ERROROUT(s)              GUI_ErrorOut(s)
S  #define GUI_DEBUG_ERROROUT1(s,p0)          GUI_ErrorOut1(s,p0)
S  #define GUI_DEBUG_ERROROUT2(s,p0,p1)       GUI_ErrorOut2(s,p0,p1)
S  #define GUI_DEBUG_ERROROUT3(s,p0,p1,p2)    GUI_ErrorOut3(s,p0,p1,p2)
S  #define GUI_DEBUG_ERROROUT4(s,p0,p1,p2,p3) GUI_ErrorOut4(s,p0,p1,p2,p3)
S  #define GUI_DEBUG_ERROROUT_IF(exp,s)              { if (exp) GUI_DEBUG_ERROROUT(s); }
S  #define GUI_DEBUG_ERROROUT1_IF(exp,s,p0)          { if (exp) GUI_DEBUG_ERROROUT1(s,p0); }
S  #define GUI_DEBUG_ERROROUT2_IF(exp,s,p0,p1)       { if (exp) GUI_DEBUG_ERROROUT2(s,p0,p1); }
S  #define GUI_DEBUG_ERROROUT3_IF(exp,s,p0,p1,p2)    { if (exp) GUI_DEBUG_ERROROUT3(s,p0,p1,p2); }
S  #define GUI_DEBUG_ERROROUT4_IF(exp,s,p0,p1,p2,p3) { if (exp) GUI_DEBUG_ERROROUT4(s,p0,p1,p2,p3); }
N#else
N  #define GUI_DEBUG_ERROROUT(s)
N  #define GUI_DEBUG_ERROROUT1(s,p0)
N  #define GUI_DEBUG_ERROROUT2(s,p0,p1)
N  #define GUI_DEBUG_ERROROUT3(s,p0,p1,p2)
N  #define GUI_DEBUG_ERROROUT4(s,p0,p1,p2,p3)
N  #define GUI_DEBUG_ERROROUT_IF(exp,s)
N  #define GUI_DEBUG_ERROROUT1_IF(exp,s,p0)
N  #define GUI_DEBUG_ERROROUT2_IF(exp,s,p0,p1)
N  #define GUI_DEBUG_ERROROUT3_IF(exp,s,p0,p1,p2)
N  #define GUI_DEBUG_ERROROUT4_IF(exp,s,p0,p1,p2,p3)
N#endif
N
N/*******************************************************************
N*
N*               Warning macros
N*
N********************************************************************
N*/
N
N/* Make sure the macros are actually defined */
N
N#if GUI_DEBUG_LEVEL >= GUI_DEBUG_LEVEL_LOG_WARNINGS
X#if 0 >= 4
S  #define GUI_DEBUG_WARN(s)              GUI_Warn(s)
S  #define GUI_DEBUG_WARN1(s,p0)          GUI_Warn1(s,p0)
S  #define GUI_DEBUG_WARN2(s,p0,p1)       GUI_Warn2(s,p0,p1)
S  #define GUI_DEBUG_WARN3(s,p0,p1,p2)    GUI_Warn3(s,p0,p1,p2)
S  #define GUI_DEBUG_WARN4(s,p0,p1,p2,p3) GUI_Warn4(s,p0,p1,p2,p3)
S  #define GUI_DEBUG_WARN_IF(exp,s)                  { if (exp) GUI_DEBUG_WARN(s); }
S  #define GUI_DEBUG_WARN1_IF(exp,s,p0)              { if (exp) GUI_DEBUG_WARN1(s,p0); }
S  #define GUI_DEBUG_WARN2_IF(exp,s,p0,p1)           { if (exp) GUI_DEBUG_WARN2(s,p0,p1); }
S  #define GUI_DEBUG_WARN3_IF(exp,s,p0,p1,p2)        { if (exp) GUI_DEBUG_WARN3(s,p0,p1,p2); }
S  #define GUI_DEBUG_WARN4_IF(exp,s,p0,p1,p2,p3)     { if (exp) GUI_DEBUG_WARN4(s,p0,p1,p2,p3); }
N#else
N  #define GUI_DEBUG_WARN(s)
N  #define GUI_DEBUG_WARN1(s,p0)
N  #define GUI_DEBUG_WARN2(s,p0,p1)
N  #define GUI_DEBUG_WARN3(s,p0,p1,p2)
N  #define GUI_DEBUG_WARN4(s,p0,p1,p2,p3)
N  #define GUI_DEBUG_WARN_IF(exp,s)
N  #define GUI_DEBUG_WARN1_IF(exp,s,p0)
N  #define GUI_DEBUG_WARN2_IF(exp,s,p0,p1)
N  #define GUI_DEBUG_WARN3_IF(exp,s,p0,p1,p2)
N  #define GUI_DEBUG_WARN4_IF(exp,s,p0,p1,p2,p3)
N#endif
N
N/*******************************************************************
N*
N*               Logging macros
N*
N********************************************************************
N*/
N/* Make sure the macros are actually defined */
N
N#if GUI_DEBUG_LEVEL >= GUI_DEBUG_LEVEL_LOG_ALL
X#if 0 >= 5
S  #define GUI_DEBUG_LOG(s)              GUI_Log(s)
S  #define GUI_DEBUG_LOG1(s,p0)          GUI_Log1(s,p0)
S  #define GUI_DEBUG_LOG2(s,p0,p1)       GUI_Log2(s,p0,p1)
S  #define GUI_DEBUG_LOG3(s,p0,p1,p2)    GUI_Log3(s,p0,p1,p2)
S  #define GUI_DEBUG_LOG4(s,p0,p1,p2,p3) GUI_Log4(s,p0,p1,p2,p3)
S  #define GUI_DEBUG_LOG_IF(exp,s)                   { if (exp) GUI_DEBUG_LOG(s); }
S  #define GUI_DEBUG_LOG1_IF(exp,s,p0)               { if (exp) GUI_DEBUG_LOG1(s,p0); }
S  #define GUI_DEBUG_LOG2_IF(exp,s,p0,p1)            { if (exp) GUI_DEBUG_LOG2(s,p0,p1); }
S  #define GUI_DEBUG_LOG3_IF(exp,s,p0,p1,p2)         { if (exp) GUI_DEBUG_LOG3(s,p0,p1,p2); }
S  #define GUI_DEBUG_LOG4_IF(exp,s,p0,p1,p2,p3)      { if (exp) GUI_DEBUG_LOG4(s,p0,p1,p2,p3); }
N#else
N  #define GUI_DEBUG_LOG(s)
N  #define GUI_DEBUG_LOG1(s,p0)
N  #define GUI_DEBUG_LOG2(s,p0,p1)
N  #define GUI_DEBUG_LOG3(s,p0,p1,p2)
N  #define GUI_DEBUG_LOG4(s,p0,p1,p2,p3)
N  #define GUI_DEBUG_LOG_IF(exp,s)
N  #define GUI_DEBUG_LOG1_IF(exp,s,p0)
N  #define GUI_DEBUG_LOG2_IF(exp,s,p0,p1)
N  #define GUI_DEBUG_LOG3_IF(exp,s,p0,p1,p2)
N  #define GUI_DEBUG_LOG4_IF(exp,s,p0,p1,p2,p3)
N#endif
N
N/*******************************************************************
N*
N*               Asserts
N*
N********************************************************************
N*/
N#if GUI_DEBUG_LEVEL >= GUI_DEBUG_LEVEL_LOG_ERRORS
X#if 0 >= 3
S  #define GUI_DEBUG_ASSERT(exp)                     { if (!exp) GUI_DEBUG_ERROROUT(#exp); }
N#else
N  #define GUI_DEBUG_ASSERT(exp)
N#endif
N
N#endif /* LCD_H */
N
N
N
N
N/*************************** End of file ****************************/
L 54 "..\..\..\..\ThirdParty\emWin\Include\WIDGET.h" 2
N
N#if GUI_WINSUPPORT
X#if 1
N
N/*********************************************************************
N*
N*       Typedefs
N*
N**********************************************************************
N*/
Ntypedef struct {
N  WM_HWIN    hWin;
X  GUI_HWIN    hWin;
N  int        Cmd;         /* WIDGET_ITEM_GET_XSIZE, WIDGET_ITEM_GET_YSIZE, WIDGET_ITEM_DRAW, */
N  int        ItemIndex;
N  int        Col;
N  int        x0, y0, x1, y1;
N  I32        Angle;
X  signed long        Angle;
N  void     * p;
N} WIDGET_ITEM_DRAW_INFO;
N
Ntypedef int  WIDGET_DRAW_ITEM_FUNC(const WIDGET_ITEM_DRAW_INFO * pDrawItemInfo);
Ntypedef void WIDGET_PAINT         (WM_HWIN hObj);
Xtypedef void WIDGET_PAINT         (GUI_HWIN hObj);
Ntypedef void WIDGET_CREATE        (WM_HWIN hObj);
Xtypedef void WIDGET_CREATE        (GUI_HWIN hObj);
N
Ntypedef struct {
N  WIDGET_PAINT  * pfPaint;
N  WIDGET_CREATE * pfCreate;
N  void          * pSkinPrivate;
N} WIDGET_SKIN;
N
N/*********************************************************************
N*
N*       WIDGET_COPY
N* 
N*  Description
N*    To be used for copy-optimizations when swiping data.
N*/
Ntypedef struct {
N  I16 x0, y0, x1, y1, xSize, ySize;
X  signed short x0, y0, x1, y1, xSize, ySize;
N} WIDGET_COPY;
N
N/*********************************************************************
N*
N*       WIDGET_SCROLLSTATE_API
N* 
N*  Description
N*    API for conversion between vertical motion and WM_SCROLL_STATE.
N* 
N*    Note: hParent is always the scrollable widget, it is the parent of
N*    a SCROLLER.
N*/
Ntypedef struct {
N  //
N  // Getters
N  //
N  int          (* pfGetScrollPosX)       (WM_HWIN hParent);
X  int          (* pfGetScrollPosX)       (GUI_HWIN hParent);
N  void         (* pfGetScrollPosY)       (WM_HWIN hParent, int * pScrollStateV, int * pMotionPosY);
X  void         (* pfGetScrollPosY)       (GUI_HWIN hParent, int * pScrollStateV, int * pMotionPosY);
N  unsigned     (* pfGetNumRows)          (WM_HWIN hParent);
X  unsigned     (* pfGetNumRows)          (GUI_HWIN hParent);
N  int          (* pfGetRowHeight)        (WM_HWIN hParent);
X  int          (* pfGetRowHeight)        (GUI_HWIN hParent);
N  int          (* pfGetYOffset)          (WM_HWIN hParent);
X  int          (* pfGetYOffset)          (GUI_HWIN hParent);
N  int          (* pfGetItemPosY)         (WM_HWIN hParent, unsigned Index);
X  int          (* pfGetItemPosY)         (GUI_HWIN hParent, unsigned Index);
N  int          (* pfGetIndexFromItemPosY)(WM_HWIN hParent, int ScrollStateV, int * pRemainder);
X  int          (* pfGetIndexFromItemPosY)(GUI_HWIN hParent, int ScrollStateV, int * pRemainder);
N  int          (* pfGetMaxMotionPosX)    (WM_HWIN hParent);
X  int          (* pfGetMaxMotionPosX)    (GUI_HWIN hParent);
N  int          (* pfGetMaxMotionPosY)    (WM_HWIN hParent);
X  int          (* pfGetMaxMotionPosY)    (GUI_HWIN hParent);
N  unsigned     (* pfGetOverlap)          (WM_HWIN hParent, int * pPeriod, U8 * pFlags);
X  unsigned     (* pfGetOverlap)          (GUI_HWIN hParent, int * pPeriod, unsigned char * pFlags);
N  //
N  // Setters
N  //
N  void         (* pfSetScrollPosX)       (WM_HWIN hParent, int ScrollStateH);
X  void         (* pfSetScrollPosX)       (GUI_HWIN hParent, int ScrollStateH);
N  void         (* pfSetScrollPosY)       (WM_HWIN hParent, int ScrollStateV, int MotionPosY);
X  void         (* pfSetScrollPosY)       (GUI_HWIN hParent, int ScrollStateV, int MotionPosY);
N  //
N  // Properties
N  //
N  U8              IndvRowHeight; // 1 if each row can have a different height, 0 if not
X  unsigned char              IndvRowHeight; 
N  U8              NoConv;        // 1 if no conversion is necessary
X  unsigned char              NoConv;        
N} WIDGET_SCROLLSTATE_API;
N
N/*********************************************************************
N*
N*       WIDGET_ENABLE_MOTION_CONTEXT
N* 
N*  Description
N*    Context for WIDGET__EnableMotion().
N*    With the context the routine knows which exact flags should be set
N*    or removed.
N*/
Ntypedef struct {
N  void    * pFlags;           // Pointer to Flags of the widget's object struct.
N  U8        SizeOfFlags;      // Size of pFlags (pFlags can be U8, U16, U32).
X  unsigned char        SizeOfFlags;      
N  U32       FlagMotionH;      // Copy of <WIDGET>_CF_MOTION_H (e.g. LISTVIEW_CF_MOTION_H)
X  unsigned long       FlagMotionH;      
N  U32       FlagMotionV;      // Copy of <WIDGET>_CF_MOTION_V
X  unsigned long       FlagMotionV;      
N  U32       FlagAutoScrollH;  // Copy of <WIDGET>_CF_AUTOSCROLL_H
X  unsigned long       FlagAutoScrollH;  
N  U32       FlagAutoScrollV;  // Copy of <WIDGET>_CF_AUTOSCROLL_V
X  unsigned long       FlagAutoScrollV;  
N  WM_HMEM * phContext;        // Pointer to widget's motion context for (de)allocation.
X  signed long * phContext;        
N} WIDGET_ENABLE_MOTION_CONTEXT;
N
N/*********************************************************************
N*
N*       Important: WIDGET_DRAW_ITEM_FUNC needs to be defined
N*                  in SCROLLBAR.h!
N*
N**********************************************************************
N*/
N#include "SCROLLBAR.h"
L 1 "..\..\..\..\ThirdParty\emWin\Include\SCROLLBAR.h" 1
N/*********************************************************************
N*                    SEGGER Microcontroller GmbH                     *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2023  SEGGER Microcontroller GmbH                *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V6.46 - Graphical user interface for embedded applications **
NemWin is protected by international copyright laws. Knowledge of the
Nsource code may not be used to write a similar product. 
NThis file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed by SEGGER Software GmbH to Nuvoton Technology Corporation
Nat the address: No. 4, Creation Rd. III, Hsinchu Science Park, Taiwan
Nfor the purposes  of  creating  libraries  for its 
NArm Cortex-A, Arm Cortex-M and  Arm9 32-bit microcontrollers, commercialized and distributed by Nuvoton Technology Corporation
Nunder  the terms and conditions  of  an  End  User  
NLicense  Agreement  supplied  with  the libraries.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NLicensing information
NLicensor:                 SEGGER Software GmbH
NLicensed to:              Nuvoton Technology Corporation, No. 4, Creation Rd. III, Hsinchu Science Park, 30077 Hsinchu City, Taiwan
NLicensed SEGGER software: emWin
NLicense number:           GUI-00735
NLicense model:            emWin License Agreement, signed February 27, 2018
NLicensed platform:        Cortex-M, Cortex-A, and ARM9 32-bit series microcontroller designed and manufactured by Nuvoton Technology Corporation.
N----------------------------------------------------------------------
NSupport and Update Agreement (SUA)
NSUA period:               2018-03-26 - 2025-09-04
NContact to extend SUA:    sales@segger.com
N----------------------------------------------------------------------
NFile        : SCROLLBAR.h
NPurpose     : SCROLLBAR include
N--------------------END-OF-HEADER-------------------------------------
N*/
N
N#ifndef SCROLLBAR_H
N#define SCROLLBAR_H
N
N#include "WM.h"
N#include "DIALOG_Type.h"      /* Req. for Create indirect data structure */
N#include "WIDGET.h"
L 1 "..\..\..\..\ThirdParty\emWin\Include\WIDGET.h" 1
N/*********************************************************************
N*                    SEGGER Microcontroller GmbH                     *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2023  SEGGER Microcontroller GmbH                *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V6.46 - Graphical user interface for embedded applications **
NemWin is protected by international copyright laws. Knowledge of the
Nsource code may not be used to write a similar product. 
NThis file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed by SEGGER Software GmbH to Nuvoton Technology Corporation
Nat the address: No. 4, Creation Rd. III, Hsinchu Science Park, Taiwan
Nfor the purposes  of  creating  libraries  for its 
NArm Cortex-A, Arm Cortex-M and  Arm9 32-bit microcontrollers, commercialized and distributed by Nuvoton Technology Corporation
Nunder  the terms and conditions  of  an  End  User  
NLicense  Agreement  supplied  with  the libraries.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NLicensing information
NLicensor:                 SEGGER Software GmbH
NLicensed to:              Nuvoton Technology Corporation, No. 4, Creation Rd. III, Hsinchu Science Park, 30077 Hsinchu City, Taiwan
NLicensed SEGGER software: emWin
NLicense number:           GUI-00735
NLicense model:            emWin License Agreement, signed February 27, 2018
NLicensed platform:        Cortex-M, Cortex-A, and ARM9 32-bit series microcontroller designed and manufactured by Nuvoton Technology Corporation.
N----------------------------------------------------------------------
NSupport and Update Agreement (SUA)
NSUA period:               2018-03-26 - 2025-09-04
NContact to extend SUA:    sales@segger.com
N----------------------------------------------------------------------
NFile        : WIDGET.h
NPurpose     : Widget interface
N---------------------------END-OF-HEADER------------------------------
N*/
N
N#ifndef WIDGET_H        /* Avoid multiple inclusion  */
S#define WIDGET_H
S
S#if defined(__cplusplus)
Sextern "C" {     /* Make sure we have C-declarations in C++ programs */
S#endif
S
S#include "WM.h"  /* Window manager, including some internals, which speed things up */
S#include "GUI_Debug.h"
S
S#if GUI_WINSUPPORT
S
S/*********************************************************************
S*
S*       Typedefs
S*
S**********************************************************************
S*/
Stypedef struct {
S  WM_HWIN    hWin;
S  int        Cmd;         /* WIDGET_ITEM_GET_XSIZE, WIDGET_ITEM_GET_YSIZE, WIDGET_ITEM_DRAW, */
S  int        ItemIndex;
S  int        Col;
S  int        x0, y0, x1, y1;
S  I32        Angle;
S  void     * p;
S} WIDGET_ITEM_DRAW_INFO;
S
Stypedef int  WIDGET_DRAW_ITEM_FUNC(const WIDGET_ITEM_DRAW_INFO * pDrawItemInfo);
Stypedef void WIDGET_PAINT         (WM_HWIN hObj);
Stypedef void WIDGET_CREATE        (WM_HWIN hObj);
S
Stypedef struct {
S  WIDGET_PAINT  * pfPaint;
S  WIDGET_CREATE * pfCreate;
S  void          * pSkinPrivate;
S} WIDGET_SKIN;
S
S/*********************************************************************
S*
S*       WIDGET_COPY
S* 
S*  Description
S*    To be used for copy-optimizations when swiping data.
S*/
Stypedef struct {
S  I16 x0, y0, x1, y1, xSize, ySize;
S} WIDGET_COPY;
S
S/*********************************************************************
S*
S*       WIDGET_SCROLLSTATE_API
S* 
S*  Description
S*    API for conversion between vertical motion and WM_SCROLL_STATE.
S* 
S*    Note: hParent is always the scrollable widget, it is the parent of
S*    a SCROLLER.
S*/
Stypedef struct {
S  //
S  // Getters
S  //
S  int          (* pfGetScrollPosX)       (WM_HWIN hParent);
S  void         (* pfGetScrollPosY)       (WM_HWIN hParent, int * pScrollStateV, int * pMotionPosY);
S  unsigned     (* pfGetNumRows)          (WM_HWIN hParent);
S  int          (* pfGetRowHeight)        (WM_HWIN hParent);
S  int          (* pfGetYOffset)          (WM_HWIN hParent);
S  int          (* pfGetItemPosY)         (WM_HWIN hParent, unsigned Index);
S  int          (* pfGetIndexFromItemPosY)(WM_HWIN hParent, int ScrollStateV, int * pRemainder);
S  int          (* pfGetMaxMotionPosX)    (WM_HWIN hParent);
S  int          (* pfGetMaxMotionPosY)    (WM_HWIN hParent);
S  unsigned     (* pfGetOverlap)          (WM_HWIN hParent, int * pPeriod, U8 * pFlags);
S  //
S  // Setters
S  //
S  void         (* pfSetScrollPosX)       (WM_HWIN hParent, int ScrollStateH);
S  void         (* pfSetScrollPosY)       (WM_HWIN hParent, int ScrollStateV, int MotionPosY);
S  //
S  // Properties
S  //
S  U8              IndvRowHeight; // 1 if each row can have a different height, 0 if not
S  U8              NoConv;        // 1 if no conversion is necessary
S} WIDGET_SCROLLSTATE_API;
S
S/*********************************************************************
S*
S*       WIDGET_ENABLE_MOTION_CONTEXT
S* 
S*  Description
S*    Context for WIDGET__EnableMotion().
S*    With the context the routine knows which exact flags should be set
S*    or removed.
S*/
Stypedef struct {
S  void    * pFlags;           // Pointer to Flags of the widget's object struct.
S  U8        SizeOfFlags;      // Size of pFlags (pFlags can be U8, U16, U32).
S  U32       FlagMotionH;      // Copy of <WIDGET>_CF_MOTION_H (e.g. LISTVIEW_CF_MOTION_H)
S  U32       FlagMotionV;      // Copy of <WIDGET>_CF_MOTION_V
S  U32       FlagAutoScrollH;  // Copy of <WIDGET>_CF_AUTOSCROLL_H
S  U32       FlagAutoScrollV;  // Copy of <WIDGET>_CF_AUTOSCROLL_V
S  WM_HMEM * phContext;        // Pointer to widget's motion context for (de)allocation.
S} WIDGET_ENABLE_MOTION_CONTEXT;
S
S/*********************************************************************
S*
S*       Important: WIDGET_DRAW_ITEM_FUNC needs to be defined
S*                  in SCROLLBAR.h!
S*
S**********************************************************************
S*/
S#include "SCROLLBAR.h"
S
S/*********************************************************************
S*
S*       Defines
S*
S**********************************************************************
S*/
S#define WIDGET_LOCK(hWin) ((WIDGET*)WM_LOCK_H(hWin))
S
S/*********************************************************************
S*
S*       Include WIDGET_TYPE_... IDs
S*
S**********************************************************************
S*/
S#include "WIDGET_ID.h"
S
S/*********************************************************************
S*
S*       Configuration
S*/
S#ifndef   WIDGET_MIN_TIME_PER_FRAME
S  #define WIDGET_MIN_TIME_PER_FRAME 40
S#endif
S#ifndef   WIDGET_USE_PARENT_EFFECT
S  #define WIDGET_USE_PARENT_EFFECT 0
S#endif
S#ifndef   WIDGET_USE_FLEX_SKIN
S  #if WM_SUPPORT_TRANSPARENCY
S    #define WIDGET_USE_FLEX_SKIN     1
S  #else
S    #define WIDGET_USE_FLEX_SKIN     0
S  #endif
S#endif
S#if !defined(WIDGET_USE_SCHEME_SMALL) && !defined(WIDGET_USE_SCHEME_MEDIUM) && !defined(WIDGET_USE_SCHEME_LARGE)
S  #define WIDGET_USE_SCHEME_SMALL  1
S  #define WIDGET_USE_SCHEME_MEDIUM 0
S  #define WIDGET_USE_SCHEME_LARGE  0
S#endif
S#ifndef   WIDGET_USE_SCHEME_SMALL
S  #define WIDGET_USE_SCHEME_SMALL  0
S#endif
S#ifndef   WIDGET_USE_SCHEME_MEDIUM
S  #define WIDGET_USE_SCHEME_MEDIUM 0
S#endif
S#ifndef   WIDGET_USE_SCHEME_LARGE
S  #define WIDGET_USE_SCHEME_LARGE  0
S#endif
S#if (WIDGET_USE_SCHEME_SMALL + WIDGET_USE_SCHEME_MEDIUM + WIDGET_USE_SCHEME_LARGE) > 1
S  #error Only one scheme can be selected!
S#endif
S
S/*********************************************************************
S*
S*       States
S*/
S#define WIDGET_STATE_FOCUS              (1 << 0)
S#define WIDGET_STATE_HORIZONTAL         (0 << 3)
S#define WIDGET_STATE_VERTICAL           (1 << 3)
S#define WIDGET_STATE_FOCUSABLE          (1 << 4)
S#define WIDGET_STATE_INVISIBLEFOCUS     (1 << 5)
S
S#define WIDGET_STATE_USER0              (1 << 8)    /* Freely available for derived widget */
S#define WIDGET_STATE_USER1              (1 << 9)    /* Freely available for derived widget */
S#define WIDGET_STATE_USER2              (1 << 10)   /* Freely available for derived widget */
S
S#define WIDGET_STATE_FOCUSSABLE         WIDGET_STATE_FOCUSABLE
S
S/*********************************************************************
S*
S*       Skinning message identifiers
S*/
S#define WIDGET_ITEM_CREATE              0
S#define WIDGET_ITEM_DRAW                1
S#define WIDGET_ITEM_DRAW_ARROW          2
S#define WIDGET_ITEM_DRAW_ARROW_L        3
S#define WIDGET_ITEM_DRAW_ARROW_R        4
S#define WIDGET_ITEM_DRAW_BACKGROUND     5
S#define WIDGET_ITEM_DRAW_BITMAP         6
S#define WIDGET_ITEM_DRAW_BUTTON         7
S#define WIDGET_ITEM_DRAW_BUTTON_L       8
S#define WIDGET_ITEM_DRAW_BUTTON_R       9
S#define WIDGET_ITEM_DRAW_FOCUS         10
S#define WIDGET_ITEM_DRAW_FRAME         11
S#define WIDGET_ITEM_DRAW_OVERLAP       12
S#define WIDGET_ITEM_DRAW_OVERLAY       13
S#define WIDGET_ITEM_DRAW_SEP           14
S#define WIDGET_ITEM_DRAW_SHAFT         15
S#define WIDGET_ITEM_DRAW_SHAFT_L       16
S#define WIDGET_ITEM_DRAW_SHAFT_R       17
S#define WIDGET_ITEM_DRAW_TEXT          18
S#define WIDGET_ITEM_DRAW_THUMB         19
S#define WIDGET_ITEM_DRAW_TICKS         20
S#define WIDGET_ITEM_GET_BORDERSIZE_B   21
S#define WIDGET_ITEM_GET_BORDERSIZE_L   22
S#define WIDGET_ITEM_GET_BORDERSIZE_R   23
S#define WIDGET_ITEM_GET_BORDERSIZE_T   24
S#define WIDGET_ITEM_GET_BUTTONSIZE     25
S#define WIDGET_ITEM_GET_XSIZE          26
S#define WIDGET_ITEM_GET_YSIZE          27
S#define WIDGET_ITEM_GET_RADIUS         28
S#define WIDGET_ITEM_APPLY_PROPS        29  // Not to be documented. Use this message identifier to update the
S                                           // properties of attached widgets from <WIDGET>_DrawSkinFlex().
S#define WIDGET_DRAW_BACKGROUND         30
S
S#define WIDGET_ITEM_DRAW_BUTTON_U      WIDGET_ITEM_DRAW_BUTTON_R
S#define WIDGET_ITEM_DRAW_BUTTON_D      WIDGET_ITEM_DRAW_BUTTON_L
S
S#define WIDGET_DRAW_OVERLAY    WIDGET_ITEM_DRAW_OVERLAY
S
S/*********************************************************************
S*
S*       Messages
S*/
S#define WM_WIDGET_SET_EFFECT    (WM_WIDGET + 0)
S
S/*********************************************************************
S*
S*       Create flags
S*/
S#define WIDGET_CF_VERTICAL      WIDGET_STATE_VERTICAL
S#define WIDGET_CF_HORIZONTAL    WIDGET_STATE_HORIZONTAL
S
S/*********************************************************************
S*
S*       Flags for stopping motion of widgets on a given axis
S*/
S#define WIDGET_MOTION_STOP_X     (1 << 8)
S#define WIDGET_MOTION_STOP_Y     (1 << 9)
S
S/*********************************************************************
S*
S*        Widget object
S*
S* The widget object is the base class for most widgets
S*/
Stypedef struct {
S  int EffectSize;
S  void (* pfDrawUp)      (void);
S  void (* pfDrawUpRect)  (const GUI_RECT * pRect);
S  void (* pfDrawDown)    (void);
S  void (* pfDrawDownRect)(const GUI_RECT * pRect);
S  void (* pfDrawFlat)    (void);
S  void (* pfDrawFlatRect)(const GUI_RECT * pRect);
S} WIDGET_EFFECT;
S
Stypedef struct {
S  WM_Obj      Win;
S  const WIDGET_EFFECT* pEffect;
S  I16 Id;
S  U16 State;
S  #if GUI_DEBUG_LEVEL > 1
S    U32 DebugId;
S  #endif  
S} WIDGET;
S
S
S/*********************************************************************
S*
S*         GUI_DRAW
S*
S* The GUI_DRAW object is used as base class for selfdrawing,
S* non-windows objects. They are used as content of different widgets,
S* such as the bitmap or header widgets.
S*/
S/* Declare Object struct */
Stypedef struct GUI_DRAW GUI_DRAW;
Stypedef void   GUI_DRAW_SELF_CB (WM_HWIN hWin);
Stypedef WM_HMEM GUI_DRAW_HANDLE;
S
S/* Declare Object constants (member functions etc)  */
Stypedef struct {
S  void (* pfDraw)    (GUI_DRAW_HANDLE hDrawObj, WM_HWIN hObj, int x, int y);
S  int  (* pfGetXSize)(GUI_DRAW_HANDLE hDrawObj);
S  int  (* pfGetYSize)(GUI_DRAW_HANDLE hDrawObj);
S} GUI_DRAW_CONSTS;
S
S/* Declare Object */
Sstruct GUI_DRAW {
S  const GUI_DRAW_CONSTS * pConsts;
S  union {
S    const void * pData;
S    GUI_DRAW_SELF_CB * pfDraw;
S  } Data;
S  I16 xOff, yOff;
S};
S
S/* GUI_DRAW_ API */
Svoid GUI_DRAW__Draw     (GUI_DRAW_HANDLE hDrawObj, WM_HWIN hObj, int x, int y);
Sint  GUI_DRAW__GetXOff  (GUI_DRAW_HANDLE hDrawObj);
Sint  GUI_DRAW__GetYOff  (GUI_DRAW_HANDLE hDrawObj);
Sint  GUI_DRAW__GetXSize (GUI_DRAW_HANDLE hDrawObj);
Sint  GUI_DRAW__GetYSize (GUI_DRAW_HANDLE hDrawObj);
Svoid GUI_DRAW__SetOffset(GUI_DRAW_HANDLE hDrawObj, int xOff, int yOff);
S
Svoid GUI_DrawStreamedEnableAuto(void);
S
S/* GUI_DRAW_ Constructurs for different objects */
SWM_HMEM GUI_DRAW_BITMAP_Create     (const GUI_BITMAP * pBitmap, int x, int y);
SWM_HMEM GUI_DRAW_BMP_Create        (const void * pBMP, int x, int y);
SWM_HMEM GUI_DRAW_STREAMED_Create   (const GUI_BITMAP_STREAM * pBitmap, int x, int y);
SWM_HMEM GUI_DRAW_SELF_Create       (GUI_DRAW_SELF_CB * pfDraw, int x, int y);
SWM_HMEM GUI_DRAW_BITMAP_HQHR_Create(const GUI_BITMAP * pBitmap, int x, int y);
S
S#if (GUI_SUPPORT_MEMDEV == 1)
S  void GUI_MEMDEV_DrawBitmapObj32HQHR  (GUI_DRAW_HANDLE hDrawObj, WM_HWIN hWin, int x0HR, int y0HR);  // This function uses parameter which are only available when Widgets and WM are available
S#endif
S
S/*********************************************************************
S*
S*       Global data
S*
S**********************************************************************
S*/
Sextern const WIDGET_EFFECT WIDGET_Effect_3D;
Sextern const WIDGET_EFFECT WIDGET_Effect_3D1L;
Sextern const WIDGET_EFFECT WIDGET_Effect_3D2L;
Sextern const WIDGET_EFFECT WIDGET_Effect_None;
Sextern const WIDGET_EFFECT WIDGET_Effect_Simple;
S
S/*********************************************************************
S*
S*       Internal API routines
S*
S**********************************************************************
S*/
Svoid      WIDGET__ConvertScrollState_PixelToLine(WM_HWIN hObj, const WIDGET_SCROLLSTATE_API * pAPI, int StateVPixelwise, int * pStateVLinewise, int * pMotionOffsetY);
Sint       WIDGET__ConvertScrollState_LineToPixel(WM_HWIN hObj, const WIDGET_SCROLLSTATE_API * pAPI, int StateVLinewise, int MotionOffsetY);
Svoid      WIDGET__DrawFocusRect                 (WIDGET * pWidget, const GUI_RECT * pRect, int Dist);
Svoid      WIDGET__DrawHLine                     (WIDGET * pWidget, int y, int x0, int x1);
Svoid      WIDGET__DrawTriangle                  (WIDGET * pWidget, int x, int y, int Size, int Inc);
Svoid      WIDGET__DrawVLine                     (WIDGET * pWidget, int x, int y0, int y1);
Svoid      WIDGET__EFFECT_DrawDownRect           (WIDGET * pWidget, GUI_RECT * pRect);
Svoid      WIDGET__EFFECT_DrawDown               (WIDGET * pWidget);
Svoid      WIDGET__EFFECT_DrawUpRect             (WIDGET * pWidget, GUI_RECT * pRect);
Svoid      WIDGET__EnableMotion                  (WM_HWIN hObj, int Flags, WIDGET_ENABLE_MOTION_CONTEXT * pContext);
Svoid      WIDGET__FillRectEx                    (WIDGET * pWidget, const GUI_RECT * pRect);
Sint       WIDGET__GetWindowSizeX                (WM_HWIN hWin);
SGUI_COLOR WIDGET__GetBkColor                    (WM_HWIN hObj);
Sint       WIDGET__GetXSize                      (const WIDGET * pWidget);
Sint       WIDGET__GetYSize                      (const WIDGET * pWidget);
Svoid      WIDGET__GetClientRect                 (WIDGET * pWidget, GUI_RECT * pRect);
Svoid      WIDGET__GetInsideRect                 (WIDGET * pWidget, GUI_RECT * pRect);
SU32       WIDGET__HandleMotionMove              (WM_HWIN hObj, WM_MOTION_INFO * pInfo, const WIDGET_SCROLLSTATE_API * pAPI);
Svoid      WIDGET__HandleMotionMoveBack          (WM_HWIN hObj, const WIDGET_SCROLLSTATE_API * pAPI);
Svoid      WIDGET__Init                          (WIDGET * pWidget, int Id, U16 State);
Svoid      WIDGET__RotateRect90                  (WIDGET * pWidget, GUI_RECT * pDest, const GUI_RECT * pRect);
Svoid      WIDGET__SetScrollState                (WM_HWIN hWin, const WM_SCROLL_STATE * pVState, const WM_SCROLL_STATE * pHState);
Svoid      WIDGET__FillStringInRect              (const char * pText, const GUI_RECT * pFillRect, const GUI_RECT * pTextRectMax, const GUI_RECT * pTextRectAct);
Svoid      WIDGET__FillStringInRectEx            (const char * pText, const GUI_RECT * pFillRect, const GUI_RECT * pTextRectMax, const GUI_RECT * pTextRectAct, int xOffset);
S
S//
S// Function pointers for drawing streamed bitmaps
S//
Sextern void (* GUI__pfDrawStreamedBitmap)  (const void * p, int x, int y);
Sextern int  (* GUI__pfDrawStreamedBitmapEx)(GUI_DTA_GET_DATA_FUNC * pfGetData, const void * p, int x, int y);
S
S/*********************************************************************
S*
S*       API routines
S*
S**********************************************************************
S*/
Svoid  WIDGET_SetState          (WM_HWIN hObj, int State);
Svoid  WIDGET_AndState          (WM_HWIN hObj, int State);
Svoid  WIDGET_OrState           (WM_HWIN hObj, int State);
Sint   WIDGET_HandleActive      (WM_HWIN hObj, WM_MESSAGE* pMsg);
Sint   WIDGET_GetState          (WM_HWIN hObj);
Sint   WIDGET_SetWidth          (WM_HWIN hObj, int Width);
Svoid  WIDGET_SetFocusable      (WM_HWIN hObj, int State);
SU32   WIDGET_GetType           (WM_HWIN hObj);
SU16   WIDGET_SetMinTimePerFrame(U16 MinTimePerFrame);
SU16   WIDGET_GetMinTimePerFrame(void);
S
Svoid  WIDGET_EFFECT_3D_DrawUp(void);
S
Sconst WIDGET_EFFECT* WIDGET_SetDefaultEffect(const WIDGET_EFFECT* pEffect);
S
Svoid  WIDGET_SetEffect              (WM_HWIN hObj, const WIDGET_EFFECT* pEffect);
S
Sconst WIDGET_EFFECT* WIDGET_GetDefaultEffect(void);
S
Svoid WIDGET_EFFECT_3D_SetColor    (unsigned Index, GUI_COLOR Color);
Svoid WIDGET_EFFECT_3D1L_SetColor  (unsigned Index, GUI_COLOR Color);
Svoid WIDGET_EFFECT_3D2L_SetColor  (unsigned Index, GUI_COLOR Color);
Svoid WIDGET_EFFECT_Simple_SetColor(unsigned Index, GUI_COLOR Color);
S
SGUI_COLOR WIDGET_EFFECT_3D_GetColor    (unsigned Index);
SGUI_COLOR WIDGET_EFFECT_3D1L_GetColor  (unsigned Index);
SGUI_COLOR WIDGET_EFFECT_3D2L_GetColor  (unsigned Index);
SGUI_COLOR WIDGET_EFFECT_Simple_GetColor(unsigned Index);
S
Sint WIDGET_EFFECT_3D_GetNumColors(void);
Sint WIDGET_EFFECT_3D1L_GetNumColors(void);
Sint WIDGET_EFFECT_3D2L_GetNumColors(void);
Sint WIDGET_EFFECT_Simple_GetNumColors(void);
S
S/*********************************************************************
S*
S*       Compatibility macros
S*
S**********************************************************************
S*/
S#define WIDGET_EnableStreamAuto() GUI_DrawStreamedEnableAuto()
S
S#define WIDGET_SetDefaultEffect_3D()     WIDGET_SetDefaultEffect(&WIDGET_Effect_3D)
S#define WIDGET_SetDefaultEffect_3D1L()   WIDGET_SetDefaultEffect(&WIDGET_Effect_3D1L)
S#define WIDGET_SetDefaultEffect_3D2L()   WIDGET_SetDefaultEffect(&WIDGET_Effect_3D2L)
S#define WIDGET_SetDefaultEffect_None()   WIDGET_SetDefaultEffect(&WIDGET_Effect_None)
S#define WIDGET_SetDefaultEffect_Simple() WIDGET_SetDefaultEffect(&WIDGET_Effect_Simple)
S
S#endif /* GUI_WINSUPPORT */
S
S#if defined(__cplusplus)
S  }
S#endif
S
N#endif   /* SLIDER_H */
N
N/*************************** End of file ****************************/
L 51 "..\..\..\..\ThirdParty\emWin\Include\SCROLLBAR.h" 2
N
N#if GUI_WINSUPPORT
X#if 1
N
N#if defined(__cplusplus)
X#if 0L
S  extern "C" {     /* Make sure we have C-declarations in C++ programs */
N#endif
N
N/*********************************************************************
N*
N*       Defines
N*
N**********************************************************************
N*/
N/*********************************************************************
N*
N*       SCROLLBAR color indexes
N*
N*  Description
N*    Color indexes for SCROLLBAR widget.
N*/
N#define SCROLLBAR_CI_THUMB 0    // Color of thumb area.
N#define SCROLLBAR_CI_SHAFT 1    // Color of shaft.
N#define SCROLLBAR_CI_ARROW 2    // Color of arrows.
N
N/*********************************************************************
N*
N*       States
N*/
N#define SCROLLBAR_STATE_PRESSED   WIDGET_STATE_USER0
N
N/*********************************************************************
N*
N*       Create / Status flags
N*/
N#define SCROLLBAR_CF_VERTICAL     WIDGET_CF_VERTICAL
N#define SCROLLBAR_CF_FOCUSABLE    WIDGET_STATE_FOCUSABLE
N
N#define SCROLLBAR_CF_FOCUSSABLE   SCROLLBAR_CF_FOCUSABLE
N
N/************************************************************
N*
N*       Skinning property indices
N*/
N#define SCROLLBAR_SKINFLEX_PI_PRESSED   0
N#define SCROLLBAR_SKINFLEX_PI_UNPRESSED 1
N
N/*********************************************************************
N*
N*       Public Types
N*
N**********************************************************************
N*/
Ntypedef WM_HMEM SCROLLBAR_Handle;
Xtypedef signed long SCROLLBAR_Handle;
N
Ntypedef struct {
N  GUI_COLOR aColorFrame[3];
N  GUI_COLOR aColorUpper[2];
N  GUI_COLOR aColorLower[2];
N  GUI_COLOR aColorShaft[2];
N  GUI_COLOR ColorArrow;
N  GUI_COLOR ColorGrasp;
N} SCROLLBAR_SKINFLEX_PROPS;
N
Ntypedef struct {
N  int IsVertical;
N  int State;
N} SCROLLBAR_SKINFLEX_INFO;
N
N/*********************************************************************
N*
N*       Create functions
N*
N**********************************************************************
N*/
NSCROLLBAR_Handle SCROLLBAR_Create        (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int Id, int WinFlags, int SpecialFlags);
XSCROLLBAR_Handle SCROLLBAR_Create        (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int Id, int WinFlags, int SpecialFlags);
NSCROLLBAR_Handle SCROLLBAR_CreateAttached(WM_HWIN hParent, int SpecialFlags);
XSCROLLBAR_Handle SCROLLBAR_CreateAttached(GUI_HWIN hParent, int SpecialFlags);
NSCROLLBAR_Handle SCROLLBAR_CreateEx      (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int ExFlags, int Id);
XSCROLLBAR_Handle SCROLLBAR_CreateEx      (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int WinFlags, int ExFlags, int Id);
NSCROLLBAR_Handle SCROLLBAR_CreateUser    (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int ExFlags, int Id, int NumExtraBytes);
XSCROLLBAR_Handle SCROLLBAR_CreateUser    (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int WinFlags, int ExFlags, int Id, int NumExtraBytes);
NSCROLLBAR_Handle SCROLLBAR_CreateIndirect(const GUI_WIDGET_CREATE_INFO * pCreateInfo, WM_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
XSCROLLBAR_Handle SCROLLBAR_CreateIndirect(const GUI_WIDGET_CREATE_INFO * pCreateInfo, GUI_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
N
N/*********************************************************************
N*
N*       The callback ...
N*
N* Do not call it directly ! It is only to be used from within an
N* overwritten callback.
N*/
Nvoid SCROLLBAR_Callback(WM_MESSAGE * pMsg);
N
N/*********************************************************************
N*
N*       Member functions
N*
N**********************************************************************
N*/
N
N/* Methods changing properties */
N
Nvoid      SCROLLBAR_AddValue   (SCROLLBAR_Handle hObj, int Add);
Nvoid      SCROLLBAR_Dec        (SCROLLBAR_Handle hObj);
Nvoid      SCROLLBAR_Inc        (SCROLLBAR_Handle hObj);
Nint       SCROLLBAR_GetUserData(SCROLLBAR_Handle hObj, void * pDest, int NumBytes);
NGUI_COLOR SCROLLBAR_SetColor   (SCROLLBAR_Handle hObj, int Index, GUI_COLOR Color);
Nvoid      SCROLLBAR_SetNumItems(SCROLLBAR_Handle hObj, int NumItems);
Nvoid      SCROLLBAR_SetPageSize(SCROLLBAR_Handle hObj, int PageSize);
Nvoid      SCROLLBAR_SetValue   (SCROLLBAR_Handle hObj, int v);
Nint       SCROLLBAR_SetWidth   (SCROLLBAR_Handle hObj, int Width);
Nvoid      SCROLLBAR_SetState   (SCROLLBAR_Handle hObj, const WM_SCROLL_STATE* pState);
Nint       SCROLLBAR_SetUserData(SCROLLBAR_Handle hObj, const void * pSrc, int NumBytes);
N
N/*********************************************************************
N*
N*       Member functions: Skinning
N*
N**********************************************************************
N*/
Nvoid SCROLLBAR_GetSkinFlexProps     (SCROLLBAR_SKINFLEX_PROPS * pProps, int Index);
Nvoid SCROLLBAR_SetSkinClassic       (SCROLLBAR_Handle hObj);
Nvoid SCROLLBAR_SetSkin              (SCROLLBAR_Handle hObj, WIDGET_DRAW_ITEM_FUNC * pfDrawSkin);
Nint  SCROLLBAR_DrawSkinFlex         (const WIDGET_ITEM_DRAW_INFO * pDrawItemInfo);
Nvoid SCROLLBAR_SetSkinFlexProps     (const SCROLLBAR_SKINFLEX_PROPS * pProps, int Index);
Nvoid SCROLLBAR_SetDefaultSkinClassic(void);
NWIDGET_DRAW_ITEM_FUNC * SCROLLBAR_SetDefaultSkin(WIDGET_DRAW_ITEM_FUNC * pfDrawSkin);
N
N#define SCROLLBAR_SKIN_FLEX    SCROLLBAR_DrawSkinFlex
N
N/*********************************************************************
N*
N*       Managing default values
N*
N**********************************************************************
N*/
Nint       SCROLLBAR_GetDefaultWidth(void);
NGUI_COLOR SCROLLBAR_SetDefaultColor(GUI_COLOR Color, unsigned int Index); /* Not yet documented */
Nint       SCROLLBAR_SetDefaultWidth(int DefaultWidth);
N
N/*********************************************************************
N*
N*       Global functions
N*
N**********************************************************************
N*/
Nint       SCROLLBAR_GetThumbSizeMin(void);
Nint       SCROLLBAR_SetThumbSizeMin(int ThumbSizeMin);
N
N/*********************************************************************
N*
N*       Query state
N*
N**********************************************************************
N*/
NGUI_COLOR SCROLLBAR_GetColor   (SCROLLBAR_Handle hObj, int Index);
Nint       SCROLLBAR_GetNumItems(SCROLLBAR_Handle hObj);
Nint       SCROLLBAR_GetPageSize(SCROLLBAR_Handle hObj);
Nint       SCROLLBAR_GetValue   (SCROLLBAR_Handle hObj);
N
N/*********************************************************************
N*
N*       Macros for compatibility
N*
N**********************************************************************
N*/
N#define SCROLLBAR_BKCOLOR0_DEFAULT SCROLLBAR_COLOR_ARROW_DEFAULT
N#define SCROLLBAR_BKCOLOR1_DEFAULT SCROLLBAR_COLOR_SHAFT_DEFAULT
N#define SCROLLBAR_COLOR0_DEFAULT   SCROLLBAR_COLOR_THUMB_DEFAULT
N
N#if defined(__cplusplus)
X#if 0L
S  }
N#endif
N
N#endif  // GUI_WINSUPPORT
N#endif  // SCROLLBAR_H
N
N/*************************** End of file ****************************/
L 157 "..\..\..\..\ThirdParty\emWin\Include\WIDGET.h" 2
N
N/*********************************************************************
N*
N*       Defines
N*
N**********************************************************************
N*/
N#define WIDGET_LOCK(hWin) ((WIDGET*)WM_LOCK_H(hWin))
N
N/*********************************************************************
N*
N*       Include WIDGET_TYPE_... IDs
N*
N**********************************************************************
N*/
N#include "WIDGET_ID.h"
L 1 "..\..\..\..\ThirdParty\emWin\Include\WIDGET_ID.h" 1
N/*********************************************************************
N*                    SEGGER Microcontroller GmbH                     *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2023  SEGGER Microcontroller GmbH                *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V6.46 - Graphical user interface for embedded applications **
NemWin is protected by international copyright laws. Knowledge of the
Nsource code may not be used to write a similar product. 
NThis file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed by SEGGER Software GmbH to Nuvoton Technology Corporation
Nat the address: No. 4, Creation Rd. III, Hsinchu Science Park, Taiwan
Nfor the purposes  of  creating  libraries  for its 
NArm Cortex-A, Arm Cortex-M and  Arm9 32-bit microcontrollers, commercialized and distributed by Nuvoton Technology Corporation
Nunder  the terms and conditions  of  an  End  User  
NLicense  Agreement  supplied  with  the libraries.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NLicensing information
NLicensor:                 SEGGER Software GmbH
NLicensed to:              Nuvoton Technology Corporation, No. 4, Creation Rd. III, Hsinchu Science Park, 30077 Hsinchu City, Taiwan
NLicensed SEGGER software: emWin
NLicense number:           GUI-00735
NLicense model:            emWin License Agreement, signed February 27, 2018
NLicensed platform:        Cortex-M, Cortex-A, and ARM9 32-bit series microcontroller designed and manufactured by Nuvoton Technology Corporation.
N----------------------------------------------------------------------
NSupport and Update Agreement (SUA)
NSUA period:               2018-03-26 - 2025-09-04
NContact to extend SUA:    sales@segger.com
N----------------------------------------------------------------------
NFile        : WIDGET_ID.h
NPurpose     : Unique widget IDs
N---------------------------END-OF-HEADER------------------------------
N*/
N
N#ifndef WIDGET_ID_H        /* Avoid multiple inclusion  */
N#define WIDGET_ID_H
N
N/*********************************************************************
N*
N*       Widget type IDs
N* 
N*  Description
N*    Unique type IDs for all widget types.
N*/
N#define WIDGET_TYPE_BUTTON            /* BUTT */   0x42555454UL   // BUTTON           widget.
N#define WIDGET_TYPE_CHECKBOX          /* CHEC */   0x43484543UL   // CHECKBOX         widget.
N#define WIDGET_TYPE_DROPDOWN          /* DROP */   0x44524F50UL   // DROPDOWN         widget.
N#define WIDGET_TYPE_EDIT              /* EDIT */   0x45444954UL   // EDIT             widget.
N#define WIDGET_TYPE_FRAMEWIN          /* FRAM */   0x4652414DUL   // FRAMEWIN         widget.
N#define WIDGET_TYPE_FRAMEWIN_CLIENT   /* FRAC */   0x46524143UL   // FRAMEWIN client  widget.
N#define WIDGET_TYPE_GRAPH             /* GRAP */   0x47524150UL   // GRAPH            widget.
N#define WIDGET_TYPE_HEADER            /* HEAD */   0x48454144UL   // HEADER           widget.
N#define WIDGET_TYPE_KEYBOARD          /* KEYB */   0x4B455942UL   // KEYBOARD         widget.
N#define WIDGET_TYPE_LISTBOX           /* LISB */   0x4C495342UL   // LISTBOX          widget.
N#define WIDGET_TYPE_LISTVIEW          /* LISV */   0x4C495356UL   // LISTVIEW         widget.
N#define WIDGET_TYPE_LISTWHEEL         /* LISW */   0x4C495357UL   // LISTWHEEL        widget.
N#define WIDGET_TYPE_MENU              /* MENU */   0x4D454E55UL   // MENU             widget.
N#define WIDGET_TYPE_MOVIE             /* MOVI */   0x4D4F5649UL   // MOVIE            widget.
N#define WIDGET_TYPE_MULTIEDIT         /* MULE */   0x4D554C45UL   // MULTIEDIT        widget.
N#define WIDGET_TYPE_MULTIPAGE         /* MULP */   0x4D554C50UL   // MULTIPAGE        widget.
N#define WIDGET_TYPE_MULTIPAGE_CLIENT  /* MPCL */   0x4D50434CUL   // MULTIPAGE client widget.
N#define WIDGET_TYPE_PROGBAR           /* PROG */   0x50524F47UL   // PROGBAR          widget.
N#define WIDGET_TYPE_RADIO             /* RADI */   0x52414449UL   // RADIO            widget.
N#define WIDGET_TYPE_SCROLLBAR         /* SCRO */   0x5343524FUL   // SCROLLBAR        widget.
N#define WIDGET_TYPE_SLIDER            /* SLID */   0x534C4944UL   // SLIDER           widget.
N#define WIDGET_TYPE_SWIPELIST         /* SWIP */   0x53574950UL   // SWIPELIST        widget.
N#define WIDGET_TYPE_TEXT              /* TEXT */   0x54455854UL   // TEXT             widget.
N#define WIDGET_TYPE_TREEVIEW          /* TREE */   0x54524545UL   // TREEVIEW         widget.
N#define WIDGET_TYPE_ICONVIEW          /* ICON */   0x49434F4EUL   // ICONVIEW         widget.
N#define WIDGET_TYPE_IMAGE             /* IMAG */   0x494D4147UL   // IMAGE            widget.
N#define WIDGET_TYPE_SPINBOX           /* SPIN */   0x5350494EUL   // SPINBOX          widget.
N#define WIDGET_TYPE_KNOB              /* KNOB */   0x4B4E4F42UL   // KNOB             widget.
N#define WIDGET_TYPE_WINDOW            /* WIND */   0x57494E44UL   // WINDOW           widget.
N#define WIDGET_TYPE_ROTARY            /* ROTA */   0x524F5441UL   // ROTARY           widget.
N#define WIDGET_TYPE_SWITCH            /* SWIT */   0x53574954UL   // SWITCH           widget.
N#define WIDGET_TYPE_TICKER            /* TICK */   0x5449434BUL   // TICKER           widget.
N#define WIDGET_TYPE_GAUGE             /* GAUG */   0x47415547UL   // GAUGE            widget.
N#define WIDGET_TYPE_QRCODE            /* QRCO */   0x5152434FUL   // QRCODE           widget.
N#define WIDGET_TYPE_SCROLLER          /* SCRL */   0x5343523CUL   // SCROLLER         widget.
N#define WIDGET_TYPE_WHEEL             /* WHEL */   0x5748454CUL   // WHEEL            widget.
N
N#endif   /* WIDGET_ID_H */
N
N/*************************** End of file ****************************/
L 173 "..\..\..\..\ThirdParty\emWin\Include\WIDGET.h" 2
N
N/*********************************************************************
N*
N*       Configuration
N*/
N#ifndef   WIDGET_MIN_TIME_PER_FRAME
N  #define WIDGET_MIN_TIME_PER_FRAME 40
N#endif
N#ifndef   WIDGET_USE_PARENT_EFFECT
N  #define WIDGET_USE_PARENT_EFFECT 0
N#endif
N#ifndef   WIDGET_USE_FLEX_SKIN
N  #if WM_SUPPORT_TRANSPARENCY
X  #if 1
N    #define WIDGET_USE_FLEX_SKIN     1
N  #else
S    #define WIDGET_USE_FLEX_SKIN     0
N  #endif
N#endif
N#if !defined(WIDGET_USE_SCHEME_SMALL) && !defined(WIDGET_USE_SCHEME_MEDIUM) && !defined(WIDGET_USE_SCHEME_LARGE)
X#if !0L && !0L && !0L
N  #define WIDGET_USE_SCHEME_SMALL  1
N  #define WIDGET_USE_SCHEME_MEDIUM 0
N  #define WIDGET_USE_SCHEME_LARGE  0
N#endif
N#ifndef   WIDGET_USE_SCHEME_SMALL
S  #define WIDGET_USE_SCHEME_SMALL  0
N#endif
N#ifndef   WIDGET_USE_SCHEME_MEDIUM
S  #define WIDGET_USE_SCHEME_MEDIUM 0
N#endif
N#ifndef   WIDGET_USE_SCHEME_LARGE
S  #define WIDGET_USE_SCHEME_LARGE  0
N#endif
N#if (WIDGET_USE_SCHEME_SMALL + WIDGET_USE_SCHEME_MEDIUM + WIDGET_USE_SCHEME_LARGE) > 1
X#if (1 + 0 + 0) > 1
S  #error Only one scheme can be selected!
N#endif
N
N/*********************************************************************
N*
N*       States
N*/
N#define WIDGET_STATE_FOCUS              (1 << 0)
N#define WIDGET_STATE_HORIZONTAL         (0 << 3)
N#define WIDGET_STATE_VERTICAL           (1 << 3)
N#define WIDGET_STATE_FOCUSABLE          (1 << 4)
N#define WIDGET_STATE_INVISIBLEFOCUS     (1 << 5)
N
N#define WIDGET_STATE_USER0              (1 << 8)    /* Freely available for derived widget */
N#define WIDGET_STATE_USER1              (1 << 9)    /* Freely available for derived widget */
N#define WIDGET_STATE_USER2              (1 << 10)   /* Freely available for derived widget */
N
N#define WIDGET_STATE_FOCUSSABLE         WIDGET_STATE_FOCUSABLE
N
N/*********************************************************************
N*
N*       Skinning message identifiers
N*/
N#define WIDGET_ITEM_CREATE              0
N#define WIDGET_ITEM_DRAW                1
N#define WIDGET_ITEM_DRAW_ARROW          2
N#define WIDGET_ITEM_DRAW_ARROW_L        3
N#define WIDGET_ITEM_DRAW_ARROW_R        4
N#define WIDGET_ITEM_DRAW_BACKGROUND     5
N#define WIDGET_ITEM_DRAW_BITMAP         6
N#define WIDGET_ITEM_DRAW_BUTTON         7
N#define WIDGET_ITEM_DRAW_BUTTON_L       8
N#define WIDGET_ITEM_DRAW_BUTTON_R       9
N#define WIDGET_ITEM_DRAW_FOCUS         10
N#define WIDGET_ITEM_DRAW_FRAME         11
N#define WIDGET_ITEM_DRAW_OVERLAP       12
N#define WIDGET_ITEM_DRAW_OVERLAY       13
N#define WIDGET_ITEM_DRAW_SEP           14
N#define WIDGET_ITEM_DRAW_SHAFT         15
N#define WIDGET_ITEM_DRAW_SHAFT_L       16
N#define WIDGET_ITEM_DRAW_SHAFT_R       17
N#define WIDGET_ITEM_DRAW_TEXT          18
N#define WIDGET_ITEM_DRAW_THUMB         19
N#define WIDGET_ITEM_DRAW_TICKS         20
N#define WIDGET_ITEM_GET_BORDERSIZE_B   21
N#define WIDGET_ITEM_GET_BORDERSIZE_L   22
N#define WIDGET_ITEM_GET_BORDERSIZE_R   23
N#define WIDGET_ITEM_GET_BORDERSIZE_T   24
N#define WIDGET_ITEM_GET_BUTTONSIZE     25
N#define WIDGET_ITEM_GET_XSIZE          26
N#define WIDGET_ITEM_GET_YSIZE          27
N#define WIDGET_ITEM_GET_RADIUS         28
N#define WIDGET_ITEM_APPLY_PROPS        29  // Not to be documented. Use this message identifier to update the
N                                           // properties of attached widgets from <WIDGET>_DrawSkinFlex().
N#define WIDGET_DRAW_BACKGROUND         30
N
N#define WIDGET_ITEM_DRAW_BUTTON_U      WIDGET_ITEM_DRAW_BUTTON_R
N#define WIDGET_ITEM_DRAW_BUTTON_D      WIDGET_ITEM_DRAW_BUTTON_L
N
N#define WIDGET_DRAW_OVERLAY    WIDGET_ITEM_DRAW_OVERLAY
N
N/*********************************************************************
N*
N*       Messages
N*/
N#define WM_WIDGET_SET_EFFECT    (WM_WIDGET + 0)
N
N/*********************************************************************
N*
N*       Create flags
N*/
N#define WIDGET_CF_VERTICAL      WIDGET_STATE_VERTICAL
N#define WIDGET_CF_HORIZONTAL    WIDGET_STATE_HORIZONTAL
N
N/*********************************************************************
N*
N*       Flags for stopping motion of widgets on a given axis
N*/
N#define WIDGET_MOTION_STOP_X     (1 << 8)
N#define WIDGET_MOTION_STOP_Y     (1 << 9)
N
N/*********************************************************************
N*
N*        Widget object
N*
N* The widget object is the base class for most widgets
N*/
Ntypedef struct {
N  int EffectSize;
N  void (* pfDrawUp)      (void);
N  void (* pfDrawUpRect)  (const GUI_RECT * pRect);
N  void (* pfDrawDown)    (void);
N  void (* pfDrawDownRect)(const GUI_RECT * pRect);
N  void (* pfDrawFlat)    (void);
N  void (* pfDrawFlatRect)(const GUI_RECT * pRect);
N} WIDGET_EFFECT;
N
Ntypedef struct {
N  WM_Obj      Win;
N  const WIDGET_EFFECT* pEffect;
N  I16 Id;
X  signed short Id;
N  U16 State;
X  unsigned short State;
N  #if GUI_DEBUG_LEVEL > 1
X  #if 0 > 1
S    U32 DebugId;
N  #endif  
N} WIDGET;
N
N
N/*********************************************************************
N*
N*         GUI_DRAW
N*
N* The GUI_DRAW object is used as base class for selfdrawing,
N* non-windows objects. They are used as content of different widgets,
N* such as the bitmap or header widgets.
N*/
N/* Declare Object struct */
Ntypedef struct GUI_DRAW GUI_DRAW;
Ntypedef void   GUI_DRAW_SELF_CB (WM_HWIN hWin);
Xtypedef void   GUI_DRAW_SELF_CB (GUI_HWIN hWin);
Ntypedef WM_HMEM GUI_DRAW_HANDLE;
Xtypedef signed long GUI_DRAW_HANDLE;
N
N/* Declare Object constants (member functions etc)  */
Ntypedef struct {
N  void (* pfDraw)    (GUI_DRAW_HANDLE hDrawObj, WM_HWIN hObj, int x, int y);
X  void (* pfDraw)    (GUI_DRAW_HANDLE hDrawObj, GUI_HWIN hObj, int x, int y);
N  int  (* pfGetXSize)(GUI_DRAW_HANDLE hDrawObj);
N  int  (* pfGetYSize)(GUI_DRAW_HANDLE hDrawObj);
N} GUI_DRAW_CONSTS;
N
N/* Declare Object */
Nstruct GUI_DRAW {
N  const GUI_DRAW_CONSTS * pConsts;
N  union {
N    const void * pData;
N    GUI_DRAW_SELF_CB * pfDraw;
N  } Data;
N  I16 xOff, yOff;
X  signed short xOff, yOff;
N};
N
N/* GUI_DRAW_ API */
Nvoid GUI_DRAW__Draw     (GUI_DRAW_HANDLE hDrawObj, WM_HWIN hObj, int x, int y);
Xvoid GUI_DRAW__Draw     (GUI_DRAW_HANDLE hDrawObj, GUI_HWIN hObj, int x, int y);
Nint  GUI_DRAW__GetXOff  (GUI_DRAW_HANDLE hDrawObj);
Nint  GUI_DRAW__GetYOff  (GUI_DRAW_HANDLE hDrawObj);
Nint  GUI_DRAW__GetXSize (GUI_DRAW_HANDLE hDrawObj);
Nint  GUI_DRAW__GetYSize (GUI_DRAW_HANDLE hDrawObj);
Nvoid GUI_DRAW__SetOffset(GUI_DRAW_HANDLE hDrawObj, int xOff, int yOff);
N
Nvoid GUI_DrawStreamedEnableAuto(void);
N
N/* GUI_DRAW_ Constructurs for different objects */
NWM_HMEM GUI_DRAW_BITMAP_Create     (const GUI_BITMAP * pBitmap, int x, int y);
Xsigned long GUI_DRAW_BITMAP_Create     (const GUI_BITMAP * pBitmap, int x, int y);
NWM_HMEM GUI_DRAW_BMP_Create        (const void * pBMP, int x, int y);
Xsigned long GUI_DRAW_BMP_Create        (const void * pBMP, int x, int y);
NWM_HMEM GUI_DRAW_STREAMED_Create   (const GUI_BITMAP_STREAM * pBitmap, int x, int y);
Xsigned long GUI_DRAW_STREAMED_Create   (const GUI_BITMAP_STREAM * pBitmap, int x, int y);
NWM_HMEM GUI_DRAW_SELF_Create       (GUI_DRAW_SELF_CB * pfDraw, int x, int y);
Xsigned long GUI_DRAW_SELF_Create       (GUI_DRAW_SELF_CB * pfDraw, int x, int y);
NWM_HMEM GUI_DRAW_BITMAP_HQHR_Create(const GUI_BITMAP * pBitmap, int x, int y);
Xsigned long GUI_DRAW_BITMAP_HQHR_Create(const GUI_BITMAP * pBitmap, int x, int y);
N
N#if (GUI_SUPPORT_MEMDEV == 1)
X#if (1 == 1)
N  void GUI_MEMDEV_DrawBitmapObj32HQHR  (GUI_DRAW_HANDLE hDrawObj, WM_HWIN hWin, int x0HR, int y0HR);  // This function uses parameter which are only available when Widgets and WM are available
X  void GUI_MEMDEV_DrawBitmapObj32HQHR  (GUI_DRAW_HANDLE hDrawObj, GUI_HWIN hWin, int x0HR, int y0HR);  
N#endif
N
N/*********************************************************************
N*
N*       Global data
N*
N**********************************************************************
N*/
Nextern const WIDGET_EFFECT WIDGET_Effect_3D;
Nextern const WIDGET_EFFECT WIDGET_Effect_3D1L;
Nextern const WIDGET_EFFECT WIDGET_Effect_3D2L;
Nextern const WIDGET_EFFECT WIDGET_Effect_None;
Nextern const WIDGET_EFFECT WIDGET_Effect_Simple;
N
N/*********************************************************************
N*
N*       Internal API routines
N*
N**********************************************************************
N*/
Nvoid      WIDGET__ConvertScrollState_PixelToLine(WM_HWIN hObj, const WIDGET_SCROLLSTATE_API * pAPI, int StateVPixelwise, int * pStateVLinewise, int * pMotionOffsetY);
Xvoid      WIDGET__ConvertScrollState_PixelToLine(GUI_HWIN hObj, const WIDGET_SCROLLSTATE_API * pAPI, int StateVPixelwise, int * pStateVLinewise, int * pMotionOffsetY);
Nint       WIDGET__ConvertScrollState_LineToPixel(WM_HWIN hObj, const WIDGET_SCROLLSTATE_API * pAPI, int StateVLinewise, int MotionOffsetY);
Xint       WIDGET__ConvertScrollState_LineToPixel(GUI_HWIN hObj, const WIDGET_SCROLLSTATE_API * pAPI, int StateVLinewise, int MotionOffsetY);
Nvoid      WIDGET__DrawFocusRect                 (WIDGET * pWidget, const GUI_RECT * pRect, int Dist);
Nvoid      WIDGET__DrawHLine                     (WIDGET * pWidget, int y, int x0, int x1);
Nvoid      WIDGET__DrawTriangle                  (WIDGET * pWidget, int x, int y, int Size, int Inc);
Nvoid      WIDGET__DrawVLine                     (WIDGET * pWidget, int x, int y0, int y1);
Nvoid      WIDGET__EFFECT_DrawDownRect           (WIDGET * pWidget, GUI_RECT * pRect);
Nvoid      WIDGET__EFFECT_DrawDown               (WIDGET * pWidget);
Nvoid      WIDGET__EFFECT_DrawUpRect             (WIDGET * pWidget, GUI_RECT * pRect);
Nvoid      WIDGET__EnableMotion                  (WM_HWIN hObj, int Flags, WIDGET_ENABLE_MOTION_CONTEXT * pContext);
Xvoid      WIDGET__EnableMotion                  (GUI_HWIN hObj, int Flags, WIDGET_ENABLE_MOTION_CONTEXT * pContext);
Nvoid      WIDGET__FillRectEx                    (WIDGET * pWidget, const GUI_RECT * pRect);
Nint       WIDGET__GetWindowSizeX                (WM_HWIN hWin);
Xint       WIDGET__GetWindowSizeX                (GUI_HWIN hWin);
NGUI_COLOR WIDGET__GetBkColor                    (WM_HWIN hObj);
XGUI_COLOR WIDGET__GetBkColor                    (GUI_HWIN hObj);
Nint       WIDGET__GetXSize                      (const WIDGET * pWidget);
Nint       WIDGET__GetYSize                      (const WIDGET * pWidget);
Nvoid      WIDGET__GetClientRect                 (WIDGET * pWidget, GUI_RECT * pRect);
Nvoid      WIDGET__GetInsideRect                 (WIDGET * pWidget, GUI_RECT * pRect);
NU32       WIDGET__HandleMotionMove              (WM_HWIN hObj, WM_MOTION_INFO * pInfo, const WIDGET_SCROLLSTATE_API * pAPI);
Xunsigned long       WIDGET__HandleMotionMove              (GUI_HWIN hObj, WM_MOTION_INFO * pInfo, const WIDGET_SCROLLSTATE_API * pAPI);
Nvoid      WIDGET__HandleMotionMoveBack          (WM_HWIN hObj, const WIDGET_SCROLLSTATE_API * pAPI);
Xvoid      WIDGET__HandleMotionMoveBack          (GUI_HWIN hObj, const WIDGET_SCROLLSTATE_API * pAPI);
Nvoid      WIDGET__Init                          (WIDGET * pWidget, int Id, U16 State);
Xvoid      WIDGET__Init                          (WIDGET * pWidget, int Id, unsigned short State);
Nvoid      WIDGET__RotateRect90                  (WIDGET * pWidget, GUI_RECT * pDest, const GUI_RECT * pRect);
Nvoid      WIDGET__SetScrollState                (WM_HWIN hWin, const WM_SCROLL_STATE * pVState, const WM_SCROLL_STATE * pHState);
Xvoid      WIDGET__SetScrollState                (GUI_HWIN hWin, const WM_SCROLL_STATE * pVState, const WM_SCROLL_STATE * pHState);
Nvoid      WIDGET__FillStringInRect              (const char * pText, const GUI_RECT * pFillRect, const GUI_RECT * pTextRectMax, const GUI_RECT * pTextRectAct);
Nvoid      WIDGET__FillStringInRectEx            (const char * pText, const GUI_RECT * pFillRect, const GUI_RECT * pTextRectMax, const GUI_RECT * pTextRectAct, int xOffset);
N
N//
N// Function pointers for drawing streamed bitmaps
N//
Nextern void (* GUI__pfDrawStreamedBitmap)  (const void * p, int x, int y);
Nextern int  (* GUI__pfDrawStreamedBitmapEx)(GUI_DTA_GET_DATA_FUNC * pfGetData, const void * p, int x, int y);
N
N/*********************************************************************
N*
N*       API routines
N*
N**********************************************************************
N*/
Nvoid  WIDGET_SetState          (WM_HWIN hObj, int State);
Xvoid  WIDGET_SetState          (GUI_HWIN hObj, int State);
Nvoid  WIDGET_AndState          (WM_HWIN hObj, int State);
Xvoid  WIDGET_AndState          (GUI_HWIN hObj, int State);
Nvoid  WIDGET_OrState           (WM_HWIN hObj, int State);
Xvoid  WIDGET_OrState           (GUI_HWIN hObj, int State);
Nint   WIDGET_HandleActive      (WM_HWIN hObj, WM_MESSAGE* pMsg);
Xint   WIDGET_HandleActive      (GUI_HWIN hObj, WM_MESSAGE* pMsg);
Nint   WIDGET_GetState          (WM_HWIN hObj);
Xint   WIDGET_GetState          (GUI_HWIN hObj);
Nint   WIDGET_SetWidth          (WM_HWIN hObj, int Width);
Xint   WIDGET_SetWidth          (GUI_HWIN hObj, int Width);
Nvoid  WIDGET_SetFocusable      (WM_HWIN hObj, int State);
Xvoid  WIDGET_SetFocusable      (GUI_HWIN hObj, int State);
NU32   WIDGET_GetType           (WM_HWIN hObj);
Xunsigned long   WIDGET_GetType           (GUI_HWIN hObj);
NU16   WIDGET_SetMinTimePerFrame(U16 MinTimePerFrame);
Xunsigned short   WIDGET_SetMinTimePerFrame(unsigned short MinTimePerFrame);
NU16   WIDGET_GetMinTimePerFrame(void);
Xunsigned short   WIDGET_GetMinTimePerFrame(void);
N
Nvoid  WIDGET_EFFECT_3D_DrawUp(void);
N
Nconst WIDGET_EFFECT* WIDGET_SetDefaultEffect(const WIDGET_EFFECT* pEffect);
N
Nvoid  WIDGET_SetEffect              (WM_HWIN hObj, const WIDGET_EFFECT* pEffect);
Xvoid  WIDGET_SetEffect              (GUI_HWIN hObj, const WIDGET_EFFECT* pEffect);
N
Nconst WIDGET_EFFECT* WIDGET_GetDefaultEffect(void);
N
Nvoid WIDGET_EFFECT_3D_SetColor    (unsigned Index, GUI_COLOR Color);
Nvoid WIDGET_EFFECT_3D1L_SetColor  (unsigned Index, GUI_COLOR Color);
Nvoid WIDGET_EFFECT_3D2L_SetColor  (unsigned Index, GUI_COLOR Color);
Nvoid WIDGET_EFFECT_Simple_SetColor(unsigned Index, GUI_COLOR Color);
N
NGUI_COLOR WIDGET_EFFECT_3D_GetColor    (unsigned Index);
NGUI_COLOR WIDGET_EFFECT_3D1L_GetColor  (unsigned Index);
NGUI_COLOR WIDGET_EFFECT_3D2L_GetColor  (unsigned Index);
NGUI_COLOR WIDGET_EFFECT_Simple_GetColor(unsigned Index);
N
Nint WIDGET_EFFECT_3D_GetNumColors(void);
Nint WIDGET_EFFECT_3D1L_GetNumColors(void);
Nint WIDGET_EFFECT_3D2L_GetNumColors(void);
Nint WIDGET_EFFECT_Simple_GetNumColors(void);
N
N/*********************************************************************
N*
N*       Compatibility macros
N*
N**********************************************************************
N*/
N#define WIDGET_EnableStreamAuto() GUI_DrawStreamedEnableAuto()
N
N#define WIDGET_SetDefaultEffect_3D()     WIDGET_SetDefaultEffect(&WIDGET_Effect_3D)
N#define WIDGET_SetDefaultEffect_3D1L()   WIDGET_SetDefaultEffect(&WIDGET_Effect_3D1L)
N#define WIDGET_SetDefaultEffect_3D2L()   WIDGET_SetDefaultEffect(&WIDGET_Effect_3D2L)
N#define WIDGET_SetDefaultEffect_None()   WIDGET_SetDefaultEffect(&WIDGET_Effect_None)
N#define WIDGET_SetDefaultEffect_Simple() WIDGET_SetDefaultEffect(&WIDGET_Effect_Simple)
N
N#endif /* GUI_WINSUPPORT */
N
N#if defined(__cplusplus)
X#if 0L
S  }
N#endif
N
N#endif   /* SLIDER_H */
N
N/*************************** End of file ****************************/
L 51 "..\..\..\..\ThirdParty\emWin\Include\BUTTON.h" 2
N
N#if GUI_WINSUPPORT
X#if 1
N
N#if defined(__cplusplus)
X#if 0L
S  extern "C" {     /* Make sure we have C-declarations in C++ programs */
N#endif
N
N/*********************************************************************
N*
N*       Create flags
N*/
N/* For compatibility only ! */
N#define BUTTON_CF_HIDE   WM_CF_HIDE
N#define BUTTON_CF_SHOW   WM_CF_SHOW
N#define BUTTON_CF_MEMDEV WM_CF_MEMDEV
N
N/*********************************************************************
N*
N*       BUTTON color indexes
N*
N*  Description
N*    Color indexes for BUTTON widget.
N*/
N#define BUTTON_CI_UNPRESSED 0    // Color for disabled state.
N#define BUTTON_CI_PRESSED   1    // Color for pressed state.
N#define BUTTON_CI_DISABLED  2    // Color for unpressed state.
N
N/*********************************************************************
N*
N*       BUTTON bitmap indexes
N*
N*  Description
N*    Bitmap indexes for BUTTON widget.
N*/
N#define BUTTON_BI_UNPRESSED 0    // Bitmap for disabled state.
N#define BUTTON_BI_PRESSED   1    // Bitmap for pressed state.
N#define BUTTON_BI_DISABLED  2    // Bitmap for unpressed state.
N
N/*********************************************************************
N*
N*       States
N*/
N#define BUTTON_STATE_FOCUS      WIDGET_STATE_FOCUS
N#define BUTTON_STATE_PRESSED    WIDGET_STATE_USER0
N#define BUTTON_STATE_TOGGLEMODE WIDGET_STATE_USER1
N#define BUTTON_STATE_TOGGLED    WIDGET_STATE_USER2
N
N/*********************************************************************
N*
N*       Skinning property indices
N*/
N#define BUTTON_SKINFLEX_PI_PRESSED     0
N#define BUTTON_SKINFLEX_PI_FOCUSED     1
N#define BUTTON_SKINFLEX_PI_ENABLED     2
N#define BUTTON_SKINFLEX_PI_DISABLED    3
N
N#define BUTTON_SKINFLEX_PI_FOCUSSED BUTTON_SKINFLEX_PI_FOCUSED
N
N/*********************************************************************
N*
N*       Types
N*
N**********************************************************************
N*/
Ntypedef WM_HMEM BUTTON_Handle;
Xtypedef signed long BUTTON_Handle;
N
Ntypedef struct {
N  GUI_COLOR aColorFrame[3];
N  GUI_COLOR aColorUpper[2];
N  GUI_COLOR aColorLower[2];
N  int Radius;
N} BUTTON_SKINFLEX_PROPS;
N
N/*********************************************************************
N*
N*       Create function(s)
N
N  Note: the parameters to a create function may vary.
N         Some widgets may have multiple create functions
N*/
N
NBUTTON_Handle BUTTON_Create        (int x0, int y0, int xSize, int ySize, int ID, int Flags);
NBUTTON_Handle BUTTON_CreateAsChild (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int Id, int Flags);
XBUTTON_Handle BUTTON_CreateAsChild (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int Id, int Flags);
NBUTTON_Handle BUTTON_CreateEx      (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int ExFlags, int Id);
XBUTTON_Handle BUTTON_CreateEx      (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int WinFlags, int ExFlags, int Id);
NBUTTON_Handle BUTTON_CreateUser    (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int ExFlags, int Id, int NumExtraBytes);
XBUTTON_Handle BUTTON_CreateUser    (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int WinFlags, int ExFlags, int Id, int NumExtraBytes);
NBUTTON_Handle BUTTON_CreateIndirect(const GUI_WIDGET_CREATE_INFO * pCreateInfo, WM_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
XBUTTON_Handle BUTTON_CreateIndirect(const GUI_WIDGET_CREATE_INFO * pCreateInfo, GUI_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
N
N/*********************************************************************
N*
N*       Managing default values
N*
N**********************************************************************
N*/
NGUI_COLOR        BUTTON_GetDefaultBkColor   (unsigned Index);
Nconst GUI_FONT * BUTTON_GetDefaultFont      (void);
Nint              BUTTON_GetDefaultTextAlign (void);
NGUI_COLOR        BUTTON_GetDefaultTextColor (unsigned Index);
Nvoid             BUTTON_SetDefaultBkColor   (GUI_COLOR Color, unsigned Index);
NGUI_COLOR        BUTTON_SetDefaultFocusColor(GUI_COLOR Color);
Nvoid             BUTTON_SetDefaultFont      (const GUI_FONT * pFont);
Nvoid             BUTTON_SetDefaultTextAlign (int Align);
Nvoid             BUTTON_SetDefaultTextColor (GUI_COLOR Color, unsigned Index);
N
N/*********************************************************************
N*
N*       The callback ...
N*
N* Do not call it directly ! It is only to be used from within an
N* overwritten callback.
N*/
Nvoid BUTTON_Callback(WM_MESSAGE *pMsg);
N
N/*********************************************************************
N*
N*       Member functions
N*
N**********************************************************************
N*/
NGUI_COLOR          BUTTON_GetBkColor         (BUTTON_Handle hObj, unsigned int Index);
Nconst GUI_BITMAP * BUTTON_GetBitmap          (BUTTON_Handle hObj,unsigned int Index);
Nconst GUI_FONT   * BUTTON_GetFont            (BUTTON_Handle hObj);
NGUI_COLOR          BUTTON_GetFrameColor      (BUTTON_Handle hObj);
NWIDGET           * BUTTON_GetpWidget         (BUTTON_Handle hObj);
Nvoid               BUTTON_GetText            (BUTTON_Handle hObj, char * pBuffer, int MaxLen);
NGUI_COLOR          BUTTON_GetTextColor       (BUTTON_Handle hObj, unsigned int Index);
Nint                BUTTON_GetTextAlign       (BUTTON_Handle hObj);
Nint                BUTTON_GetUserData        (BUTTON_Handle hObj, void * pDest, int NumBytes);
Nunsigned           BUTTON_IsPressed          (BUTTON_Handle hObj);
Nvoid               BUTTON_SetBitmap          (BUTTON_Handle hObj, unsigned int Index, const GUI_BITMAP * pBitmap);
Nvoid               BUTTON_SetBitmapEx        (BUTTON_Handle hObj, unsigned int Index, const GUI_BITMAP * pBitmap, int x, int y);
Nvoid               BUTTON_SetBkColor         (BUTTON_Handle hObj, unsigned int Index, GUI_COLOR Color);
Nvoid               BUTTON_SetBMP             (BUTTON_Handle hObj, unsigned int Index, const void * pBitmap);
Nvoid               BUTTON_SetBMPEx           (BUTTON_Handle hObj, unsigned int Index, const void * pBitmap, int x, int y);
Nvoid               BUTTON_SetFont            (BUTTON_Handle hObj, const GUI_FONT * pfont);
Nvoid               BUTTON_SetFrameColor      (BUTTON_Handle hObj, GUI_COLOR Color);
Nvoid               BUTTON_SetState           (BUTTON_Handle hObj, int State);                                    /* Not to be doc. */
Nvoid               BUTTON_SetPressed         (BUTTON_Handle hObj, int State);
NGUI_COLOR          BUTTON_SetFocusColor      (BUTTON_Handle hObj, GUI_COLOR Color);
Nvoid               BUTTON_SetStreamedBitmap  (BUTTON_Handle hObj, unsigned int Index, const GUI_BITMAP_STREAM * pBitmap);
Nvoid               BUTTON_SetStreamedBitmapEx(BUTTON_Handle hObj, unsigned int Index, const GUI_BITMAP_STREAM * pBitmap, int x, int y);
Nint                BUTTON_SetText            (BUTTON_Handle hObj, const char* s);
Nvoid               BUTTON_SetTextAlign       (BUTTON_Handle hObj, int Align);
Nvoid               BUTTON_SetTextColor       (BUTTON_Handle hObj, unsigned int Index, GUI_COLOR Color);
Nvoid               BUTTON_SetTextOffset      (BUTTON_Handle hObj, int xPos, int yPos);
Nvoid               BUTTON_SetToggleMode      (BUTTON_Handle hObj, int OnOff);
Nvoid               BUTTON_SetSelfDrawEx      (BUTTON_Handle hObj, unsigned int Index, GUI_DRAW_SELF_CB * pDraw, int x, int y); /* Not to be doc. */
Nvoid               BUTTON_SetSelfDraw        (BUTTON_Handle hObj, unsigned int Index, GUI_DRAW_SELF_CB * pDraw);               /* Not to be doc. */
Nvoid               BUTTON_SetReactOnLevel    (void);
Nvoid               BUTTON_SetReactOnTouch    (void);
Nint                BUTTON_SetUserData        (BUTTON_Handle hObj, const void * pSrc, int NumBytes);
Nint                BUTTON_Toggle             (BUTTON_Handle hObj);
N
N#define BUTTON_SetFocussable BUTTON_SetFocusable
N#define BUTTON_SetFocusable  WIDGET_SetFocusable
N
N/*********************************************************************
N*
N*       Member functions: Skinning
N*
N**********************************************************************
N*/
Nvoid BUTTON_GetSkinFlexProps     (BUTTON_SKINFLEX_PROPS * pProps, int Index);
Nvoid BUTTON_SetSkinClassic       (BUTTON_Handle hObj);
Nvoid BUTTON_SetSkin              (BUTTON_Handle hObj, WIDGET_DRAW_ITEM_FUNC * pfDrawSkin);
Nint  BUTTON_DrawSkinFlex         (const WIDGET_ITEM_DRAW_INFO * pDrawItemInfo);
Nvoid BUTTON_SetSkinFlexProps     (const BUTTON_SKINFLEX_PROPS * pProps, int Index);
Nvoid BUTTON_SetDefaultSkinClassic(void);
NWIDGET_DRAW_ITEM_FUNC * BUTTON_SetDefaultSkin(WIDGET_DRAW_ITEM_FUNC * pfDrawSkin);
N
N#define BUTTON_SKIN_FLEX    BUTTON_DrawSkinFlex
N
N#if defined(__cplusplus)
X#if 0L
S  }
N#endif
N
N#endif   // GUI_WINSUPPORT
N#endif   // BUTTON_H
N
N/*************************** End of file ****************************/
L 51 "..\..\..\..\ThirdParty\emWin\Include\DIALOG.h" 2
N#include "CALENDAR.h"
L 1 "..\..\..\..\ThirdParty\emWin\Include\CALENDAR.h" 1
N/*********************************************************************
N*                    SEGGER Microcontroller GmbH                     *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2023  SEGGER Microcontroller GmbH                *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V6.46 - Graphical user interface for embedded applications **
NemWin is protected by international copyright laws. Knowledge of the
Nsource code may not be used to write a similar product. 
NThis file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed by SEGGER Software GmbH to Nuvoton Technology Corporation
Nat the address: No. 4, Creation Rd. III, Hsinchu Science Park, Taiwan
Nfor the purposes  of  creating  libraries  for its 
NArm Cortex-A, Arm Cortex-M and  Arm9 32-bit microcontrollers, commercialized and distributed by Nuvoton Technology Corporation
Nunder  the terms and conditions  of  an  End  User  
NLicense  Agreement  supplied  with  the libraries.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NLicensing information
NLicensor:                 SEGGER Software GmbH
NLicensed to:              Nuvoton Technology Corporation, No. 4, Creation Rd. III, Hsinchu Science Park, 30077 Hsinchu City, Taiwan
NLicensed SEGGER software: emWin
NLicense number:           GUI-00735
NLicense model:            emWin License Agreement, signed February 27, 2018
NLicensed platform:        Cortex-M, Cortex-A, and ARM9 32-bit series microcontroller designed and manufactured by Nuvoton Technology Corporation.
N----------------------------------------------------------------------
NSupport and Update Agreement (SUA)
NSUA period:               2018-03-26 - 2025-09-04
NContact to extend SUA:    sales@segger.com
N----------------------------------------------------------------------
NFile        : CALENDAR.h
NPurpose     : Message box interface
N--------------------END-OF-HEADER-------------------------------------
N*/
N
N#ifndef CALENDAR_H
N#define CALENDAR_H
N
N#include "WM.h"
N
N#if GUI_WINSUPPORT
X#if 1
N
N#if defined(__cplusplus)
X#if 0L
S  extern "C" {     /* Make sure we have C-declarations in C++ programs */
N#endif
N
N/*********************************************************************
N*
N*       Defines
N*
N**********************************************************************
N*/
N/*********************************************************************
N*
N*       CALENDAR color indexes
N*
N*  Description
N*    Color indexes used by the CALENDAR dialog.
N*/
N#define CALENDAR_CI_WEEKEND 0     // Color to be used for weekend days.
N#define CALENDAR_CI_WEEKDAY 1     // Color to be used for weekdays.
N#define CALENDAR_CI_SEL     2     // Color to be used for the selection.
N#define CALENDAR_CI_HEADER  3     // Background color to be used for the header area.
N#define CALENDAR_CI_MONTH   4     // Color to be used for the month (and year) text.
N#define CALENDAR_CI_LABEL   5     // Color to be used for labeling the days.
N#define CALENDAR_CI_FRAME   6     // Color to be used for the frame of the current date.
N
N/*********************************************************************
N*
N*       CALENDAR font indexes
N*
N*  Description
N*    Font indexes used by the CALENDAR dialog.
N*/
N#define CALENDAR_FI_CONTENT 0     // Font to be used for labeling and the numbers.
N#define CALENDAR_FI_HEADER  1     // Font to be used for month / year.
N
N/*********************************************************************
N*
N*       CALENDAR size indexes
N*
N*  Description
N*    Size indexes used by the routine CALENDAR_SetDefaultSize().
N*/
N#define CALENDAR_SI_HEADER  0     // Y-size in pixels used for the header area. (default is 25)
N#define CALENDAR_SI_CELL_X  1     // Cell size in X to be used for one item in the day pad. (default is 18)
N#define CALENDAR_SI_CELL_Y  2     // Cell size in Y to be used for one item in the day pad. (default is 13)
N
N/*********************************************************************
N*
N*       CALENDAR Notification codes
N*
N* The following is the list of notification codes specific to this widget,
N* Send with the WM_NOTIFY_PARENT message
N*/
N#define CALENDAR_NOTIFICATION_MONTH_CLICKED  (WM_NOTIFICATION_WIDGET + 0)
N#define CALENDAR_NOTIFICATION_MONTH_RELEASED (WM_NOTIFICATION_WIDGET + 1)
N
N/*********************************************************************
N*
N*       Types
N*
N**********************************************************************
N*/
N/*********************************************************************
N*
N*       CALENDAR_DATE
N*
N*  Description
N*    Structure used by the routine CALENDAR_GetDate() to retrieve a date.
N*/
Ntypedef struct {
N  int Year;       // Year of requested date.
N  int Month;      // Month of requested date.
N  int Day;        // Day of requested date.
N} CALENDAR_DATE;
N
N/*********************************************************************
N*
N*       CALENDAR_SKINFLEX_PROPS
N*/
Ntypedef struct {
N  GUI_COLOR aColorFrame[3]; // Frame colors of buttons
N  GUI_COLOR aColorUpper[2]; // Upper gradient colors of buttons
N  GUI_COLOR aColorLower[2]; // Lower gradient colors of buttons
N  GUI_COLOR ColorArrow;     // Arrow colors
N} CALENDAR_SKINFLEX_PROPS;
N
N/*********************************************************************
N*
N*       Public code
N*
N**********************************************************************
N*/
NWM_HWIN CALENDAR_Create           (WM_HWIN hParent, int xPos, int yPos, unsigned Year, unsigned Month, unsigned Day, unsigned FirstDayOfWeek, int Id, int Flags);
XGUI_HWIN CALENDAR_Create           (GUI_HWIN hParent, int xPos, int yPos, unsigned Year, unsigned Month, unsigned Day, unsigned FirstDayOfWeek, int Id, int Flags);
Nvoid    CALENDAR_GetDate          (WM_HWIN hWin, CALENDAR_DATE * pDate);
Xvoid    CALENDAR_GetDate          (GUI_HWIN hWin, CALENDAR_DATE * pDate);
Nint     CALENDAR_GetDaysOfMonth   (CALENDAR_DATE * pDate);
Nvoid    CALENDAR_GetSel           (WM_HWIN hWin, CALENDAR_DATE * pDate);
Xvoid    CALENDAR_GetSel           (GUI_HWIN hWin, CALENDAR_DATE * pDate);
Nint     CALENDAR_GetWeekday       (CALENDAR_DATE * pDate);
Nvoid    CALENDAR_SetDate          (WM_HWIN hWin, CALENDAR_DATE * pDate);
Xvoid    CALENDAR_SetDate          (GUI_HWIN hWin, CALENDAR_DATE * pDate);
Nvoid    CALENDAR_SetSel           (WM_HWIN hWin, CALENDAR_DATE * pDate);
Xvoid    CALENDAR_SetSel           (GUI_HWIN hWin, CALENDAR_DATE * pDate);
Nvoid    CALENDAR_ShowDate         (WM_HWIN hWin, CALENDAR_DATE * pDate);
Xvoid    CALENDAR_ShowDate         (GUI_HWIN hWin, CALENDAR_DATE * pDate);
Nint     CALENDAR_AddKey           (WM_HWIN hWin, int Key);
Xint     CALENDAR_AddKey           (GUI_HWIN hWin, int Key);
N
N/*********************************************************************
N*
N*       Default related
N*/
Nvoid    CALENDAR_SetDefaultBkColor(unsigned Index, GUI_COLOR Color);
Nvoid    CALENDAR_SetDefaultColor  (unsigned Index, GUI_COLOR Color);
Nvoid    CALENDAR_SetDefaultDays   (const char ** apDays);
Nvoid    CALENDAR_SetDefaultFont   (unsigned Index, const GUI_FONT * pFont);
Nvoid    CALENDAR_SetDefaultMonths (const char ** apMonths);
Nvoid    CALENDAR_SetDefaultSize   (unsigned Index, unsigned Size);
N
N/*********************************************************************
N*
N*       Skinning related
N*/
Nvoid    CALENDAR_GetSkinFlexProps (CALENDAR_SKINFLEX_PROPS * pProps, int Index);
Nvoid    CALENDAR_SetSkinFlexProps (const CALENDAR_SKINFLEX_PROPS * pProps, int Index);
N
N/*********************************************************************
N*
N*       The callback ...
N*
N* Do not call it directly ! It is only to be used from within an
N* overwritten callback.
N*/
Nvoid CALENDAR_Callback(WM_MESSAGE * pMsg);
N
N#if defined(__cplusplus)
X#if 0L
S  }
N#endif
N
N#endif // GUI_WINSUPPORT
N#endif // CALENDAR_H
N
N/*************************** End of file ****************************/
L 52 "..\..\..\..\ThirdParty\emWin\Include\DIALOG.h" 2
N#include "CHECKBOX.h"
L 1 "..\..\..\..\ThirdParty\emWin\Include\CHECKBOX.h" 1
N/*********************************************************************
N*                    SEGGER Microcontroller GmbH                     *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2023  SEGGER Microcontroller GmbH                *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V6.46 - Graphical user interface for embedded applications **
NemWin is protected by international copyright laws. Knowledge of the
Nsource code may not be used to write a similar product. 
NThis file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed by SEGGER Software GmbH to Nuvoton Technology Corporation
Nat the address: No. 4, Creation Rd. III, Hsinchu Science Park, Taiwan
Nfor the purposes  of  creating  libraries  for its 
NArm Cortex-A, Arm Cortex-M and  Arm9 32-bit microcontrollers, commercialized and distributed by Nuvoton Technology Corporation
Nunder  the terms and conditions  of  an  End  User  
NLicense  Agreement  supplied  with  the libraries.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NLicensing information
NLicensor:                 SEGGER Software GmbH
NLicensed to:              Nuvoton Technology Corporation, No. 4, Creation Rd. III, Hsinchu Science Park, 30077 Hsinchu City, Taiwan
NLicensed SEGGER software: emWin
NLicense number:           GUI-00735
NLicense model:            emWin License Agreement, signed February 27, 2018
NLicensed platform:        Cortex-M, Cortex-A, and ARM9 32-bit series microcontroller designed and manufactured by Nuvoton Technology Corporation.
N----------------------------------------------------------------------
NSupport and Update Agreement (SUA)
NSUA period:               2018-03-26 - 2025-09-04
NContact to extend SUA:    sales@segger.com
N----------------------------------------------------------------------
NFile        : CHECKBOX.h
NPurpose     : CHECKBOX include
N--------------------END-OF-HEADER-------------------------------------
N*/
N
N#ifndef CHECKBOX_H
N#define CHECKBOX_H
N
N#include "WM.h"
N#include "DIALOG_Type.h"      /* Req. for Create indirect data structure */
N#include "WIDGET.h"
N
N#if GUI_WINSUPPORT
X#if 1
N
N#if defined(__cplusplus)
X#if 0L
S  extern "C" {     /* Make sure we have C-declarations in C++ programs */
N#endif
N
N/*********************************************************************
N*
N*       Defines
N*
N**********************************************************************
N*/
N
N/*********************************************************************
N*
N*       CHECKBOX color indexes
N*
N*  Description
N*    Color indexes for CHECKBOX widget.
N*/
N#define CHECKBOX_CI_DISABLED 0            // Color used for disabled state.
N#define CHECKBOX_CI_ENABLED  1            // Color used for enabled state.
N
N/*********************************************************************
N*
N*       CHECKBOX bitmap indexes
N*
N*  Description
N*    Bitmap indexes for CHECKBOX widget.
N*/
N#define CHECKBOX_BI_INACTIV_UNCHECKED 0   // Bitmap displayed when the CHECKBOX is unchecked and disabled.
N#define CHECKBOX_BI_ACTIV_UNCHECKED   1   // Bitmap displayed when the CHECKBOX is unchecked and enabled.
N#define CHECKBOX_BI_INACTIV_CHECKED   2   // Bitmap displayed when the CHECKBOX is checked and disabled.
N#define CHECKBOX_BI_ACTIV_CHECKED     3   // Bitmap displayed when the CHECKBOX is checked and enabled.
N#define CHECKBOX_BI_INACTIV_3STATE    4   // Bitmap displayed when the CHECKBOX is in the third state and disabled.
N#define CHECKBOX_BI_ACTIV_3STATE      5   // Bitmap displayed when the CHECKBOX is in the third state and enabled.
N
N/*********************************************************************
N*
N*       Skinning property indices
N*/
N#define CHECKBOX_SKINFLEX_PI_ENABLED     0
N#define CHECKBOX_SKINFLEX_PI_DISABLED    1
N
N/*********************************************************************
N*
N*       Public Types
N*
N**********************************************************************
N*/
Ntypedef WM_HMEM CHECKBOX_Handle;
Xtypedef signed long CHECKBOX_Handle;
N
Ntypedef struct {
N  GUI_COLOR aColorFrame[3];
N  GUI_COLOR aColorInner[2];
N  GUI_COLOR ColorCheck;
N  int       ButtonSize;
N} CHECKBOX_SKINFLEX_PROPS;
N
N/*********************************************************************
N*
N*       Create functions
N*
N**********************************************************************
N*/
NCHECKBOX_Handle CHECKBOX_Create        (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int Id, int Flags);
XCHECKBOX_Handle CHECKBOX_Create        (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int Id, int Flags);
NCHECKBOX_Handle CHECKBOX_CreateEx      (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int ExFlags, int Id);
XCHECKBOX_Handle CHECKBOX_CreateEx      (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int WinFlags, int ExFlags, int Id);
NCHECKBOX_Handle CHECKBOX_CreateUser    (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int ExFlags, int Id, int NumExtraBytes);
XCHECKBOX_Handle CHECKBOX_CreateUser    (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int WinFlags, int ExFlags, int Id, int NumExtraBytes);
NCHECKBOX_Handle CHECKBOX_CreateIndirect(const GUI_WIDGET_CREATE_INFO * pCreateInfo, WM_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
XCHECKBOX_Handle CHECKBOX_CreateIndirect(const GUI_WIDGET_CREATE_INFO * pCreateInfo, GUI_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
N
N/*********************************************************************
N*
N*       The callback ...
N*
N* Do not call it directly ! It is only to be used from within an
N* overwritten callback.
N*/
Nvoid CHECKBOX_Callback(WM_MESSAGE * pMsg);
N
N/*********************************************************************
N*
N*       Managing default values
N*
N**********************************************************************
N*/
N
Nint              CHECKBOX_GetDefaultAlign     (void);
NGUI_COLOR        CHECKBOX_GetDefaultBkColor   (void);
Nconst GUI_FONT * CHECKBOX_GetDefaultFont      (void);
Nint              CHECKBOX_GetDefaultSpacing   (void);
NGUI_COLOR        CHECKBOX_GetDefaultTextColor (void);
Nint              CHECKBOX_GetUserData         (CHECKBOX_Handle hObj, void * pDest, int NumBytes);
Nvoid             CHECKBOX_SetDefaultAlign     (int Align);
Nvoid             CHECKBOX_SetDefaultBkColor   (GUI_COLOR Color);
NGUI_COLOR        CHECKBOX_SetDefaultFocusColor(GUI_COLOR Color);
Nvoid             CHECKBOX_SetDefaultFont      (const GUI_FONT * pFont);
Nvoid             CHECKBOX_SetDefaultImage     (const GUI_BITMAP * pBitmap, unsigned int Index);
Nvoid             CHECKBOX_SetDefaultSpacing   (int Spacing);
Nvoid             CHECKBOX_SetDefaultTextColor (GUI_COLOR Color);
N
N#define          CHECKBOX_GetDefaultTextAlign CHECKBOX_GetDefaultAlign
N#define          CHECKBOX_SetDefaultTextAlign CHECKBOX_SetDefaultAlign
N
N/*********************************************************************
N*
N*       Member functions
N*
N**********************************************************************
N*/
NGUI_COLOR          CHECKBOX_GetBkColor   (CHECKBOX_Handle hObj);
NGUI_COLOR          CHECKBOX_GetBoxBkColor(CHECKBOX_Handle hObj, int Index);
NGUI_COLOR          CHECKBOX_GetFocusColor(CHECKBOX_Handle hObj);
Nconst GUI_FONT   * CHECKBOX_GetFont      (CHECKBOX_Handle hObj);
Nconst GUI_BITMAP * CHECKBOX_GetImage     (CHECKBOX_Handle hObj, unsigned int Index);
Nint                CHECKBOX_GetState     (CHECKBOX_Handle hObj);
Nint                CHECKBOX_GetText      (CHECKBOX_Handle hObj, char * pBuffer, int MaxLen);
Nint                CHECKBOX_GetTextAlign (CHECKBOX_Handle hObj);
NGUI_COLOR          CHECKBOX_GetTextColor (CHECKBOX_Handle hObj);
Nint                CHECKBOX_IsChecked    (CHECKBOX_Handle hObj);
Nvoid               CHECKBOX_SetBkColor   (CHECKBOX_Handle hObj, GUI_COLOR Color);
NGUI_COLOR          CHECKBOX_SetBoxBkColor(CHECKBOX_Handle hObj, GUI_COLOR Color, int Index);
NGUI_COLOR          CHECKBOX_SetFocusColor(CHECKBOX_Handle hObj, GUI_COLOR Color);
Nvoid               CHECKBOX_SetFont      (CHECKBOX_Handle hObj, const GUI_FONT * pFont);
Nvoid               CHECKBOX_SetImage     (CHECKBOX_Handle hObj, const GUI_BITMAP * pBitmap, unsigned int Index);
Nvoid               CHECKBOX_SetNumStates (CHECKBOX_Handle hObj, unsigned NumStates);
Nvoid               CHECKBOX_SetSpacing   (CHECKBOX_Handle hObj, unsigned Spacing);
Nvoid               CHECKBOX_SetState     (CHECKBOX_Handle hObj, unsigned State);
Nvoid               CHECKBOX_SetText      (CHECKBOX_Handle hObj, const char * pText);
Nvoid               CHECKBOX_SetTextAlign (CHECKBOX_Handle hObj, int Align);
Nvoid               CHECKBOX_SetTextColor (CHECKBOX_Handle hObj, GUI_COLOR Color);
Nint                CHECKBOX_SetUserData  (CHECKBOX_Handle hObj, const void * pSrc, int NumBytes);
N
N/*********************************************************************
N*
N*       Member functions: Skinning
N*
N**********************************************************************
N*/
Nvoid CHECKBOX_GetSkinFlexProps      (CHECKBOX_SKINFLEX_PROPS * pProps, int Index);
Nvoid CHECKBOX_SetSkinClassic        (CHECKBOX_Handle hObj);
Nvoid CHECKBOX_SetSkin               (CHECKBOX_Handle hObj, WIDGET_DRAW_ITEM_FUNC * pfDrawSkin);
Nint  CHECKBOX_DrawSkinFlex          (const WIDGET_ITEM_DRAW_INFO * pDrawItemInfo);
Nvoid CHECKBOX_SetSkinFlexProps      (const CHECKBOX_SKINFLEX_PROPS * pProps, int Index);
Nvoid CHECKBOX_SetDefaultSkinClassic (void);
Nint  CHECKBOX_GetSkinFlexButtonSize (CHECKBOX_Handle hObj);
Nvoid CHECKBOX_SetSkinFlexButtonSize (CHECKBOX_Handle hObj, int ButtonSize);
NWIDGET_DRAW_ITEM_FUNC * CHECKBOX_SetDefaultSkin(WIDGET_DRAW_ITEM_FUNC * pfDrawSkin);
N
N#define CHECKBOX_SKIN_FLEX    CHECKBOX_DrawSkinFlex
N
N/*********************************************************************
N*
N*       Macros for compatibility
N*
N**********************************************************************
N*/
N
N#define CHECKBOX_Check(hObj)   CHECKBOX_SetState(hObj, 1)
N#define CHECKBOX_Uncheck(hObj) CHECKBOX_SetState(hObj, 0)
N
N#define CHECKBOX_BI_INACTIV    CHECKBOX_BI_INACTIV_CHECKED
N#define CHECKBOX_BI_ACTIV      CHECKBOX_BI_ACTIV_CHECKED
N
N#if defined(__cplusplus)
X#if 0L
S  }
N#endif
N
N#endif  // GUI_WINSUPPORT
N#endif  // CHECKBOX_H
N
N/*************************** End of file ****************************/
L 53 "..\..\..\..\ThirdParty\emWin\Include\DIALOG.h" 2
N#include "CHOOSECOLOR.h"
L 1 "..\..\..\..\ThirdParty\emWin\Include\CHOOSECOLOR.h" 1
N/*********************************************************************
N*                    SEGGER Microcontroller GmbH                     *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2023  SEGGER Microcontroller GmbH                *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V6.46 - Graphical user interface for embedded applications **
NemWin is protected by international copyright laws. Knowledge of the
Nsource code may not be used to write a similar product. 
NThis file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed by SEGGER Software GmbH to Nuvoton Technology Corporation
Nat the address: No. 4, Creation Rd. III, Hsinchu Science Park, Taiwan
Nfor the purposes  of  creating  libraries  for its 
NArm Cortex-A, Arm Cortex-M and  Arm9 32-bit microcontrollers, commercialized and distributed by Nuvoton Technology Corporation
Nunder  the terms and conditions  of  an  End  User  
NLicense  Agreement  supplied  with  the libraries.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NLicensing information
NLicensor:                 SEGGER Software GmbH
NLicensed to:              Nuvoton Technology Corporation, No. 4, Creation Rd. III, Hsinchu Science Park, 30077 Hsinchu City, Taiwan
NLicensed SEGGER software: emWin
NLicense number:           GUI-00735
NLicense model:            emWin License Agreement, signed February 27, 2018
NLicensed platform:        Cortex-M, Cortex-A, and ARM9 32-bit series microcontroller designed and manufactured by Nuvoton Technology Corporation.
N----------------------------------------------------------------------
NSupport and Update Agreement (SUA)
NSUA period:               2018-03-26 - 2025-09-04
NContact to extend SUA:    sales@segger.com
N----------------------------------------------------------------------
NFile        : CHOOSECOLOR.h
NPurpose     : Message box interface
N--------------------END-OF-HEADER-------------------------------------
N*/
N
N#ifndef CHOOSECOLOR_H
N#define CHOOSECOLOR_H
N
N#include "WM.h"
N
N#if GUI_WINSUPPORT
X#if 1
N
N#if defined(__cplusplus)
X#if 0L
Sextern "C" {     /* Make sure we have C-declarations in C++ programs */
N#endif
N
N/*********************************************************************
N*
N*       Defines
N*
N**********************************************************************
N*/
N#define CHOOSECOLOR_CF_MOVEABLE FRAMEWIN_CF_MOVEABLE
N
N/*********************************************************************
N*
N*       CHOOSECOLOR color indexes
N*
N*  Description
N*    Color indexes used by the CHOOSECOLOR dialog.
N*/
N#define CHOOSECOLOR_CI_FRAME 0    // Color to be used to draw the frame surrounding each color. Default is GUI_GRAY.
N#define CHOOSECOLOR_CI_FOCUS 1    // Color to be used to draw the focus rectangle. Default is GUI_BLACK.
N
N/*********************************************************************
N*
N*       Types
N*
N**********************************************************************
N*/
N/*********************************************************************
N*
N*       CHOOSECOLOR_PROPS
N*/
Ntypedef struct {
N  unsigned  aBorder[2];
N  unsigned  aSpace[2];
N  unsigned  aButtonSize[2];
N  GUI_COLOR aColor[2];
N} CHOOSECOLOR_PROPS;
N
N/*********************************************************************
N*
N*       CHOOSECOLOR_CONTEXT
N*/
Ntypedef struct {
N  U32               LastColor;
X  unsigned long               LastColor;
N  const GUI_COLOR * pColor;
N  unsigned          NumColors;
N  unsigned          NumColorsPerLine;
N  int               SelOld;
N  int               Sel;
N  WM_HWIN           hParent;
X  GUI_HWIN           hParent;
N  CHOOSECOLOR_PROPS Props;
N} CHOOSECOLOR_CONTEXT;
N
N/*********************************************************************
N*
N*       Public code
N*
N**********************************************************************
N*/
NWM_HWIN CHOOSECOLOR_Create(WM_HWIN           hParent,
XGUI_HWIN CHOOSECOLOR_Create(GUI_HWIN           hParent,
N                           int               xPos,
N                           int               yPos,
N                           int               xSize,
N                           int               ySize,
N                           const GUI_COLOR * pColor,
N                           unsigned          NumColors,
N                           unsigned          NumColorsPerLine,
N                           int               Sel,
N                           const char      * sCaption,
N                           int               Flags);
N
Nint  CHOOSECOLOR_GetSel(WM_HWIN hObj);
Xint  CHOOSECOLOR_GetSel(GUI_HWIN hObj);
Nvoid CHOOSECOLOR_SetSel(WM_HWIN hObj, int Sel);
Xvoid CHOOSECOLOR_SetSel(GUI_HWIN hObj, int Sel);
N
Nvoid CHOOSECOLOR_SetDefaultColor     (unsigned Index, GUI_COLOR Color);
Nvoid CHOOSECOLOR_SetDefaultSpace     (unsigned Index, unsigned Space);
Nvoid CHOOSECOLOR_SetDefaultBorder    (unsigned Index, unsigned Border);
Nvoid CHOOSECOLOR_SetDefaultButtonSize(unsigned Index, unsigned ButtonSize);
N
N/*********************************************************************
N*
N*       The callback ...
N*
N* Do not call it directly ! It is only to be used from within an
N* overwritten callback.
N*/
Nvoid CHOOSECOLOR_Callback(WM_MESSAGE * pMsg);
N
N#if defined(__cplusplus)
X#if 0L
S  }
N#endif
N
N#endif /* GUI_WINSUPPORT */
N
N#endif /* CHOOSECOLOR_H */
N
N/*************************** End of file ****************************/
L 54 "..\..\..\..\ThirdParty\emWin\Include\DIALOG.h" 2
N#include "CHOOSEFILE.h"
L 1 "..\..\..\..\ThirdParty\emWin\Include\CHOOSEFILE.h" 1
N/*********************************************************************
N*                    SEGGER Microcontroller GmbH                     *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2023  SEGGER Microcontroller GmbH                *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V6.46 - Graphical user interface for embedded applications **
NemWin is protected by international copyright laws. Knowledge of the
Nsource code may not be used to write a similar product. 
NThis file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed by SEGGER Software GmbH to Nuvoton Technology Corporation
Nat the address: No. 4, Creation Rd. III, Hsinchu Science Park, Taiwan
Nfor the purposes  of  creating  libraries  for its 
NArm Cortex-A, Arm Cortex-M and  Arm9 32-bit microcontrollers, commercialized and distributed by Nuvoton Technology Corporation
Nunder  the terms and conditions  of  an  End  User  
NLicense  Agreement  supplied  with  the libraries.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NLicensing information
NLicensor:                 SEGGER Software GmbH
NLicensed to:              Nuvoton Technology Corporation, No. 4, Creation Rd. III, Hsinchu Science Park, 30077 Hsinchu City, Taiwan
NLicensed SEGGER software: emWin
NLicense number:           GUI-00735
NLicense model:            emWin License Agreement, signed February 27, 2018
NLicensed platform:        Cortex-M, Cortex-A, and ARM9 32-bit series microcontroller designed and manufactured by Nuvoton Technology Corporation.
N----------------------------------------------------------------------
NSupport and Update Agreement (SUA)
NSUA period:               2018-03-26 - 2025-09-04
NContact to extend SUA:    sales@segger.com
N----------------------------------------------------------------------
NFile        : CHOOSEFILE.h
NPurpose     : File dialog interface
N--------------------END-OF-HEADER-------------------------------------
N*/
N
N#ifndef CHOOSEFILE_H
N#define CHOOSEFILE_H
N
N#include "WM.h"
N
N#if GUI_WINSUPPORT
X#if 1
N
N#if defined(__cplusplus)
X#if 0L
Sextern "C" {     /* Make sure we have C-declarations in C++ programs */
N#endif
N
N/*********************************************************************
N*
N*       Defines
N*
N**********************************************************************
N*/
N#define CHOOSEFILE_FINDFIRST 0
N#define CHOOSEFILE_FINDNEXT  1
N
N#define CHOOSEFILE_FLAG_DIRECTORY (1 << 0)
N
N#ifndef   CHOOSEFILE_MAXLEN
N  #define CHOOSEFILE_MAXLEN 256
N#endif
N
N/*********************************************************************
N*
N*       CHOOSEFILE button indexes
N*
N*  Description
N*    Button indexes used by the CHOOSEFILE dialog.
N*/
N#define CHOOSEFILE_BI_CANCEL 0   // Index of 'Cancel' button.
N#define CHOOSEFILE_BI_OK     1   // Index of 'Ok' button.
N#define CHOOSEFILE_BI_UP     2   // Index of 'Up' button.
N
N/*********************************************************************
N*
N*       Types
N*
N**********************************************************************
N*/
Ntypedef struct CHOOSEFILE_INFO CHOOSEFILE_INFO;
N
N/*********************************************************************
N*
N*       CHOOSEFILE_GET_DATA_FUNC
N* 
N*  Function description
N*    A callback which has to pass information about the requested file
N*    to the dialog.
N* 
N*  Parameters
N*    pInfo: [IN/OUT] Pointer to a CHOOSEFILE_INFO structure which contains
N*                    all details of the requested file and needs to be
N*                    filled by the function.
N* 
N*  Return value
N*    == 0: On success.
N*    == 1: On error.
N* 
N*  Additional information
N*    The following structure elements of pInfo have to be set by this function:
N*      \item \bc{pInfo->Cmd:}     Determines if information about the first or
N*                                 the next file should be returned.
N*      \item \bc{pInfo->pRoot:}   Pointer to a string containing the path of the
N*                                 directory to be used. The \c{GetData()} function
N*                                 then has to use the following elements for providing
N*                                 information about the requested file to the dialog:
N*      \item \bc{pInfo->pAttrib:} Should point to a string which is shown in the 'Type'
N*                                 column. Because the CHOOSEFILE dialog can be used with
N*                                 any file system there are no special flags but a string
N*                                 which should be passed by the application to the dialog.
N*      \item \bc{pInfo->pName:}   Should point to a string which contains the file name
N*                                 without path and extension. Shown in the 'Name' column
N*                                 of the dialog.
N*      \item \bc{pInfo->pExt:}    Should point to a string which contains the extension
N*                                 of the file shown in the 'Type' column of the dialog.
N*      \item \bc{pInfo->SizeL:}   Should be set to the lower 32 bit of the file length.
N*      \item \bc{pInfo->SizeH:}   Should be set to the upper 32 bit of the file length
N*                                 in case of file larger than 4,294,967,295 bytes.
N*      \item \bc{pInfo->Flags:}   If the requested file is a directory this element has
N*                                 to be set to CHOOSEFILE_FLAG_DIRECTORY. Otherwise it
N*                                 has to be 0.
N*/
Ntypedef int CHOOSEFILE_GET_DATA_FUNC(CHOOSEFILE_INFO * pInfo);
N
Nstruct CHOOSEFILE_INFO {
N  int                        Cmd;                      // Command for GetData() function
N  int                        Id;                       // Id of pressed button (for internal use only)
N  const char               * pMask;                    // Mask to be used for searching files
N  char                     * pName;                    // (for internal use only)
N  char                     * pExt;                     // (for internal use only)
N  char                     * pAttrib;                  // (for internal use only)
N  WM_TOOLTIP_HANDLE          hToolTip;                 // (for internal use only)
N  U32                        SizeL;                    // FileSize low word
X  unsigned long                        SizeL;                    
N  U32                        SizeH;                    // FileSize high word
X  unsigned long                        SizeH;                    
N  U32                        Flags;                    // File flags
X  unsigned long                        Flags;                    
N  char                       pRoot[CHOOSEFILE_MAXLEN]; // Buffer used internally and for passing result
X  char                       pRoot[256]; 
N  CHOOSEFILE_GET_DATA_FUNC * pfGetData;                // Pointer to GetData() function
N};
N
N/*********************************************************************
N*
N*       Functions
N*
N**********************************************************************
N*/
NWM_HWIN CHOOSEFILE_Create(WM_HWIN           hParent,  // Parent window
XGUI_HWIN CHOOSEFILE_Create(GUI_HWIN           hParent,  
N                          int               xPos,     // xPosition in window coordinates
N                          int               yPos,     // yPosition in window coordinates
N                          int               xSize,    // xSize in pixels
N                          int               ySize,    // ySize in pixels
N                          const char      * apRoot[], // Pointers to root strings
N                          int               NumRoot,  // Number of roots
N                          int               SelRoot,  // Root to be selected at first
N                          const char      * sCaption, // Shown in title bar
N                          int               Flags,    // Flags for FRAMEWINDOW
N                          CHOOSEFILE_INFO * pInfo     // Pointer to CHOOSEFILE_INFO structure
N                          );
N
Nvoid    CHOOSEFILE_Callback            (WM_MESSAGE * pMsg);
Nvoid    CHOOSEFILE_EnableToolTips      (void);
Nvoid    CHOOSEFILE_SetButtonText       (WM_HWIN hWin, unsigned ButtonIndex, const char * pText);
Xvoid    CHOOSEFILE_SetButtonText       (GUI_HWIN hWin, unsigned ButtonIndex, const char * pText);
Nvoid    CHOOSEFILE_SetDefaultButtonText(unsigned ButtonIndex, const char * pText);
Nvoid    CHOOSEFILE_SetDelim            (char Delim);
Nvoid    CHOOSEFILE_SetToolTips         (const TOOLTIP_INFO * pInfo, int NumItems);
Nvoid    CHOOSEFILE_SetTopMode          (unsigned OnOff);
N
N#if defined(__cplusplus)
X#if 0L
S  }
N#endif
N
N#endif /* GUI_WINSUPPORT */
N
N#endif /* CHOOSEFILE_H */
N
N/*************************** End of file ****************************/
L 55 "..\..\..\..\ThirdParty\emWin\Include\DIALOG.h" 2
N#include "DROPDOWN.h"
L 1 "..\..\..\..\ThirdParty\emWin\Include\DROPDOWN.h" 1
N/*********************************************************************
N*                    SEGGER Microcontroller GmbH                     *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2023  SEGGER Microcontroller GmbH                *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V6.46 - Graphical user interface for embedded applications **
NemWin is protected by international copyright laws. Knowledge of the
Nsource code may not be used to write a similar product. 
NThis file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed by SEGGER Software GmbH to Nuvoton Technology Corporation
Nat the address: No. 4, Creation Rd. III, Hsinchu Science Park, Taiwan
Nfor the purposes  of  creating  libraries  for its 
NArm Cortex-A, Arm Cortex-M and  Arm9 32-bit microcontrollers, commercialized and distributed by Nuvoton Technology Corporation
Nunder  the terms and conditions  of  an  End  User  
NLicense  Agreement  supplied  with  the libraries.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NLicensing information
NLicensor:                 SEGGER Software GmbH
NLicensed to:              Nuvoton Technology Corporation, No. 4, Creation Rd. III, Hsinchu Science Park, 30077 Hsinchu City, Taiwan
NLicensed SEGGER software: emWin
NLicense number:           GUI-00735
NLicense model:            emWin License Agreement, signed February 27, 2018
NLicensed platform:        Cortex-M, Cortex-A, and ARM9 32-bit series microcontroller designed and manufactured by Nuvoton Technology Corporation.
N----------------------------------------------------------------------
NSupport and Update Agreement (SUA)
NSUA period:               2018-03-26 - 2025-09-04
NContact to extend SUA:    sales@segger.com
N----------------------------------------------------------------------
NFile        : DROPDOWN.h
NPurpose     : Multiple choice object include
N--------------------END-OF-HEADER-------------------------------------
N*/
N
N#ifndef DROPDOWN_H
N#define DROPDOWN_H
N
N#include "WM.h"
N#include "DIALOG_Type.h"      /* Req. for Create indirect data structure */
N#include "LISTBOX.h"
L 1 "..\..\..\..\ThirdParty\emWin\Include\LISTBOX.h" 1
N/*********************************************************************
N*                    SEGGER Microcontroller GmbH                     *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2023  SEGGER Microcontroller GmbH                *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V6.46 - Graphical user interface for embedded applications **
NemWin is protected by international copyright laws. Knowledge of the
Nsource code may not be used to write a similar product. 
NThis file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed by SEGGER Software GmbH to Nuvoton Technology Corporation
Nat the address: No. 4, Creation Rd. III, Hsinchu Science Park, Taiwan
Nfor the purposes  of  creating  libraries  for its 
NArm Cortex-A, Arm Cortex-M and  Arm9 32-bit microcontrollers, commercialized and distributed by Nuvoton Technology Corporation
Nunder  the terms and conditions  of  an  End  User  
NLicense  Agreement  supplied  with  the libraries.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NLicensing information
NLicensor:                 SEGGER Software GmbH
NLicensed to:              Nuvoton Technology Corporation, No. 4, Creation Rd. III, Hsinchu Science Park, 30077 Hsinchu City, Taiwan
NLicensed SEGGER software: emWin
NLicense number:           GUI-00735
NLicense model:            emWin License Agreement, signed February 27, 2018
NLicensed platform:        Cortex-M, Cortex-A, and ARM9 32-bit series microcontroller designed and manufactured by Nuvoton Technology Corporation.
N----------------------------------------------------------------------
NSupport and Update Agreement (SUA)
NSUA period:               2018-03-26 - 2025-09-04
NContact to extend SUA:    sales@segger.com
N----------------------------------------------------------------------
NFile        : LISTBOX.h
NPurpose     : LISTBOX widget include
N--------------------END-OF-HEADER-------------------------------------
N*/
N
N#ifndef LISTBOX_H
N#define LISTBOX_H
N
N#include "WM.h"
N#include "WIDGET.h"             /* Req. for WIDGET_DRAW_ITEM_FUNC */
N#include "DIALOG_Type.h"      /* Req. for Create indirect data structure */
N
N#if GUI_WINSUPPORT
X#if 1
N
N#if defined(__cplusplus)
X#if 0L
S  extern "C" {     /* Make sure we have C-declarations in C++ programs */
N#endif
N
N/*********************************************************************
N*
N*       defines
N*
N**********************************************************************
N*/
N
N#define LISTBOX_ALL_ITEMS  -1
N
N/*********************************************************************
N*
N*       LISTBOX color indexes
N*
N*  Description
N*    Color indexes used by the LISTBOX widget.
N*/
N#define LISTBOX_CI_UNSEL    0     // Color of unselected element.
N#define LISTBOX_CI_SEL      1     // Color of selected element.
N#define LISTBOX_CI_SELFOCUS 2     // Color of selected element with focus.
N#define LISTBOX_CI_DISABLED 3     // Color of disabled element.
N
N/************************************************************
N*
N*       States
N*/
Ntypedef WM_HMEM LISTBOX_Handle;
Xtypedef signed long LISTBOX_Handle;
N
N/*********************************************************************
N*
N*       LISTBOX Notification codes
N*
N* The following is the list of notification codes specific to this widget,
N* Send with the WM_NOTIFY_PARENT message
N*/
N#define LISTBOX_NOTIFICATION_LOST_FOCUS    (WM_NOTIFICATION_WIDGET + 0)
N
N/************************************************************
N*
N*       Create / Status flags
N*/
N#define LISTBOX_CF_AUTOSCROLLBAR_H   (1 << 0)
N#define LISTBOX_CF_AUTOSCROLLBAR_V   (1 << 1)
N#define LISTBOX_CF_MULTISEL          (1 << 2)
N#define LISTBOX_CF_WRAP              (1 << 3)
N#define LISTBOX_CF_FIXEDSCROLLMODE   (1 << 4)
N#define LISTBOX_CF_MOTION_H          (1 << 5)
N#define LISTBOX_CF_MOTION_V          (1 << 6)
N#define LISTBOX_CF_USE_COPY          (1 << 7)
N#define LISTBOX_SF_AUTOSCROLLBAR_H   LISTBOX_CF_AUTOSCROLLBAR_H
N#define LISTBOX_SF_AUTOSCROLLBAR_V   LISTBOX_CF_AUTOSCROLLBAR_V
N#define LISTBOX_SF_MULTISEL          LISTBOX_CF_MULTISEL
N#define LISTBOX_SF_WRAP              LISTBOX_CF_WRAP
N#define LISTBOX_SF_FIXEDSCROLLMODE   LISTBOX_CF_FIXEDSCROLLMODE
N#define LISTBOX_SF_MOTION_H          LISTBOX_CF_MOTION_H
N#define LISTBOX_SF_MOTION_V          LISTBOX_CF_MOTION_V
N
N/************************************************************
N*
N*       LISTBOX fixed scroll mode flags
N*
N*  Description
N*    Defines used for the fixed scroll mode of the widget.
N*    Refer to LISTBOX_SetFixedScrollPos() for more information.
N*/
N#define LISTBOX_FM_OFF               0       // Disables the fixed scroll mode.
N#define LISTBOX_FM_ON                1       // Enables the fixed scroll mode.
N#define LISTBOX_FM_CENTER            2       // Tries to keep the selected item in the center.
N
N/*********************************************************************
N*
N*       Create functions
N*
N**********************************************************************
N*/
N
NLISTBOX_Handle LISTBOX_Create        (const GUI_ConstString * ppText, int x0, int y0, int xSize, int ySize, int Flags);
NLISTBOX_Handle LISTBOX_CreateAsChild (const GUI_ConstString * ppText, WM_HWIN hWinParent, int x0, int y0, int xSize, int ySize, int Flags);
XLISTBOX_Handle LISTBOX_CreateAsChild (const GUI_ConstString * ppText, GUI_HWIN hWinParent, int x0, int y0, int xSize, int ySize, int Flags);
NLISTBOX_Handle LISTBOX_CreateEx      (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int ExFlags, int Id, const GUI_ConstString * ppText);
XLISTBOX_Handle LISTBOX_CreateEx      (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int WinFlags, int ExFlags, int Id, const GUI_ConstString * ppText);
NLISTBOX_Handle LISTBOX_CreateUser    (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int ExFlags, int Id, const GUI_ConstString * ppText, int NumExtraBytes);
XLISTBOX_Handle LISTBOX_CreateUser    (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int WinFlags, int ExFlags, int Id, const GUI_ConstString * ppText, int NumExtraBytes);
NLISTBOX_Handle LISTBOX_CreateIndirect(const GUI_WIDGET_CREATE_INFO * pCreateInfo, WM_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
XLISTBOX_Handle LISTBOX_CreateIndirect(const GUI_WIDGET_CREATE_INFO * pCreateInfo, GUI_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
N
N/*********************************************************************
N*
N*       The callback ...
N*
N* Do not call it directly ! It is only to be used from within an
N* overwritten callback.
N*/
Nvoid LISTBOX_Callback(WM_MESSAGE * pMsg);
N
N/*********************************************************************
N*
N*       Member functions
N*
N**********************************************************************
N*/
N
Nint              LISTBOX_AddKey                (LISTBOX_Handle hObj, int Key);
Nvoid             LISTBOX_AddString             (LISTBOX_Handle hObj, const char * s);
Nvoid             LISTBOX_AddStringH            (LISTBOX_Handle hObj, WM_HMEM hString); /* Not to be documented!!! */
Xvoid             LISTBOX_AddStringH            (LISTBOX_Handle hObj, signed long hString);  
Nvoid             LISTBOX_Clear                 (LISTBOX_Handle hObj);
Nvoid             LISTBOX_DecSel                (LISTBOX_Handle hObj);
Nvoid             LISTBOX_DeleteItem            (LISTBOX_Handle hObj, unsigned Index);
Nvoid             LISTBOX_EnableCopy            (LISTBOX_Handle hObj, unsigned OnOff);
Nvoid             LISTBOX_EnableMotion          (LISTBOX_Handle hObj, int Flags);
Nvoid             LISTBOX_EnableWrapMode        (LISTBOX_Handle hObj, int OnOff);
NGUI_COLOR        LISTBOX_GetBkColor            (LISTBOX_Handle hObj, unsigned Index);
NU16              LISTBOX_GetFixedScrollPos     (LISTBOX_Handle hObj);
Xunsigned short              LISTBOX_GetFixedScrollPos     (LISTBOX_Handle hObj);
Nconst GUI_FONT * LISTBOX_GetFont               (LISTBOX_Handle hObj);
Nunsigned         LISTBOX_GetItemSpacing        (LISTBOX_Handle hObj);
Nunsigned         LISTBOX_GetNumItems           (LISTBOX_Handle hObj);
NU32              LISTBOX_GetVisItemIndices     (LISTBOX_Handle hObj, int * pFirst, int * pLast);
Xunsigned long              LISTBOX_GetVisItemIndices     (LISTBOX_Handle hObj, int * pFirst, int * pLast);
Nint              LISTBOX_GetSel                (LISTBOX_Handle hObj);
NGUI_COLOR        LISTBOX_GetTextColor          (LISTBOX_Handle hObj, unsigned Index);
Nint              LISTBOX_GetItemDisabled       (LISTBOX_Handle hObj, unsigned Index);
Nint              LISTBOX_GetItemSel            (LISTBOX_Handle hObj, unsigned Index);
Nvoid             LISTBOX_GetItemText           (LISTBOX_Handle hObj, unsigned Index, char * pBuffer, int MaxSize);
Nint              LISTBOX_GetMulti              (LISTBOX_Handle hObj);
NWM_HWIN          LISTBOX_GetOwner              (LISTBOX_Handle hObj);
XGUI_HWIN          LISTBOX_GetOwner              (LISTBOX_Handle hObj);
Nint              LISTBOX_GetScrollStepH        (LISTBOX_Handle hObj);
Nint              LISTBOX_GetTextAlign          (LISTBOX_Handle hObj);
Nint              LISTBOX_GetUserData           (LISTBOX_Handle hObj, void * pDest, int NumBytes);
Nvoid             LISTBOX_IncSel                (LISTBOX_Handle hObj);
Nvoid             LISTBOX_InsertString          (LISTBOX_Handle hObj, const char * s, unsigned Index);
Nvoid             LISTBOX_InvalidateItem        (LISTBOX_Handle hObj, int Index);
NU32              LISTBOX_IsItemPartiallyVisible(LISTBOX_Handle hObj, int Index);
Xunsigned long              LISTBOX_IsItemPartiallyVisible(LISTBOX_Handle hObj, int Index);
Nint              LISTBOX_OwnerDraw             (const WIDGET_ITEM_DRAW_INFO * pDrawItemInfo);
Nvoid             LISTBOX_SetAutoScrollH        (LISTBOX_Handle hObj, int OnOff);
Nvoid             LISTBOX_SetAutoScrollV        (LISTBOX_Handle hObj, int OnOff);
Nvoid             LISTBOX_SetBkColor            (LISTBOX_Handle hObj, unsigned Index, GUI_COLOR color);
Nvoid             LISTBOX_SetFixedScrollPos     (LISTBOX_Handle hObj, U16 FixedScrollPos, U8 Mode);
Xvoid             LISTBOX_SetFixedScrollPos     (LISTBOX_Handle hObj, unsigned short FixedScrollPos, unsigned char Mode);
Nvoid             LISTBOX_SetFont               (LISTBOX_Handle hObj, const GUI_FONT * pFont);
Nvoid             LISTBOX_SetItemDisabled       (LISTBOX_Handle hObj, unsigned Index, int OnOff);
Nvoid             LISTBOX_SetItemSel            (LISTBOX_Handle hObj, unsigned Index, int OnOff);
Nvoid             LISTBOX_SetItemSpacing        (LISTBOX_Handle hObj, unsigned Value);
Nvoid             LISTBOX_SetMulti              (LISTBOX_Handle hObj, int Mode);
Nvoid             LISTBOX_SetOwner              (LISTBOX_Handle hObj, WM_HWIN hOwner);
Xvoid             LISTBOX_SetOwner              (LISTBOX_Handle hObj, GUI_HWIN hOwner);
Nvoid             LISTBOX_SetOwnerDraw          (LISTBOX_Handle hObj, WIDGET_DRAW_ITEM_FUNC * pfDrawItem);
Nvoid             LISTBOX_SetScrollStepH        (LISTBOX_Handle hObj, int Value);
Nvoid             LISTBOX_SetSel                (LISTBOX_Handle hObj, int Sel);
Nvoid             LISTBOX_SetScrollbarColor     (LISTBOX_Handle hObj, unsigned Index, GUI_COLOR Color);
Nvoid             LISTBOX_SetScrollbarWidth     (LISTBOX_Handle hObj, unsigned Width);
Nvoid             LISTBOX_SetString             (LISTBOX_Handle hObj, const char * s, unsigned Index);
Nvoid             LISTBOX_SetText               (LISTBOX_Handle hObj, const GUI_ConstString * ppText);
Nvoid             LISTBOX_SetTextAlign          (LISTBOX_Handle hObj, int Align);
NGUI_COLOR        LISTBOX_SetTextColor          (LISTBOX_Handle hObj, unsigned Index, GUI_COLOR Color);
Nint              LISTBOX_SetUserData           (LISTBOX_Handle hObj, const void * pSrc, int NumBytes);
N
N/*********************************************************************
N*
N*       Managing default values
N*
N**********************************************************************
N*/
N
Nconst GUI_FONT * LISTBOX_GetDefaultFont(void);
Nint              LISTBOX_GetDefaultScrollStepH (void);
NGUI_COLOR        LISTBOX_GetDefaultBkColor     (unsigned Index);
Nint              LISTBOX_GetDefaultTextAlign   (void);
NGUI_COLOR        LISTBOX_GetDefaultTextColor   (unsigned Index);
Nvoid             LISTBOX_SetDefaultFont        (const GUI_FONT * pFont);
Nvoid             LISTBOX_SetDefaultScrollStepH (int Value);
Nvoid             LISTBOX_SetDefaultBkColor     (unsigned Index, GUI_COLOR Color);
Nvoid             LISTBOX_SetDefaultTextAlign   (int Align);
Nvoid             LISTBOX_SetDefaultTextColor   (unsigned Index, GUI_COLOR Color);
N
N/*********************************************************************
N*
N*       Compatibility to older versions
N*
N**********************************************************************
N*/
N
N#define LISTBOX_SetBackColor(hObj, Index, Color) LISTBOX_SetBkColor(hObj, Index, Color)
N#define LISTBOX_DeleteString  LISTBOX_DeleteItem
N
N#if defined(__cplusplus)
X#if 0L
S  }
N#endif
N
N#endif  // GUI_WINSUPPORT
N#endif  // LISTBOX_H
N
N/*************************** End of file ****************************/
L 51 "..\..\..\..\ThirdParty\emWin\Include\DROPDOWN.h" 2
N
N#if GUI_WINSUPPORT
X#if 1
N
N#if defined(__cplusplus)
X#if 0L
S  extern "C" {     /* Make sure we have C-declarations in C++ programs */
N#endif
N
N/************************************************************
N*
N*       DROPDOWN create flags
N*
N*  Description
N*    These flags can be used when creating a DROPDOWN widget via
N*    DROPDOWN_CreateEx(). 0 can be specified for the \a{ExFlags} parameter,
N*    if no flags should be used.
N*/
N#define DROPDOWN_CF_AUTOSCROLLBAR   (1 << 0)    // Enable automatic use of a scroll bar. For details, refer to DROPDOWN_SetAutoScroll().
N#define DROPDOWN_CF_UP              (1 << 1)    // Creates a DROPDOWN widget which opens the dropdown list above the widget. This flag is useful if
N                                                // the space below the widget is not sufficient for the dropdown list.
N#define DROPDOWN_CF_MOTION          (1 << 2)    // Enables motion support on the vertical axis.
N
N/*********************************************************************
N*
N*       DROPDOWN color indexes
N*
N*  Description
N*    Color indexes for DROPDOWN widget.
N*/
N#define DROPDOWN_CI_UNSEL    0    // Unselected element.
N#define DROPDOWN_CI_SEL      1    // Selected element, without focus.
N#define DROPDOWN_CI_SELFOCUS 2    // Selected element, with focus.
N/* not documented */
N#define DROPDOWN_CI_ARROW    0
N#define DROPDOWN_CI_BUTTON   1
N
N/*********************************************************************
N*
N*       Skinning property indices
N*/
N#define DROPDOWN_SKINFLEX_PI_EXPANDED 0
N#define DROPDOWN_SKINFLEX_PI_FOCUSED  1
N#define DROPDOWN_SKINFLEX_PI_ENABLED  2
N#define DROPDOWN_SKINFLEX_PI_DISABLED 3
N
N/*********************************************************************
N*
N*       DROPDOWN notification codes
N*
N*  Description
N*    Notifications sent by DROPDOWN widget to its parent widget through
N*    a WM_NOTIFY_PARENT message.
N*/
N#define DROPDOWN_NOTIFICATION_EXPANDED   (WM_NOTIFICATION_WIDGET + 0)     // Sent when the list of the DROPDOWN has been expanded.
N#define DROPDOWN_NOTIFICATION_COLLAPSED  (WM_NOTIFICATION_WIDGET + 1)     // Sent when the list of the DROPDOWN has been collapsed.
N
N/*********************************************************************
N*
N*       Types
N*
N**********************************************************************
N*/
Ntypedef WM_HMEM DROPDOWN_Handle;
Xtypedef signed long DROPDOWN_Handle;
N
Ntypedef struct {
N  GUI_COLOR aColorFrame[3];
N  GUI_COLOR aColorUpper[2];
N  GUI_COLOR aColorLower[2];
N  GUI_COLOR ColorArrow;
N  GUI_COLOR ColorText;
N  GUI_COLOR ColorSep;
N  int Radius;
N} DROPDOWN_SKINFLEX_PROPS;
N
N/*********************************************************************
N*
N*       Create functions
N*
N**********************************************************************
N*/
NDROPDOWN_Handle DROPDOWN_Create        (WM_HWIN hWinParent, int x0, int y0, int xSize, int ySize, int Flags);
XDROPDOWN_Handle DROPDOWN_Create        (GUI_HWIN hWinParent, int x0, int y0, int xSize, int ySize, int Flags);
NDROPDOWN_Handle DROPDOWN_CreateEx      (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int ExFlags, int Id);
XDROPDOWN_Handle DROPDOWN_CreateEx      (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int WinFlags, int ExFlags, int Id);
NDROPDOWN_Handle DROPDOWN_CreateUser    (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int ExFlags, int Id, int NumExtraBytes);
XDROPDOWN_Handle DROPDOWN_CreateUser    (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int WinFlags, int ExFlags, int Id, int NumExtraBytes);
NDROPDOWN_Handle DROPDOWN_CreateIndirect(const GUI_WIDGET_CREATE_INFO* pCreateInfo, WM_HWIN hWinParent, int x0, int y0, WM_CALLBACK* cb);
XDROPDOWN_Handle DROPDOWN_CreateIndirect(const GUI_WIDGET_CREATE_INFO* pCreateInfo, GUI_HWIN hWinParent, int x0, int y0, WM_CALLBACK* cb);
N
N/*********************************************************************
N*
N*       The callback ...
N*
N* Do not call it directly ! It is only to be used from within an
N* overwritten callback.
N*/
Nvoid DROPDOWN_Callback(WM_MESSAGE * pMsg);
N
N/*********************************************************************
N*
N*       Member functions
N*
N**********************************************************************
N*/
Nvoid             DROPDOWN_AddKey           (DROPDOWN_Handle hObj, int Key);
Nvoid             DROPDOWN_AddString        (DROPDOWN_Handle hObj, const char* s);
Nvoid             DROPDOWN_Clear            (DROPDOWN_Handle hObj);
Nvoid             DROPDOWN_Collapse         (DROPDOWN_Handle hObj);
Nvoid             DROPDOWN_DecSel           (DROPDOWN_Handle hObj);
Nvoid             DROPDOWN_DecSelExp        (DROPDOWN_Handle hObj);
Nvoid             DROPDOWN_DeleteItem       (DROPDOWN_Handle hObj, unsigned int Index);
Nvoid             DROPDOWN_EnableMotion     (DROPDOWN_Handle hObj, int Flags);
Nvoid             DROPDOWN_Expand           (DROPDOWN_Handle hObj);
NGUI_COLOR        DROPDOWN_GetBkColor       (DROPDOWN_Handle hObj, unsigned int Index);
NGUI_COLOR        DROPDOWN_GetColor         (DROPDOWN_Handle hObj, unsigned int Index);
Nconst GUI_FONT * DROPDOWN_GetFont          (DROPDOWN_Handle hObj);
Nunsigned         DROPDOWN_GetItemDisabled  (DROPDOWN_Handle hObj, unsigned Index);
Nunsigned         DROPDOWN_GetItemSpacing   (DROPDOWN_Handle hObj);
Nint              DROPDOWN_GetItemText      (DROPDOWN_Handle hObj, unsigned Index, char * pBuffer, int MaxSize);
NLISTBOX_Handle   DROPDOWN_GetListbox       (DROPDOWN_Handle hObj);
Nint              DROPDOWN_GetNumItems      (DROPDOWN_Handle hObj);
Nint              DROPDOWN_GetSel           (DROPDOWN_Handle hObj);
Nint              DROPDOWN_GetSelExp        (DROPDOWN_Handle hObj);
NGUI_COLOR        DROPDOWN_GetTextColor     (DROPDOWN_Handle hObj, unsigned int Index);
NU8               DROPDOWN_GetUpMode        (DROPDOWN_Handle hObj);
Xunsigned char               DROPDOWN_GetUpMode        (DROPDOWN_Handle hObj);
Nint              DROPDOWN_GetUserData      (DROPDOWN_Handle hObj, void * pDest, int NumBytes);
Nvoid             DROPDOWN_IncSel           (DROPDOWN_Handle hObj);
Nvoid             DROPDOWN_IncSelExp        (DROPDOWN_Handle hObj);
Nvoid             DROPDOWN_InsertString     (DROPDOWN_Handle hObj, const char* s, unsigned int Index);
Nvoid             DROPDOWN_SetAutoScroll    (DROPDOWN_Handle hObj, int OnOff);
Nvoid             DROPDOWN_SetBkColor       (DROPDOWN_Handle hObj, unsigned int Index, GUI_COLOR Color);
Nvoid             DROPDOWN_SetColor         (DROPDOWN_Handle hObj, unsigned int Index, GUI_COLOR Color);
Nvoid             DROPDOWN_SetFont          (DROPDOWN_Handle hObj, const GUI_FONT * pFont);
Nvoid             DROPDOWN_SetItemDisabled  (DROPDOWN_Handle hObj, unsigned Index, int OnOff);
Nvoid             DROPDOWN_SetItemSpacing   (DROPDOWN_Handle hObj, unsigned Value);
Nint              DROPDOWN_SetListHeight    (DROPDOWN_Handle hObj, unsigned Height);
Nvoid             DROPDOWN_SetScrollbarColor(DROPDOWN_Handle hObj, unsigned Index, GUI_COLOR Color);
Nvoid             DROPDOWN_SetScrollbarWidth(DROPDOWN_Handle hObj, unsigned Width);
Nvoid             DROPDOWN_SetSel           (DROPDOWN_Handle hObj, int Sel);
Nvoid             DROPDOWN_SetSelExp        (DROPDOWN_Handle hObj, int Sel);
Nvoid             DROPDOWN_SetString        (DROPDOWN_Handle hObj, const char* s, unsigned int Index);
Nvoid             DROPDOWN_SetText          (DROPDOWN_Handle hObj, const GUI_ConstString * ppText);
Nvoid             DROPDOWN_SetTextAlign     (DROPDOWN_Handle hObj, int Align);
Nvoid             DROPDOWN_SetTextColor     (DROPDOWN_Handle hObj, unsigned int Index, GUI_COLOR Color);
Nvoid             DROPDOWN_SetTextHeight    (DROPDOWN_Handle hObj, unsigned TextHeight);
Nint              DROPDOWN_SetUpMode        (DROPDOWN_Handle hObj, int OnOff);
Nint              DROPDOWN_SetUserData      (DROPDOWN_Handle hObj, const void * pSrc, int NumBytes);
N
N/*********************************************************************
N*
N*       Member functions: Skinning
N*
N**********************************************************************
N*/
Nvoid DROPDOWN_GetSkinFlexProps     (DROPDOWN_SKINFLEX_PROPS * pProps, int Index);
Nvoid DROPDOWN_SetSkinClassic       (DROPDOWN_Handle hObj);
Nvoid DROPDOWN_SetSkin              (DROPDOWN_Handle hObj, WIDGET_DRAW_ITEM_FUNC * pfDrawSkin);
Nint  DROPDOWN_DrawSkinFlex         (const WIDGET_ITEM_DRAW_INFO * pDrawItemInfo);
Nvoid DROPDOWN_SetSkinFlexProps     (const DROPDOWN_SKINFLEX_PROPS * pProps, int Index);
Nvoid DROPDOWN_SetDefaultSkinClassic(void);
NWIDGET_DRAW_ITEM_FUNC * DROPDOWN_SetDefaultSkin(WIDGET_DRAW_ITEM_FUNC * pfDrawSkin);
N
N#define DROPDOWN_SKIN_FLEX    DROPDOWN_DrawSkinFlex
N
N/*********************************************************************
N*
N*       Managing default values
N*
N**********************************************************************
N*/
NGUI_COLOR        DROPDOWN_GetDefaultBkColor       (int Index);
NGUI_COLOR        DROPDOWN_GetDefaultColor         (int Index);
Nconst GUI_FONT * DROPDOWN_GetDefaultFont          (void);
NGUI_COLOR        DROPDOWN_GetDefaultScrollbarColor(int Index);
Nvoid             DROPDOWN_SetDefaultFont          (const GUI_FONT * pFont);
NGUI_COLOR        DROPDOWN_SetDefaultBkColor       (int Index, GUI_COLOR Color);
NGUI_COLOR        DROPDOWN_SetDefaultColor         (int Index, GUI_COLOR Color);
NGUI_COLOR        DROPDOWN_SetDefaultScrollbarColor(int Index, GUI_COLOR Color);
N
N#if defined(__cplusplus)
X#if 0L
S  }
N#endif
N
N#endif  // GUI_WINSUPPORT
N#endif  // DROPDOWN_H
N
N/*************************** End of file ****************************/
L 56 "..\..\..\..\ThirdParty\emWin\Include\DIALOG.h" 2
N#include "EDIT.h"
L 1 "..\..\..\..\ThirdParty\emWin\Include\EDIT.h" 1
N/*********************************************************************
N*                    SEGGER Microcontroller GmbH                     *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2023  SEGGER Microcontroller GmbH                *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V6.46 - Graphical user interface for embedded applications **
NemWin is protected by international copyright laws. Knowledge of the
Nsource code may not be used to write a similar product. 
NThis file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed by SEGGER Software GmbH to Nuvoton Technology Corporation
Nat the address: No. 4, Creation Rd. III, Hsinchu Science Park, Taiwan
Nfor the purposes  of  creating  libraries  for its 
NArm Cortex-A, Arm Cortex-M and  Arm9 32-bit microcontrollers, commercialized and distributed by Nuvoton Technology Corporation
Nunder  the terms and conditions  of  an  End  User  
NLicense  Agreement  supplied  with  the libraries.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NLicensing information
NLicensor:                 SEGGER Software GmbH
NLicensed to:              Nuvoton Technology Corporation, No. 4, Creation Rd. III, Hsinchu Science Park, 30077 Hsinchu City, Taiwan
NLicensed SEGGER software: emWin
NLicense number:           GUI-00735
NLicense model:            emWin License Agreement, signed February 27, 2018
NLicensed platform:        Cortex-M, Cortex-A, and ARM9 32-bit series microcontroller designed and manufactured by Nuvoton Technology Corporation.
N----------------------------------------------------------------------
NSupport and Update Agreement (SUA)
NSUA period:               2018-03-26 - 2025-09-04
NContact to extend SUA:    sales@segger.com
N----------------------------------------------------------------------
NFile        : EDIT.h
NPurpose     : EDIT include
N--------------------END-OF-HEADER-------------------------------------
N*/
N
N#ifndef EDIT_H
N#define EDIT_H
N
N#include "WM.h"
N#include "DIALOG_Type.h" // Required for Create indirect data structure
N
N#if GUI_WINSUPPORT
X#if 1
N
N#if defined(__cplusplus)
X#if 0L
S  extern "C" {             // Make sure we have C-declarations in C++ programs
N#endif
N
N/*********************************************************************
N*
N*       Defaults for configuration switches
N*
N*  The following are defaults for config switches which affect the
N*  interface specified in this module
N*
N**********************************************************************
N*/
N/*********************************************************************
N*
N*       Defines
N*
N**********************************************************************
N*/
N//
N// Create / Status flags
N//
N#define EDIT_CF_LEFT    GUI_TA_LEFT
N#define EDIT_CF_RIGHT   GUI_TA_RIGHT
N#define EDIT_CF_HCENTER GUI_TA_HCENTER
N#define EDIT_CF_VCENTER GUI_TA_VCENTER
N#define EDIT_CF_TOP     GUI_TA_TOP
N#define EDIT_CF_BOTTOM  GUI_TA_BOTTOM
N
N/*********************************************************************
N*
N*       EDIT color indexes
N*
N*  Description
N*    Color indexes for EDIT widget.
N*/
N#define EDIT_CI_DISABLED 0    // Color index for the disabled state.
N#define EDIT_CI_ENABLED  1    // Color index for the enabled state.
N#define EDIT_CI_CURSOR   2    // Color to be used for the cursor. This is only taken into account if the cursor is not in inversion mode (\c{EDIT_EnableInversion(0)}).
N
N/*********************************************************************
N*
N*       EDIT flags
N*
N*  Description
N*    These flags are used if the EDIT widget is in decimal or float mode.
N*    This can be activated by calling EDIT_SetDecMode() or EDIT_SetFloatMode().
N*    These flags are OR-combinable.
N*/
N#define GUI_EDIT_NORMAL                  (0 << 0)    // Edit in normal mode. A sign is displayed only if the value is negative.
N#define GUI_EDIT_SIGNED                  (1 << 0)    // "+" and "-" sign is displayed.
N#define GUI_EDIT_SUPPRESS_LEADING_ZEROES (1 << 1)    // Does not show leading zeroes.
N/* emDoc mark */
N
N//
N// Cursor coloring
N//
N#define GUI_EDIT_SHOWCURSOR              (1 << 2)
N#define GUI_EDIT_CUSTCOLORMODE           (1 << 3)
N#define GUI_EDIT_CURSORBLINK             (1 << 4)
N//
N// Automatic text scrolling
N//
N#define GUI_EDIT_AUTOSCROLL              (1 << 5)
N//
N// Password mode
N//
N#define GUI_EDIT_PASSWORD_MODE           (1 << 6)
N
N//
N// Edit modes
N//
N#define GUI_EDIT_MODE_INSERT    0
N#define GUI_EDIT_MODE_OVERWRITE 1
N
N//
N// Compatibility macros
N//
N#define EDIT_CI_DISABELD EDIT_CI_DISABLED
N#define EDIT_CI_ENABELD  EDIT_CI_ENABLED
N
N/*********************************************************************
N*
N*       Types
N*
N**********************************************************************
N*/
Ntypedef WM_HMEM EDIT_Handle;
Xtypedef signed long EDIT_Handle;
Ntypedef int  tEDIT_AddKeyEx    (EDIT_Handle hObj, int Key);
Ntypedef void tEDIT_UpdateBuffer(EDIT_Handle hObj);
N
N/*********************************************************************
N*
N*             Create functions
N*/
NEDIT_Handle EDIT_Create        (int x0, int y0, int xSize, int ySize, int Id, int MaxLen, int Flags);
NEDIT_Handle EDIT_CreateAsChild (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int Id, int Flags, int MaxLen);
XEDIT_Handle EDIT_CreateAsChild (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int Id, int Flags, int MaxLen);
NEDIT_Handle EDIT_CreateEx      (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int ExFlags, int Id, int MaxLen);
XEDIT_Handle EDIT_CreateEx      (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int WinFlags, int ExFlags, int Id, int MaxLen);
NEDIT_Handle EDIT_CreateUser    (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int ExFlags, int Id, int MaxLen, int NumExtraBytes);
XEDIT_Handle EDIT_CreateUser    (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int WinFlags, int ExFlags, int Id, int MaxLen, int NumExtraBytes);
NEDIT_Handle EDIT_CreateIndirect(const GUI_WIDGET_CREATE_INFO * pCreateInfo, WM_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
XEDIT_Handle EDIT_CreateIndirect(const GUI_WIDGET_CREATE_INFO * pCreateInfo, GUI_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
N
N/*********************************************************************
N*
N*       The callback ...
N*
N* Do not call it directly ! It is only to be used from within an
N* overwritten callback.
N*/
Nvoid EDIT_Callback(WM_MESSAGE * pMsg);
N
N/*********************************************************************
N*
N*       Managing default values
N*
N**********************************************************************
N*/
Nvoid EDIT_SetDefaultBkColor  (unsigned int Index, GUI_COLOR Color);
Nvoid EDIT_SetDefaultFont     (const GUI_FONT * pFont);
Nvoid EDIT_SetDefaultTextAlign(int Align);
Nvoid EDIT_SetDefaultTextColor(unsigned int Index, GUI_COLOR Color);
NU16  EDIT_SetPasswordChar    (U16 PasswordChar);
Xunsigned short  EDIT_SetPasswordChar    (unsigned short PasswordChar);
N
N/*********************************************************************
N*
N*       Individual member functions
N*/
N//
N// Query preferences
N//
NGUI_COLOR        EDIT_GetDefaultBkColor(unsigned int Index);
Nconst GUI_FONT * EDIT_GetDefaultFont(void);
Nint              EDIT_GetDefaultTextAlign(void);
NGUI_COLOR        EDIT_GetDefaultTextColor(unsigned int Index);
N//
N// Methods changing properties
N//
Nvoid             EDIT_AddKey           (EDIT_Handle hObj, int Key);
Nvoid             EDIT_EnableAutoScroll (EDIT_Handle hObj, int OnOff);
Nvoid             EDIT_EnableBlink      (EDIT_Handle hObj, int Period, int OnOff);
NGUI_COLOR        EDIT_GetBkColor       (EDIT_Handle hObj, unsigned int Index);
Nvoid             EDIT_SetBkColor       (EDIT_Handle hObj, unsigned int Index, GUI_COLOR color);
Nvoid             EDIT_SetBorderSize    (EDIT_Handle hObj, int Border);
Nint              EDIT_GetBorderSize    (EDIT_Handle hObj);
Nvoid             EDIT_SetCursorAtChar  (EDIT_Handle hObj, int Pos);
Nvoid             EDIT_SetCursorAtPixel (EDIT_Handle hObj, int xPos);
Nvoid             EDIT_SetFont          (EDIT_Handle hObj, const GUI_FONT * pFont);
Nint              EDIT_SetInsertMode    (EDIT_Handle hObj, int OnOff);
Nvoid             EDIT_SetMaxLen        (EDIT_Handle hObj, int MaxLen);
Nvoid             EDIT_SetPasswordMode  (EDIT_Handle hObj, int OnOff);
Nvoid             EDIT_SetpfAddKeyEx    (EDIT_Handle hObj, tEDIT_AddKeyEx * pfAddKeyEx);
Nvoid             EDIT_SetpfUpdateBuffer(EDIT_Handle hObj, tEDIT_UpdateBuffer * pfUpdateBuffer);
Nvoid             EDIT_SetText          (EDIT_Handle hObj, const char * s);
Nvoid             EDIT_SetTextAlign     (EDIT_Handle hObj, int Align);
NGUI_COLOR        EDIT_GetTextColor     (EDIT_Handle hObj, unsigned int Index);
Nvoid             EDIT_SetTextColor     (EDIT_Handle hObj, unsigned int Index, GUI_COLOR Color);
Nvoid             EDIT_SetSel           (EDIT_Handle hObj, int FirstChar, int LastChar);
Nint              EDIT_SetUserData      (EDIT_Handle hObj, const void * pSrc, int NumBytes);
Nint              EDIT_EnableInversion  (EDIT_Handle hObj, int OnOff);
N//
N// Get/Set user input
N//
NU16              EDIT_GetCharAtPixel   (EDIT_Handle hObj, int x, int y, int * pIndex);
Xunsigned short              EDIT_GetCharAtPixel   (EDIT_Handle hObj, int x, int y, int * pIndex);
Nint              EDIT_GetCursorCharPos (EDIT_Handle hObj);
Nvoid             EDIT_GetCursorPixelPos(EDIT_Handle hObj, int * pxPos, int * pyPos);
Nfloat            EDIT_GetFloatValue    (EDIT_Handle hObj);
Nconst GUI_FONT * EDIT_GetFont          (EDIT_Handle hObj);
Nint              EDIT_GetMaxLen        (EDIT_Handle hObj);
Nvoid             EDIT_GetMinMax        (EDIT_Handle hObj, int * pMin, int * pMax);
Nint              EDIT_GetNumChars      (EDIT_Handle hObj);
Nvoid             EDIT_GetText          (EDIT_Handle hObj, char * sDest, int MaxLen);
Nint              EDIT_GetTextAlign     (EDIT_Handle hObj);
NI32              EDIT_GetValue         (EDIT_Handle hObj);
Xsigned long              EDIT_GetValue         (EDIT_Handle hObj);
Nvoid             EDIT_SetFloatValue    (EDIT_Handle hObj, float Value);
Nvoid             EDIT_GetSel           (EDIT_Handle hObj, int * pFirstChar, int * pLastChar);
Nvoid             EDIT_GetSelText       (EDIT_Handle hObj, char * sDest, int MaxLen);
Nint              EDIT_GetUserData      (EDIT_Handle hObj, void * pDest, int NumBytes);
Nvoid             EDIT_SetValue         (EDIT_Handle hObj, I32 Value);
Xvoid             EDIT_SetValue         (EDIT_Handle hObj, signed long Value);
N
N/*********************************************************************
N*
N*       Defines for compatability
N*/
N#define EDIT_SetFocussable EDIT_SetFocusable
N#define EDIT_SetFocusable  WIDGET_SetFocusable
N
N/*********************************************************************
N*
N*       Routines for editing values
N*
N**********************************************************************
N*/
Nvoid  EDIT_SetHexMode  (EDIT_Handle hEdit, U32 Value, U32 Min, U32 Max);
Xvoid  EDIT_SetHexMode  (EDIT_Handle hEdit, unsigned long Value, unsigned long Min, unsigned long Max);
Nvoid  EDIT_SetBinMode  (EDIT_Handle hEdit, U32 Value, U32 Min, U32 Max);
Xvoid  EDIT_SetBinMode  (EDIT_Handle hEdit, unsigned long Value, unsigned long Min, unsigned long Max);
Nvoid  EDIT_SetDecMode  (EDIT_Handle hEdit, I32 Value, I32 Min, I32 Max, int Shift, U8 Flags);
Xvoid  EDIT_SetDecMode  (EDIT_Handle hEdit, signed long Value, signed long Min, signed long Max, int Shift, unsigned char Flags);
Nvoid  EDIT_SetFloatMode(EDIT_Handle hEdit, float Value, float Min, float Max, int Shift, U8 Flags);
Xvoid  EDIT_SetFloatMode(EDIT_Handle hEdit, float Value, float Min, float Max, int Shift, unsigned char Flags);
Nvoid  EDIT_SetTextMode (EDIT_Handle hEdit);
Nvoid  EDIT_SetUlongMode(EDIT_Handle hEdit, U32 Value, U32 Min, U32 Max);
Xvoid  EDIT_SetUlongMode(EDIT_Handle hEdit, unsigned long Value, unsigned long Min, unsigned long Max);
N
NU32   GUI_EditHex      (U32 Value, U32 Min, U32 Max, int Len, int xSize);
Xunsigned long   GUI_EditHex      (unsigned long Value, unsigned long Min, unsigned long Max, int Len, int xSize);
NU32   GUI_EditBin      (U32 Value, U32 Min, U32 Max, int Len, int xSize);
Xunsigned long   GUI_EditBin      (unsigned long Value, unsigned long Min, unsigned long Max, int Len, int xSize);
NI32   GUI_EditDec      (I32 Value, I32 Min, I32 Max, int Len, int xSize, int Shift, U8 Flags);
Xsigned long   GUI_EditDec      (signed long Value, signed long Min, signed long Max, int Len, int xSize, int Shift, unsigned char Flags);
Nfloat GUI_EditFloat    (float Value, float Min, float Max, int Len, int xSize, int Shift, U8 Flags);
Xfloat GUI_EditFloat    (float Value, float Min, float Max, int Len, int xSize, int Shift, unsigned char Flags);
Nvoid  GUI_EditString   (char * pString, int Len, int xSize);
N
N#if defined(__cplusplus)
X#if 0L
S  }
N#endif
N
N#endif  // GUI_WINSUPPORT
N#endif  // EDIT_H
N
N/*************************** End of file ****************************/
L 57 "..\..\..\..\ThirdParty\emWin\Include\DIALOG.h" 2
N#include "FRAMEWIN.h"
L 1 "..\..\..\..\ThirdParty\emWin\Include\FRAMEWIN.h" 1
N/*********************************************************************
N*                    SEGGER Microcontroller GmbH                     *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2023  SEGGER Microcontroller GmbH                *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V6.46 - Graphical user interface for embedded applications **
NemWin is protected by international copyright laws. Knowledge of the
Nsource code may not be used to write a similar product. 
NThis file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed by SEGGER Software GmbH to Nuvoton Technology Corporation
Nat the address: No. 4, Creation Rd. III, Hsinchu Science Park, Taiwan
Nfor the purposes  of  creating  libraries  for its 
NArm Cortex-A, Arm Cortex-M and  Arm9 32-bit microcontrollers, commercialized and distributed by Nuvoton Technology Corporation
Nunder  the terms and conditions  of  an  End  User  
NLicense  Agreement  supplied  with  the libraries.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NLicensing information
NLicensor:                 SEGGER Software GmbH
NLicensed to:              Nuvoton Technology Corporation, No. 4, Creation Rd. III, Hsinchu Science Park, 30077 Hsinchu City, Taiwan
NLicensed SEGGER software: emWin
NLicense number:           GUI-00735
NLicense model:            emWin License Agreement, signed February 27, 2018
NLicensed platform:        Cortex-M, Cortex-A, and ARM9 32-bit series microcontroller designed and manufactured by Nuvoton Technology Corporation.
N----------------------------------------------------------------------
NSupport and Update Agreement (SUA)
NSUA period:               2018-03-26 - 2025-09-04
NContact to extend SUA:    sales@segger.com
N----------------------------------------------------------------------
NFile        : FRAMEWIN.h
NPurpose     : Frame window include
N--------------------END-OF-HEADER-------------------------------------
N*/
N
N#ifndef FRAMEWIN_H
N#define FRAMEWIN_H
N
N#include "WM.h"
N#include "WIDGET.h"             /* Req. for WIDGET_DRAW_ITEM_FUNC */
N#if GUI_WINSUPPORT
X#if 1
N#include "DIALOG_Type.h"      /* Req. for Create indirect data structure */
N
N#if defined(__cplusplus)
X#if 0L
S  extern "C" {     /* Make sure we have C-declarations in C++ programs */
N#endif
N
N/*********************************************************************
N*
N*       Defines
N*
N**********************************************************************
N*/
N/*********************************************************************
N*
N*       Configuration
N*/
N#ifndef   FRAMEWIN_ALLOW_DRAG_ON_FRAME
N  #define FRAMEWIN_ALLOW_DRAG_ON_FRAME 1
N#endif
N
N/*********************************************************************
N*
N*       FRAMEWIN states
N*
N*  Description
N*    State of the FRAMEWIN used for various functions.
N*/
N#define FRAMEWIN_CI_INACTIVE 0    // When the FRAMEWIN is inactive.
N#define FRAMEWIN_CI_ACTIVE   1    // When the FRAMEWIN is active.
N
N/*********************************************************************
N*
N*       FRAMEWIN create flags
N*
N*  Description
N*    Create flags that define the behavior of the FRAMEWIN widget.
N*    These flags are OR-combinable and can be specified upon creation
N*    of the widget via the \a{ExFlags} parameter of FRAMEWIN_CreateEx().
N*/
N#define FRAMEWIN_CF_ACTIVE     (1 << 3)    // Active-state of the frame window. See FRAMEWIN_SetActive().
N#define FRAMEWIN_CF_MOVEABLE   (1 << 4)    // Sets the frame window to a moveable state. See FRAMEWIN_SetMoveable().
N#define FRAMEWIN_CF_TITLEVIS   (1 << 5)    // Visibility of the frame window's title. See FRAMEWIN_SetTitleVis().
N#define FRAMEWIN_CF_MINIMIZED  (1 << 6)    // Minimized-state of the frame window. See FRAMEWIN_Minimize().
N#define FRAMEWIN_CF_MAXIMIZED  (1 << 7)    // Maximized-state of the frame window. See FRAMEWIN_Maximize().
N#define FRAMEWIN_CF_DRAGGING   (1 << 8)
N
N/* status flags */
N#define FRAMEWIN_SF_ACTIVE     FRAMEWIN_CF_ACTIVE
N#define FRAMEWIN_SF_MOVEABLE   FRAMEWIN_CF_MOVEABLE
N#define FRAMEWIN_SF_TITLEVIS   FRAMEWIN_CF_TITLEVIS
N#define FRAMEWIN_SF_MINIMIZED  FRAMEWIN_CF_MINIMIZED
N#define FRAMEWIN_SF_MAXIMIZED  FRAMEWIN_CF_MAXIMIZED
N#define FRAMEWIN_SF_DRAGGING   FRAMEWIN_CF_DRAGGING
N
N/*********************************************************************
N*
N*       FRAMEWIN button flags
N*
N*  Description
N*    These flags determine on which side of the FRAMEWIN widget a button
N*    should be added.
N*/
N#define FRAMEWIN_BUTTON_RIGHT   (1 << 0)    // The BUTTON will be created at the right side.
N#define FRAMEWIN_BUTTON_LEFT    (1 << 1)    // The BUTTON will be created at the left side.
N
N/*********************************************************************
N*
N*       Skinning property indices
N*/
N#define FRAMEWIN_SKINFLEX_PI_ACTIVE   0
N#define FRAMEWIN_SKINFLEX_PI_INACTIVE 1
N
N/*********************************************************************
N*
N*       Getting border size
N*/
N#define FRAMEWIN_BORDERSIZE_T 0
N#define FRAMEWIN_BORDERSIZE_L 1
N#define FRAMEWIN_BORDERSIZE_B 2
N#define FRAMEWIN_BORDERSIZE_R 3
N
N/*********************************************************************
N*
N*       Types
N*
N**********************************************************************
N*/
Ntypedef WM_HMEM FRAMEWIN_Handle;
Xtypedef signed long FRAMEWIN_Handle;
N
Ntypedef struct {
N  GUI_COLOR aColorFrame[3];
N  GUI_COLOR aColorTitle[2];
N  int Radius;
N  int SpaceX;
N  int BorderSizeL;
N  int BorderSizeR;
N  int BorderSizeT;
N  int BorderSizeB;
N} FRAMEWIN_SKINFLEX_PROPS;
N
N/*********************************************************************
N*
N*       Create functions
N*
N**********************************************************************
N*/
NFRAMEWIN_Handle FRAMEWIN_Create        (const char * pTitle, WM_CALLBACK * cb, int Flags, int x0, int y0, int xSize, int ySize);
NFRAMEWIN_Handle FRAMEWIN_CreateAsChild (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, const char * pText, WM_CALLBACK * cb, int Flags);
XFRAMEWIN_Handle FRAMEWIN_CreateAsChild (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, const char * pText, WM_CALLBACK * cb, int Flags);
NFRAMEWIN_Handle FRAMEWIN_CreateEx      (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int ExFlags, int Id, const char * pTitle, WM_CALLBACK * cb);
XFRAMEWIN_Handle FRAMEWIN_CreateEx      (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int WinFlags, int ExFlags, int Id, const char * pTitle, WM_CALLBACK * cb);
NFRAMEWIN_Handle FRAMEWIN_CreateUser    (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int ExFlags, int Id, const char * pTitle, WM_CALLBACK * cb, int NumExtraBytes);
XFRAMEWIN_Handle FRAMEWIN_CreateUser    (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int WinFlags, int ExFlags, int Id, const char * pTitle, WM_CALLBACK * cb, int NumExtraBytes);
NFRAMEWIN_Handle FRAMEWIN_CreateIndirect(const GUI_WIDGET_CREATE_INFO * pCreateInfo, WM_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
XFRAMEWIN_Handle FRAMEWIN_CreateIndirect(const GUI_WIDGET_CREATE_INFO * pCreateInfo, GUI_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
N
N/*********************************************************************
N*
N*       The callback ...
N*
N* Do not call it directly ! It is only to be used from within an
N* overwritten callback.
N*/
Nvoid FRAMEWIN_Callback(WM_MESSAGE * pMsg);
N
N/*********************************************************************
N*
N*       Member functions: Set Properties
N*
N**********************************************************************
N*/
NWM_HWIN FRAMEWIN_AddButton     (FRAMEWIN_Handle hObj, int Flags, int Off, int Id);
XGUI_HWIN FRAMEWIN_AddButton     (FRAMEWIN_Handle hObj, int Flags, int Off, int Id);
NWM_HWIN FRAMEWIN_AddCloseButton(FRAMEWIN_Handle hObj, int Flags, int Off);
XGUI_HWIN FRAMEWIN_AddCloseButton(FRAMEWIN_Handle hObj, int Flags, int Off);
NWM_HWIN FRAMEWIN_AddMaxButton  (FRAMEWIN_Handle hObj, int Flags, int Off);
XGUI_HWIN FRAMEWIN_AddMaxButton  (FRAMEWIN_Handle hObj, int Flags, int Off);
Nvoid    FRAMEWIN_AddMenu       (FRAMEWIN_Handle hObj, WM_HWIN hMenu);
Xvoid    FRAMEWIN_AddMenu       (FRAMEWIN_Handle hObj, GUI_HWIN hMenu);
NWM_HWIN FRAMEWIN_AddMinButton  (FRAMEWIN_Handle hObj, int Flags, int Off);
XGUI_HWIN FRAMEWIN_AddMinButton  (FRAMEWIN_Handle hObj, int Flags, int Off);
Nvoid    FRAMEWIN_Minimize      (FRAMEWIN_Handle hObj);
Nvoid    FRAMEWIN_Maximize      (FRAMEWIN_Handle hObj);
Nvoid    FRAMEWIN_Restore       (FRAMEWIN_Handle hObj);
Nvoid    FRAMEWIN_SetActive     (FRAMEWIN_Handle hObj, int State);
Nvoid    FRAMEWIN_SetBarColor   (FRAMEWIN_Handle hObj, unsigned Index, GUI_COLOR Color);
Nvoid    FRAMEWIN_SetBorderSize (FRAMEWIN_Handle hObj, unsigned Size);
Nvoid    FRAMEWIN_SetClientColor(FRAMEWIN_Handle hObj, GUI_COLOR Color);
Nvoid    FRAMEWIN_SetFont       (FRAMEWIN_Handle hObj, const GUI_FONT * pFont);
Nvoid    FRAMEWIN_SetMoveable   (FRAMEWIN_Handle hObj, int State);
Nvoid    FRAMEWIN_SetOwnerDraw  (FRAMEWIN_Handle hObj, WIDGET_DRAW_ITEM_FUNC * pfDrawItem);
Nvoid    FRAMEWIN_SetResizeable (FRAMEWIN_Handle hObj, int State);
Nvoid    FRAMEWIN_SetText       (FRAMEWIN_Handle hObj, const char* s);
Nvoid    FRAMEWIN_SetTextAlign  (FRAMEWIN_Handle hObj, int Align);
Nvoid    FRAMEWIN_SetTextColor  (FRAMEWIN_Handle hObj, GUI_COLOR Color);
Nvoid    FRAMEWIN_SetTextColorEx(FRAMEWIN_Handle hObj, unsigned Index, GUI_COLOR Color);
Nvoid    FRAMEWIN_SetTitleVis   (FRAMEWIN_Handle hObj, int Show);
Nint     FRAMEWIN_SetTitleHeight(FRAMEWIN_Handle hObj, int Height);
Nint     FRAMEWIN_SetUserData   (FRAMEWIN_Handle hObj, const void * pSrc, int NumBytes);
N
N/*********************************************************************
N*
N*       Member functions: Skinning
N*
N**********************************************************************
N*/
Nvoid FRAMEWIN_GetSkinFlexProps     (FRAMEWIN_SKINFLEX_PROPS * pProps, int Index);
Nvoid FRAMEWIN_SetSkinClassic       (FRAMEWIN_Handle hObj);
Nvoid FRAMEWIN_SetSkin              (FRAMEWIN_Handle hObj, WIDGET_DRAW_ITEM_FUNC * pfDrawSkin);
Nint  FRAMEWIN_DrawSkinFlex         (const WIDGET_ITEM_DRAW_INFO * pDrawItemInfo);
Nvoid FRAMEWIN_SetSkinFlexProps     (const FRAMEWIN_SKINFLEX_PROPS * pProps, int Index);
Nvoid FRAMEWIN_SetDefaultSkinClassic(void);
NWIDGET_DRAW_ITEM_FUNC * FRAMEWIN_SetDefaultSkin(WIDGET_DRAW_ITEM_FUNC * pfDrawSkin);
N
N#define FRAMEWIN_SKIN_FLEX    FRAMEWIN_DrawSkinFlex
N
N/*********************************************************************
N*
N*       Member functions: Get Properties
N*
N**********************************************************************
N*/
Nconst GUI_FONT * FRAMEWIN_GetFont(FRAMEWIN_Handle hObj);
N
Nint       FRAMEWIN_GetActive      (FRAMEWIN_Handle hObj);
Nint       FRAMEWIN_GetTitleHeight (FRAMEWIN_Handle hObj);
NGUI_COLOR FRAMEWIN_GetBarColor    (FRAMEWIN_Handle hObj, unsigned Index);
Nint       FRAMEWIN_GetBorderSize  (FRAMEWIN_Handle hObj);
Nint       FRAMEWIN_GetBorderSizeEx(FRAMEWIN_Handle hObj, unsigned Edge);
Nvoid      FRAMEWIN_GetText        (FRAMEWIN_Handle hObj, char * pBuffer, int MaxLen);
Nint       FRAMEWIN_GetTextAlign   (FRAMEWIN_Handle hObj);
Nint       FRAMEWIN_GetUserData    (FRAMEWIN_Handle hObj, void * pDest, int NumBytes);
Nint       FRAMEWIN_IsMinimized    (FRAMEWIN_Handle hObj);
Nint       FRAMEWIN_IsMaximized    (FRAMEWIN_Handle hObj);
N
N/*********************************************************************
N*
N*       Managing default values
N*
N**********************************************************************
N*/
NGUI_COLOR        FRAMEWIN_GetDefaultBarColor   (unsigned Index);
Nint              FRAMEWIN_GetDefaultBorderSize (void);
Nint              FRAMEWIN_GetDefaultTitleHeight(void);
NGUI_COLOR        FRAMEWIN_GetDefaultClientColor(void);
Nconst GUI_FONT * FRAMEWIN_GetDefaultFont       (void);
NGUI_COLOR        FRAMEWIN_GetDefaultTextColor  (unsigned Index);
Nint              FRAMEWIN_OwnerDraw            (const WIDGET_ITEM_DRAW_INFO * pDrawItemInfo);
Nvoid             FRAMEWIN_SetDefaultBarColor   (unsigned Index, GUI_COLOR Color);
Nvoid             FRAMEWIN_SetDefaultBorderSize (int DefaultBorderSize);
Nvoid             FRAMEWIN_SetDefaultTitleHeight(int DefaultTitleHeight);
Nvoid             FRAMEWIN_SetDefaultClientColor(GUI_COLOR Color);
Nvoid             FRAMEWIN_SetDefaultFont       (const GUI_FONT * pFont);
Nint              FRAMEWIN_SetDefaultTextAlign  (int TextAlign);
Nvoid             FRAMEWIN_SetDefaultTextColor  (unsigned Index, GUI_COLOR Color);
N
N/*********************************************************************
N*
N*       Macros for compatibility
N*
N**********************************************************************
N*/
N#define         FRAMEWIN_SetDefaultCaptionSize(Height)       FRAMEWIN_SetDefaultTitleHeight(Height)
N#define         FRAMEWIN_GetDefaultCaptionSize()             FRAMEWIN_GetDefaultTitleHeight()
N#define         FRAMEWIN_CreateButton(hObj, Flags, Off, Id)  FRAMEWIN_AddButton(hObj, Flags, Off, Id) 
N#define         FRAMEWIN_CreateCloseButton(hObj, Flags, Off) FRAMEWIN_AddCloseButton(hObj, Flags, Off)
N#define         FRAMEWIN_CreateMaxButton(hObj, Flags, Off)   FRAMEWIN_AddMaxButton(hObj, Flags, Off)  
N#define         FRAMEWIN_CreateMinButton(hObj, Flags, Off)   FRAMEWIN_AddMinButton(hObj, Flags, Off)  
N
N#if defined(__cplusplus)
X#if 0L
S  }
N#endif
N
N#endif  // GUI_WINSUPPORT
N#endif  // FRAMEWIN_H
N
N/*************************** End of file ****************************/
L 58 "..\..\..\..\ThirdParty\emWin\Include\DIALOG.h" 2
N#include "GAUGE.h"
L 1 "..\..\..\..\ThirdParty\emWin\Include\GAUGE.h" 1
N/*********************************************************************
N*                    SEGGER Microcontroller GmbH                     *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2023  SEGGER Microcontroller GmbH                *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V6.46 - Graphical user interface for embedded applications **
NemWin is protected by international copyright laws. Knowledge of the
Nsource code may not be used to write a similar product. 
NThis file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed by SEGGER Software GmbH to Nuvoton Technology Corporation
Nat the address: No. 4, Creation Rd. III, Hsinchu Science Park, Taiwan
Nfor the purposes  of  creating  libraries  for its 
NArm Cortex-A, Arm Cortex-M and  Arm9 32-bit microcontrollers, commercialized and distributed by Nuvoton Technology Corporation
Nunder  the terms and conditions  of  an  End  User  
NLicense  Agreement  supplied  with  the libraries.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NLicensing information
NLicensor:                 SEGGER Software GmbH
NLicensed to:              Nuvoton Technology Corporation, No. 4, Creation Rd. III, Hsinchu Science Park, 30077 Hsinchu City, Taiwan
NLicensed SEGGER software: emWin
NLicense number:           GUI-00735
NLicense model:            emWin License Agreement, signed February 27, 2018
NLicensed platform:        Cortex-M, Cortex-A, and ARM9 32-bit series microcontroller designed and manufactured by Nuvoton Technology Corporation.
N----------------------------------------------------------------------
NSupport and Update Agreement (SUA)
NSUA period:               2018-03-26 - 2025-09-04
NContact to extend SUA:    sales@segger.com
N----------------------------------------------------------------------
NFile        : GAUGE.h
NPurpose     : GAUGE public header file (API)
N--------------------END-OF-HEADER-------------------------------------
N*/
N
N#ifndef GAUGE_H
N#define GAUGE_H
N
N#include "WM.h"
N#include "DIALOG_Type.h"      /* Req. for Create indirect data structure */
N#include "WIDGET.h"
N
N#if GUI_WINSUPPORT
X#if 1
N
N#if defined(__cplusplus)
X#if 0L
S  extern "C" {     /* Make sure we have C-declarations in C++ programs */
N#endif
N
N/*********************************************************************
N*
N*       GAUGE curved flags
N*
N*  Description
N*    With these flags the drawing of the widget's arc lines can be set to have
N*    round edges. The flags can be used upon creation of the GAUGE widget.
N*/
N#define GAUGE_CURVED_VALUE  (1 << 0)  // The arc that is drawn for the GAUGE's value will have a
N                                      // curved edge on the beginning and end of the line.
N#define GAUGE_CURVED_END    (1 << 1)  // The background arc will be drawn with a curved edge on the
N                                      // beginning and end of the line.
N#define GAUGE_DIRECTION_CCW (1 << 2)  // Widget works counterclockwise
N
N/*********************************************************************
N*
N*       Types
N*
N**********************************************************************
N*/
Ntypedef WM_HMEM GAUGE_Handle;
Xtypedef signed long GAUGE_Handle;
N
N/*********************************************************************
N*
N*       Create function(s)
N
N  Note: the parameters to a create function may vary.
N         Some widgets may have multiple create functions
N*/
NGAUGE_Handle GAUGE_CreateUser    (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int ExFlags, int Id, int NumExtraBytes);
XGAUGE_Handle GAUGE_CreateUser    (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int WinFlags, int ExFlags, int Id, int NumExtraBytes);
NGAUGE_Handle GAUGE_CreateIndirect(const GUI_WIDGET_CREATE_INFO * pCreateInfo, WM_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
XGAUGE_Handle GAUGE_CreateIndirect(const GUI_WIDGET_CREATE_INFO * pCreateInfo, GUI_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
N
N/*********************************************************************
N*
N*       The callback ...
N*
N* Do not call it directly ! It is only to be used from within an
N* overwritten callback.
N*/
Nvoid GAUGE_Callback(WM_MESSAGE *pMsg);
N
N/*********************************************************************
N*
N*       Member functions
N*
N**********************************************************************
N*/
Nvoid GAUGE_EnableCCW      (GAUGE_Handle hObj, int OnOff);
NI32  GAUGE_GetValue       (GAUGE_Handle hObj);
Xsigned long  GAUGE_GetValue       (GAUGE_Handle hObj);
Nvoid GAUGE_GetRange       (GAUGE_Handle hObj, I32 * pAng0, I32 * pAng1);
Xvoid GAUGE_GetRange       (GAUGE_Handle hObj, signed long * pAng0, signed long * pAng1);
Nvoid GAUGE_SetAlign       (GAUGE_Handle hObj, int Align);
Nvoid GAUGE_SetBkColor     (GAUGE_Handle hObj, GUI_COLOR BkColor);
Nvoid GAUGE_SetColor       (GAUGE_Handle hObj, unsigned Index, GUI_COLOR Color);
Nvoid GAUGE_SetWidth       (GAUGE_Handle hObj, unsigned Index, int Width);
Nvoid GAUGE_SetOffset      (GAUGE_Handle hObj, int xOff, int yOff);
Nvoid GAUGE_SetRadius      (GAUGE_Handle hObj, int Radius);
Nvoid GAUGE_SetRange       (GAUGE_Handle hObj, I32 Ang0, I32 Ang1);
Xvoid GAUGE_SetRange       (GAUGE_Handle hObj, signed long Ang0, signed long Ang1);
Nvoid GAUGE_SetRoundedEnd  (GAUGE_Handle hObj, int OnOff);
Nvoid GAUGE_SetRoundedValue(GAUGE_Handle hObj, int OnOff);
Nvoid GAUGE_SetValueRange  (GAUGE_Handle hObj, I32 Min, I32 Max);
Xvoid GAUGE_SetValueRange  (GAUGE_Handle hObj, signed long Min, signed long Max);
Nvoid GAUGE_SetValue       (GAUGE_Handle hObj, I32 Value);
Xvoid GAUGE_SetValue       (GAUGE_Handle hObj, signed long Value);
N
N#if defined(__cplusplus)
X#if 0L
S  }
N#endif
N
N#endif  // GUI_WINSUPPORT
N#endif  // GAUGE_H
N
N/*************************** End of file ****************************/
N
L 59 "..\..\..\..\ThirdParty\emWin\Include\DIALOG.h" 2
N#include "GRAPH.h"
L 1 "..\..\..\..\ThirdParty\emWin\Include\GRAPH.h" 1
N/*********************************************************************
N*                    SEGGER Microcontroller GmbH                     *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2023  SEGGER Microcontroller GmbH                *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V6.46 - Graphical user interface for embedded applications **
NemWin is protected by international copyright laws. Knowledge of the
Nsource code may not be used to write a similar product. 
NThis file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed by SEGGER Software GmbH to Nuvoton Technology Corporation
Nat the address: No. 4, Creation Rd. III, Hsinchu Science Park, Taiwan
Nfor the purposes  of  creating  libraries  for its 
NArm Cortex-A, Arm Cortex-M and  Arm9 32-bit microcontrollers, commercialized and distributed by Nuvoton Technology Corporation
Nunder  the terms and conditions  of  an  End  User  
NLicense  Agreement  supplied  with  the libraries.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NLicensing information
NLicensor:                 SEGGER Software GmbH
NLicensed to:              Nuvoton Technology Corporation, No. 4, Creation Rd. III, Hsinchu Science Park, 30077 Hsinchu City, Taiwan
NLicensed SEGGER software: emWin
NLicense number:           GUI-00735
NLicense model:            emWin License Agreement, signed February 27, 2018
NLicensed platform:        Cortex-M, Cortex-A, and ARM9 32-bit series microcontroller designed and manufactured by Nuvoton Technology Corporation.
N----------------------------------------------------------------------
NSupport and Update Agreement (SUA)
NSUA period:               2018-03-26 - 2025-09-04
NContact to extend SUA:    sales@segger.com
N----------------------------------------------------------------------
NFile        : GRAPH.h
NPurpose     : GRAPH include
N--------------------END-OF-HEADER-------------------------------------
N*/
N
N#ifndef GRAPH_H
N#define GRAPH_H
N
N#include "WM.h"
N#include "DIALOG_Type.h"      /* Req. for Create indirect data structure */
N#include "WIDGET.h"
N
N#if GUI_WINSUPPORT
X#if 1
N
N#if defined(__cplusplus)
X#if 0L
S  extern "C" {     /* Make sure we have C-declarations in C++ programs */
N#endif
N
N/*********************************************************************
N*
N*       Defines
N*
N**********************************************************************
N*/
N/*********************************************************************
N*
N*       GRAPH color indexes
N*
N*  Description
N*    Color indexes used by the GRAPH widget.
N*/
N#define GRAPH_CI_BK                  0           // Background color.
N#define GRAPH_CI_BORDER              1           // Color of the border area.
N#define GRAPH_CI_FRAME               2           // Color of the thin frame line.
N#define GRAPH_CI_GRID                3           // Color of the grid.
N
N/*********************************************************************
N*
N*       SCALE create flags
N*
N*  Description
N*    Create flags used for scale objects.
N*/
N#define GRAPH_SCALE_CF_HORIZONTAL    (0 << 0)    // Creates a horizontal scale object.
N#define GRAPH_SCALE_CF_VERTICAL      (1 << 0)    // Creates a vertical scale object.
N
N/* status flags */
N#define GRAPH_SCALE_SF_HORIZONTAL    GRAPH_SCALE_CF_HORIZONTAL
N#define GRAPH_SCALE_SF_VERTICAL      GRAPH_SCALE_CF_VERTICAL
N
N/*********************************************************************
N*
N*       GRAPH user draw stages
N*
N*  Description
N*    Stages sent to a user draw routine with the \a{Stage} parameter.
N*    For more information, refer to GRAPH_SetUserDraw().
N*/
N#define GRAPH_DRAW_FIRST             0           // Gives the application the possibility to perform drawing operations at the beginning of the drawing process.
N#define GRAPH_DRAW_AFTER_BORDER      1           // Gives the application the possibility to perform drawing operations after the border was drawn.
N#define GRAPH_DRAW_LAST              2           // Performs final drawing operations.
N
N/*********************************************************************
N*
N*       GRAPH alignment flags
N*
N*  Description
N*    Flags that define the alignment of the date of a graph.
N*/
N#define GRAPH_ALIGN_RIGHT            (0 << 0)    // The data is aligned at the right edge (default).
N#define GRAPH_ALIGN_LEFT             (1 << 0)    // The data is aligned at the left edge.
N
N/*********************************************************************
N*
N*       GRAPH create flags
N*
N*  Description
N*    Create flags used for GRAPH objects.
N*/
N#define GRAPH_CF_GRID_FIXED_X        (1 << 0)    // This flag 'fixes' the grid in X-axis. That means if horizontal scrolling is used, the grid remains in its position.
N#define GRAPH_CF_AVOID_SCROLLBAR_H   (1 << 1)    // Automatic use of a horizontal scrollbar is disabled. (Default).
N#define GRAPH_CF_AVOID_SCROLLBAR_V   (1 << 2)    // Automatic use of a vertical scrollbar is disabled. (Default).
N/* */
N
N//
N// Status flags
N//
N#define GRAPH_SF_AVOID_SCROLLBAR_H   GRAPH_CF_AVOID_SCROLLBAR_H
N#define GRAPH_SF_AVOID_SCROLLBAR_V   GRAPH_CF_AVOID_SCROLLBAR_V
N
N/*********************************************************************
N*
N*       Public Types
N*
N**********************************************************************
N*/
Ntypedef WM_HMEM GRAPH_Handle;
Xtypedef signed long GRAPH_Handle;
Ntypedef WM_HMEM GRAPH_DATA_Handle;
Xtypedef signed long GRAPH_DATA_Handle;
Ntypedef WM_HMEM GRAPH_SCALE_Handle;
Xtypedef signed long GRAPH_SCALE_Handle;
N
N/*********************************************************************
N*
N*       Create functions
N*
N**********************************************************************
N*/
N
NGRAPH_Handle GRAPH_CreateEx      (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int ExFlags, int Id);
XGRAPH_Handle GRAPH_CreateEx      (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int WinFlags, int ExFlags, int Id);
NGRAPH_Handle GRAPH_CreateUser    (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int ExFlags, int Id, int NumExtraBytes);
XGRAPH_Handle GRAPH_CreateUser    (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int WinFlags, int ExFlags, int Id, int NumExtraBytes);
NGRAPH_Handle GRAPH_CreateIndirect(const GUI_WIDGET_CREATE_INFO * pCreateInfo, WM_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
XGRAPH_Handle GRAPH_CreateIndirect(const GUI_WIDGET_CREATE_INFO * pCreateInfo, GUI_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
N
NGRAPH_DATA_Handle  GRAPH_DATA_XY_Create(GUI_COLOR Color, unsigned MaxNumItems, const GUI_POINT * pData, unsigned NumItems);
NGRAPH_DATA_Handle  GRAPH_DATA_YT_Create(GUI_COLOR Color, unsigned MaxNumItems, const I16 * pData, unsigned NumItems);
XGRAPH_DATA_Handle  GRAPH_DATA_YT_Create(GUI_COLOR Color, unsigned MaxNumItems, const signed short * pData, unsigned NumItems);
NGRAPH_SCALE_Handle GRAPH_SCALE_Create  (int Pos, int TextAlign, unsigned Flags, unsigned TickDist);
N
N/*********************************************************************
N*
N*       The callback ...
N*
N* Do not call it directly ! It is only to be used from within an
N* overwritten callback.
N*/
Nvoid GRAPH_Callback(WM_MESSAGE * pMsg);
N
N/*********************************************************************
N*
N*       Member functions
N*
N**********************************************************************
N*/
Nvoid      GRAPH_AttachData             (GRAPH_Handle hObj, GRAPH_DATA_Handle hData);
Nvoid      GRAPH_AttachScale            (GRAPH_Handle hObj, GRAPH_SCALE_Handle hScale);
Nvoid      GRAPH_DetachData             (GRAPH_Handle hObj, GRAPH_DATA_Handle hData);
Nvoid      GRAPH_DetachScale            (GRAPH_Handle hObj, GRAPH_SCALE_Handle hScale);
NGUI_COLOR GRAPH_GetColor               (GRAPH_Handle hObj, unsigned Index);
NI32       GRAPH_GetScrollValue         (GRAPH_Handle hObj, U8 Coord);
Xsigned long       GRAPH_GetScrollValue         (GRAPH_Handle hObj, unsigned char Coord);
Nint       GRAPH_GetUserData            (GRAPH_Handle hObj, void * pDest, int NumBytes);
Nvoid      GRAPH_InvertScrollbar        (GRAPH_Handle hObj, U8 Coord);
Xvoid      GRAPH_InvertScrollbar        (GRAPH_Handle hObj, unsigned char Coord);
Nvoid      GRAPH_SetAutoScrollbar       (GRAPH_Handle hObj, U8 Coord, U8 OnOff);
Xvoid      GRAPH_SetAutoScrollbar       (GRAPH_Handle hObj, unsigned char Coord, unsigned char OnOff);
Nvoid      GRAPH_SetBorder              (GRAPH_Handle hObj, unsigned BorderL, unsigned BorderT, unsigned BorderR, unsigned BorderB);
NGUI_COLOR GRAPH_SetColor               (GRAPH_Handle hObj, GUI_COLOR Color, unsigned Index);
Nunsigned  GRAPH_SetGridFixedX          (GRAPH_Handle hObj, unsigned OnOff);
Nunsigned  GRAPH_SetGridOffX            (GRAPH_Handle hObj, unsigned Value);
Nunsigned  GRAPH_SetGridOffY            (GRAPH_Handle hObj, unsigned Value);
Nunsigned  GRAPH_SetGridVis             (GRAPH_Handle hObj, unsigned OnOff);
Nunsigned  GRAPH_SetGridDistX           (GRAPH_Handle hObj, unsigned Value);
Nunsigned  GRAPH_SetGridDistY           (GRAPH_Handle hObj, unsigned Value);
NU8        GRAPH_SetLineStyleH          (GRAPH_Handle hObj, U8 Value);
Xunsigned char        GRAPH_SetLineStyleH          (GRAPH_Handle hObj, unsigned char Value);
NU8        GRAPH_SetLineStyleV          (GRAPH_Handle hObj, U8 Value);
Xunsigned char        GRAPH_SetLineStyleV          (GRAPH_Handle hObj, unsigned char Value);
Nvoid      GRAPH_SetLineStyle           (GRAPH_Handle hObj, U8 Value);
Xvoid      GRAPH_SetLineStyle           (GRAPH_Handle hObj, unsigned char Value);
Nvoid      GRAPH_SetScrollValue         (GRAPH_Handle hObj, U8 Coord, U32 Value);
Xvoid      GRAPH_SetScrollValue         (GRAPH_Handle hObj, unsigned char Coord, unsigned long Value);
Nunsigned  GRAPH_SetVSizeX              (GRAPH_Handle hObj, unsigned Value);
Nunsigned  GRAPH_SetVSizeY              (GRAPH_Handle hObj, unsigned Value);
Nint       GRAPH_SetUserData            (GRAPH_Handle hObj, const void * pSrc, int NumBytes);
Nvoid      GRAPH_SetUserDraw            (GRAPH_Handle hObj, void (* pOwnerDraw)(WM_HWIN, int));
Xvoid      GRAPH_SetUserDraw            (GRAPH_Handle hObj, void (* pOwnerDraw)(GUI_HWIN, int));
N
Nvoid      GRAPH_DATA_YT_AddValue       (GRAPH_DATA_Handle hDataObj, I16 Value);
Xvoid      GRAPH_DATA_YT_AddValue       (GRAPH_DATA_Handle hDataObj, signed short Value);
Nvoid      GRAPH_DATA_YT_Clear          (GRAPH_DATA_Handle hDataObj);
Nvoid      GRAPH_DATA_YT_Delete         (GRAPH_DATA_Handle hDataObj);
Nint       GRAPH_DATA_YT_GetValue       (GRAPH_DATA_Handle hDataObj, I16 * pValue, U32 Index);
Xint       GRAPH_DATA_YT_GetValue       (GRAPH_DATA_Handle hDataObj, signed short * pValue, unsigned long Index);
N
Nvoid      GRAPH_DATA_YT_SetAlign       (GRAPH_DATA_Handle hDataObj, int Align);
NGUI_COLOR GRAPH_DATA_YT_SetColor       (GRAPH_DATA_Handle hDataObj, GUI_COLOR Color);
Nvoid      GRAPH_DATA_YT_SetOffY        (GRAPH_DATA_Handle hDataObj, int Off);
Nvoid      GRAPH_DATA_YT_MirrorX        (GRAPH_DATA_Handle hDataObj, int OnOff);
N
Nvoid      GRAPH_DATA_XY_AddPoint       (GRAPH_DATA_Handle hDataObj, GUI_POINT * pPoint);
Nvoid      GRAPH_DATA_XY_Clear          (GRAPH_DATA_Handle hDataObj);
Nvoid      GRAPH_DATA_XY_Delete         (GRAPH_DATA_Handle hDataObj);
Nunsigned  GRAPH_DATA_XY_GetLineVis     (GRAPH_DATA_Handle hDataObj);
Nint       GRAPH_DATA_XY_GetPoint       (GRAPH_DATA_Handle hDataObj, GUI_POINT * pPoint, U32 Index);
Xint       GRAPH_DATA_XY_GetPoint       (GRAPH_DATA_Handle hDataObj, GUI_POINT * pPoint, unsigned long Index);
Nunsigned  GRAPH_DATA_XY_GetPointVis    (GRAPH_DATA_Handle hDataObj);
NGUI_COLOR GRAPH_DATA_XY_SetColor       (GRAPH_DATA_Handle hDataObj, GUI_COLOR Color);
Nvoid      GRAPH_DATA_XY_SetLineStyle   (GRAPH_DATA_Handle hDataObj, U8 LineStyle);
Xvoid      GRAPH_DATA_XY_SetLineStyle   (GRAPH_DATA_Handle hDataObj, unsigned char LineStyle);
Nunsigned  GRAPH_DATA_XY_SetLineVis     (GRAPH_DATA_Handle hDataObj, unsigned OnOff);
Nvoid      GRAPH_DATA_XY_SetOffX        (GRAPH_DATA_Handle hDataObj, int Off);
Nvoid      GRAPH_DATA_XY_SetOffY        (GRAPH_DATA_Handle hDataObj, int Off);
Nvoid      GRAPH_DATA_XY_SetPenSize     (GRAPH_DATA_Handle hDataObj, U8 PenSize);
Xvoid      GRAPH_DATA_XY_SetPenSize     (GRAPH_DATA_Handle hDataObj, unsigned char PenSize);
Nvoid      GRAPH_DATA_XY_SetPointSize   (GRAPH_DATA_Handle hDataObj, unsigned PointSize);
Nunsigned  GRAPH_DATA_XY_SetPointVis    (GRAPH_DATA_Handle hDataObj, unsigned OnOff);
Nvoid      GRAPH_DATA_XY_SetOwnerDraw   (GRAPH_DATA_Handle hDataObj, WIDGET_DRAW_ITEM_FUNC * pOwnerDraw);
N
Nvoid             GRAPH_SCALE_Delete      (GRAPH_SCALE_Handle hScaleObj);
Nfloat            GRAPH_SCALE_SetFactor   (GRAPH_SCALE_Handle hScaleObj, float Factor);
Nconst GUI_FONT * GRAPH_SCALE_SetFont     (GRAPH_SCALE_Handle hScaleObj, const GUI_FONT * pFont);
Nint              GRAPH_SCALE_SetNumDecs  (GRAPH_SCALE_Handle hScaleObj, int NumDecs);
Nint              GRAPH_SCALE_SetOff      (GRAPH_SCALE_Handle hScaleObj, int Off);
Nint              GRAPH_SCALE_SetPos      (GRAPH_SCALE_Handle hScaleObj, int Pos);
NGUI_COLOR        GRAPH_SCALE_SetTextColor(GRAPH_SCALE_Handle hScaleObj, GUI_COLOR Color);
Nunsigned         GRAPH_SCALE_SetTickDist (GRAPH_SCALE_Handle hScaleObj, unsigned Value);
N
N#if defined(__cplusplus)
X#if 0L
S  }
N#endif
N
N#endif  // GUI_WINSUPPORT
N#endif  // GRAPH_H
N
N/*************************** End of file ****************************/
L 60 "..\..\..\..\ThirdParty\emWin\Include\DIALOG.h" 2
N#include "HEADER.h"
L 1 "..\..\..\..\ThirdParty\emWin\Include\HEADER.h" 1
N/*********************************************************************
N*                    SEGGER Microcontroller GmbH                     *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2023  SEGGER Microcontroller GmbH                *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V6.46 - Graphical user interface for embedded applications **
NemWin is protected by international copyright laws. Knowledge of the
Nsource code may not be used to write a similar product. 
NThis file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed by SEGGER Software GmbH to Nuvoton Technology Corporation
Nat the address: No. 4, Creation Rd. III, Hsinchu Science Park, Taiwan
Nfor the purposes  of  creating  libraries  for its 
NArm Cortex-A, Arm Cortex-M and  Arm9 32-bit microcontrollers, commercialized and distributed by Nuvoton Technology Corporation
Nunder  the terms and conditions  of  an  End  User  
NLicense  Agreement  supplied  with  the libraries.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NLicensing information
NLicensor:                 SEGGER Software GmbH
NLicensed to:              Nuvoton Technology Corporation, No. 4, Creation Rd. III, Hsinchu Science Park, 30077 Hsinchu City, Taiwan
NLicensed SEGGER software: emWin
NLicense number:           GUI-00735
NLicense model:            emWin License Agreement, signed February 27, 2018
NLicensed platform:        Cortex-M, Cortex-A, and ARM9 32-bit series microcontroller designed and manufactured by Nuvoton Technology Corporation.
N----------------------------------------------------------------------
NSupport and Update Agreement (SUA)
NSUA period:               2018-03-26 - 2025-09-04
NContact to extend SUA:    sales@segger.com
N----------------------------------------------------------------------
NFile        : HEADER.h
NPurpose     : HEADER include
N--------------------END-OF-HEADER-------------------------------------
N*/
N
N#ifndef HEADER_H
N#define HEADER_H
N
N#include "WM.h"
N#include "DIALOG_Type.h"      /* Req. for Create indirect data structure */
N#include "WIDGET.h"
N
N#if GUI_WINSUPPORT
X#if 1
N
N#if defined(__cplusplus)
X#if 0L
S  extern "C" {     /* Make sure we have C-declarations in C++ programs */
N#endif
N
N/*********************************************************************
N*
N*       Public Types
N*
N**********************************************************************
N*/
N
Ntypedef WM_HMEM HEADER_Handle;
Xtypedef signed long HEADER_Handle;
N
Ntypedef struct {
N  GUI_COLOR aColorFrame[2];
N  GUI_COLOR aColorUpper[2];
N  GUI_COLOR aColorLower[2];
N  GUI_COLOR ColorArrow;
N} HEADER_SKINFLEX_PROPS;
N
N/*********************************************************************
N*
N*       Create functions
N*
N**********************************************************************
N*/
N
NHEADER_Handle HEADER_Create        (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int Id, int Flags, int SpecialFlags);
XHEADER_Handle HEADER_Create        (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int Id, int Flags, int SpecialFlags);
NHEADER_Handle HEADER_CreateAttached(WM_HWIN hParent, int Id, int SpecialFlags);
XHEADER_Handle HEADER_CreateAttached(GUI_HWIN hParent, int Id, int SpecialFlags);
NHEADER_Handle HEADER_CreateEx      (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int ExFlags, int Id);
XHEADER_Handle HEADER_CreateEx      (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int WinFlags, int ExFlags, int Id);
NHEADER_Handle HEADER_CreateUser    (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int ExFlags, int Id, int NumExtraBytes);
XHEADER_Handle HEADER_CreateUser    (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int WinFlags, int ExFlags, int Id, int NumExtraBytes);
NHEADER_Handle HEADER_CreateIndirect(const GUI_WIDGET_CREATE_INFO * pCreateInfo, WM_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
XHEADER_Handle HEADER_CreateIndirect(const GUI_WIDGET_CREATE_INFO * pCreateInfo, GUI_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
N
N/*********************************************************************
N*
N*       The callback ...
N*
N* Do not call it directly ! It is only to be used from within an
N* overwritten callback.
N*/
Nvoid HEADER_Callback(WM_MESSAGE * pMsg);
N
N/*********************************************************************
N*
N*       Managing default values
N*
N**********************************************************************
N*/
N/* Set defaults */
NGUI_COLOR          HEADER_SetDefaultArrowColor(GUI_COLOR Color);
NGUI_COLOR          HEADER_SetDefaultBkColor   (GUI_COLOR Color);
Nconst GUI_CURSOR * HEADER_SetDefaultCursor    (const GUI_CURSOR * pCursor);
Nconst GUI_FONT *   HEADER_SetDefaultFont      (const GUI_FONT * pFont);
Nint                HEADER_SetDefaultBorderH   (int Spacing);
Nint                HEADER_SetDefaultBorderV   (int Spacing);
NGUI_COLOR          HEADER_SetDefaultTextColor (GUI_COLOR Color);
N
N/* Get defaults */
NGUI_COLOR          HEADER_GetDefaultArrowColor(void);
NGUI_COLOR          HEADER_GetDefaultBkColor   (void);
Nconst GUI_CURSOR * HEADER_GetDefaultCursor    (void);
Nconst GUI_FONT *   HEADER_GetDefaultFont      (void);
Nint                HEADER_GetDefaultBorderH   (void);
Nint                HEADER_GetDefaultBorderV   (void);
NGUI_COLOR          HEADER_GetDefaultTextColor (void);
N
N/*********************************************************************
N*
N*       Member functions
N*
N**********************************************************************
N*/
Nvoid             HEADER_AddItem             (HEADER_Handle hObj, int Width, const char * s, int Align);
Nvoid             HEADER_DeleteItem          (HEADER_Handle hObj, unsigned Index);
NGUI_COLOR        HEADER_GetArrowColor       (HEADER_Handle hObj);
NGUI_COLOR        HEADER_GetBkColor          (HEADER_Handle hObj);
NU8               HEADER_GetBorderH          (HEADER_Handle hObj);
Xunsigned char               HEADER_GetBorderH          (HEADER_Handle hObj);
NU8               HEADER_GetBorderV          (HEADER_Handle hObj);
Xunsigned char               HEADER_GetBorderV          (HEADER_Handle hObj);
Nint              HEADER_GetColumnFromPos    (HEADER_Handle hObj, int x);
Nconst GUI_FONT * HEADER_GetFont             (HEADER_Handle hObj);
Nint              HEADER_GetHeight           (HEADER_Handle hObj);
Nint              HEADER_GetItemText         (HEADER_Handle hObj, unsigned Index, char * pBuffer, int MaxSize);
Nint              HEADER_GetItemWidth        (HEADER_Handle hObj, unsigned Index);
Nint              HEADER_GetNumItems         (HEADER_Handle hObj);
Nint              HEADER_GetSel              (HEADER_Handle hObj);
NGUI_COLOR        HEADER_GetTextColor        (HEADER_Handle hObj);
Nint              HEADER_GetUserData         (HEADER_Handle hObj, void * pDest, int NumBytes);
Nvoid             HEADER_SetArrowColor       (HEADER_Handle hObj, GUI_COLOR Color);
Nvoid             HEADER_SetBitmap           (HEADER_Handle hObj, unsigned Index, const GUI_BITMAP * pBitmap);
Nvoid             HEADER_SetBitmapEx         (HEADER_Handle hObj, unsigned Index, const GUI_BITMAP * pBitmap, int x, int y);
Nvoid             HEADER_SetBkColor          (HEADER_Handle hObj, GUI_COLOR Color);
Nvoid             HEADER_SetBMP              (HEADER_Handle hObj, unsigned Index, const void * pBitmap);
Nvoid             HEADER_SetBMPEx            (HEADER_Handle hObj, unsigned Index, const void * pBitmap, int x, int y);
Nvoid             HEADER_SetBorderH          (HEADER_Handle hObj, U8 Border);
Xvoid             HEADER_SetBorderH          (HEADER_Handle hObj, unsigned char Border);
Nvoid             HEADER_SetBorderV          (HEADER_Handle hObj, U8 Border);
Xvoid             HEADER_SetBorderV          (HEADER_Handle hObj, unsigned char Border);
Nvoid             HEADER_SetColumnsResizeable(HEADER_Handle hObj, int OnOff);
Nvoid             HEADER_SetDirIndicator     (HEADER_Handle hObj, int Column, int Reverse); /* !!!Not to be documented!!! */
Nvoid             HEADER_SetDragLimit        (HEADER_Handle hObj, unsigned DragLimit);
Nunsigned         HEADER_SetFixed            (HEADER_Handle hObj, unsigned Fixed);
Nvoid             HEADER_SetFont             (HEADER_Handle hObj, const GUI_FONT * pFont);
Nvoid             HEADER_SetHeight           (HEADER_Handle hObj, int Height);
Nvoid             HEADER_SetTextAlign        (HEADER_Handle hObj, unsigned Index, int Align);
Nvoid             HEADER_SetItemText         (HEADER_Handle hObj, unsigned Index, const char * s);
Nvoid             HEADER_SetItemWidth        (HEADER_Handle hObj, unsigned Index, int Width);
Nvoid             HEADER_SetScrollPos        (HEADER_Handle hObj, int ScrollPos);
Nvoid             HEADER_SetStreamedBitmap   (HEADER_Handle hObj, unsigned Index, const GUI_BITMAP_STREAM * pBitmap);
Nvoid             HEADER_SetStreamedBitmapEx (HEADER_Handle hObj, unsigned Index, const GUI_BITMAP_STREAM * pBitmap, int x, int y);
Nvoid             HEADER_SetTextColor        (HEADER_Handle hObj, GUI_COLOR Color);
Nint              HEADER_SetUserData         (HEADER_Handle hObj, const void * pSrc, int NumBytes);
N
N/*********************************************************************
N*
N*       Member functions: Skinning
N*
N**********************************************************************
N*/
Nvoid HEADER_GetSkinFlexProps     (HEADER_SKINFLEX_PROPS * pProps, int Index);
Nvoid HEADER_SetSkinClassic       (HEADER_Handle hObj);
Nvoid HEADER_SetSkin              (HEADER_Handle hObj, WIDGET_DRAW_ITEM_FUNC * pfDrawSkin);
Nint  HEADER_DrawSkinFlex         (const WIDGET_ITEM_DRAW_INFO * pDrawItemInfo);
Nvoid HEADER_SetSkinFlexProps     (const HEADER_SKINFLEX_PROPS * pProps, int Index);
Nvoid HEADER_SetDefaultSkinClassic(void);
NWIDGET_DRAW_ITEM_FUNC * HEADER_SetDefaultSkin(WIDGET_DRAW_ITEM_FUNC * pfDrawSkin);
N
N#define HEADER_SKIN_FLEX          HEADER_DrawSkinFlex
N
N/*********************************************************************
N*
N*       Macros for compatibility with older versions
N*
N**********************************************************************
N*/
N
N#ifdef HEADER_SPACING_H
S  #define HEADER_BORDER_H_DEFAULT HEADER_SPACING_H
N#endif
N#ifdef HEADER_SPACING_V
S  #define HEADER_BORDER_V_DEFAULT HEADER_SPACING_V
N#endif
N#define HEADER_SetDefaultSpacingH(Value) HEADER_SetDefaultBorderH(Value)
N#define HEADER_SetDefaultSpacingV(Value) HEADER_SetDefaultBorderV(Value)
N#define HEADER_GetDefaultSpacingH()      HEADER_GetDefaultBorderH()
N#define HEADER_GetDefaultSpacingV()      HEADER_GetDefaultBorderV()
N
N#if defined(__cplusplus)
X#if 0L
S  }
N#endif
N
N#endif  // GUI_WINSUPPORT
N#endif  // HEADER_H
N
N/*************************** End of file ****************************/
L 61 "..\..\..\..\ThirdParty\emWin\Include\DIALOG.h" 2
N#include "ICONVIEW.h"
L 1 "..\..\..\..\ThirdParty\emWin\Include\ICONVIEW.h" 1
N/*********************************************************************
N*                    SEGGER Microcontroller GmbH                     *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2023  SEGGER Microcontroller GmbH                *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V6.46 - Graphical user interface for embedded applications **
NemWin is protected by international copyright laws. Knowledge of the
Nsource code may not be used to write a similar product. 
NThis file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed by SEGGER Software GmbH to Nuvoton Technology Corporation
Nat the address: No. 4, Creation Rd. III, Hsinchu Science Park, Taiwan
Nfor the purposes  of  creating  libraries  for its 
NArm Cortex-A, Arm Cortex-M and  Arm9 32-bit microcontrollers, commercialized and distributed by Nuvoton Technology Corporation
Nunder  the terms and conditions  of  an  End  User  
NLicense  Agreement  supplied  with  the libraries.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NLicensing information
NLicensor:                 SEGGER Software GmbH
NLicensed to:              Nuvoton Technology Corporation, No. 4, Creation Rd. III, Hsinchu Science Park, 30077 Hsinchu City, Taiwan
NLicensed SEGGER software: emWin
NLicense number:           GUI-00735
NLicense model:            emWin License Agreement, signed February 27, 2018
NLicensed platform:        Cortex-M, Cortex-A, and ARM9 32-bit series microcontroller designed and manufactured by Nuvoton Technology Corporation.
N----------------------------------------------------------------------
NSupport and Update Agreement (SUA)
NSUA period:               2018-03-26 - 2025-09-04
NContact to extend SUA:    sales@segger.com
N----------------------------------------------------------------------
NFile        : ICONVIEW.h
NPurpose     : ICONVIEW include
N--------------------END-OF-HEADER-------------------------------------
N*/
N
N#ifndef ICONVIEW_H
N#define ICONVIEW_H
N
N#include "WM.h"
N#include "DIALOG_Type.h"      /* Req. for Create indirect data structure */
N#include "WIDGET.h"
N
N#if GUI_WINSUPPORT
X#if 1
N
N#if defined(__cplusplus)
X#if 0L
S  extern "C" {     /* Make sure we have C-declarations in C++ programs */
N#endif
N
N/*********************************************************************
N*
N*       Defines
N*
N**********************************************************************
N*/
N//
N// Status- and create flags
N//
N#define ICONVIEW_CF_AUTOSCROLLBAR_V (1 << 1)
N#define ICONVIEW_SF_AUTOSCROLLBAR_V ICONVIEW_CF_AUTOSCROLLBAR_V
N
N/*********************************************************************
N*
N*       ICONVIEW color indexes
N*
N*  Description
N*    Color indexes used by the ICONVIEW widget.
N*
N*  Additional information
N*    ICONVIEW_CI_BK is only used by the routines ICONVIEW_GetBkColor() and
N*    ICONVIEW_SetBkColor() instead of ICONVIEW_CI_UNSEL.
N*/
N#define ICONVIEW_CI_BK              0           // Color used to draw the widget background.
N#define ICONVIEW_CI_UNSEL           0           // Color of an unselected item.
N#define ICONVIEW_CI_SEL             1           // Color of a selected item.
N#define ICONVIEW_CI_DISABLED        2           // Color used in disabled state.
N/* # emDoc */
N
N//
N// Icon alignment flags, horizontal
N//
N#define ICONVIEW_IA_HCENTER         (0 << 0)
N#define ICONVIEW_IA_LEFT            (1 << 0)
N#define ICONVIEW_IA_RIGHT           (2 << 0)
N
N//
N// Icon alignment flags, vertical
N//
N#define ICONVIEW_IA_VCENTER         (0 << 2)
N#define ICONVIEW_IA_BOTTOM          (1 << 2)
N#define ICONVIEW_IA_TOP             (2 << 2)
N
N/*********************************************************************
N*
N*       Types
N*
N**********************************************************************
N*/
Ntypedef WM_HMEM ICONVIEW_Handle;
Xtypedef signed long ICONVIEW_Handle;
N
N/*********************************************************************
N*
N*       Public functions
N*
N**********************************************************************
N*/
NICONVIEW_Handle ICONVIEW_CreateEx      (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int ExFlags, int Id, int xSizeItems, int ySizeItems);
XICONVIEW_Handle ICONVIEW_CreateEx      (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int WinFlags, int ExFlags, int Id, int xSizeItems, int ySizeItems);
NICONVIEW_Handle ICONVIEW_CreateUser    (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int ExFlags, int Id, int xSizeItems, int ySizeItems, int NumExtraBytes);
XICONVIEW_Handle ICONVIEW_CreateUser    (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int WinFlags, int ExFlags, int Id, int xSizeItems, int ySizeItems, int NumExtraBytes);
NICONVIEW_Handle ICONVIEW_CreateIndirect(const GUI_WIDGET_CREATE_INFO * pCreateInfo, WM_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
XICONVIEW_Handle ICONVIEW_CreateIndirect(const GUI_WIDGET_CREATE_INFO * pCreateInfo, GUI_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
N
Nint              ICONVIEW_AddBitmapItem           (ICONVIEW_Handle hObj, const GUI_BITMAP * pBitmap, const char * pText);
Nint              ICONVIEW_AddBMPItem              (ICONVIEW_Handle hObj, const U8 * pBMP, const char * pText);
Xint              ICONVIEW_AddBMPItem              (ICONVIEW_Handle hObj, const unsigned char * pBMP, const char * pText);
Nint              ICONVIEW_AddBMPItemEx            (ICONVIEW_Handle hObj, const void * pBMP, GUI_BMP_GET_DATA_FUNC * pfGetData, const char * pText);
Nint              ICONVIEW_AddStreamedBitmapItem   (ICONVIEW_Handle hObj, const void * pStreamedBitmap, const char * pText);
Nvoid             ICONVIEW_DeleteItem              (ICONVIEW_Handle hObj, unsigned Index);
NGUI_COLOR        ICONVIEW_GetBkColor              (ICONVIEW_Handle hObj, int Index);
Nconst GUI_FONT * ICONVIEW_GetFont                 (ICONVIEW_Handle hObj);
NU32              ICONVIEW_GetItemUserData         (ICONVIEW_Handle hObj, int Index);
Xunsigned long              ICONVIEW_GetItemUserData         (ICONVIEW_Handle hObj, int Index);
Nint              ICONVIEW_GetNumItems             (ICONVIEW_Handle hObj);
Nint              ICONVIEW_GetItemText             (ICONVIEW_Handle hObj, int Index, char * pBuffer, int MaxSize);
Nint              ICONVIEW_GetSel                  (ICONVIEW_Handle hObj);
NGUI_COLOR        ICONVIEW_GetTextColor            (ICONVIEW_Handle hObj, int Index);
Nint              ICONVIEW_GetUserData             (ICONVIEW_Handle hObj, void * pDest, int NumBytes);
NGUI_BITMAP *     ICONVIEW_GetItemBitmap           (ICONVIEW_Handle hObj, int ItemIndex);
Nint              ICONVIEW_GetReleasedItem         (ICONVIEW_Handle hObj);
Nint              ICONVIEW_InsertBitmapItem        (ICONVIEW_Handle hObj, const GUI_BITMAP * pBitmap, const char * pText, int Index);
Nint              ICONVIEW_InsertBMPItem           (ICONVIEW_Handle hObj, const U8 * pBMP, const char * pText, int Index);
Xint              ICONVIEW_InsertBMPItem           (ICONVIEW_Handle hObj, const unsigned char * pBMP, const char * pText, int Index);
Nint              ICONVIEW_InsertBMPItemEx         (ICONVIEW_Handle hObj, const void * pBMP, GUI_BMP_GET_DATA_FUNC * pfGetData, const char * pText, int Index);
Nint              ICONVIEW_InsertStreamedBitmapItem(ICONVIEW_Handle hObj, const void * pStreamedBitmap, const char * pText, int Index);
Nint              ICONVIEW_OwnerDraw               (const WIDGET_ITEM_DRAW_INFO * pDrawItemInfo);
Nint              ICONVIEW_SetBitmapItem           (ICONVIEW_Handle hObj, int Index, const GUI_BITMAP * pBitmap);
Nvoid             ICONVIEW_SetBkColor              (ICONVIEW_Handle hObj, int Index, GUI_COLOR Color);
Nint              ICONVIEW_SetBMPItem              (ICONVIEW_Handle hObj, const U8 * pBMP, int Index);
Xint              ICONVIEW_SetBMPItem              (ICONVIEW_Handle hObj, const unsigned char * pBMP, int Index);
Nint              ICONVIEW_SetBMPItemEx            (ICONVIEW_Handle hObj, const void * pBMP, GUI_BMP_GET_DATA_FUNC * pfGetData, int Index);
Nvoid             ICONVIEW_SetFont                 (ICONVIEW_Handle hObj, const GUI_FONT * pFont);
Nvoid             ICONVIEW_SetFrame                (ICONVIEW_Handle hObj, int Coord, int Value);
Nvoid             ICONVIEW_SetItemText             (ICONVIEW_Handle hObj, int Index, const char * pText);
Nvoid             ICONVIEW_SetItemUserData         (ICONVIEW_Handle hObj, int Index, U32 UserData);
Xvoid             ICONVIEW_SetItemUserData         (ICONVIEW_Handle hObj, int Index, unsigned long UserData);
Nvoid             ICONVIEW_SetOwnerDraw            (ICONVIEW_Handle hObj, WIDGET_DRAW_ITEM_FUNC * pfDrawItem);
Nvoid             ICONVIEW_SetSel                  (ICONVIEW_Handle hObj, int Sel);
Nvoid             ICONVIEW_SetSpace                (ICONVIEW_Handle hObj, int Coord, int Value);
Nint              ICONVIEW_SetStreamedBitmapItem   (ICONVIEW_Handle hObj, int Index, const void * pStreamedBitmap);
Nvoid             ICONVIEW_SetIconAlign            (ICONVIEW_Handle hObj, int IconAlign);
Nvoid             ICONVIEW_SetTextAlign            (ICONVIEW_Handle hObj, int TextAlign);
Nvoid             ICONVIEW_SetTextColor            (ICONVIEW_Handle hObj, int Index, GUI_COLOR Color);
Nint              ICONVIEW_SetUserData             (ICONVIEW_Handle hObj, const void * pSrc, int NumBytes);
Nvoid             ICONVIEW_SetWrapMode             (ICONVIEW_Handle hObj, GUI_WRAPMODE WrapMode);
N
Nvoid             ICONVIEW_Callback                (WM_MESSAGE * pMsg);
N
N//
N// Compatibility macro
N//
N#define ICONVIEW_EnableStreamAuto() GUI_DrawStreamedEnableAuto()
N
N#if defined(__cplusplus)
X#if 0L
S  }
N#endif
N
N#endif  // GUI_WINSUPPORT
N#endif  // ICONVIEW_H
N
N/*************************** End of file ****************************/
L 62 "..\..\..\..\ThirdParty\emWin\Include\DIALOG.h" 2
N#include "IMAGE.h"
L 1 "..\..\..\..\ThirdParty\emWin\Include\IMAGE.h" 1
N/*********************************************************************
N*                    SEGGER Microcontroller GmbH                     *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2023  SEGGER Microcontroller GmbH                *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V6.46 - Graphical user interface for embedded applications **
NemWin is protected by international copyright laws. Knowledge of the
Nsource code may not be used to write a similar product. 
NThis file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed by SEGGER Software GmbH to Nuvoton Technology Corporation
Nat the address: No. 4, Creation Rd. III, Hsinchu Science Park, Taiwan
Nfor the purposes  of  creating  libraries  for its 
NArm Cortex-A, Arm Cortex-M and  Arm9 32-bit microcontrollers, commercialized and distributed by Nuvoton Technology Corporation
Nunder  the terms and conditions  of  an  End  User  
NLicense  Agreement  supplied  with  the libraries.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NLicensing information
NLicensor:                 SEGGER Software GmbH
NLicensed to:              Nuvoton Technology Corporation, No. 4, Creation Rd. III, Hsinchu Science Park, 30077 Hsinchu City, Taiwan
NLicensed SEGGER software: emWin
NLicense number:           GUI-00735
NLicense model:            emWin License Agreement, signed February 27, 2018
NLicensed platform:        Cortex-M, Cortex-A, and ARM9 32-bit series microcontroller designed and manufactured by Nuvoton Technology Corporation.
N----------------------------------------------------------------------
NSupport and Update Agreement (SUA)
NSUA period:               2018-03-26 - 2025-09-04
NContact to extend SUA:    sales@segger.com
N----------------------------------------------------------------------
NFile        : IMAGE.h
NPurpose     : Image include
N--------------------END-OF-HEADER-------------------------------------
N*/
N
N#ifndef IMAGE_H
N#define IMAGE_H
N
N#include "WM.h"
N#include "DIALOG_Type.h"
N#include "WIDGET.h"
N
N#if GUI_WINSUPPORT
X#if 1
N
N#if defined(__cplusplus)
X#if 0L
S  extern "C" { // Make sure we have C-declarations in C++ programs
N#endif
N
N/*********************************************************************
N*
N*       Defines
N*
N**********************************************************************
N*/
N/*********************************************************************
N*
N*       IMAGE create flags
N*
N*  Description
N*    Create flags for the IMAGE widget. These flags can be passed to ICONVIEW_CreateEx() via the
N*    \a{ExFlags} parameter.
N*/
N#define IMAGE_CF_MEMDEV   (1 << 0)      // Makes the IMAGE widget use an internal Memory Device for
N                                        // drawing. Contrary to the Memory Device which is created
N                                        // by the Window Manager's automatic use of Memory Devices
N                                        // (WM_CF_MEMDEV), this device stays valid all the time. It has to be
N                                        // ensured that the emWin memory pool which is defined by the
N                                        // function GUI_ALLOC_AssignMemory() (in \c{GUIConf.c}), is big enough
N                                        // to store the complete data. If the Memory Device can not be created,
N                                        // the image is drawn directly. This might possibly mean loss
N                                        // of performance.
N#define IMAGE_CF_TILE     (1 << 1)      // Uses tiling to fill up the whole area of the widget.
N#define IMAGE_CF_ALPHA    (1 << 2)      // Needs to be set if alpha blending is required (PNG).
N#define IMAGE_CF_ATTACHED (1 << 3)      // Widget size is fixed to the parent border.
N#define IMAGE_CF_AUTOSIZE (1 << 4)      // Widget size is taken from the attached image.
N#define IMAGE_CF_LQ       (1 << 5)      // Fast mode (lower quality) should be used for rotating/scaling.
N
N/*********************************************************************
N*
N*       Types
N*
N**********************************************************************
N*/
Ntypedef WM_HMEM IMAGE_Handle;
Xtypedef signed long IMAGE_Handle;
N
N/*********************************************************************
N*
N*       Public functions
N*
N**********************************************************************
N*/
NIMAGE_Handle IMAGE_CreateEx      (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int ExFlags, int Id);
XIMAGE_Handle IMAGE_CreateEx      (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int WinFlags, int ExFlags, int Id);
NIMAGE_Handle IMAGE_CreateUser    (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int ExFlags, int Id, int NumExtraBytes);
XIMAGE_Handle IMAGE_CreateUser    (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int WinFlags, int ExFlags, int Id, int NumExtraBytes);
NIMAGE_Handle IMAGE_CreateIndirect(const GUI_WIDGET_CREATE_INFO * pCreateInfo, WM_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
XIMAGE_Handle IMAGE_CreateIndirect(const GUI_WIDGET_CREATE_INFO * pCreateInfo, GUI_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
N
Nvoid IMAGE_Callback(WM_MESSAGE * pMsg);
N
N/*********************************************************************
N*
N*       Member functions
N*
N**********************************************************************
N*/
Nint  IMAGE_GetImageSize(IMAGE_Handle hObj, int * pxSize, int * pySize);
Nint  IMAGE_GetUserData (IMAGE_Handle hObj, void * pDest, int NumBytes);
Nvoid IMAGE_SetBitmap   (IMAGE_Handle hWin, const GUI_BITMAP * pBitmap);
Nvoid IMAGE_SetBMP      (IMAGE_Handle hObj, const void * pData, U32 FileSize);
Xvoid IMAGE_SetBMP      (IMAGE_Handle hObj, const void * pData, unsigned long FileSize);
Nvoid IMAGE_SetBMPEx    (IMAGE_Handle hObj, GUI_BMP_GET_DATA_FUNC * pfGetData, void * pVoid);
Nvoid IMAGE_SetDTA      (IMAGE_Handle hObj, const void * pData, U32 FileSize);
Xvoid IMAGE_SetDTA      (IMAGE_Handle hObj, const void * pData, unsigned long FileSize);
Nvoid IMAGE_SetDTAEx    (IMAGE_Handle hObj, GUI_DTA_GET_DATA_FUNC * pfGetData, void * pVoid);
Nvoid IMAGE_SetGIF      (IMAGE_Handle hObj, const void * pData, U32 FileSize);
Xvoid IMAGE_SetGIF      (IMAGE_Handle hObj, const void * pData, unsigned long FileSize);
Nvoid IMAGE_SetGIFEx    (IMAGE_Handle hObj, GUI_GIF_GET_DATA_FUNC * pfGetData, void * pVoid);
Nvoid IMAGE_SetJPEG     (IMAGE_Handle hObj, const void * pData, U32 FileSize);
Xvoid IMAGE_SetJPEG     (IMAGE_Handle hObj, const void * pData, unsigned long FileSize);
Nvoid IMAGE_SetJPEGEx   (IMAGE_Handle hObj, GUI_JPEG_GET_DATA_FUNC * pfGetData, void * pVoid);
Nvoid IMAGE_SetPNG      (IMAGE_Handle hObj, const void * pData, U32 FileSize);
Xvoid IMAGE_SetPNG      (IMAGE_Handle hObj, const void * pData, unsigned long FileSize);
Nvoid IMAGE_SetPNGEx    (IMAGE_Handle hObj, GUI_PNG_GET_DATA_FUNC * pfGetData, void * pVoid);
Nvoid IMAGE_SetTiled    (IMAGE_Handle hObj, int OnOff);
Nint  IMAGE_SetUserData (IMAGE_Handle hObj, const void * pSrc, int NumBytes);
Nvoid IMAGE_SetAlign    (IMAGE_Handle hObj, int Align);
Nvoid IMAGE_SetOffset   (IMAGE_Handle hObj, int xOff, int yOff);
Nvoid IMAGE_SetBkColor  (IMAGE_Handle hObj, GUI_COLOR BkColor);
N
N#if GUI_SUPPORT_MEMDEV
X#if 1
NU8   IMAGE_SetAlpha    (IMAGE_Handle hObj, U8 Alpha);
Xunsigned char   IMAGE_SetAlpha    (IMAGE_Handle hObj, unsigned char Alpha);
Nint  IMAGE_SetAngle    (IMAGE_Handle hObj, unsigned Angle);
Nvoid IMAGE_EnableLQ    (IMAGE_Handle hObj, int OnOff);
Nint  IMAGE_SetScale    (IMAGE_Handle hObj, unsigned Scale);
N#endif
N
N#if defined(__cplusplus)
X#if 0L
S  }
N#endif
N
N#endif // GUI_WINSUPPORT
N#endif // IMAGE_H
N
N/*************************** End of file ****************************/
L 63 "..\..\..\..\ThirdParty\emWin\Include\DIALOG.h" 2
N#include "KEYBOARD.h"
L 1 "..\..\..\..\ThirdParty\emWin\Include\KEYBOARD.h" 1
N/*********************************************************************
N*                    SEGGER Microcontroller GmbH                     *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2023  SEGGER Microcontroller GmbH                *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V6.46 - Graphical user interface for embedded applications **
NemWin is protected by international copyright laws. Knowledge of the
Nsource code may not be used to write a similar product. 
NThis file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed by SEGGER Software GmbH to Nuvoton Technology Corporation
Nat the address: No. 4, Creation Rd. III, Hsinchu Science Park, Taiwan
Nfor the purposes  of  creating  libraries  for its 
NArm Cortex-A, Arm Cortex-M and  Arm9 32-bit microcontrollers, commercialized and distributed by Nuvoton Technology Corporation
Nunder  the terms and conditions  of  an  End  User  
NLicense  Agreement  supplied  with  the libraries.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NLicensing information
NLicensor:                 SEGGER Software GmbH
NLicensed to:              Nuvoton Technology Corporation, No. 4, Creation Rd. III, Hsinchu Science Park, 30077 Hsinchu City, Taiwan
NLicensed SEGGER software: emWin
NLicense number:           GUI-00735
NLicense model:            emWin License Agreement, signed February 27, 2018
NLicensed platform:        Cortex-M, Cortex-A, and ARM9 32-bit series microcontroller designed and manufactured by Nuvoton Technology Corporation.
N----------------------------------------------------------------------
NSupport and Update Agreement (SUA)
NSUA period:               2018-03-26 - 2025-09-04
NContact to extend SUA:    sales@segger.com
N----------------------------------------------------------------------
NFile        : KEYBOARD.h
NPurpose     : KEYBOARD public header file (API)
N--------------------END-OF-HEADER-------------------------------------
N*/
N
N#ifndef KEYBOARD_H
N#define KEYBOARD_H
N
N#include "WM.h"
N#include "DIALOG_Type.h"      /* Req. for Create indirect data structure */
N#include "WIDGET.h"
N
N#if GUI_WINSUPPORT
X#if 1
N
N#if defined(__cplusplus)
X#if 0L
S  extern "C" {     /* Make sure we have C-declarations in C++ programs */
N#endif
N
N/*********************************************************************
N*
N*       KEYBOARD color indexes
N*
N*  Description
N*    Color indices for KEYBOARD widget.
N*/
N#define KEYBOARD_CI_KEY     0    // Color of key.
N#define KEYBOARD_CI_FKEY    1    // Color of function key, such as shift.
N#define KEYBOARD_CI_PRESSED 2    // Pressed color of a key.
N#define KEYBOARD_CI_CODE    3    // Text color of character on a key.
N#define KEYBOARD_CI_LONG    4    // Text color of long press character on a key.
N#define KEYBOARD_CI_BK      5    // Background color of widget.
N#define KEYBOARD_CI_MARK    6    // Color of shift-lock symbol.
N
N/*********************************************************************
N*
N*       KEYBOARD font indexes
N*
N*  Description
N*    Font indexes for KEYBOARD widget.
N*/
N#define KEYBOARD_FI_CODE 0       // Font used for text displayed on a key.
N#define KEYBOARD_FI_LONG 1       // Font used for smaller long press characters displayed on a key.
N
N/*********************************************************************
N*
N*       KEYBOARD period indexes
N*
N*  Description
N*    Period indices for KEYBOARD widget.
N*/
N#define KEYBOARD_PI_LONGPRESS 0  // Period it takes for a long press to open the long press dialog.
N#define KEYBOARD_PI_REPEAT    1  // Period for repeated actions, such as holding the backspace key.
N
N/*********************************************************************
N*
N*       States of shift key
N*/
N#define KEYBOARD_STATE_CODES 0
N#define KEYBOARD_STATE_SHIFT 1
N#define KEYBOARD_STATE_SLOCK 2
N#define KEYBOARD_STATE_EXTRA 3
N
N/*********************************************************************
N*
N*       Types
N*
N**********************************************************************
N*/
Ntypedef WM_HMEM KEYBOARD_Handle;
Xtypedef signed long KEYBOARD_Handle;
N
N/*********************************************************************
N*
N*       KEYBOARD_CODES
N*
N*  Description
N*    Structure that is used for storing pointers to arrays of long press characters.
N*/
Ntypedef struct {
N        unsigned   NumCodes;            // Number of characters.
N  const U16      * pCodes;              // Pointer to an array of character codes.
X  const unsigned short      * pCodes;              
N} KEYBOARD_CODES;
N
N/*********************************************************************
N*
N*       KEYDEF_AREA
N*
N*  Description
N*    This structure is used to define the position and size of keys on
N*    the keyboard.
N*
N*  Additional information
N*    All positions and sizes are entered in promille. This way, the sizes
N*    and positions are relative to the keyboard's window size.
N*
N*    For example, if the width of a key line is defined as 1000, that means the line will span
N*    over the entire keyboard widget, since 1000\promille  \preserve{equals} 100%.
N*    If the keyboard widget has an x-size of 400 px, the line will also have an
N*    x-size of 400.
N*/
Ntypedef struct {
N  unsigned x;                           // X-position.
N  unsigned y;                           // Y-position.
N  unsigned w;                           // Width.
N  unsigned h;                           // Height.
N} KEYDEF_AREA;
N
N/*********************************************************************
N*
N*       KEYDEF_LINE
N*
N*  Description
N*    Structure that defines one line of characters of a keyboard.
N*
N*  Additional information
N*    The given key codes defined in Codes are spread equally and horizontally
N*    over the area defined in the member Area.
N*/
Ntypedef struct {
N        KEYDEF_AREA      Area;          // Data structure of type KEYDEF_AREA that defines position and size of the line.
N        KEYBOARD_CODES   Codes;         // Data structure of type KEYBOARD_CODES that hold the character codes to be used for the line.
N  const KEYBOARD_CODES * pCodesLong;    // Pointer to an array of the type KEYBOARD_CODES that holds the character codes for long press. \n
N                                        // \b{Note:} The number of elements in the array \b{must} be equal to the number of codes defined
N                                        // in the previous member Codes.
N} KEYDEF_LINE;
N
N/*********************************************************************
N*
N*       KEYDEF_BUTTON
N*
N*  Description
N*    Structure that holds information about how a key should look like. This structure is
N*    used by KEYDEF_KEY, KEYDEF_SHIFT and KEYDEF_SWITCH.
N*
N*  Additional information
N*    The streamed bitmap should ideally contain a compressed alpha channel (type: "Alpha channel,
N*    compressed). This is necessary so the given shift color can be applied to the key bitmap.
N*/
Ntypedef struct {
N  const char * pText;                   // Pointer to text shown for the key.
N  const void * pBm;                     // Pointer to streamed bitmap shown for the key.
N  U32          Size;                    // Array size of streamed bitmap.
X  unsigned long          Size;                    
N} KEYDEF_BUTTON;
N
N/*********************************************************************
N*
N*       KEYDEF_KEY
N*
N*  Description
N*    Structure that defines a single key to be used in a keyboard.
N*/
Ntypedef struct {
N  const KEYDEF_AREA   Area;             // Pointer to data structure of type KEYDEF_AREA that defines the
N                                        // position and size of the key.
N        U16           Code;             // Character code that is inserted when the key is pressed.
X        unsigned short           Code;             
N  const KEYDEF_BUTTON Button;           // Pointer to data structure of type KEYDEF_BUTTON that defines
N                                        // the appearance of the key.
N} KEYDEF_KEY;
N
N/*********************************************************************
N*
N*       KEYDEF_SHIFT
N*
N*  Description
N*    Configuration structure to define a shift key for the keyboard.
N*    A shift key is used to switch between lower and upper case letters.
N*/
Ntypedef struct {
N  const KEYDEF_AREA   Area;             // Data structure of type KEYDEF_AREA that defines position and size of the shift key.
N  const KEYDEF_BUTTON aButton[4];       // Array of type KEYDEF_BUTTON that holds the definition of appearance of four states. The four states
N                                        // are: normal, shift, shift locked and extra.
N} KEYDEF_SHIFT;
N
N/*********************************************************************
N*
N*       KEYDEF_SWITCH
N*
N*  Description
N*    Configuration structure to define a switch key for the keyboard.
N*    A switch key is used to switch between different lines of characters,
N*    mostly used for switching between letters and special characters.
N*/
Ntypedef struct {
N  const KEYDEF_AREA   Area;             // Data structure of type KEYDEF_AREA that defines position and size of the switch key.
N  const KEYDEF_BUTTON aButton[2];       // Array of type KEYDEF_BUTTON that holds the appearance definition for pressed and unpressed state.
N} KEYDEF_SWITCH;
N
N/*********************************************************************
N*
N*       KEYDEF_KEYBOARD
N*
N*  Description
N*    Configuration structure to define the entire layout of a KEYBOARD
N*    widget. A pointer to a filled structure of this type can be passed
N*    to KEYBOARD_SetLayout() or KEYBOARD_CreateUser().
N*
N*    If any keyboard components are not needed for the layout, such as certain keys
N*    or shift lines etc., NULL can be passed instead.
N*/
Ntypedef struct {
N  const char          * pLongName;      // Name of the layout. The name is only used by AppWizard, therefore the pointer can be NULL.
N  const KEYDEF_KEY    * pDefBackspace;  // Pointer to key definition of backspace key.
N  const KEYDEF_KEY    * pDefEnter;      // Pointer to key definition of enter key.
N  const KEYDEF_KEY    * pDefSpace;      // Pointer to key definition of space key.
N  const KEYDEF_SHIFT  * pDefShift;      // Pointer to the definition structure of the shift key.
N  const KEYDEF_SWITCH * pDefSwitch;     // Pointer to the definition structure of the switch key.
N        unsigned        NumFixedLines;  // Number of fixed lines of characters in the keyboard that will not be affected by the shift or switch key.
N        unsigned        NumCodesLines;  // Number of lines of characters in the keyboard that are shown when neither shift nor switch has been pressed.
N        unsigned        NumShiftLines;  // Number of lines of characters to be shown when the shift key has been pressed.
N        unsigned        NumExtraLines;  // Number of lines of characters to be shown when the switch key has been pressed.
N  const KEYDEF_LINE  ** ppLineFixed;    // Pointer to an array of definition structures for the fixed lines of characters.
N  const KEYDEF_LINE  ** ppLineCodes;    // Pointer to an array of definition structures for the lines shown by default.
N  const KEYDEF_LINE  ** ppLineShift;    // Pointer to an array of definition structures for the lines shown when the shift key is pressed.
N  const KEYDEF_LINE  ** ppLineExtra;    // Pointer to an array of definition structures for the lines shown when the switch key is pressed.
N        unsigned        wLong;          // Width of a long press key in the long press dialog. The size is specified in promille and relative to the KEYBOARD widget's size.
N        unsigned        hLong;          // Height of a long press key in the long press dialog. The size is specified in promille and relative to the KEYBOARD widget's size.
N} KEYDEF_KEYBOARD;
N
N/*********************************************************************
N*
N*       Create function(s)
N
N  Note: the parameters to a create function may vary.
N         Some widgets may have multiple create functions
N*/
NKEYBOARD_Handle KEYBOARD_CreateUser    (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int ExFlags, const KEYDEF_KEYBOARD * pKeyboard, int Id, int NumExtraBytes);
XKEYBOARD_Handle KEYBOARD_CreateUser    (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int WinFlags, int ExFlags, const KEYDEF_KEYBOARD * pKeyboard, int Id, int NumExtraBytes);
NKEYBOARD_Handle KEYBOARD_CreateIndirect(const GUI_WIDGET_CREATE_INFO * pCreateInfo, WM_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
XKEYBOARD_Handle KEYBOARD_CreateIndirect(const GUI_WIDGET_CREATE_INFO * pCreateInfo, GUI_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
N
N/*********************************************************************
N*
N*       The callback ...
N*
N* Do not call it directly ! It is only to be used from within an
N* overwritten callback.
N*/
Nvoid KEYBOARD_Callback(WM_MESSAGE *pMsg);
N
N/*********************************************************************
N*
N*       Member functions
N*
N**********************************************************************
N*/
Nvoid KEYBOARD_ExportLayout     (GUI_CALLBACK_VOID_U8_P * pfSerialize, void * pVoid, const KEYDEF_KEYBOARD * pKeyboard);
Nvoid KEYBOARD_ExportPatternFile(GUI_CALLBACK_VOID_U8_P * pfSerialize, void * pVoid, const KEYDEF_KEYBOARD * pKeyboard);
Nint  KEYBOARD_GetKeyRect       (KEYBOARD_Handle hObj, GUI_RECT * pRect, U32 cKey);
Xint  KEYBOARD_GetKeyRect       (KEYBOARD_Handle hObj, GUI_RECT * pRect, unsigned long cKey);
Nvoid KEYBOARD_LockShiftState   (KEYBOARD_Handle hObj, unsigned OnOff);
Nvoid KEYBOARD_SetColor         (KEYBOARD_Handle hObj, unsigned Index, GUI_COLOR Color);
Nvoid KEYBOARD_SetFont          (KEYBOARD_Handle hObj, unsigned Index, const GUI_FONT * pFont);
Nint  KEYBOARD_SetLayout        (KEYBOARD_Handle hObj, const KEYDEF_KEYBOARD * pKeyboard);
Nvoid KEYBOARD_SetPeriod        (KEYBOARD_Handle hObj, unsigned Index, unsigned Period);
Nvoid KEYBOARD_SetRadius        (KEYBOARD_Handle hObj, unsigned Radius);
Nvoid KEYBOARD_SetSpace         (KEYBOARD_Handle hObj, unsigned Axis, unsigned Space);
Nvoid KEYBOARD_SetSensy         (KEYBOARD_Handle hObj, unsigned Sensy);
Nint  KEYBOARD_SetStreamedLayout(KEYBOARD_Handle hObj, const void * pVoid, U32 Size);
Xint  KEYBOARD_SetStreamedLayout(KEYBOARD_Handle hObj, const void * pVoid, unsigned long Size);
Nvoid KEYBOARD_SetShiftState    (KEYBOARD_Handle hObj, unsigned State);
N
N/*********************************************************************
N*
N*       Managing default values
N*
N**********************************************************************
N*/
NGUI_COLOR KEYBOARD_GetDefaultColor    (unsigned Index);
Nint       KEYBOARD_GetDefaultFrameSize(void);
Nunsigned  KEYBOARD_GetDefaultPeriod   (unsigned Index);
Nint       KEYBOARD_GetDefaultRadius   (void);
Nint       KEYBOARD_GetDefaultSpace    (unsigned Axis);
Nunsigned  KEYBOARD_GetDefaultSensy    (void);
Nvoid      KEYBOARD_SetDefaultColor    (unsigned Index, GUI_COLOR Color);
Nvoid      KEYBOARD_SetDefaultFrameSize(int FrameSize);
Nvoid      KEYBOARD_SetDefaultPeriod   (unsigned Index, unsigned Period);
Nvoid      KEYBOARD_SetDefaultRadius   (int Radius);
Nvoid      KEYBOARD_SetDefaultSpace    (unsigned Axis, int Space);
Nvoid      KEYBOARD_SetDefaultSensy    (unsigned Sensy);
N
N/*********************************************************************
N*
N*       Predefined keyboard layout(s)
N*
N**********************************************************************
N*/
Nextern const KEYDEF_KEYBOARD KEYBOARD_ARA;
Nextern const KEYDEF_KEYBOARD KEYBOARD_DEU;
Nextern const KEYDEF_KEYBOARD KEYBOARD_DEU_LP;
Nextern const KEYDEF_KEYBOARD KEYBOARD_ENG;
Nextern const KEYDEF_KEYBOARD KEYBOARD_ENG_LP;
Nextern const KEYDEF_KEYBOARD KEYBOARD_FRA_LP;
Nextern const KEYDEF_KEYBOARD KEYBOARD_RUS;
Nextern const KEYDEF_KEYBOARD KEYBOARD_NUMPAD;
N
N#if defined(__cplusplus)
X#if 0L
S  }
N#endif
N
N#endif  // GUI_WINSUPPORT
N#endif  // KEYBOARD_H
L 64 "..\..\..\..\ThirdParty\emWin\Include\DIALOG.h" 2
N#include "KNOB.h"
L 1 "..\..\..\..\ThirdParty\emWin\Include\KNOB.h" 1
N/*********************************************************************
N*                    SEGGER Microcontroller GmbH                     *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2023  SEGGER Microcontroller GmbH                *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V6.46 - Graphical user interface for embedded applications **
NemWin is protected by international copyright laws. Knowledge of the
Nsource code may not be used to write a similar product. 
NThis file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed by SEGGER Software GmbH to Nuvoton Technology Corporation
Nat the address: No. 4, Creation Rd. III, Hsinchu Science Park, Taiwan
Nfor the purposes  of  creating  libraries  for its 
NArm Cortex-A, Arm Cortex-M and  Arm9 32-bit microcontrollers, commercialized and distributed by Nuvoton Technology Corporation
Nunder  the terms and conditions  of  an  End  User  
NLicense  Agreement  supplied  with  the libraries.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NLicensing information
NLicensor:                 SEGGER Software GmbH
NLicensed to:              Nuvoton Technology Corporation, No. 4, Creation Rd. III, Hsinchu Science Park, 30077 Hsinchu City, Taiwan
NLicensed SEGGER software: emWin
NLicense number:           GUI-00735
NLicense model:            emWin License Agreement, signed February 27, 2018
NLicensed platform:        Cortex-M, Cortex-A, and ARM9 32-bit series microcontroller designed and manufactured by Nuvoton Technology Corporation.
N----------------------------------------------------------------------
NSupport and Update Agreement (SUA)
NSUA period:               2018-03-26 - 2025-09-04
NContact to extend SUA:    sales@segger.com
N----------------------------------------------------------------------
NFile        : KNOB.h
NPurpose     : KNOB include
N--------------------END-OF-HEADER-------------------------------------
N*/
N
N#ifndef KNOB_H
N#define KNOB_H
N
N#include "WM.h"
N#include "DIALOG_Type.h"      // Req. for Create indirect data structure
N#include "WIDGET.h"
N#include "GUI_Debug.h"
N
N#if (GUI_SUPPORT_MEMDEV && GUI_WINSUPPORT)
X#if (1 && 1)
N
N#if defined(__cplusplus)
X#if 0L
S  extern "C" {                  // Make sure we have C-declarations in C++ programs
N#endif
N
N/*********************************************************************
N*
N*       Public Types
N*
N**********************************************************************
N*/
Ntypedef WM_HMEM KNOB_Handle;
Xtypedef signed long KNOB_Handle;
N
N/*********************************************************************
N*
N*       Create functions
N*
N**********************************************************************
N*/
NKNOB_Handle KNOB_CreateEx      (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int Id);
XKNOB_Handle KNOB_CreateEx      (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int WinFlags, int Id);
NKNOB_Handle KNOB_CreateUser    (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int Id, int NumExtraBytes);
XKNOB_Handle KNOB_CreateUser    (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int WinFlags, int Id, int NumExtraBytes);
NKNOB_Handle KNOB_CreateIndirect(const GUI_WIDGET_CREATE_INFO * pCreateInfo, WM_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
XKNOB_Handle KNOB_CreateIndirect(const GUI_WIDGET_CREATE_INFO * pCreateInfo, GUI_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
N
N/*********************************************************************
N*
N*       The callback ...
N*
N* Do not call it directly ! It is only to be used from within an
N* overwritten callback.
N*/
Nvoid KNOB_Callback(WM_MESSAGE * pMsg);
N
N/*********************************************************************
N*
N*       Member functions
N*
N**********************************************************************
N*/
Nvoid KNOB_AddValue     (KNOB_Handle hObj, I32 Value);
Xvoid KNOB_AddValue     (KNOB_Handle hObj, signed long Value);
Nint  KNOB_GetUserData  (KNOB_Handle hObj, void * pDest, int NumBytes);               // Gets user defined data
NI32  KNOB_GetValue     (KNOB_Handle hObj);                                           // Returns the position of the knob in tenth of degree
Xsigned long  KNOB_GetValue     (KNOB_Handle hObj);                                           
Nint  KNOB_OwnerDraw    (const WIDGET_ITEM_DRAW_INFO * pDrawItemInfo);
Nvoid KNOB_SetBkColor   (KNOB_Handle hObj, GUI_COLOR Color);                          // Sets the BK color of the widget
Nvoid KNOB_SetBkDevice  (KNOB_Handle hObj, GUI_MEMDEV_Handle hMemBk);                 // Sets the background device
Nvoid KNOB_SetDevice    (KNOB_Handle hObj, GUI_MEMDEV_Handle hMemSrc);                // Sets the memory device with the drawn knob
Nvoid KNOB_SetInvert    (KNOB_Handle hObj, U8 Invert);                                // Inverts value of the knob widget
Xvoid KNOB_SetInvert    (KNOB_Handle hObj, unsigned char Invert);                                
Nvoid KNOB_SetKeyValue  (KNOB_Handle hObj, I32 KeyValue);                             // Sets the value the knob will rotate on one key press
Xvoid KNOB_SetKeyValue  (KNOB_Handle hObj, signed long KeyValue);                             
Nvoid KNOB_SetOffset    (KNOB_Handle hObj, I32 Offset);                               // Sets the offset angle of the knob
Xvoid KNOB_SetOffset    (KNOB_Handle hObj, signed long Offset);                               
Nvoid KNOB_SetOwnerDraw (KNOB_Handle hObj, WIDGET_DRAW_ITEM_FUNC * pfOwnerDraw);
Nvoid KNOB_SetPeriod    (KNOB_Handle hObj, I32 Period);                               // Sets the period in which the knob stops
Xvoid KNOB_SetPeriod    (KNOB_Handle hObj, signed long Period);                               
Nvoid KNOB_SetPos       (KNOB_Handle hObj, I32 Pos);                                  // Sets position of the knob in tenth of degree
Xvoid KNOB_SetPos       (KNOB_Handle hObj, signed long Pos);                                  
Nvoid KNOB_SetRange     (KNOB_Handle hObj, I32 MinRange, I32 MaxRange);               // Sets the usable range of the knob widget
Xvoid KNOB_SetRange     (KNOB_Handle hObj, signed long MinRange, signed long MaxRange);               
Nvoid KNOB_SetSnap      (KNOB_Handle hObj, I32 Snap);                                 // Sets Snap positions where the knob stops
Xvoid KNOB_SetSnap      (KNOB_Handle hObj, signed long Snap);                                 
Nvoid KNOB_SetRotateHQ  (KNOB_Handle hObj);
Nvoid KNOB_SetRotateLQ  (KNOB_Handle hObj);
Nvoid KNOB_SetTickSize  (KNOB_Handle hObj, I32 TickSize);                             // Sets the ticksize, in 1/10 of degree
Xvoid KNOB_SetTickSize  (KNOB_Handle hObj, signed long TickSize);                             
Nint  KNOB_SetUserData  (KNOB_Handle hObj, const void * pSrc, int NumBytes);          // Sets user defined data
Nvoid KNOB_SetValueRange(KNOB_Handle hObj, I32 Min, I32 Max);
Xvoid KNOB_SetValueRange(KNOB_Handle hObj, signed long Min, signed long Max);
N
N/*********************************************************************
N*
N*       Global functions
N*
N**********************************************************************
N*/
N
N#if defined(__cplusplus)
X#if 0L
S  }
N#endif
N
N#endif  // (GUI_SUPPORT_MEMDEV && GUI_WINSUPPORT)
N#endif  // KNOB_H
N
N/*************************** End of file ****************************/
L 65 "..\..\..\..\ThirdParty\emWin\Include\DIALOG.h" 2
N#include "LISTBOX.h"
N#include "LISTVIEW.h"
L 1 "..\..\..\..\ThirdParty\emWin\Include\LISTVIEW.h" 1
N/*********************************************************************
N*                    SEGGER Microcontroller GmbH                     *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2023  SEGGER Microcontroller GmbH                *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V6.46 - Graphical user interface for embedded applications **
NemWin is protected by international copyright laws. Knowledge of the
Nsource code may not be used to write a similar product. 
NThis file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed by SEGGER Software GmbH to Nuvoton Technology Corporation
Nat the address: No. 4, Creation Rd. III, Hsinchu Science Park, Taiwan
Nfor the purposes  of  creating  libraries  for its 
NArm Cortex-A, Arm Cortex-M and  Arm9 32-bit microcontrollers, commercialized and distributed by Nuvoton Technology Corporation
Nunder  the terms and conditions  of  an  End  User  
NLicense  Agreement  supplied  with  the libraries.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NLicensing information
NLicensor:                 SEGGER Software GmbH
NLicensed to:              Nuvoton Technology Corporation, No. 4, Creation Rd. III, Hsinchu Science Park, 30077 Hsinchu City, Taiwan
NLicensed SEGGER software: emWin
NLicense number:           GUI-00735
NLicense model:            emWin License Agreement, signed February 27, 2018
NLicensed platform:        Cortex-M, Cortex-A, and ARM9 32-bit series microcontroller designed and manufactured by Nuvoton Technology Corporation.
N----------------------------------------------------------------------
NSupport and Update Agreement (SUA)
NSUA period:               2018-03-26 - 2025-09-04
NContact to extend SUA:    sales@segger.com
N----------------------------------------------------------------------
NFile        : LISTVIEW.h
NPurpose     : LISTVIEW include
N--------------------END-OF-HEADER-------------------------------------
N*/
N
N#ifndef LISTVIEW_H
N#define LISTVIEW_H
N
N#include "WM.h"
N#include "DIALOG_Type.h"      // Req. for Create indirect data structure
N#include "ICONVIEW.h"
N#include "HEADER.h"
N
N#if GUI_WINSUPPORT
X#if 1
N
N#if defined(__cplusplus)
X#if 0L
S  extern "C" {     /* Make sure we have C-declarations in C++ programs */
N#endif
N
N/*********************************************************************
N*
N*       Defines
N*/
N#define LISTVIEW_ALL_ITEMS  -1
N
N/*********************************************************************
N*
N*       LISTVIEW color indexes
N*
N*  Description
N*    Color indexes to be used by the LISTVIEW widget.
N*/
N#define LISTVIEW_CI_UNSEL       0      // Unselected element.
N#define LISTVIEW_CI_SEL         1      // Selected element, without focus.
N#define LISTVIEW_CI_SELFOCUS    2      // Selected element, with focus.
N#define LISTVIEW_CI_DISABLED    3      // Disabled element.
N
N/************************************************************
N*
N*       Create / Status flags
N*/
N#define LISTVIEW_CF_AUTOSCROLLBAR_H   (1 << 0)
N#define LISTVIEW_CF_AUTOSCROLLBAR_V   (1 << 1)
N#define LISTVIEW_CF_CELL_SELECT       (1 << 2)                     // Create Flag used to enable cell selection
N#define LISTVIEW_CF_MOTION_H          (1 << 3)
N#define LISTVIEW_CF_MOTION_V          (1 << 4)
N#define LISTVIEW_CF_USE_COPY          (1 << 5)
N#define LISTVIEW_SF_AUTOSCROLLBAR_H   LISTVIEW_CF_AUTOSCROLLBAR_H
N#define LISTVIEW_SF_AUTOSCROLLBAR_V   LISTVIEW_CF_AUTOSCROLLBAR_V
N
N/*********************************************************************
N*
N*       Public Types
N*
N**********************************************************************
N*/
Ntypedef WM_HMEM LISTVIEW_Handle;
Xtypedef signed long LISTVIEW_Handle;
N
N/*********************************************************************
N*
N*       Create functions
N*
N**********************************************************************
N*/
NLISTVIEW_Handle LISTVIEW_Create        (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int Id, int Flags, int SpecialFlags);
XLISTVIEW_Handle LISTVIEW_Create        (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int Id, int Flags, int SpecialFlags);
NLISTVIEW_Handle LISTVIEW_CreateEx      (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int ExFlags, int Id);
XLISTVIEW_Handle LISTVIEW_CreateEx      (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int WinFlags, int ExFlags, int Id);
NLISTVIEW_Handle LISTVIEW_CreateUser    (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int ExFlags, int Id, int NumExtraBytes);
XLISTVIEW_Handle LISTVIEW_CreateUser    (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int WinFlags, int ExFlags, int Id, int NumExtraBytes);
NLISTVIEW_Handle LISTVIEW_CreateAttached(WM_HWIN hParent, int Id, int SpecialFlags);
XLISTVIEW_Handle LISTVIEW_CreateAttached(GUI_HWIN hParent, int Id, int SpecialFlags);
NLISTVIEW_Handle LISTVIEW_CreateIndirect(const GUI_WIDGET_CREATE_INFO * pCreateInfo, WM_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
XLISTVIEW_Handle LISTVIEW_CreateIndirect(const GUI_WIDGET_CREATE_INFO * pCreateInfo, GUI_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
N
N/*********************************************************************
N*
N*       The callback ...
N*
N* Do not call it directly ! It is only to be used from within an
N* overwritten callback.
N*/
Nvoid LISTVIEW_Callback(WM_MESSAGE * pMsg);
N
N/*********************************************************************
N*
N*       Member functions
N*
N**********************************************************************
N*/
Nint              LISTVIEW_AddColumn            (LISTVIEW_Handle hObj, int Width, const char * s, int Align);
Nint              LISTVIEW_AddRow               (LISTVIEW_Handle hObj, const GUI_ConstString * ppText);
Nvoid             LISTVIEW_Clear                (LISTVIEW_Handle hObj);
Nint              LISTVIEW_CompareText          (const void * p0, const void * p1);
Nint              LISTVIEW_CompareDec           (const void * p0, const void * p1);
Nvoid             LISTVIEW_DecSel               (LISTVIEW_Handle hObj);
Nvoid             LISTVIEW_DeleteAllRows        (LISTVIEW_Handle hObj);
Nvoid             LISTVIEW_DeleteColumn         (LISTVIEW_Handle hObj, unsigned Index);
Nvoid             LISTVIEW_DeleteRow            (LISTVIEW_Handle hObj, unsigned Index);
Nvoid             LISTVIEW_DeleteRowSorted      (LISTVIEW_Handle hObj, int Row);
Nvoid             LISTVIEW_DisableRow           (LISTVIEW_Handle hObj, unsigned Row);
Nvoid             LISTVIEW_DisableSort          (LISTVIEW_Handle hObj);
Nvoid             LISTVIEW_EnableCellSelect     (LISTVIEW_Handle hObj, unsigned OnOff);  // Enables/disables cell selection
Nvoid             LISTVIEW_EnableCopy           (LISTVIEW_Handle hObj, unsigned OnOff);
Nvoid             LISTVIEW_EnableMotion         (LISTVIEW_Handle hObj, int Flags);
Nvoid             LISTVIEW_EnableRow            (LISTVIEW_Handle hObj, unsigned Row);
Nvoid             LISTVIEW_EnableSort           (LISTVIEW_Handle hObj);
NGUI_COLOR        LISTVIEW_GetBkColor           (LISTVIEW_Handle hObj, unsigned Index);
Nint              LISTVIEW_GetCol               (LISTVIEW_Handle hObj, int xPos);
Nconst GUI_FONT * LISTVIEW_GetFont              (LISTVIEW_Handle hObj);
NGUI_COLOR        LISTVIEW_GetGridColor         (LISTVIEW_Handle hObj);
NHEADER_Handle    LISTVIEW_GetHeader            (LISTVIEW_Handle hObj);
Nvoid             LISTVIEW_GetItemRect          (LISTVIEW_Handle hObj, U32 Col, U32 Row, GUI_RECT * pRect);
Xvoid             LISTVIEW_GetItemRect          (LISTVIEW_Handle hObj, unsigned long Col, unsigned long Row, GUI_RECT * pRect);
Nvoid             LISTVIEW_GetItemText          (LISTVIEW_Handle hObj, unsigned Column, unsigned Row, char * pBuffer, unsigned MaxSize);
Nunsigned         LISTVIEW_GetItemTextLen       (LISTVIEW_Handle hObj, unsigned Column, unsigned Row);
Nvoid             LISTVIEW_GetItemTextSorted    (LISTVIEW_Handle hObj, unsigned Column, unsigned Row, char * pBuffer, unsigned MaxSize);
Nunsigned         LISTVIEW_GetLBorder           (LISTVIEW_Handle hObj);
Nunsigned         LISTVIEW_GetNumColumns        (LISTVIEW_Handle hObj);
Nunsigned         LISTVIEW_GetNumRows           (LISTVIEW_Handle hObj);
Nunsigned         LISTVIEW_GetOverlap           (LISTVIEW_Handle hObj, int * pPeriod, U8 * pFlags);
Xunsigned         LISTVIEW_GetOverlap           (LISTVIEW_Handle hObj, int * pPeriod, unsigned char * pFlags);
Nunsigned         LISTVIEW_GetRBorder           (LISTVIEW_Handle hObj);
Nint              LISTVIEW_GetRow               (LISTVIEW_Handle hObj, int yPos);
Nint              LISTVIEW_GetScrollStepH       (LISTVIEW_Handle hObj);
Nint              LISTVIEW_GetScrollPos         (LISTVIEW_Handle hObj, int Coord);
Nint              LISTVIEW_GetSel               (LISTVIEW_Handle hObj);
Nint              LISTVIEW_GetSelCol            (LISTVIEW_Handle hObj);
Nint              LISTVIEW_GetSelUnsorted       (LISTVIEW_Handle hObj);
Nint              LISTVIEW_GetTextAlign         (LISTVIEW_Handle hObj, unsigned ColIndex);
NGUI_COLOR        LISTVIEW_GetTextColor         (LISTVIEW_Handle hObj, unsigned Index);
Nint              LISTVIEW_GetUserData          (LISTVIEW_Handle hObj, void * pDest, int NumBytes);
NU32              LISTVIEW_GetUserDataRow       (LISTVIEW_Handle hObj, unsigned Row);
Xunsigned long              LISTVIEW_GetUserDataRow       (LISTVIEW_Handle hObj, unsigned Row);
Nint              LISTVIEW_GetVisRowIndices     (LISTVIEW_Handle hObj, int * pFirst, int * pLast);
NGUI_WRAPMODE     LISTVIEW_GetWrapMode          (LISTVIEW_Handle hObj);
Nvoid             LISTVIEW_IncSel               (LISTVIEW_Handle hObj);
Nint              LISTVIEW_InsertRow            (LISTVIEW_Handle hObj, unsigned Index, const GUI_ConstString * ppText);
Nint              LISTVIEW_IsRowPartiallyVisible(LISTVIEW_Handle hObj, unsigned Index);
Nint              LISTVIEW_OwnerDraw            (const WIDGET_ITEM_DRAW_INFO * pDrawItemInfo);
Nunsigned         LISTVIEW_RowIsDisabled        (LISTVIEW_Handle hObj, unsigned Row);
Nvoid             LISTVIEW_SetAutoScrollH       (LISTVIEW_Handle hObj, int OnOff);
Nvoid             LISTVIEW_SetAutoScrollV       (LISTVIEW_Handle hObj, int OnOff);
Nvoid             LISTVIEW_SetItemBitmap        (LISTVIEW_Handle hObj, unsigned Column, unsigned Row, int xOff, int yOff, const GUI_BITMAP * pBitmap);
Nvoid             LISTVIEW_SetBkColor           (LISTVIEW_Handle hObj, unsigned int Index, GUI_COLOR Color);
Nvoid             LISTVIEW_SetColumnWidth       (LISTVIEW_Handle hObj, unsigned int Index, int Width);
Nvoid             LISTVIEW_SetCompareFunc       (LISTVIEW_Handle hObj, unsigned Column, int (* fpCompare)(const void * p0, const void * p1));
Nunsigned         LISTVIEW_SetFixed             (LISTVIEW_Handle hObj, unsigned Fixed);
Nvoid             LISTVIEW_SetFont              (LISTVIEW_Handle hObj, const GUI_FONT * pFont);
Nvoid             LISTVIEW_SetGridColor         (LISTVIEW_Handle hObj, GUI_COLOR Color);
Nint              LISTVIEW_SetGridVis           (LISTVIEW_Handle hObj, int Show);
Nvoid             LISTVIEW_SetHeaderHeight      (LISTVIEW_Handle hObj, unsigned HeaderHeight);
Nvoid             LISTVIEW_SetItemBkColor       (LISTVIEW_Handle hObj, unsigned Column, unsigned Row, unsigned Index, GUI_COLOR Color);
Nvoid             LISTVIEW_SetItemText          (LISTVIEW_Handle hObj, unsigned Column, unsigned Row, const char * s);
Nvoid             LISTVIEW_SetItemTextColor     (LISTVIEW_Handle hObj, unsigned Column, unsigned Row, unsigned Index, GUI_COLOR Color);
Nvoid             LISTVIEW_SetItemTextSorted    (LISTVIEW_Handle hObj, unsigned Column, unsigned Row, const char * pText);
Nvoid             LISTVIEW_SetLBorder           (LISTVIEW_Handle hObj, unsigned BorderSize);
Nvoid             LISTVIEW_SetOverlap           (LISTVIEW_Handle hObj, unsigned Overlap, int Period, U8 Flags);
Xvoid             LISTVIEW_SetOverlap           (LISTVIEW_Handle hObj, unsigned Overlap, int Period, unsigned char Flags);
Nvoid             LISTVIEW_SetOwnerDraw         (LISTVIEW_Handle hObj, WIDGET_DRAW_ITEM_FUNC * pfDrawItem);
Nvoid             LISTVIEW_SetRBorder           (LISTVIEW_Handle hObj, unsigned BorderSize);
Nunsigned         LISTVIEW_SetRowHeight         (LISTVIEW_Handle hObj, unsigned RowHeight);
Nvoid             LISTVIEW_SetScrollPos         (LISTVIEW_Handle hObj, unsigned Col, unsigned Row);
Nint              LISTVIEW_SetScrollStepH       (LISTVIEW_Handle hObj, int Dist);
Nvoid             LISTVIEW_SetSel               (LISTVIEW_Handle hObj, int Sel);
Nvoid             LISTVIEW_SetSelCol            (LISTVIEW_Handle hObj, int NewCol);
Nvoid             LISTVIEW_SetSelUnsorted       (LISTVIEW_Handle hObj, int Sel);
Nunsigned         LISTVIEW_SetSort              (LISTVIEW_Handle hObj, unsigned Column, unsigned Reverse);
Nvoid             LISTVIEW_SetTextAlign         (LISTVIEW_Handle hObj, unsigned int Index, int Align);
Nvoid             LISTVIEW_SetTextColor         (LISTVIEW_Handle hObj, unsigned int Index, GUI_COLOR Color);
Nint              LISTVIEW_SetUserData          (LISTVIEW_Handle hObj, const void * pSrc, int NumBytes);
Nvoid             LISTVIEW_SetUserDataRow       (LISTVIEW_Handle hObj, unsigned Row, U32 UserData);
Xvoid             LISTVIEW_SetUserDataRow       (LISTVIEW_Handle hObj, unsigned Row, unsigned long UserData);
Nvoid             LISTVIEW_SetWrapMode          (LISTVIEW_Handle hObj, GUI_WRAPMODE WrapMode);
N
N/*********************************************************************
N*
N*       Managing default values
N*
N**********************************************************************
N*/
NGUI_COLOR        LISTVIEW_GetDefaultBkColor    (unsigned  Index);
Nconst GUI_FONT * LISTVIEW_GetDefaultFont       (void);
NGUI_COLOR        LISTVIEW_GetDefaultGridColor  (void);
Nint              LISTVIEW_GetDefaultScrollStepH(void);
NGUI_COLOR        LISTVIEW_GetDefaultTextColor  (unsigned  Index);
NGUI_COLOR        LISTVIEW_SetDefaultBkColor    (unsigned  Index, GUI_COLOR Color);
Nconst GUI_FONT * LISTVIEW_SetDefaultFont       (const GUI_FONT * pFont);
NGUI_COLOR        LISTVIEW_SetDefaultGridColor  (GUI_COLOR Color);
Nint              LISTVIEW_SetDefaultScrollStepH(int Dist);
NGUI_COLOR        LISTVIEW_SetDefaultTextColor  (unsigned  Index, GUI_COLOR Color);
N
N#if defined(__cplusplus)
X#if 0L
S  }
N#endif
N
N#endif  // GUI_WINSUPPORT
N#endif  // LISTVIEW_H
N
N/*************************** End of file ****************************/
L 67 "..\..\..\..\ThirdParty\emWin\Include\DIALOG.h" 2
N#include "LISTWHEEL.h"
L 1 "..\..\..\..\ThirdParty\emWin\Include\LISTWHEEL.h" 1
N/*********************************************************************
N*                    SEGGER Microcontroller GmbH                     *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2023  SEGGER Microcontroller GmbH                *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V6.46 - Graphical user interface for embedded applications **
NemWin is protected by international copyright laws. Knowledge of the
Nsource code may not be used to write a similar product. 
NThis file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed by SEGGER Software GmbH to Nuvoton Technology Corporation
Nat the address: No. 4, Creation Rd. III, Hsinchu Science Park, Taiwan
Nfor the purposes  of  creating  libraries  for its 
NArm Cortex-A, Arm Cortex-M and  Arm9 32-bit microcontrollers, commercialized and distributed by Nuvoton Technology Corporation
Nunder  the terms and conditions  of  an  End  User  
NLicense  Agreement  supplied  with  the libraries.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NLicensing information
NLicensor:                 SEGGER Software GmbH
NLicensed to:              Nuvoton Technology Corporation, No. 4, Creation Rd. III, Hsinchu Science Park, 30077 Hsinchu City, Taiwan
NLicensed SEGGER software: emWin
NLicense number:           GUI-00735
NLicense model:            emWin License Agreement, signed February 27, 2018
NLicensed platform:        Cortex-M, Cortex-A, and ARM9 32-bit series microcontroller designed and manufactured by Nuvoton Technology Corporation.
N----------------------------------------------------------------------
NSupport and Update Agreement (SUA)
NSUA period:               2018-03-26 - 2025-09-04
NContact to extend SUA:    sales@segger.com
N----------------------------------------------------------------------
NFile        : LISTWHEEL.h
NPurpose     : LISTWHEEL widget include
N--------------------END-OF-HEADER-------------------------------------
N*/
N
N#ifndef LISTWHEEL_H
N#define LISTWHEEL_H
N
N#include "WM.h"
N#include "DIALOG_Type.h"
N#include "WIDGET.h"
N
N#if GUI_WINSUPPORT
X#if 1
N
N#if defined(__cplusplus)
X#if 0L
S  extern "C" {        // Make sure we have C-declarations in C++ programs
N#endif
N
N/*********************************************************************
N*
N*       Defines
N*
N**********************************************************************
N*/
N/*********************************************************************
N*
N*       LISTWHEEL color indexes
N*
N*  Description
N*    Color indexes to be used by the LISTWHEEL widget.
N*/
N#define LISTWHEEL_CI_UNSEL 0     // Color of unselected element.
N#define LISTWHEEL_CI_SEL   1     // Color of selected element.
N
N/*********************************************************************
N*
N*       Types
N*
N**********************************************************************
N*/
Ntypedef WM_HMEM LISTWHEEL_Handle;
Xtypedef signed long LISTWHEEL_Handle;
N
N/*********************************************************************
N*
N*       Standard member functions
N*
N**********************************************************************
N*/
N/*********************************************************************
N*
N*       Create functions
N*
N**********************************************************************
N*/
NLISTWHEEL_Handle LISTWHEEL_Create        (const GUI_ConstString * ppText, int x0, int y0, int xSize, int ySize, int Flags);
NLISTWHEEL_Handle LISTWHEEL_CreateAsChild (const GUI_ConstString * ppText, WM_HWIN hWinParent, int x0, int y0, int xSize, int ySize, int Flags);
XLISTWHEEL_Handle LISTWHEEL_CreateAsChild (const GUI_ConstString * ppText, GUI_HWIN hWinParent, int x0, int y0, int xSize, int ySize, int Flags);
NLISTWHEEL_Handle LISTWHEEL_CreateIndirect(const GUI_WIDGET_CREATE_INFO * pCreateInfo, WM_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
XLISTWHEEL_Handle LISTWHEEL_CreateIndirect(const GUI_WIDGET_CREATE_INFO * pCreateInfo, GUI_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
NLISTWHEEL_Handle LISTWHEEL_CreateEx      (int x0, int y0, int xSize, int ySize, WM_HWIN hParent,
XLISTWHEEL_Handle LISTWHEEL_CreateEx      (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent,
N                                          int WinFlags, int ExFlags, int Id, const GUI_ConstString * ppText);
NLISTWHEEL_Handle LISTWHEEL_CreateUser    (int x0, int y0, int xSize, int ySize, WM_HWIN hParent,
XLISTWHEEL_Handle LISTWHEEL_CreateUser    (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent,
N                                          int WinFlags, int ExFlags, int Id, const GUI_ConstString * ppText, int NumExtraBytes);
N
N/*********************************************************************
N*
N*       The callback ...
N*
N* Do not call it directly ! It is only to be used from within an
N* overwritten callback.
N*/
Nvoid LISTWHEEL_Callback(WM_MESSAGE * pMsg);
N
N/*********************************************************************
N*
N*       Member functions
N*
N**********************************************************************
N*/
Nvoid      LISTWHEEL_AddString      (LISTWHEEL_Handle hObj, const char * s);
NGUI_COLOR LISTWHEEL_GetBkColor     (LISTWHEEL_Handle hObj, unsigned int Index);
Nvoid *    LISTWHEEL_GetItemData    (LISTWHEEL_Handle hObj, unsigned Index); /* not to be documented */
Nvoid      LISTWHEEL_GetItemText    (LISTWHEEL_Handle hObj, unsigned Index, char * pBuffer, int MaxSize);
Nint       LISTWHEEL_GetItemFromPos (LISTWHEEL_Handle hObj, int yPos);
Nint       LISTWHEEL_GetLBorder     (LISTWHEEL_Handle hObj);
Nunsigned  LISTWHEEL_GetLineHeight  (LISTWHEEL_Handle hObj);
Nint       LISTWHEEL_GetNumItems    (LISTWHEEL_Handle hObj);
Nint       LISTWHEEL_GetPos         (LISTWHEEL_Handle hObj);
Nint       LISTWHEEL_GetRBorder     (LISTWHEEL_Handle hObj);
Nint       LISTWHEEL_GetSel         (LISTWHEEL_Handle hObj);
Nint       LISTWHEEL_GetSnapPosition(LISTWHEEL_Handle hObj);
Nint       LISTWHEEL_GetTextAlign   (LISTWHEEL_Handle hObj);
NGUI_COLOR LISTWHEEL_GetTextColor   (LISTWHEEL_Handle hObj, unsigned int Index);
Nint       LISTWHEEL_GetUserData    (LISTWHEEL_Handle hObj, void * pDest, int NumBytes);
Nint       LISTWHEEL_IsMoving       (LISTWHEEL_Handle hObj);
Nvoid      LISTWHEEL_MoveToPos      (LISTWHEEL_Handle hObj, unsigned int Index);
Nint       LISTWHEEL_OwnerDraw      (const WIDGET_ITEM_DRAW_INFO * pDrawItemInfo);
Nvoid      LISTWHEEL_SetBkColor     (LISTWHEEL_Handle hObj, unsigned int Index, GUI_COLOR Color);
Nvoid      LISTWHEEL_SetDeceleration(LISTWHEEL_Handle hObj, unsigned Deceleration);
Nvoid      LISTWHEEL_SetFont        (LISTWHEEL_Handle hObj, const GUI_FONT * pFont);
Nvoid      LISTWHEEL_SetItemData    (LISTWHEEL_Handle hObj, unsigned Index, void * pData); /* not to be documented */
Nvoid      LISTWHEEL_SetLBorder     (LISTWHEEL_Handle hObj, unsigned BorderSize);
Nvoid      LISTWHEEL_SetLineHeight  (LISTWHEEL_Handle hObj, unsigned LineHeight);
Nvoid      LISTWHEEL_SetOwnerDraw   (LISTWHEEL_Handle hObj, WIDGET_DRAW_ITEM_FUNC * pfOwnerDraw);
Nvoid      LISTWHEEL_SetPos         (LISTWHEEL_Handle hObj, unsigned Index);
Nvoid      LISTWHEEL_SetRBorder     (LISTWHEEL_Handle hObj, unsigned BorderSize);
Nvoid      LISTWHEEL_SetSel         (LISTWHEEL_Handle hObj, int Sel);
Nvoid      LISTWHEEL_SetSnapPosition(LISTWHEEL_Handle hObj, int SnapPosition);
Nvoid      LISTWHEEL_SetText        (LISTWHEEL_Handle hObj, const GUI_ConstString * ppText);
Nvoid      LISTWHEEL_SetTextAlign   (LISTWHEEL_Handle hObj, int Align);
Nvoid      LISTWHEEL_SetTextColor   (LISTWHEEL_Handle hObj, unsigned int Index, GUI_COLOR Color);
Nvoid      LISTWHEEL_SetTimerPeriod (LISTWHEEL_Handle hObj, GUI_TIMER_TIME TimerPeriod);
Xvoid      LISTWHEEL_SetTimerPeriod (LISTWHEEL_Handle hObj, int TimerPeriod);
Nint       LISTWHEEL_SetUserData    (LISTWHEEL_Handle hObj, const void * pSrc, int NumBytes);
Nvoid      LISTWHEEL_SetVelocity    (LISTWHEEL_Handle hObj, int Velocity);
N
Nconst GUI_FONT * LISTWHEEL_GetFont(LISTWHEEL_Handle hObj);
N
N#if defined(__cplusplus)
X#if 0L
S  }
N#endif
N
N#endif  // GUI_WINSUPPORT
N#endif  // LISTWHEEL_H
N
N/*************************** End of file ****************************/
L 68 "..\..\..\..\ThirdParty\emWin\Include\DIALOG.h" 2
N#include "MENU.h"
L 1 "..\..\..\..\ThirdParty\emWin\Include\MENU.h" 1
N/*********************************************************************
N*                    SEGGER Microcontroller GmbH                     *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2023  SEGGER Microcontroller GmbH                *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V6.46 - Graphical user interface for embedded applications **
NemWin is protected by international copyright laws. Knowledge of the
Nsource code may not be used to write a similar product. 
NThis file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed by SEGGER Software GmbH to Nuvoton Technology Corporation
Nat the address: No. 4, Creation Rd. III, Hsinchu Science Park, Taiwan
Nfor the purposes  of  creating  libraries  for its 
NArm Cortex-A, Arm Cortex-M and  Arm9 32-bit microcontrollers, commercialized and distributed by Nuvoton Technology Corporation
Nunder  the terms and conditions  of  an  End  User  
NLicense  Agreement  supplied  with  the libraries.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NLicensing information
NLicensor:                 SEGGER Software GmbH
NLicensed to:              Nuvoton Technology Corporation, No. 4, Creation Rd. III, Hsinchu Science Park, 30077 Hsinchu City, Taiwan
NLicensed SEGGER software: emWin
NLicense number:           GUI-00735
NLicense model:            emWin License Agreement, signed February 27, 2018
NLicensed platform:        Cortex-M, Cortex-A, and ARM9 32-bit series microcontroller designed and manufactured by Nuvoton Technology Corporation.
N----------------------------------------------------------------------
NSupport and Update Agreement (SUA)
NSUA period:               2018-03-26 - 2025-09-04
NContact to extend SUA:    sales@segger.com
N----------------------------------------------------------------------
NFile        : MENU.h
NPurpose     : MENU include
N--------------------END-OF-HEADER-------------------------------------
N*/
N
N#ifndef MENU_H
N#define MENU_H
N
N#include "WM.h"
N#include "WIDGET.h"
N#include "DIALOG_Type.h"      // Required for Create indirect data structure
N
N#if GUI_WINSUPPORT
X#if 1
N
N#if defined(__cplusplus)
X#if 0L
S  extern "C" {     // Make sure we have C-declarations in C++ programs
N#endif
N
N/*********************************************************************
N*
N*       Defines
N*
N**********************************************************************
N*/
N#define MENU_SKIN_FLEX    MENU_DrawSkinFlex
N
N/*********************************************************************
N*
N*       Create flags
N*/
N#define MENU_CF_HORIZONTAL              (0 << 0)
N#define MENU_CF_VERTICAL                (1 << 0)
N#define MENU_CF_OPEN_ON_POINTEROVER     (1 << 1)  // Normally a menu opens first when clicked on it
N#define MENU_CF_CLOSE_ON_SECOND_CLICK   (1 << 2)  // Normally a menu closes only when clicked outside it
N#define MENU_CF_HIDE_DISABLED_SEL       (1 << 3)  // Hides the selection when a disabled item is selected
N
N/*********************************************************************
N*
N*       MENU item flags
N*
N*  Description
N*    Flags used by the MENU_ITEM_DATA structure.
N*/
N#define MENU_IF_DISABLED                (1 << 0)  // Indicates that item is disabled.
N#define MENU_IF_SEPARATOR               (1 << 1)  // Indicates that item is a separator.
N
N/*********************************************************************
N*
N*       MENU color indexes
N*
N*  Description
N*    Color indexes used by the MENU widget.
N*/
N#define MENU_CI_ENABLED                 0         // Color of enabled and not selected MENU items.
N#define MENU_CI_SELECTED                1         // Color of enabled and selected MENU items.
N#define MENU_CI_DISABLED                2         // Color of disabled MENU items.
N#define MENU_CI_DISABLED_SEL            3         // Color of disabled and selected MENU items.
N#define MENU_CI_ACTIVE_SUBMENU          4         // Color of active submenu items.
N
N/*********************************************************************
N*
N*       MENU border indexes
N*
N*  Description
N*    Border indexes used by functions to set the border properties of
N*    a MENU widget.
N*/
N#define MENU_BI_LEFT                    0         // Border between item text and left edge of item.
N#define MENU_BI_RIGHT                   1         // Border between item text and right edge of item.
N#define MENU_BI_TOP                     2         // Border between item text and item top.
N#define MENU_BI_BOTTOM                  3         // Border between item text and item bottom.
N
N/*********************************************************************
N*
N*       MENU message types
N*
N*  Description
N*    Types of messages sent with the \a{MsgType} parameter of the MENU_MSG_DATA structure.
N*    A pointer to this structure is sent via the \c{Data.p} pointer of a WM_MENU message.
N*/
N#define MENU_ON_ITEMSELECT              0         // This message is sent to the owner of a MENU immediately after a MENU item is selected. The \c{ItemId} element of
N                                                  // the MENU_MSG_DATA structure contains the Id of the pressed MENU item.
N#define MENU_ON_INITMENU                1         // This message is sent to the owner of MENU immediately before the MENU opens. This enables the application to
N                                                  // modify the MENU before it is shown.
N#define MENU_ON_INITSUBMENU             2         /* Send to owner when selecting a submenu                                                        */
N#define MENU_ON_OPEN                    3         /* Internal message of menu widget (only send to submenus)                                       */
N#define MENU_ON_CLOSE                   4         /* Internal message of menu widget (only send to submenus)                                       */
N#define MENU_IS_MENU                    5         /* Internal message of menu widget. Owner must call WM_DefaultProc() when not handle the message */
N#define MENU_ON_ITEMACTIVATE            6         // The owner window of a MENU will receive this message after a MENU item has been highlighted. The message is
N                                                  // not sent after highlighting a submenu.
N#define MENU_ON_ITEMPRESSED             7         // After pressing a MENU item this message will be sent to the owner window of the widget. It will be sent also for
N                                                  // disabled MENU items.
N
N/*********************************************************************
N*
N*       Skinning property indices
N*/
N#define MENU_SKINFLEX_PI_ENABLED        0
N#define MENU_SKINFLEX_PI_SELECTED       1
N#define MENU_SKINFLEX_PI_DISABLED       2
N#define MENU_SKINFLEX_PI_DISABLED_SEL   3
N#define MENU_SKINFLEX_PI_ACTIVE_SUBMENU 4
N
N/*********************************************************************
N*
N*       Types
N*
N**********************************************************************
N*/
N
Ntypedef WM_HMEM MENU_Handle;
Xtypedef signed long MENU_Handle;
N
Ntypedef struct {
N  //
N  // Background
N  //  
N  GUI_COLOR aBkColorH[2];
N  GUI_COLOR BkColorV;
N  GUI_COLOR FrameColorH;
N  GUI_COLOR FrameColorV;
N  //
N  // Selection
N  //
N  GUI_COLOR aSelColorH[2];
N  GUI_COLOR aSelColorV[2];
N  GUI_COLOR FrameColorSelH;
N  GUI_COLOR FrameColorSelV;
N  //
N  // Separator
N  //
N  GUI_COLOR aSepColorH[2];
N  GUI_COLOR aSepColorV[2];
N  //
N  // Arrow
N  //
N  GUI_COLOR ArrowColor;
N  //
N  // Text
N  //
N  GUI_COLOR TextColor;
N} MENU_SKINFLEX_PROPS;
N
N/*********************************************************************
N*
N*       MENU_MSG_DATA
N*
N*  Description
N*    This structure is used in conjunction with the WM_MENU message,
N*    specific to the MENU widget. The \c{Data.p} pointer of the message
N*    points to a MENU_MSG_DATA structure.
N*/
Ntypedef struct {
N  U16 MsgType;              // See \ref{MENU message types}.
X  unsigned short MsgType;              
N  U16 ItemId;               // Id of MENU item.
X  unsigned short ItemId;               
N} MENU_MSG_DATA;
N
N/*********************************************************************
N*
N*       MENU_ITEM_DATA
N*
N*  Description
N*    This structure serves as a container to set or retrieve information about MENU items.
N*/
Ntypedef struct {
N  const char  * pText;      // MENU item text.
N  U16           Id;         // Id of the MENU item.
X  unsigned short           Id;         
N  U16           Flags;      // See \ref{MENU item flags}.
X  unsigned short           Flags;      
N  MENU_Handle   hSubmenu;   // If the item represents a submenu this element contains the handle of the submenu.
N} MENU_ITEM_DATA;
N
N/*********************************************************************
N*
N*       Create functions
N*
N**********************************************************************
N*/
NMENU_Handle MENU_CreateIndirect(const GUI_WIDGET_CREATE_INFO * pCreateInfo, WM_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
XMENU_Handle MENU_CreateIndirect(const GUI_WIDGET_CREATE_INFO * pCreateInfo, GUI_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
NMENU_Handle MENU_CreateEx      (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int ExFlags, int Id);
XMENU_Handle MENU_CreateEx      (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int WinFlags, int ExFlags, int Id);
NMENU_Handle MENU_CreateUser    (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int ExFlags, int Id, int NumExtraBytes);
XMENU_Handle MENU_CreateUser    (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int WinFlags, int ExFlags, int Id, int NumExtraBytes);
N
N/*********************************************************************
N*
N*       The callback ...
N*
N* Do not call it directly ! It is only to be used from within an
N* overwritten callback.
N*/
Nvoid MENU_Callback(WM_MESSAGE * pMsg);
N
N/*********************************************************************
N*
N*       Individual member functions
N*
N**********************************************************************
N*/
Nvoid             MENU_AddItem       (MENU_Handle hObj, const MENU_ITEM_DATA * pItemData);
Nvoid             MENU_Attach        (MENU_Handle hObj, WM_HWIN hDestWin, int x, int y, int xSize, int ySize, int Flags);
Xvoid             MENU_Attach        (MENU_Handle hObj, GUI_HWIN hDestWin, int x, int y, int xSize, int ySize, int Flags);
Nvoid             MENU_DeleteItem    (MENU_Handle hObj, U16 ItemId);
Xvoid             MENU_DeleteItem    (MENU_Handle hObj, unsigned short ItemId);
Nvoid             MENU_DisableItem   (MENU_Handle hObj, U16 ItemId);
Xvoid             MENU_DisableItem   (MENU_Handle hObj, unsigned short ItemId);
Nvoid             MENU_EnableItem    (MENU_Handle hObj, U16 ItemId);
Xvoid             MENU_EnableItem    (MENU_Handle hObj, unsigned short ItemId);
NGUI_COLOR        MENU_GetBkColor    (MENU_Handle hObj, unsigned ColorIndex);
Nconst GUI_FONT * MENU_GetFont       (MENU_Handle hObj);
Nvoid             MENU_GetItem       (MENU_Handle hObj, U16 ItemId, MENU_ITEM_DATA * pItemData);
Xvoid             MENU_GetItem       (MENU_Handle hObj, unsigned short ItemId, MENU_ITEM_DATA * pItemData);
Nvoid             MENU_GetItemText   (MENU_Handle hObj, U16 ItemId, char * pBuffer, unsigned BufferSize);
Xvoid             MENU_GetItemText   (MENU_Handle hObj, unsigned short ItemId, char * pBuffer, unsigned BufferSize);
Nunsigned         MENU_GetNumItems   (MENU_Handle hObj);
NWM_HWIN          MENU_GetOwner      (MENU_Handle hObj);
XGUI_HWIN          MENU_GetOwner      (MENU_Handle hObj);
NGUI_COLOR        MENU_GetTextColor  (MENU_Handle hObj, unsigned ColorIndex);
Nint              MENU_GetUserData   (MENU_Handle hObj, void * pDest, int NumBytes);
Nvoid             MENU_InsertItem    (MENU_Handle hObj, U16 ItemId, const MENU_ITEM_DATA * pItemData);
Xvoid             MENU_InsertItem    (MENU_Handle hObj, unsigned short ItemId, const MENU_ITEM_DATA * pItemData);
Nvoid             MENU_Popup         (MENU_Handle hObj, WM_HWIN hDestWin, int x, int y, int xSize, int ySize, int Flags);
Xvoid             MENU_Popup         (MENU_Handle hObj, GUI_HWIN hDestWin, int x, int y, int xSize, int ySize, int Flags);
Nvoid             MENU_SetBkColor    (MENU_Handle hObj, unsigned ColorIndex, GUI_COLOR Color);
Nvoid             MENU_SetBorderSize (MENU_Handle hObj, unsigned BorderIndex, U8 BorderSize);
Xvoid             MENU_SetBorderSize (MENU_Handle hObj, unsigned BorderIndex, unsigned char BorderSize);
Nvoid             MENU_SetFont       (MENU_Handle hObj, const GUI_FONT * pFont);
Nvoid             MENU_SetItem       (MENU_Handle hObj, U16 ItemId, const MENU_ITEM_DATA * pItemData);
Xvoid             MENU_SetItem       (MENU_Handle hObj, unsigned short ItemId, const MENU_ITEM_DATA * pItemData);
Nvoid             MENU_SetOwner      (MENU_Handle hObj, WM_HWIN hOwner);
Xvoid             MENU_SetOwner      (MENU_Handle hObj, GUI_HWIN hOwner);
Nint              MENU_SetSel        (MENU_Handle hObj, int Sel);
Nvoid             MENU_SetTextColor  (MENU_Handle hObj, unsigned ColorIndex, GUI_COLOR Color);
Nint              MENU_SetUserData   (MENU_Handle hObj, const void * pSrc, int NumBytes);
N
N/*********************************************************************
N*
N*       Managing default values
N*
N**********************************************************************
N*/
NGUI_COLOR             MENU_GetDefaultTextColor  (unsigned ColorIndex);
NGUI_COLOR             MENU_GetDefaultBkColor    (unsigned ColorIndex);
NU8                    MENU_GetDefaultBorderSize (unsigned BorderIndex);
Xunsigned char                    MENU_GetDefaultBorderSize (unsigned BorderIndex);
Nconst WIDGET_EFFECT * MENU_GetDefaultEffect     (void);
Nconst GUI_FONT      * MENU_GetDefaultFont       (void);
Nvoid                  MENU_SetDefaultTextColor  (unsigned ColorIndex, GUI_COLOR Color);
Nvoid                  MENU_SetDefaultBkColor    (unsigned ColorIndex, GUI_COLOR Color);
Nvoid                  MENU_SetDefaultBorderSize (unsigned BorderIndex, U8 BorderSize);
Xvoid                  MENU_SetDefaultBorderSize (unsigned BorderIndex, unsigned char BorderSize);
Nvoid                  MENU_SetDefaultEffect     (const WIDGET_EFFECT * pEffect);
Nvoid                  MENU_SetDefaultFont       (const GUI_FONT * pFont);
N
N/*********************************************************************
N*
N*       Member functions: Skinning
N*
N**********************************************************************
N*/
Nint                     MENU_DrawSkinFlex         (const WIDGET_ITEM_DRAW_INFO * pDrawItemInfo);
Nvoid                    MENU_GetSkinFlexProps     (MENU_SKINFLEX_PROPS * pProps, int Index);
NWIDGET_DRAW_ITEM_FUNC * MENU_SetDefaultSkin       (WIDGET_DRAW_ITEM_FUNC * pfDrawSkin);
Nvoid                    MENU_SetDefaultSkinClassic(void);
Nvoid                    MENU_SetSkinClassic       (MENU_Handle hObj);
Nvoid                    MENU_SetSkin              (MENU_Handle hObj, WIDGET_DRAW_ITEM_FUNC * pfDrawSkin);
Nvoid                    MENU_SetSkinFlexProps     (const MENU_SKINFLEX_PROPS * pProps, int Index);
Nvoid                    MENU_SkinEnableArrow      (MENU_Handle hObj, int OnOff);
N
N#if defined(__cplusplus)
X#if 0L
S  }
N#endif
N
N#endif  // GUI_WINSUPPORT
N#endif  // MENU_H
N
N/*************************** End of file ****************************/
L 69 "..\..\..\..\ThirdParty\emWin\Include\DIALOG.h" 2
N#include "MOVIE.h"
L 1 "..\..\..\..\ThirdParty\emWin\Include\MOVIE.h" 1
N/*********************************************************************
N*                    SEGGER Microcontroller GmbH                     *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2023  SEGGER Microcontroller GmbH                *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V6.46 - Graphical user interface for embedded applications **
NemWin is protected by international copyright laws. Knowledge of the
Nsource code may not be used to write a similar product. 
NThis file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed by SEGGER Software GmbH to Nuvoton Technology Corporation
Nat the address: No. 4, Creation Rd. III, Hsinchu Science Park, Taiwan
Nfor the purposes  of  creating  libraries  for its 
NArm Cortex-A, Arm Cortex-M and  Arm9 32-bit microcontrollers, commercialized and distributed by Nuvoton Technology Corporation
Nunder  the terms and conditions  of  an  End  User  
NLicense  Agreement  supplied  with  the libraries.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NLicensing information
NLicensor:                 SEGGER Software GmbH
NLicensed to:              Nuvoton Technology Corporation, No. 4, Creation Rd. III, Hsinchu Science Park, 30077 Hsinchu City, Taiwan
NLicensed SEGGER software: emWin
NLicense number:           GUI-00735
NLicense model:            emWin License Agreement, signed February 27, 2018
NLicensed platform:        Cortex-M, Cortex-A, and ARM9 32-bit series microcontroller designed and manufactured by Nuvoton Technology Corporation.
N----------------------------------------------------------------------
NSupport and Update Agreement (SUA)
NSUA period:               2018-03-26 - 2025-09-04
NContact to extend SUA:    sales@segger.com
N----------------------------------------------------------------------
NFile        : MOVIE.h
NPurpose     : MOVIE public header file (API)
N--------------------END-OF-HEADER-------------------------------------
N*/
N
N#ifndef MOVIE_H
N#define MOVIE_H
N
N#include "WM.h"
N#include "DIALOG_Type.h"  // Req. for Create indirect data structure
N#include "WIDGET.h"
N
N#if GUI_WINSUPPORT
X#if 1
N
N#if defined(__cplusplus)
X#if 0L
S  extern "C" {  // Make sure we have C-declarations in C++ programs
N#endif
N
N/*********************************************************************
N*
N*       MOVIE bitmap indexes
N*
N*  Description
N*    Bitmap indexes for MOVIE widget.
N*/
N#define MOVIE_BI_CENTER_PLAY  0  // Bitmap to be shown as play button in the center of the widget.
N#define MOVIE_BI_PANEL_PLAY   1  // Bitmap for panel play button.
N#define MOVIE_BI_PANEL_PAUSE  2  // Bitmap for panel pause button.
N#define MOVIE_BI_PANEL_BEGIN  3  // Bitmap for panel begin button.
N
N/*********************************************************************
N*
N*       MOVIE color indexes
N*
N*  Description
N*    Color indexes for MOVIE widget.
N*/
N#define MOVIE_CI_CENTER 0  // Color for center bitmap.
N#define MOVIE_CI_PANEL  1  // Color for panel bitmaps.
N#define MOVIE_CI_BK     2  // Color for background if MOVIE does not fill the complete widget area.
N#define MOVIE_CI_LEFT   3  // Color for progress bar (left).
N#define MOVIE_CI_RIGHT  4  // Color for progress bar (right).
N
N/*********************************************************************
N*
N*       MOVIE period indexes
N*
N*  Description
N*    Period indexes for MOVIE widgets.
N*/
N#define MOVIE_PI_SHIFT_IN  0  // The length in ms for shifting in the panel.
N#define MOVIE_PI_SHIFT_OUT 1  // The length in ms for shifting out the panel.
N#define MOVIE_PI_INACTIVE  2  // Period it takes from releasing the widget until the shifting operation is started.
N
N/*********************************************************************
N*
N*       Types
N*
N**********************************************************************
N*/
Ntypedef WM_HMEM MOVIE_Handle;
Xtypedef signed long MOVIE_Handle;
N
N/*********************************************************************
N*
N*       Create function(s)
N
N  Note: the parameters to a create function may vary.
N         Some widgets may have multiple create functions
N*/
NMOVIE_Handle MOVIE_CreateUser(int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int ExFlags, int Id, int NumExtraBytes);
XMOVIE_Handle MOVIE_CreateUser(int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int WinFlags, int ExFlags, int Id, int NumExtraBytes);
N
N/*********************************************************************
N*
N*       The callback ...
N*
N* Do not call it directly ! It is only to be used from within an
N* overwritten callback.
N*/
Nvoid MOVIE_Callback(WM_MESSAGE *pMsg);
N
N/*********************************************************************
N*
N*       Private functions
N*
N**********************************************************************
N*/
Nvoid MOVIE__CalcPanel (void * pVoid);
Nvoid MOVIE__CalcCenter(void * pVoid);
N
N/*********************************************************************
N*
N*       Member functions
N*
N**********************************************************************
N*/
Nint              MOVIE_GetBarSize     (MOVIE_Handle hObj);
NGUI_COLOR        MOVIE_GetColor       (MOVIE_Handle hObj, unsigned ColorIndex);
NGUI_MOVIE_HANDLE MOVIE_GethMovie      (MOVIE_Handle hObj);
Nint              MOVIE_GetInfo        (MOVIE_Handle hObj, GUI_MOVIE_INFO * pInfo);
Nint              MOVIE_GetPanelSize   (MOVIE_Handle hObj);
Nint              MOVIE_GetPeriod      (MOVIE_Handle hObj, unsigned PeriodIndex);
Nint              MOVIE_GetSpace       (MOVIE_Handle hObj);
Nint              MOVIE_GetUserData    (MOVIE_Handle hObj, void * pDest, int NumBytes);
Nvoid             MOVIE_GotoFrame      (MOVIE_Handle hObj, U32 Frame);
Xvoid             MOVIE_GotoFrame      (MOVIE_Handle hObj, unsigned long Frame);
Nint              MOVIE_Pause          (MOVIE_Handle hObj);
Nint              MOVIE_Play           (MOVIE_Handle hObj);
Nvoid             MOVIE_SetBarSize     (MOVIE_Handle hObj, int ySizeBar);
Nvoid             MOVIE_SetBitmapObj   (MOVIE_Handle hObj, GUI_DRAW_HANDLE hDrawObj, unsigned Index);
Nvoid             MOVIE_SetCenterBitmap(MOVIE_Handle hObj, const GUI_BITMAP * pBmPlay);
Nvoid             MOVIE_SetColor       (MOVIE_Handle hObj, unsigned ColorIndex, GUI_COLOR Color);
Nvoid             MOVIE_SetColors      (MOVIE_Handle hObj, GUI_COLOR ColorCenter, GUI_COLOR ColorPanel, GUI_COLOR ColorLeft, GUI_COLOR ColorRight, GUI_COLOR ColorBk);
Nvoid             MOVIE_SetData        (MOVIE_Handle hObj, const U8 * pData, U32 Size, int DoLoop, GUI_MOVIE_FUNC * pfNotify);
Xvoid             MOVIE_SetData        (MOVIE_Handle hObj, const unsigned char * pData, unsigned long Size, int DoLoop, GUI_MOVIE_FUNC * pfNotify);
Nvoid             MOVIE_SetDataEx      (MOVIE_Handle hObj, GUI_MOVIE_GET_DATA_FUNC * pfGetData, void * pVoidImage, void * pVoidTable, int DoLoop, GUI_MOVIE_FUNC * pfNotify);
Nvoid             MOVIE_SetPanelBitmaps(MOVIE_Handle hObj, const GUI_BITMAP * pBmPlay, const GUI_BITMAP * pBmPause, const GUI_BITMAP * pBmStart);
Nvoid             MOVIE_SetPeriod      (MOVIE_Handle hObj, unsigned PeriodIndex, int Period);
Nvoid             MOVIE_SetPeriods     (MOVIE_Handle hObj, int PeriodShiftIn, int PeriodShiftOut, int PeriodInactive);
Nvoid             MOVIE_SetPanelSize   (MOVIE_Handle hObj, int ySizePanel);
Nvoid             MOVIE_SetSizes       (MOVIE_Handle hObj, int ySizePanel, int ySizeBar, int Space);
Nvoid             MOVIE_SetSpace       (MOVIE_Handle hObj, int Space);
Nint              MOVIE_SetUserData    (MOVIE_Handle hObj, const void * pSrc, int NumBytes);
N
N/*********************************************************************
N*
N*       Managing default values
N*
N**********************************************************************
N*/
NGUI_COLOR MOVIE_GetDefaultColor    (unsigned ColorIndex);
Nint       MOVIE_GetDefaultPeriod   (unsigned PeriodIndex);
Nint       MOVIE_GetDefaultSizeBar  (void);
Nint       MOVIE_GetDefaultSizePanel(void);
Nint       MOVIE_GetDefaultSpace    (void);
Nvoid      MOVIE_SetDefaultColor    (unsigned ColorIndex, GUI_COLOR Color);
Nvoid      MOVIE_SetDefaultPeriod   (unsigned PeriodIndex, int Period);
Nvoid      MOVIE_SetDefaultSizeBar  (int SizeBar);
Nvoid      MOVIE_SetDefaultSizePanel(int SizePanel);
Nvoid      MOVIE_SetDefaultSpace    (int Space);
N
N#if defined(__cplusplus)
X#if 0L
S  }
N#endif
N
N#endif   // GUI_WINSUPPORT
N#endif   // MOVIE_H
N
N/*************************** End of file ****************************/
L 70 "..\..\..\..\ThirdParty\emWin\Include\DIALOG.h" 2
N#include "MULTIEDIT.h"
L 1 "..\..\..\..\ThirdParty\emWin\Include\MULTIEDIT.h" 1
N/*********************************************************************
N*                    SEGGER Microcontroller GmbH                     *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2023  SEGGER Microcontroller GmbH                *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V6.46 - Graphical user interface for embedded applications **
NemWin is protected by international copyright laws. Knowledge of the
Nsource code may not be used to write a similar product. 
NThis file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed by SEGGER Software GmbH to Nuvoton Technology Corporation
Nat the address: No. 4, Creation Rd. III, Hsinchu Science Park, Taiwan
Nfor the purposes  of  creating  libraries  for its 
NArm Cortex-A, Arm Cortex-M and  Arm9 32-bit microcontrollers, commercialized and distributed by Nuvoton Technology Corporation
Nunder  the terms and conditions  of  an  End  User  
NLicense  Agreement  supplied  with  the libraries.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NLicensing information
NLicensor:                 SEGGER Software GmbH
NLicensed to:              Nuvoton Technology Corporation, No. 4, Creation Rd. III, Hsinchu Science Park, 30077 Hsinchu City, Taiwan
NLicensed SEGGER software: emWin
NLicense number:           GUI-00735
NLicense model:            emWin License Agreement, signed February 27, 2018
NLicensed platform:        Cortex-M, Cortex-A, and ARM9 32-bit series microcontroller designed and manufactured by Nuvoton Technology Corporation.
N----------------------------------------------------------------------
NSupport and Update Agreement (SUA)
NSUA period:               2018-03-26 - 2025-09-04
NContact to extend SUA:    sales@segger.com
N----------------------------------------------------------------------
NFile        : MULTIEDIT.h
NPurpose     : MULTIEDIT include
N--------------------END-OF-HEADER-------------------------------------
N*/
N
N#ifndef MULTIEDIT_H
N#define MULTIEDIT_H
N
N#include "WM.h"
N#include "WIDGET.h"
N#include "DIALOG_Type.h"      /* Req. for Create indirect data structure */
N
N#if GUI_WINSUPPORT
X#if 1
N
N#if defined(__cplusplus)
X#if 0L
S  extern "C" {     /* Make sure we have C-declarations in C++ programs */
N#endif
N
N/*********************************************************************
N*
N*       MULTIEDIT create flags
N*
N*  Description
N*    Create flags that define the behavior of the FRAMEWIN widget. These flags are OR-combinable
N*    and can be specified upon creation of the widget via the \a{ExFlags} parameter of MULTIEDIT_CreateEx().
N*/
N#define MULTIEDIT_CF_READONLY           (1 << 0)     // Enables read only mode.
N#define MULTIEDIT_CF_INSERT             (1 << 2)     // Enables insert mode.
N#define MULTIEDIT_CF_AUTOSCROLLBAR_V    (1 << 3)     // Automatic use of a vertical scroll bar.
N#define MULTIEDIT_CF_AUTOSCROLLBAR_H    (1 << 4)     // Automatic use of a horizontal scroll bar.
N#define MULTIEDIT_CF_PASSWORD           (1 << 5)     // Enables password mode.
N#define MULTIEDIT_CF_SHOWCURSOR         (1 << 6)     // Shows the cursor.
N#define MULTIEDIT_CF_MOTION_H           (1 << 7)     // Enables motion support on X-axis.
N#define MULTIEDIT_CF_MOTION_V           (1 << 8)     // Enables motion support on Y-axis.
N#define MULTIEDIT_CF_USE_COPY           (1 << 9)     // Enables copyrect optimization
N/* status flags */
N#define MULTIEDIT_SF_READONLY           MULTIEDIT_CF_READONLY
N#define MULTIEDIT_SF_INSERT             MULTIEDIT_CF_INSERT
N#define MULTIEDIT_SF_AUTOSCROLLBAR_V    MULTIEDIT_CF_AUTOSCROLLBAR_V
N#define MULTIEDIT_SF_AUTOSCROLLBAR_H    MULTIEDIT_CF_AUTOSCROLLBAR_H
N#define MULTIEDIT_SF_PASSWORD           MULTIEDIT_CF_PASSWORD
N#define MULTIEDIT_SF_MOTION_H           MULTIEDIT_CF_MOTION_H
N#define MULTIEDIT_SF_MOTION_V           MULTIEDIT_CF_MOTION_V
N
N/*********************************************************************
N*
N*       MULTIEDIT color indexes
N*
N*  Description
N*    Color indexes used by the MULTIEDIT widget.
N*/
N#define MULTIEDIT_CI_EDIT               0                   // Color in edit mode.
N#define MULTIEDIT_CI_READONLY           1                   // Color in read-only mode.
N
N/*********************************************************************
N*
N*       MULTIEDIT cursor color indexes
N*
N*  Description
N*    Color indexes used for the cursor of the MULTIEDIT widget.
N*/
N#define MULTIEDIT_CI_CURSOR_BK          0                   // Background color for cursor
N#define MULTIEDIT_CI_CURSOR_FG          1                   // Foreground color for cursor
N
N#define GUI_MULTIEDIT_SHOWCURSOR        (1 << 10)
N#define GUI_MULTIEDIT_CURSORBLINK       (1 << 11)
N
N/*********************************************************************
N*
N*                         Public Types
N*
N**********************************************************************
N*/
N
Ntypedef WM_HMEM MULTIEDIT_HANDLE;
Xtypedef signed long MULTIEDIT_HANDLE;
N
N/*********************************************************************
N*
N*                 Create functions
N*
N**********************************************************************
N*/
NMULTIEDIT_HANDLE MULTIEDIT_Create        (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int Id, int Flags, int ExFlags, const char * pText, int MaxLen);
XMULTIEDIT_HANDLE MULTIEDIT_Create        (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int Id, int Flags, int ExFlags, const char * pText, int MaxLen);
NMULTIEDIT_HANDLE MULTIEDIT_CreateEx      (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int ExFlags, int Id, int BufferSize, const char * pText);
XMULTIEDIT_HANDLE MULTIEDIT_CreateEx      (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int WinFlags, int ExFlags, int Id, int BufferSize, const char * pText);
NMULTIEDIT_HANDLE MULTIEDIT_CreateIndirect(const GUI_WIDGET_CREATE_INFO* pCreateInfo, WM_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
XMULTIEDIT_HANDLE MULTIEDIT_CreateIndirect(const GUI_WIDGET_CREATE_INFO* pCreateInfo, GUI_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
NMULTIEDIT_HANDLE MULTIEDIT_CreateUser    (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int ExFlags, int Id, int BufferSize, const char * pText, int NumExtraBytes);
XMULTIEDIT_HANDLE MULTIEDIT_CreateUser    (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int WinFlags, int ExFlags, int Id, int BufferSize, const char * pText, int NumExtraBytes);
N
N/*********************************************************************
N*
N*       The callback ...
N*
N* Do not call it directly ! It is only to be used from within an
N* overwritten callback.
N*/
Nvoid MULTIEDIT_Callback(WM_MESSAGE * pMsg);
N
N/*********************************************************************
N*
N*                 Member functions
N*
N**********************************************************************
N*/
N
Nint              MULTIEDIT_AddKey               (MULTIEDIT_HANDLE hObj, U16 Key);
Xint              MULTIEDIT_AddKey               (MULTIEDIT_HANDLE hObj, unsigned short Key);
Nint              MULTIEDIT_AddText              (MULTIEDIT_HANDLE hObj, const char * s);
Nvoid             MULTIEDIT_EnableBlink          (MULTIEDIT_HANDLE hObj, int Period, int OnOff);
Nvoid             MULTIEDIT_EnableCopy           (MULTIEDIT_HANDLE hObj, unsigned OnOff);
Nvoid             MULTIEDIT_EnableMotion         (MULTIEDIT_HANDLE hObj, int Flags);
NGUI_COLOR        MULTIEDIT_GetBkColor           (MULTIEDIT_HANDLE hObj, unsigned Index);
Nint              MULTIEDIT_GetCursorCharPos     (MULTIEDIT_HANDLE hObj);
Nvoid             MULTIEDIT_GetCursorPixelPos    (MULTIEDIT_HANDLE hObj, int * pxPos, int * pyPos);
Nconst GUI_FONT * MULTIEDIT_GetFont              (MULTIEDIT_HANDLE hObj);
Nint              MULTIEDIT_GetNumChars          (MULTIEDIT_HANDLE hObj);
Nvoid             MULTIEDIT_GetPrompt            (MULTIEDIT_HANDLE hObj, char* sDest, int MaxNumChars);
Nvoid             MULTIEDIT_GetText              (MULTIEDIT_HANDLE hObj, char* sDest, int MaxNumChars);
NGUI_COLOR        MULTIEDIT_GetTextColor         (MULTIEDIT_HANDLE hObj, unsigned Index);
Nint              MULTIEDIT_GetTextFromLine      (MULTIEDIT_HANDLE hObj, char * sDest, int MaxLen, unsigned CharPos, unsigned Line);
Nint              MULTIEDIT_GetTextFromPos       (MULTIEDIT_HANDLE hObj, char * sDest, int MaxLen, int CharStart, int LineStart, int CharEnd, int LineEnd);
Nint              MULTIEDIT_GetTextSize          (MULTIEDIT_HANDLE hObj);
Nint              MULTIEDIT_GetUserData          (MULTIEDIT_HANDLE hObj, void * pDest, int NumBytes);
Nint              MULTIEDIT_ReadBytesFromPos     (MULTIEDIT_HANDLE hObj, char * sDest, U32 SizeOfBuffer, U32 Off);
Xint              MULTIEDIT_ReadBytesFromPos     (MULTIEDIT_HANDLE hObj, char * sDest, unsigned long SizeOfBuffer, unsigned long Off);
Nint              MULTIEDIT_ReadCharsFromPos     (MULTIEDIT_HANDLE hObj, char * sDest, U32 SizeOfBuffer, U32 Offset);
Xint              MULTIEDIT_ReadCharsFromPos     (MULTIEDIT_HANDLE hObj, char * sDest, unsigned long SizeOfBuffer, unsigned long Offset);
Nvoid             MULTIEDIT_SetTextAlign         (MULTIEDIT_HANDLE hObj, int Align);
Nvoid             MULTIEDIT_SetAutoScrollH       (MULTIEDIT_HANDLE hObj, int OnOff);
Nvoid             MULTIEDIT_SetAutoScrollV       (MULTIEDIT_HANDLE hObj, int OnOff);
Nvoid             MULTIEDIT_SetBkColor           (MULTIEDIT_HANDLE hObj, unsigned Index, GUI_COLOR color);
Nvoid             MULTIEDIT_SetCursorColor       (MULTIEDIT_HANDLE hObj, unsigned Index, GUI_COLOR color);
Nvoid             MULTIEDIT_SetCursorCharPos     (MULTIEDIT_HANDLE hObj, int x, int y);       /* Not yet implemented */
Nvoid             MULTIEDIT_SetCursorPixelPos    (MULTIEDIT_HANDLE hObj, int x, int y);       /* Not yet implemented */
Nvoid             MULTIEDIT_SetCursorOffset      (MULTIEDIT_HANDLE hObj, int Offset);
Nvoid             MULTIEDIT_SetHBorder           (MULTIEDIT_HANDLE hObj, unsigned HBorder);
Nvoid             MULTIEDIT_SetFocusable         (MULTIEDIT_HANDLE hObj, int State);
Nvoid             MULTIEDIT_SetFont              (MULTIEDIT_HANDLE hObj, const GUI_FONT * pFont);
Nvoid             MULTIEDIT_SetInsertMode        (MULTIEDIT_HANDLE hObj, int OnOff);
Nvoid             MULTIEDIT_SetInvertCursor      (MULTIEDIT_HANDLE hObj, int OnOff);
Nvoid             MULTIEDIT_SetBufferSize        (MULTIEDIT_HANDLE hObj, int BufferSize);
Nvoid             MULTIEDIT_SetMaxNumChars       (MULTIEDIT_HANDLE hObj, unsigned MaxNumChars);
Nvoid             MULTIEDIT_SetPrompt            (MULTIEDIT_HANDLE hObj, const char* sPrompt);
Nvoid             MULTIEDIT_SetReadOnly          (MULTIEDIT_HANDLE hObj, int OnOff);
Nvoid             MULTIEDIT_SetPasswordMode      (MULTIEDIT_HANDLE hObj, int OnOff);
Nvoid             MULTIEDIT_SetText              (MULTIEDIT_HANDLE hObj, const char* s);
Nvoid             MULTIEDIT_SetTextColor         (MULTIEDIT_HANDLE hObj, unsigned Index, GUI_COLOR color);
Nint              MULTIEDIT_SetUserData          (MULTIEDIT_HANDLE hObj, const void * pSrc, int NumBytes);
Nvoid             MULTIEDIT_SetWrapNone          (MULTIEDIT_HANDLE hObj);
Nvoid             MULTIEDIT_SetWrapChar          (MULTIEDIT_HANDLE hObj);
Nvoid             MULTIEDIT_SetWrapWord          (MULTIEDIT_HANDLE hObj);
Nint              MULTIEDIT_ShowCursor           (MULTIEDIT_HANDLE hObj, unsigned OnOff);
N//
N// Default getters/setters
N//
Nint              MULTIEDIT_GetDefaultAlign      (void);
NGUI_COLOR        MULTIEDIT_GetDefaultBkColor    (unsigned Index);
NGUI_COLOR        MULTIEDIT_GetDefaultCursorColor(unsigned Index);
Nconst GUI_FONT * MULTIEDIT_GetDefaultFont       (void);
Nunsigned         MULTIEDIT_GetDefaultHBorder    (void);
NGUI_COLOR        MULTIEDIT_GetDefaultTextColor  (unsigned Index);
Nvoid             MULTIEDIT_SetDefaultAlign      (int Align);
Nvoid             MULTIEDIT_SetDefaultBkColor    (GUI_COLOR Color, unsigned Index);
Nvoid             MULTIEDIT_SetDefaultCursorColor(GUI_COLOR Color, unsigned Index);
Nvoid             MULTIEDIT_SetDefaultFont       (const GUI_FONT * pFont);
Nvoid             MULTIEDIT_SetDefaultHBorder    (unsigned HBorder);
Nvoid             MULTIEDIT_SetDefaultTextColor  (GUI_COLOR Color, unsigned Index);
N
N/*********************************************************************
N*
N*       Macros for compatibility with older versions
N*
N**********************************************************************
N*/
N
N#define MULTIEDIT_SetMaxLen(hObj, MaxLen) MULTIEDIT_SetBufferSize(hObj, MaxLen)
N#define MULTIEDIT_GetStringSize           MULTIEDIT_GetTextSize
N#define MULTIEDIT_SetFocussable           MULTIEDIT_SetFocusable
N
N#if defined(__cplusplus)
X#if 0L
S  }
N#endif
N
N#endif  // GUI_WINSUPPORT
N#endif  // MULTIEDIT_H
N
N/*************************** End of file ****************************/
L 71 "..\..\..\..\ThirdParty\emWin\Include\DIALOG.h" 2
N#include "MULTIPAGE.h"
L 1 "..\..\..\..\ThirdParty\emWin\Include\MULTIPAGE.h" 1
N/*********************************************************************
N*                    SEGGER Microcontroller GmbH                     *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2023  SEGGER Microcontroller GmbH                *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V6.46 - Graphical user interface for embedded applications **
NemWin is protected by international copyright laws. Knowledge of the
Nsource code may not be used to write a similar product. 
NThis file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed by SEGGER Software GmbH to Nuvoton Technology Corporation
Nat the address: No. 4, Creation Rd. III, Hsinchu Science Park, Taiwan
Nfor the purposes  of  creating  libraries  for its 
NArm Cortex-A, Arm Cortex-M and  Arm9 32-bit microcontrollers, commercialized and distributed by Nuvoton Technology Corporation
Nunder  the terms and conditions  of  an  End  User  
NLicense  Agreement  supplied  with  the libraries.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NLicensing information
NLicensor:                 SEGGER Software GmbH
NLicensed to:              Nuvoton Technology Corporation, No. 4, Creation Rd. III, Hsinchu Science Park, 30077 Hsinchu City, Taiwan
NLicensed SEGGER software: emWin
NLicense number:           GUI-00735
NLicense model:            emWin License Agreement, signed February 27, 2018
NLicensed platform:        Cortex-M, Cortex-A, and ARM9 32-bit series microcontroller designed and manufactured by Nuvoton Technology Corporation.
N----------------------------------------------------------------------
NSupport and Update Agreement (SUA)
NSUA period:               2018-03-26 - 2025-09-04
NContact to extend SUA:    sales@segger.com
N----------------------------------------------------------------------
NFile        : MULTIPAGE.h
NPurpose     : MULTIPAGE include
N--------------------END-OF-HEADER-------------------------------------
N*/
N
N#ifndef MULTIPAGE_H
N#define MULTIPAGE_H
N
N#include "WM.h"
N#include "DIALOG.h"   // Required for Create indirect data structure
L 1 "..\..\..\..\ThirdParty\emWin\Include\DIALOG.h" 1
N/*********************************************************************
N*                    SEGGER Microcontroller GmbH                     *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2023  SEGGER Microcontroller GmbH                *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V6.46 - Graphical user interface for embedded applications **
NemWin is protected by international copyright laws. Knowledge of the
Nsource code may not be used to write a similar product. 
NThis file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed by SEGGER Software GmbH to Nuvoton Technology Corporation
Nat the address: No. 4, Creation Rd. III, Hsinchu Science Park, Taiwan
Nfor the purposes  of  creating  libraries  for its 
NArm Cortex-A, Arm Cortex-M and  Arm9 32-bit microcontrollers, commercialized and distributed by Nuvoton Technology Corporation
Nunder  the terms and conditions  of  an  End  User  
NLicense  Agreement  supplied  with  the libraries.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NLicensing information
NLicensor:                 SEGGER Software GmbH
NLicensed to:              Nuvoton Technology Corporation, No. 4, Creation Rd. III, Hsinchu Science Park, 30077 Hsinchu City, Taiwan
NLicensed SEGGER software: emWin
NLicense number:           GUI-00735
NLicense model:            emWin License Agreement, signed February 27, 2018
NLicensed platform:        Cortex-M, Cortex-A, and ARM9 32-bit series microcontroller designed and manufactured by Nuvoton Technology Corporation.
N----------------------------------------------------------------------
NSupport and Update Agreement (SUA)
NSUA period:               2018-03-26 - 2025-09-04
NContact to extend SUA:    sales@segger.com
N----------------------------------------------------------------------
NFile        : Dialog.h
NPurpose     : Dialog box include
N--------------------END-OF-HEADER-------------------------------------
N*/
N
N#ifndef DIALOG_H
S#define DIALOG_H
S
S#include "WM.h"
S
S#include "BUTTON.h"
S#include "CALENDAR.h"
S#include "CHECKBOX.h"
S#include "CHOOSECOLOR.h"
S#include "CHOOSEFILE.h"
S#include "DROPDOWN.h"
S#include "EDIT.h"
S#include "FRAMEWIN.h"
S#include "GAUGE.h"
S#include "GRAPH.h"
S#include "HEADER.h"
S#include "ICONVIEW.h"
S#include "IMAGE.h"
S#include "KEYBOARD.h"
S#include "KNOB.h"
S#include "LISTBOX.h"
S#include "LISTVIEW.h"
S#include "LISTWHEEL.h"
S#include "MENU.h"
S#include "MOVIE.h"
S#include "MULTIEDIT.h"
S#include "MULTIPAGE.h"
S#include "PROGBAR.h"
S#include "QRCODE.h"
S#include "RADIO.h"
S#include "ROTARY.h"
S#include "SCROLLBAR.h"
S#include "SCROLLER.h"
S#include "SLIDER.h"
S#include "SPINBOX.h"
S#include "SWIPELIST.h"
S#include "SWITCH.h"
S#include "TEXT.h"
S#include "TICKER.h"
S#include "TREEVIEW.h"
S#include "WHEEL.h"
S
S#if GUI_WINSUPPORT
S
S#if defined(__cplusplus)
S  extern "C" {     /* Make sure we have C-declarations in C++ programs */
S#endif
S
S/*********************************************************************
S*
S*       WINDOW API
S*/
SWM_HWIN   WINDOW_CreateEx         (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int ExFlags, int Id, WM_CALLBACK * cb);
SWM_HWIN   WINDOW_CreateUser       (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int ExFlags, int Id, WM_CALLBACK * cb, int NumExtraBytes);
SWM_HWIN   WINDOW_CreateIndirect   (const GUI_WIDGET_CREATE_INFO * pCreateInfo, WM_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
SGUI_COLOR WINDOW_GetBkColor       (WM_HWIN hObj);
SGUI_COLOR WINDOW_GetDefaultBkColor(void);
Sint       WINDOW_GetUserData      (WM_HWIN hObj, void * pDest, int NumBytes);
Svoid      WINDOW_SetBkColor       (WM_HWIN hObj, GUI_COLOR Color);
Svoid      WINDOW_SetDefaultBkColor(GUI_COLOR Color);
Sint       WINDOW_SetUserData      (WM_HWIN hObj, const void * pSrc, int NumBytes);
S
Svoid WINDOW_Callback(WM_MESSAGE * pMsg);
S
S#if defined(__cplusplus)
S  }
S#endif
S
S#endif  // GUI_WINSUPPORT
N#endif  // DIALOG_H
N
N/*************************** End of file ****************************/
L 50 "..\..\..\..\ThirdParty\emWin\Include\MULTIPAGE.h" 2
N
N#if GUI_WINSUPPORT
X#if 1
N
N#if defined(__cplusplus)
X#if 0L
S  extern "C" {        // Make sure we have C-declarations in C++ programs
N#endif
N
N/*********************************************************************
N*
N*       Defines
N*
N**********************************************************************
N*/
N/*********************************************************************
N*
N*       MULTIPAGE alignment flags
N*
N*  Description
N*    These flags are used by MULTIPAGE_SetAlign() and define the tab alignment
N*    of a MULTIPAGE widget. Horizontal and vertical flags are OR-combinable.
N*/
N#define MULTIPAGE_ALIGN_LEFT           (0 << 0)    // Aligns the tabs at the left side.
N#define MULTIPAGE_ALIGN_RIGHT          (1 << 0)    // Aligns the tabs at the right side.
N#define MULTIPAGE_ALIGN_TOP            (0 << 2)    // Aligns the tabs at the top of the widget.
N#define MULTIPAGE_ALIGN_BOTTOM         (1 << 2)    // Aligns the tabs at the bottom of the widget.
N
N/*********************************************************************
N*
N*       MULTIPAGE color indexes
N*
N*  Description
N*    Color indexes used by the MULTIPAGE widget.
N*/
N#define MULTIPAGE_CI_DISABLED           0          // Color for disabled pages.
N#define MULTIPAGE_CI_ENABLED            1          // Color for enabled pages.
N
N/*********************************************************************
N*
N*       Create / Status flags
N*/
N#define MULTIPAGE_CF_ROTATE_CW          WIDGET_CF_VERTICAL
N
N#define MULTIPAGE_SKIN_FRAME_LEFT      (1 << 0)
N#define MULTIPAGE_SKIN_FRAME_RIGHT     (1 << 1)
N#define MULTIPAGE_SKIN_FRAME_TOP       (1 << 2)
N#define MULTIPAGE_SKIN_FRAME_BOTTOM    (1 << 3)
N#define MULTIPAGE_SKIN_FRAME_ALL       (MULTIPAGE_SKIN_FRAME_LEFT | MULTIPAGE_SKIN_FRAME_RIGHT | MULTIPAGE_SKIN_FRAME_TOP | MULTIPAGE_SKIN_FRAME_BOTTOM)
N
N#define MULTIPAGE_SKINFLEX_PI_ENABLED   0
N#define MULTIPAGE_SKINFLEX_PI_SELECTED  1
N#define MULTIPAGE_SKINFLEX_PI_DISABLED  2
N
N#define SCROLLBAR_SIZE                 32 // Defines the space for the scrollbar arrows
N
N/*********************************************************************
N*
N*       MULTIPAGE bitmap indexes
N*/
N#define MULTIPAGE_BI_SELECTED           0          // Selected state.
N#define MULTIPAGE_BI_UNSELECTED         1          // Unselected state.
N#define MULTIPAGE_BI_DISABLED           2          // Disabled state.
N#define MULTIPAGE_BI_MAX                3          // The defines above are used as array indices.
N
N/*********************************************************************
N*
N*       Public Types
N*
N**********************************************************************
N*/
Ntypedef WM_HMEM MULTIPAGE_Handle;
Xtypedef signed long MULTIPAGE_Handle;
N
Ntypedef struct {
N  GUI_COLOR BkColor;
N  GUI_COLOR aBkUpper[2];
N  GUI_COLOR aBkLower[2];
N  GUI_COLOR FrameColor;
N  GUI_COLOR TextColor;
N} MULTIPAGE_SKINFLEX_PROPS;
N
Ntypedef struct {
N  U8  SelSideBorderInc;         // Number of pixels to add on both sides when drawing the selected item.
X  unsigned char  SelSideBorderInc;         
N  U8  SelTopBorderInc;          // Number of pixels to add on top of selected items.
X  unsigned char  SelTopBorderInc;          
N} MULTIPAGE_SKIN_PROPS;
N
Ntypedef struct {
N  #if GUI_SUPPORT_ROTATION
X  #if 1
N    GUI_ROTATION  * pRotation;
X    tLCD_APIList  * pRotation;
N  #endif
N  unsigned          Align;
N  int               Sel;
N  U16               State;
X  unsigned short               State;
N  U8                FrameFlags;    // Flags to let the drawing function know which parts of the frame to display.
X  unsigned char                FrameFlags;    
N  U8                PageStatus;
X  unsigned char                PageStatus;
N  GUI_DRAW_HANDLE * pDrawObj;
N} MULTIPAGE_SKIN_INFO;
N
N/*********************************************************************
N*
N*       Create functions
N*
N**********************************************************************
N*/
NMULTIPAGE_Handle MULTIPAGE_Create        (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int Id, int Flags, int SpecialFlags);
XMULTIPAGE_Handle MULTIPAGE_Create        (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int Id, int Flags, int SpecialFlags);
NMULTIPAGE_Handle MULTIPAGE_CreateEx      (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int ExFlags, int Id);
XMULTIPAGE_Handle MULTIPAGE_CreateEx      (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int WinFlags, int ExFlags, int Id);
NMULTIPAGE_Handle MULTIPAGE_CreateUser    (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int ExFlags, int Id, int NumExtraBytes);
XMULTIPAGE_Handle MULTIPAGE_CreateUser    (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int WinFlags, int ExFlags, int Id, int NumExtraBytes);
NMULTIPAGE_Handle MULTIPAGE_CreateIndirect(const GUI_WIDGET_CREATE_INFO * pCreateInfo, WM_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
XMULTIPAGE_Handle MULTIPAGE_CreateIndirect(const GUI_WIDGET_CREATE_INFO * pCreateInfo, GUI_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
N
N/*********************************************************************
N*
N*       The callback ...
N*
N* Do not call it directly ! It is only to be used from within an
N* overwritten callback.
N*/
Nvoid MULTIPAGE_Callback(WM_MESSAGE * pMsg);
N
N/*********************************************************************
N*
N*       Member functions
N*
N**********************************************************************
N*/
Nvoid             MULTIPAGE_AddEmptyPage   (MULTIPAGE_Handle hObj, WM_HWIN hWin ,const char * pText);
Xvoid             MULTIPAGE_AddEmptyPage   (MULTIPAGE_Handle hObj, GUI_HWIN hWin ,const char * pText);
Nvoid             MULTIPAGE_AddPage        (MULTIPAGE_Handle hObj, WM_HWIN hWin ,const char * pText);
Xvoid             MULTIPAGE_AddPage        (MULTIPAGE_Handle hObj, GUI_HWIN hWin ,const char * pText);
NWM_HWIN          MULTIPAGE_AttachWindow   (MULTIPAGE_Handle hObj, unsigned Index, WM_HWIN hWin);
XGUI_HWIN          MULTIPAGE_AttachWindow   (MULTIPAGE_Handle hObj, unsigned Index, GUI_HWIN hWin);
Nvoid             MULTIPAGE_DeletePage     (MULTIPAGE_Handle hObj, unsigned Index, int Delete);
Nvoid             MULTIPAGE_DisablePage    (MULTIPAGE_Handle hObj, unsigned Index);
Nvoid             MULTIPAGE_EnablePage     (MULTIPAGE_Handle hObj, unsigned Index);
Nvoid             MULTIPAGE_EnableScrollbar(MULTIPAGE_Handle hObj, unsigned OnOff);
NGUI_COLOR        MULTIPAGE_GetBkColor     (MULTIPAGE_Handle hObj, unsigned Index);
Nconst GUI_FONT * MULTIPAGE_GetFont        (MULTIPAGE_Handle hObj);
Nint              MULTIPAGE_GetNumTabs     (MULTIPAGE_Handle hObj);
Nint              MULTIPAGE_GetSelection   (MULTIPAGE_Handle hObj);
Nint              MULTIPAGE_GetPageText    (MULTIPAGE_Handle hObj, unsigned Index, char * pBuffer, int MaxLen);
Nint              MULTIPAGE_GetTabHeight   (MULTIPAGE_Handle hObj);
Nint              MULTIPAGE_GetTabWidth    (MULTIPAGE_Handle hObj, int Index);
NGUI_COLOR        MULTIPAGE_GetTextColor   (MULTIPAGE_Handle hObj, unsigned Index);
Nint              MULTIPAGE_GetUserData    (MULTIPAGE_Handle hObj, void * pDest, int NumBytes);
NWM_HWIN          MULTIPAGE_GetWindow      (MULTIPAGE_Handle hObj, unsigned Index);
XGUI_HWIN          MULTIPAGE_GetWindow      (MULTIPAGE_Handle hObj, unsigned Index);
Nint              MULTIPAGE_IsPageEnabled  (MULTIPAGE_Handle hObj, unsigned Index);
Nvoid             MULTIPAGE_SelectPage     (MULTIPAGE_Handle hObj, unsigned Index);
Nvoid             MULTIPAGE_SetAlign       (MULTIPAGE_Handle hObj, unsigned Align);
Nint              MULTIPAGE_SetBitmapEx    (MULTIPAGE_Handle hObj, const GUI_BITMAP * pBitmap, int x, int y, int Index, int State);
Nint              MULTIPAGE_SetBitmap      (MULTIPAGE_Handle hObj, const GUI_BITMAP * pBitmap, int Index, int State);
Nvoid             MULTIPAGE_SetBkColor     (MULTIPAGE_Handle hObj, GUI_COLOR Color, unsigned Index);
Nvoid             MULTIPAGE_SetFont        (MULTIPAGE_Handle hObj, const GUI_FONT * pFont);
Nvoid             MULTIPAGE_SetRotation    (MULTIPAGE_Handle hObj, unsigned Rotation);
Nvoid             MULTIPAGE_SetTabWidth    (MULTIPAGE_Handle hObj, int Width, int Index);
Nvoid             MULTIPAGE_SetTabHeight   (MULTIPAGE_Handle hObj, int Height);
Nvoid             MULTIPAGE_SetTextAlign   (MULTIPAGE_Handle hObj, unsigned Align);
Nvoid             MULTIPAGE_SetText        (MULTIPAGE_Handle hObj, const char * pText, unsigned Index);
Nvoid             MULTIPAGE_SetTextColor   (MULTIPAGE_Handle hObj, GUI_COLOR Color, unsigned Index);
Nint              MULTIPAGE_SetUserData    (MULTIPAGE_Handle hObj, const void * pSrc, int NumBytes);
N
N/*********************************************************************
N*
N*       Managing default values
N*
N**********************************************************************
N*/
Nunsigned         MULTIPAGE_GetDefaultAlign      (void);
NGUI_COLOR        MULTIPAGE_GetDefaultBkColor    (unsigned Index);
Nconst GUI_FONT * MULTIPAGE_GetDefaultFont       (void);
NGUI_COLOR        MULTIPAGE_GetDefaultTextColor  (unsigned Index);
N
Nvoid             MULTIPAGE_SetDefaultAlign      (unsigned Align);
Nvoid             MULTIPAGE_SetDefaultBkColor    (GUI_COLOR Color, unsigned Index);
Nvoid             MULTIPAGE_SetDefaultBorderSizeX(unsigned Size);
Nvoid             MULTIPAGE_SetDefaultBorderSizeY(unsigned Size);
Nvoid             MULTIPAGE_SetDefaultFont       (const GUI_FONT * pFont);
Nvoid             MULTIPAGE_SetDefaultTextColor  (GUI_COLOR Color, unsigned Index);
N
Nvoid             MULTIPAGE_SetEffectColor       (unsigned Index, GUI_COLOR Color);
NGUI_COLOR        MULTIPAGE_GetEffectColor       (unsigned Index);
Nint              MULTIPAGE_GetNumEffectColors   (void);
N
N/*********************************************************************
N*
N*       Member functions: Skinning
N*
N**********************************************************************
N*/
Nint                     MULTIPAGE_DrawSkinFlex         (const WIDGET_ITEM_DRAW_INFO * pDrawItemInfo);
Nvoid                    MULTIPAGE_GetSkinFlexProps     (MULTIPAGE_SKINFLEX_PROPS * pProps, int Index);
NWIDGET_DRAW_ITEM_FUNC * MULTIPAGE_SetDefaultSkin       (WIDGET_DRAW_ITEM_FUNC * pfDrawSkin);
Nvoid                    MULTIPAGE_SetDefaultSkinClassic(void);
Nvoid                    MULTIPAGE_SetSkinClassic       (MULTIPAGE_Handle hObj);
Nvoid                    MULTIPAGE_SetSkin              (MULTIPAGE_Handle hObj, WIDGET_DRAW_ITEM_FUNC * pfDrawSkin);
Nvoid                    MULTIPAGE_SetSkinFlexProps     (const MULTIPAGE_SKINFLEX_PROPS * pProps, int Index);
N
N#define MULTIPAGE_SKIN_FLEX MULTIPAGE_DrawSkinFlex
N
N#if defined(__cplusplus)
X#if 0L
S  }
N#endif
N
N#endif  // GUI_WINSUPPORT
N#endif  // MULTIPAGE_H
N
N/*************************** End of file ****************************/
L 72 "..\..\..\..\ThirdParty\emWin\Include\DIALOG.h" 2
N#include "PROGBAR.h"
L 1 "..\..\..\..\ThirdParty\emWin\Include\PROGBAR.h" 1
N/*********************************************************************
N*                    SEGGER Microcontroller GmbH                     *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2023  SEGGER Microcontroller GmbH                *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V6.46 - Graphical user interface for embedded applications **
NemWin is protected by international copyright laws. Knowledge of the
Nsource code may not be used to write a similar product. 
NThis file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed by SEGGER Software GmbH to Nuvoton Technology Corporation
Nat the address: No. 4, Creation Rd. III, Hsinchu Science Park, Taiwan
Nfor the purposes  of  creating  libraries  for its 
NArm Cortex-A, Arm Cortex-M and  Arm9 32-bit microcontrollers, commercialized and distributed by Nuvoton Technology Corporation
Nunder  the terms and conditions  of  an  End  User  
NLicense  Agreement  supplied  with  the libraries.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NLicensing information
NLicensor:                 SEGGER Software GmbH
NLicensed to:              Nuvoton Technology Corporation, No. 4, Creation Rd. III, Hsinchu Science Park, 30077 Hsinchu City, Taiwan
NLicensed SEGGER software: emWin
NLicense number:           GUI-00735
NLicense model:            emWin License Agreement, signed February 27, 2018
NLicensed platform:        Cortex-M, Cortex-A, and ARM9 32-bit series microcontroller designed and manufactured by Nuvoton Technology Corporation.
N----------------------------------------------------------------------
NSupport and Update Agreement (SUA)
NSUA period:               2018-03-26 - 2025-09-04
NContact to extend SUA:    sales@segger.com
N----------------------------------------------------------------------
NFile        : PROGBAR.h
NPurpose     : Progressbar include
N--------------------END-OF-HEADER-------------------------------------
N*/
N
N#ifndef PROGBAR_H        /* Avoid multiple inclusion  */
N#define PROGBAR_H
N
N#include "WM.h"
N#include "DIALOG_Type.h"      /* Req. for Create indirect data structure */
N#include "WIDGET.h"
N
N#if GUI_WINSUPPORT
X#if 1
N
N#if defined(__cplusplus)
X#if 0L
S  extern "C" {     /* Make sure we have C-declarations in C++ programs */
N#endif
N
N/*********************************************************************
N*
N*       Defines
N*
N**********************************************************************
N*/
N/*********************************************************************
N*
N*       Create flags
N*/
N#define PROGBAR_CF_HORIZONTAL (0 << 0)
N#define PROGBAR_CF_VERTICAL   (1 << 0)
N#define PROGBAR_CF_USER       (1 << 1)
N
N/*********************************************************************
N*
N*       Skinning constants
N*/
N#define PROGBAR_SKINFLEX_L 0
N#define PROGBAR_SKINFLEX_R 1
N
N/*********************************************************************
N*
N*       Types
N*
N**********************************************************************
N*/
Ntypedef WM_HMEM PROGBAR_Handle;
Xtypedef signed long PROGBAR_Handle;
N
Ntypedef struct {
N  GUI_COLOR aColorUpperL[2];
N  GUI_COLOR aColorLowerL[2];
N  GUI_COLOR aColorUpperR[2];
N  GUI_COLOR aColorLowerR[2];
N  GUI_COLOR ColorFrame;
N  GUI_COLOR ColorText;
N} PROGBAR_SKINFLEX_PROPS;
N
Ntypedef struct {
N  int IsVertical;
N  int Index;
N  const char * pText;
N} PROGBAR_SKINFLEX_INFO;
N
N/*********************************************************************
N*
N*       Create functions
N*
N**********************************************************************
N*/
N
NPROGBAR_Handle PROGBAR_Create        (int x0, int y0, int xSize, int ySize, int Flags);
NPROGBAR_Handle PROGBAR_CreateAsChild (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int Id, int Flags);
XPROGBAR_Handle PROGBAR_CreateAsChild (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int Id, int Flags);
NPROGBAR_Handle PROGBAR_CreateEx      (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int ExFlags, int Id);
XPROGBAR_Handle PROGBAR_CreateEx      (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int WinFlags, int ExFlags, int Id);
NPROGBAR_Handle PROGBAR_CreateUser    (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int ExFlags, int Id, int NumExtraBytes);
XPROGBAR_Handle PROGBAR_CreateUser    (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int WinFlags, int ExFlags, int Id, int NumExtraBytes);
NPROGBAR_Handle PROGBAR_CreateIndirect(const GUI_WIDGET_CREATE_INFO * pCreateInfo, WM_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
XPROGBAR_Handle PROGBAR_CreateIndirect(const GUI_WIDGET_CREATE_INFO * pCreateInfo, GUI_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
N
N/*********************************************************************
N*
N*       The callback ...
N*
N* Do not call it directly ! It is only to be used from within an
N* overwritten callback.
N*/
Nvoid PROGBAR_Callback(WM_MESSAGE * pMsg);
N
N/*********************************************************************
N*
N*       Individual member functions
N*
N**********************************************************************
N*/
NGUI_COLOR        PROGBAR_GetBarColor(PROGBAR_Handle hObj, unsigned int Index);
Nconst GUI_FONT * PROGBAR_GetFont     (PROGBAR_Handle hObj);
Nvoid             PROGBAR_GetMinMax   (PROGBAR_Handle hObj, int * pMin, int * pMax);
Nint              PROGBAR_GetUserData (PROGBAR_Handle hObj, void * pDest, int NumBytes);
NGUI_COLOR        PROGBAR_GetTextColor(PROGBAR_Handle hObj, unsigned int Index);
Nint              PROGBAR_GetValue    (PROGBAR_Handle hObj);
Nvoid             PROGBAR_SetBarColor (PROGBAR_Handle hObj, unsigned int index, GUI_COLOR color);
Nvoid             PROGBAR_SetFont     (PROGBAR_Handle hObj, const GUI_FONT * pfont);
Nvoid             PROGBAR_SetMinMax   (PROGBAR_Handle hObj, int Min, int Max);
Nvoid             PROGBAR_SetText     (PROGBAR_Handle hObj, const char* s);
Nvoid             PROGBAR_SetTextAlign(PROGBAR_Handle hObj, int Align);
Nvoid             PROGBAR_SetTextColor(PROGBAR_Handle hObj, unsigned int index, GUI_COLOR color);
Nvoid             PROGBAR_SetTextPos  (PROGBAR_Handle hObj, int XOff, int YOff);
Nvoid             PROGBAR_SetValue    (PROGBAR_Handle hObj, int v);
Nint              PROGBAR_SetUserData (PROGBAR_Handle hObj, const void * pSrc, int NumBytes);
N
N/*********************************************************************
N*
N*       Member functions: Skinning
N*
N**********************************************************************
N*/
Nvoid PROGBAR_GetSkinFlexProps     (PROGBAR_SKINFLEX_PROPS * pProps, int Index);
Nvoid PROGBAR_SetSkinClassic       (PROGBAR_Handle hObj);
Nvoid PROGBAR_SetSkin              (PROGBAR_Handle hObj, WIDGET_DRAW_ITEM_FUNC * pfDrawSkin);
Nint  PROGBAR_DrawSkinFlex         (const WIDGET_ITEM_DRAW_INFO * pDrawItemInfo);
Nvoid PROGBAR_SetSkinFlexProps     (const PROGBAR_SKINFLEX_PROPS * pProps, int Index);
Nvoid PROGBAR_SetDefaultSkinClassic(void);
NWIDGET_DRAW_ITEM_FUNC * PROGBAR_SetDefaultSkin(WIDGET_DRAW_ITEM_FUNC * pfDrawSkin);
N
N#define PROGBAR_SKIN_FLEX    PROGBAR_DrawSkinFlex
N
N#if defined(__cplusplus)
X#if 0L
S  }
N#endif
N
N#endif  // GUI_WINSUPPORT
N#endif  // PROGBAR_H
N
N/*************************** End of file ****************************/
L 73 "..\..\..\..\ThirdParty\emWin\Include\DIALOG.h" 2
N#include "QRCODE.h"
L 1 "..\..\..\..\ThirdParty\emWin\Include\QRCODE.h" 1
N/*********************************************************************
N*                    SEGGER Microcontroller GmbH                     *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2023  SEGGER Microcontroller GmbH                *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V6.46 - Graphical user interface for embedded applications **
NemWin is protected by international copyright laws. Knowledge of the
Nsource code may not be used to write a similar product. 
NThis file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed by SEGGER Software GmbH to Nuvoton Technology Corporation
Nat the address: No. 4, Creation Rd. III, Hsinchu Science Park, Taiwan
Nfor the purposes  of  creating  libraries  for its 
NArm Cortex-A, Arm Cortex-M and  Arm9 32-bit microcontrollers, commercialized and distributed by Nuvoton Technology Corporation
Nunder  the terms and conditions  of  an  End  User  
NLicense  Agreement  supplied  with  the libraries.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NLicensing information
NLicensor:                 SEGGER Software GmbH
NLicensed to:              Nuvoton Technology Corporation, No. 4, Creation Rd. III, Hsinchu Science Park, 30077 Hsinchu City, Taiwan
NLicensed SEGGER software: emWin
NLicense number:           GUI-00735
NLicense model:            emWin License Agreement, signed February 27, 2018
NLicensed platform:        Cortex-M, Cortex-A, and ARM9 32-bit series microcontroller designed and manufactured by Nuvoton Technology Corporation.
N----------------------------------------------------------------------
NSupport and Update Agreement (SUA)
NSUA period:               2018-03-26 - 2025-09-04
NContact to extend SUA:    sales@segger.com
N----------------------------------------------------------------------
NFile        : QRCODE.h
NPurpose     : QRCODE public header file (API)
N--------------------END-OF-HEADER-------------------------------------
N*/
N
N#ifndef QRCODE_H
N#define QRCODE_H
N
N#include "WM.h"
N#include "DIALOG_Type.h"      /* Req. for Create indirect data structure */
N#include "WIDGET.h"
N
N#if GUI_WINSUPPORT
X#if 1
N
N#if defined(__cplusplus)
X#if 0L
S  extern "C" {     /* Make sure we have C-declarations in C++ programs */
N#endif
N
N/*********************************************************************
N*
N*       Defines
N*
N**********************************************************************
N*/
N/*********************************************************************
N*
N*       QRCODE WiFi encryption types
N*
N*  Description
N*    These macros are to be used for the \a{Encryption} parameter of
N*    QRCODE_SetWiFiText().
N*/
N#define QRCODE_WIFI_WPA    0    // If the WiFi password is WPA encrypted.
N#define QRCODE_WIFI_WEP    1    // If the WiFi password is WEP encrypted.
N
N/*********************************************************************
N*
N*       Types
N*
N**********************************************************************
N*/
Ntypedef WM_HMEM QRCODE_Handle;
Xtypedef signed long QRCODE_Handle;
N
N/*********************************************************************
N*
N*       Create function(s)
N
N  Note: the parameters to a create function may vary.
N         Some widgets may have multiple create functions
N*/
NQRCODE_Handle QRCODE_CreateUser    (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, U32 WinFlags, int ExFlags, int Id, const char * pText, int PixelSize, int EccLevel, int Version, int NumExtraBytes);
XQRCODE_Handle QRCODE_CreateUser    (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, unsigned long WinFlags, int ExFlags, int Id, const char * pText, int PixelSize, int EccLevel, int Version, int NumExtraBytes);
NQRCODE_Handle QRCODE_CreateIndirect(const GUI_WIDGET_CREATE_INFO * pCreateInfo, WM_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
XQRCODE_Handle QRCODE_CreateIndirect(const GUI_WIDGET_CREATE_INFO * pCreateInfo, GUI_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
N
N/*********************************************************************
N*
N*       The callback ...
N*
N* Do not call it directly ! It is only to be used from within an
N* overwritten callback.
N*/
Nvoid QRCODE_Callback(WM_MESSAGE *pMsg);
N
N/*********************************************************************
N*
N*       Member functions
N*
N**********************************************************************
N*/
Nvoid QRCODE_SetEccLevel  (QRCODE_Handle hObj, int EccLevel);
Nvoid QRCODE_SetNumModules(QRCODE_Handle hObj, int NumModules);
Nvoid QRCODE_SetPixelSize (QRCODE_Handle hObj, int PixelSize);
Nvoid QRCODE_SetText      (QRCODE_Handle hObj, const char * pText);
Nvoid QRCODE_SetVersion   (QRCODE_Handle hObj, int Version);
Nvoid QRCODE_SetWiFiText  (QRCODE_Handle hObj, const char * pSSID, U8 Encryption, const char * pPassword, U8 Hidden);
Xvoid QRCODE_SetWiFiText  (QRCODE_Handle hObj, const char * pSSID, unsigned char Encryption, const char * pPassword, unsigned char Hidden);
N
N#if defined(__cplusplus)
X#if 0L
S  }
N#endif
N
N#endif  // GUI_WINSUPPORT
N#endif  // QRCODE_H
N
N/*************************** End of file ****************************/
N
L 74 "..\..\..\..\ThirdParty\emWin\Include\DIALOG.h" 2
N#include "RADIO.h"
L 1 "..\..\..\..\ThirdParty\emWin\Include\RADIO.h" 1
N/*********************************************************************
N*                    SEGGER Microcontroller GmbH                     *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2023  SEGGER Microcontroller GmbH                *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V6.46 - Graphical user interface for embedded applications **
NemWin is protected by international copyright laws. Knowledge of the
Nsource code may not be used to write a similar product. 
NThis file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed by SEGGER Software GmbH to Nuvoton Technology Corporation
Nat the address: No. 4, Creation Rd. III, Hsinchu Science Park, Taiwan
Nfor the purposes  of  creating  libraries  for its 
NArm Cortex-A, Arm Cortex-M and  Arm9 32-bit microcontrollers, commercialized and distributed by Nuvoton Technology Corporation
Nunder  the terms and conditions  of  an  End  User  
NLicense  Agreement  supplied  with  the libraries.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NLicensing information
NLicensor:                 SEGGER Software GmbH
NLicensed to:              Nuvoton Technology Corporation, No. 4, Creation Rd. III, Hsinchu Science Park, 30077 Hsinchu City, Taiwan
NLicensed SEGGER software: emWin
NLicense number:           GUI-00735
NLicense model:            emWin License Agreement, signed February 27, 2018
NLicensed platform:        Cortex-M, Cortex-A, and ARM9 32-bit series microcontroller designed and manufactured by Nuvoton Technology Corporation.
N----------------------------------------------------------------------
NSupport and Update Agreement (SUA)
NSUA period:               2018-03-26 - 2025-09-04
NContact to extend SUA:    sales@segger.com
N----------------------------------------------------------------------
NFile        : RADIO.h
NPurpose     : RADIO include
N--------------------END-OF-HEADER-------------------------------------
N*/
N
N#ifndef RADIO_H
N#define RADIO_H
N
N#include "WM.h"
N#include "DIALOG_Type.h"      /* Req. for Create indirect data structure */
N#include "WIDGET.h"
N
N#if GUI_WINSUPPORT
X#if 1
N
N#if defined(__cplusplus)
X#if 0L
S  extern "C" {     /* Make sure we have C-declarations in C++ programs */
N#endif
N
N/*********************************************************************
N*
N*       Bitmap indices
N*/
N#define RADIO_BI_INACTIV  0
N#define RADIO_BI_ACTIV    1
N#define RADIO_BI_INACTIVE RADIO_BI_INACTIV
N#define RADIO_BI_ACTIVE   RADIO_BI_ACTIV
N#define RADIO_BI_CHECK    2
N
N/*********************************************************************
N*
N*       Skinning property indices
N*/
N#define RADIO_SKINFLEX_PI_PRESSED     0
N#define RADIO_SKINFLEX_PI_UNPRESSED   1
N
N/*********************************************************************
N*
N*       Defaults for public configuration switches
N*
N**********************************************************************
N
NThe following are defaults for config switches which affect the
Ninterface specified in this module
N*/
N
N/*********************************************************************
N*
N*       Defines
N*
N**********************************************************************
N*/
N#define RADIO_TEXTPOS_RIGHT       0
N#define RADIO_TEXTPOS_LEFT        WIDGET_STATE_USER0  /* Not implemented, TBD */
N
N/*********************************************************************
N*
N*       Public Types
N*
N**********************************************************************
N*/
Ntypedef WM_HMEM RADIO_Handle;
Xtypedef signed long RADIO_Handle;
N
Ntypedef struct {
N  GUI_COLOR aColorButton[4];
N  int       ButtonSize;
N} RADIO_SKINFLEX_PROPS;
N
N/*********************************************************************
N*
N*       Create functions
N*
N**********************************************************************
N*/
N
NRADIO_Handle RADIO_Create        (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int Id, int Flags, unsigned Para);
XRADIO_Handle RADIO_Create        (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int Id, int Flags, unsigned Para);
NRADIO_Handle RADIO_CreateEx      (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int ExFlags, int Id, int NumItems, int Spacing);
XRADIO_Handle RADIO_CreateEx      (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int WinFlags, int ExFlags, int Id, int NumItems, int Spacing);
NRADIO_Handle RADIO_CreateUser    (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int ExFlags, int Id, int NumItems, int Spacing, int NumExtraBytes);
XRADIO_Handle RADIO_CreateUser    (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int WinFlags, int ExFlags, int Id, int NumItems, int Spacing, int NumExtraBytes);
NRADIO_Handle RADIO_CreateIndirect(const GUI_WIDGET_CREATE_INFO * pCreateInfo, WM_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
XRADIO_Handle RADIO_CreateIndirect(const GUI_WIDGET_CREATE_INFO * pCreateInfo, GUI_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
N
N/*********************************************************************
N*
N*       The callback ...
N*
N* Do not call it directly ! It is only to be used from within an
N* overwritten callback.
N*/
Nvoid RADIO_Callback(WM_MESSAGE * pMsg);
N
N/*********************************************************************
N*
N*       Managing default values
N*
N**********************************************************************
N*/
N
Nvoid             RADIO_SetDefaultFont      (const GUI_FONT * pFont);
NGUI_COLOR        RADIO_SetDefaultFocusColor(GUI_COLOR Color);
Nvoid             RADIO_SetDefaultImage     (const GUI_BITMAP * pBitmap, unsigned int Index);
Nvoid             RADIO_SetDefaultTextColor (GUI_COLOR TextColor);
Nconst GUI_FONT * RADIO_GetDefaultFont      (void);
NGUI_COLOR        RADIO_GetDefaultTextColor (void);
N
N/*********************************************************************
N*
N*       Member functions
N*
N**********************************************************************
N*/
N
Nvoid               RADIO_AddValue       (RADIO_Handle hObj, int Add);
Nvoid               RADIO_Dec            (RADIO_Handle hObj);
NGUI_COLOR          RADIO_GetBkColor     (RADIO_Handle hObj);
NGUI_COLOR          RADIO_GetFocusColor  (RADIO_Handle hObj);
Nconst GUI_FONT *   RADIO_GetFont        (RADIO_Handle hObj);
Nconst GUI_BITMAP * RADIO_GetImage       (RADIO_Handle hObj, unsigned int Index);
Nint                RADIO_GetNumItems    (RADIO_Handle hObj);
NU16                RADIO_GetSpacing     (RADIO_Handle hObj);
Xunsigned short                RADIO_GetSpacing     (RADIO_Handle hObj);
Nint                RADIO_GetText        (RADIO_Handle hObj, unsigned Index, char * pBuffer, int MaxLen);
NGUI_COLOR          RADIO_GetTextColor   (RADIO_Handle hObj);
Nint                RADIO_GetUserData    (RADIO_Handle hObj, void * pDest, int NumBytes);
Nvoid               RADIO_Inc            (RADIO_Handle hObj);
Nvoid               RADIO_SetBkColor     (RADIO_Handle hObj, GUI_COLOR Color);
NGUI_COLOR          RADIO_SetFocusColor  (RADIO_Handle hObj, GUI_COLOR Color);
Nvoid               RADIO_SetFont        (RADIO_Handle hObj, const GUI_FONT * pFont);
Nvoid               RADIO_SetGroupId     (RADIO_Handle hObj, U8 GroupId);
Xvoid               RADIO_SetGroupId     (RADIO_Handle hObj, unsigned char GroupId);
Nvoid               RADIO_SetImage       (RADIO_Handle hObj, const GUI_BITMAP * pBitmap, unsigned int Index);
Nvoid               RADIO_SetReactOnLevel(void);  // Not to be documented
Nvoid               RADIO_SetReactOnTouch(void);  // Not to be documented
Nvoid               RADIO_SetSpacing     (RADIO_Handle hObj, U16 Spacing);
Xvoid               RADIO_SetSpacing     (RADIO_Handle hObj, unsigned short Spacing);
Nvoid               RADIO_SetText        (RADIO_Handle hObj, const char* pText, unsigned Index);
Nvoid               RADIO_SetTextColor   (RADIO_Handle hObj, GUI_COLOR Color);
Nvoid               RADIO_SetValue       (RADIO_Handle hObj, int v);
Nint                RADIO_SetUserData    (RADIO_Handle hObj, const void * pSrc, int NumBytes);
N
N/*********************************************************************
N*
N*       Member functions: Skinning
N*
N**********************************************************************
N*/
Nvoid RADIO_GetSkinFlexProps     (RADIO_SKINFLEX_PROPS * pProps, int Index);
Nvoid RADIO_SetSkinClassic       (RADIO_Handle hObj);
Nvoid RADIO_SetSkin              (RADIO_Handle hObj, WIDGET_DRAW_ITEM_FUNC * pfDrawSkin);
Nint  RADIO_DrawSkinFlex         (const WIDGET_ITEM_DRAW_INFO * pDrawItemInfo);
Nvoid RADIO_SetSkinFlexProps     (const RADIO_SKINFLEX_PROPS * pProps, int Index);
Nvoid RADIO_SetDefaultSkinClassic(void);
NWIDGET_DRAW_ITEM_FUNC * RADIO_SetDefaultSkin(WIDGET_DRAW_ITEM_FUNC * pfDrawSkin);
N
N#define RADIO_SKIN_FLEX    RADIO_DrawSkinFlex
N
N/*********************************************************************
N*
N*       Query state
N*
N**********************************************************************
N*/
Nint RADIO_GetValue(RADIO_Handle hObj);
N
N#if defined(__cplusplus)
X#if 0L
S  }
N#endif
N
N#endif  // GUI_WINSUPPORT
N#endif  // RADIO_H
N
N/*************************** End of file ****************************/
L 75 "..\..\..\..\ThirdParty\emWin\Include\DIALOG.h" 2
N#include "ROTARY.h"
L 1 "..\..\..\..\ThirdParty\emWin\Include\ROTARY.h" 1
N/*********************************************************************
N*                    SEGGER Microcontroller GmbH                     *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2023  SEGGER Microcontroller GmbH                *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V6.46 - Graphical user interface for embedded applications **
NemWin is protected by international copyright laws. Knowledge of the
Nsource code may not be used to write a similar product. 
NThis file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed by SEGGER Software GmbH to Nuvoton Technology Corporation
Nat the address: No. 4, Creation Rd. III, Hsinchu Science Park, Taiwan
Nfor the purposes  of  creating  libraries  for its 
NArm Cortex-A, Arm Cortex-M and  Arm9 32-bit microcontrollers, commercialized and distributed by Nuvoton Technology Corporation
Nunder  the terms and conditions  of  an  End  User  
NLicense  Agreement  supplied  with  the libraries.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NLicensing information
NLicensor:                 SEGGER Software GmbH
NLicensed to:              Nuvoton Technology Corporation, No. 4, Creation Rd. III, Hsinchu Science Park, 30077 Hsinchu City, Taiwan
NLicensed SEGGER software: emWin
NLicense number:           GUI-00735
NLicense model:            emWin License Agreement, signed February 27, 2018
NLicensed platform:        Cortex-M, Cortex-A, and ARM9 32-bit series microcontroller designed and manufactured by Nuvoton Technology Corporation.
N----------------------------------------------------------------------
NSupport and Update Agreement (SUA)
NSUA period:               2018-03-26 - 2025-09-04
NContact to extend SUA:    sales@segger.com
N----------------------------------------------------------------------
NFile        : ROTARY.h
NPurpose     : ROTARY include
N--------------------END-OF-HEADER-------------------------------------
N*/
N
N#ifndef ROTARY_H
N#define ROTARY_H
N
N#include "WM.h"
N#include "DIALOG_Type.h"      // Req. for Create indirect data structure
N#include "WIDGET.h"
N
N#if (GUI_SUPPORT_MEMDEV && GUI_WINSUPPORT)
X#if (1 && 1)
N
N#if defined(__cplusplus)
X#if 0L
S  extern "C" {                  // Make sure we have C-declarations in C++ programs
N#endif
N
N/*********************************************************************
N*
N*       Public Types
N*
N**********************************************************************
N*/
Ntypedef WM_HMEM ROTARY_Handle;
Xtypedef signed long ROTARY_Handle;
N
N/*********************************************************************
N*
N*       Create functions
N*
N**********************************************************************
N*/
NROTARY_Handle ROTARY_CreateEx      (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int Id);
XROTARY_Handle ROTARY_CreateEx      (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int WinFlags, int Id);
NROTARY_Handle ROTARY_CreateUser    (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int Id, int NumExtraBytes);
XROTARY_Handle ROTARY_CreateUser    (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int WinFlags, int Id, int NumExtraBytes);
NROTARY_Handle ROTARY_CreateIndirect(const GUI_WIDGET_CREATE_INFO * pCreateInfo, WM_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
XROTARY_Handle ROTARY_CreateIndirect(const GUI_WIDGET_CREATE_INFO * pCreateInfo, GUI_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
N
N/*********************************************************************
N*
N*       The callback ...
N*
N* Do not call it directly ! It is only to be used from within an
N* overwritten callback.
N*/
Nvoid ROTARY_Callback(WM_MESSAGE * pMsg);
N
N/*********************************************************************
N*
N*       Member functions
N*
N**********************************************************************
N*/
Nvoid ROTARY_AddValue     (ROTARY_Handle hObj, I32 Delta);
Xvoid ROTARY_AddValue     (ROTARY_Handle hObj, signed long Delta);
Nvoid ROTARY_AddAngle     (ROTARY_Handle hObj, I32 Delta);
Xvoid ROTARY_AddAngle     (ROTARY_Handle hObj, signed long Delta);
Nvoid ROTARY_EnableLQ     (ROTARY_Handle hObj, int OnOff);
NI32  ROTARY_GetAngle     (ROTARY_Handle hObj);
Xsigned long  ROTARY_GetAngle     (ROTARY_Handle hObj);
Nint  ROTARY_GetImageSize (ROTARY_Handle hObj, int * pxSize, int * pySize);
Nint  ROTARY_GetMarkerSize(ROTARY_Handle hObj, int * pxSize, int * pySize);
Nint  ROTARY_GetUserData  (ROTARY_Handle hObj, void * pDest, int NumBytes);
NI32  ROTARY_GetValue     (ROTARY_Handle hObj);
Xsigned long  ROTARY_GetValue     (ROTARY_Handle hObj);
Nvoid ROTARY_SetAlign     (ROTARY_Handle hObj, int Align, int xOff, int yOff);
Nvoid ROTARY_SetAngle     (ROTARY_Handle hObj, I32 Pos);
Xvoid ROTARY_SetAngle     (ROTARY_Handle hObj, signed long Pos);
Nvoid ROTARY_SetBitmap    (ROTARY_Handle hObj, const GUI_BITMAP * pBitmap);
Nvoid ROTARY_SetBitmapObj (ROTARY_Handle hObj, GUI_DRAW_HANDLE hDrawObj);
Nvoid ROTARY_SetDoRotate  (ROTARY_Handle hObj, U8 DoRotate);
Xvoid ROTARY_SetDoRotate  (ROTARY_Handle hObj, unsigned char DoRotate);
Nvoid ROTARY_SetMarker    (ROTARY_Handle hObj, const GUI_BITMAP * pBitmap, int Radius, I32 AngleOffset, U8 DoRotate);
Xvoid ROTARY_SetMarker    (ROTARY_Handle hObj, const GUI_BITMAP * pBitmap, int Radius, signed long AngleOffset, unsigned char DoRotate);
Nvoid ROTARY_SetMarkerObj (ROTARY_Handle hObj, GUI_DRAW_HANDLE hDrawObjMarker, GUI_DRAW_HANDLE hDrawObjMarkerHR, int Radius, I32 Offset, U8 DoRotate);
Xvoid ROTARY_SetMarkerObj (ROTARY_Handle hObj, GUI_DRAW_HANDLE hDrawObjMarker, GUI_DRAW_HANDLE hDrawObjMarkerHR, int Radius, signed long Offset, unsigned char DoRotate);
Nvoid ROTARY_SetOffset    (ROTARY_Handle hObj, int Offset);
Nvoid ROTARY_SetPeriod    (ROTARY_Handle hObj, I32 Period);
Xvoid ROTARY_SetPeriod    (ROTARY_Handle hObj, signed long Period);
Nvoid ROTARY_SetRadius    (ROTARY_Handle hObj, int Radius);
Nvoid ROTARY_SetRange     (ROTARY_Handle hObj, U32 AngPositive, U32 AngNegative);
Xvoid ROTARY_SetRange     (ROTARY_Handle hObj, unsigned long AngPositive, unsigned long AngNegative);
Nvoid ROTARY_SetSnap      (ROTARY_Handle hObj, I32 Snap);
Xvoid ROTARY_SetSnap      (ROTARY_Handle hObj, signed long Snap);
Nvoid ROTARY_SetTickSize  (ROTARY_Handle hObj, I32 TickSize);
Xvoid ROTARY_SetTickSize  (ROTARY_Handle hObj, signed long TickSize);
Nint  ROTARY_SetUserData  (ROTARY_Handle hObj, const void * pSrc, int NumBytes);
Nvoid ROTARY_SetValue     (ROTARY_Handle hObj, I32 Value);
Xvoid ROTARY_SetValue     (ROTARY_Handle hObj, signed long Value);
Nint  ROTARY_SetValueRange(ROTARY_Handle hObj, I32 Min, I32 Max);
Xint  ROTARY_SetValueRange(ROTARY_Handle hObj, signed long Min, signed long Max);
N
N/*********************************************************************
N*
N*       Global functions
N*
N**********************************************************************
N*/
N
N#if defined(__cplusplus)
X#if 0L
S  }
N#endif
N
N#endif  // (GUI_SUPPORT_MEMDEV && GUI_WINSUPPORT)
N#endif  // ROTARY_H
N
N/*************************** End of file ****************************/
L 76 "..\..\..\..\ThirdParty\emWin\Include\DIALOG.h" 2
N#include "SCROLLBAR.h"
N#include "SCROLLER.h"
L 1 "..\..\..\..\ThirdParty\emWin\Include\SCROLLER.h" 1
N/*********************************************************************
N*                    SEGGER Microcontroller GmbH                     *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2023  SEGGER Microcontroller GmbH                *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V6.46 - Graphical user interface for embedded applications **
NemWin is protected by international copyright laws. Knowledge of the
Nsource code may not be used to write a similar product. 
NThis file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed by SEGGER Software GmbH to Nuvoton Technology Corporation
Nat the address: No. 4, Creation Rd. III, Hsinchu Science Park, Taiwan
Nfor the purposes  of  creating  libraries  for its 
NArm Cortex-A, Arm Cortex-M and  Arm9 32-bit microcontrollers, commercialized and distributed by Nuvoton Technology Corporation
Nunder  the terms and conditions  of  an  End  User  
NLicense  Agreement  supplied  with  the libraries.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NLicensing information
NLicensor:                 SEGGER Software GmbH
NLicensed to:              Nuvoton Technology Corporation, No. 4, Creation Rd. III, Hsinchu Science Park, 30077 Hsinchu City, Taiwan
NLicensed SEGGER software: emWin
NLicense number:           GUI-00735
NLicense model:            emWin License Agreement, signed February 27, 2018
NLicensed platform:        Cortex-M, Cortex-A, and ARM9 32-bit series microcontroller designed and manufactured by Nuvoton Technology Corporation.
N----------------------------------------------------------------------
NSupport and Update Agreement (SUA)
NSUA period:               2018-03-26 - 2025-09-04
NContact to extend SUA:    sales@segger.com
N----------------------------------------------------------------------
NFile        : SCROLLER.h
NPurpose     : SCROLLER include
N--------------------END-OF-HEADER-------------------------------------
N*/
N
N#ifndef SCROLLER_H
N#define SCROLLER_H
N
N#include "WM.h"
N#include "DIALOG_Type.h"      /* Req. for Create indirect data structure */
N#include "WIDGET.h"
N
N#if GUI_WINSUPPORT
X#if 1
N
N#if defined(__cplusplus)
X#if 0L
S  extern "C" {     /* Make sure we have C-declarations in C++ programs */
N#endif
N
N/*********************************************************************
N*
N*       Defines
N*
N**********************************************************************
N*/
N/*********************************************************************
N*
N*       SCROLLER color indexes
N*
N*  Description
N*    Color indexes for SCROLLER widgets.
N*/
N#define SCROLLER_CI_ACTIVE     0    // Color for active state (when the scroller is moving or receives touch input).
N#define SCROLLER_CI_INACTIVE   1    // Color for inactive state.
N
N/*********************************************************************
N*
N*       SCROLLER period indexes
N*
N*  Description
N*    Period indexes for SCROLLER widgets.
N*/
N#define SCROLLER_PI_FADE_IN       0    // The length in ms for fading in, from inactive to active color.
N#define SCROLLER_PI_FADE_OUT      1    // The length in ms for fading out, from active color to inactive color.
N#define SCROLLER_PI_INACTIVE      2    // Period it takes from releasing the widget until the fade operation is started.
N#define SCROLLER_PI_ANIM_SCROLL   3    // Period for animating the changing of the scroll state when the SCROLLER was moved by touch.
N
N/*********************************************************************
N*
N*       SCROLLER alignment indexes
N*
N*  Description
N*    Alignment indexes for SCROLLER widgets.
N*/
N#define SCROLLER_AI_WIDGETPOS   0   // The alignment of the SCROLLER widget within its parent widget (left or right, bottom or top).
N#define SCROLLER_AI_THUMB       1   // The alignment of the thumb rectangle within the SCROLLER widget.\n
N                                    // Allowed values for vertical SCROLLERs:\n
N                                    // GUI_ALIGN_LEFT, GUI_ALIGN_HCENTER, GUI_ALIGN_RIGHT\n
N                                    // Allowed values for horizontal SCROLLERs:\n
N                                    // GUI_ALIGN_TOP, GUI_ALIGN_VCENTER, GUI_ALIGN_BOTTOM
N
N/*********************************************************************
N*
N*       SCROLLER animation indexes
N*
N*  Description
N*    Animation indexes used for SCROLLER_SetAnimEase().
N*/
N#define SCROLLER_ANIM_FADE    0     // Animation for fading between the active and inactive state.
N#define SCROLLER_ANIM_SCROLL  1     // Animation for animating the scroll state when the SCROLLER was clicked outside of the thumb
N                                    // rectangle.
N
N/*********************************************************************
N*
N*       SCROLLER create flags
N*
N*  Description
N*    Create flags for SCROLLER widgets.
N*/
N#define SCROLLER_CF_FADING                  (1 << 0)     // Enables automatic fading between the active and inactive state of the SCROLLER.
N#define SCROLLER_CF_TOUCH                   (1 << 1)     // Enables touch input for the SCROLLER.
N#define SCROLLER_CF_VERTICAL                (1 << 3)     // Creates a vertical SCROLLER.
N#define SCROLLER_CF_HORIZONTAL              (0 << 3)     // Creates a horizontal SCROLLER.
N
N/*********************************************************************
N*
N*       Types
N*
N**********************************************************************
N*/
Ntypedef WM_HMEM SCROLLER_Handle;
Xtypedef signed long SCROLLER_Handle;
N
N/*********************************************************************
N*
N*       SCROLLER_INTERFACE_API
N*
N*  Description
N*    Interface API between the SCROLLER and its parent widget.
N* 
N*    This structure is only needed when attaching SCROLLERs to custom
N*    widgets or windows.
N* 
N*    See also the function SCROLLER_SetInterfaceAPI().
N*/
Ntypedef struct {
N  void (* pfUpdateScrollPos)(WM_HWIN hParent, SCROLLER_Handle hScroller);                                  // Routine for setting the scroll state of the parent widget to the SCROLLER.
X  void (* pfUpdateScrollPos)(GUI_HWIN hParent, SCROLLER_Handle hScroller);                                  
N  void (* pfScrollerAdded)  (WM_HWIN hParent, SCROLLER_Handle hScroller);                                  // Routine that is called when the parent receives the WM_NOTIFY_PARENT message
X  void (* pfScrollerAdded)  (GUI_HWIN hParent, SCROLLER_Handle hScroller);                                  
N                                                                                                           // with a WM_NOTIFICATION_SCROLLER_ADDED notification.
N  void (* pfValueChanged)   (WM_HWIN hParent, SCROLLER_Handle hScroller, WM_SCROLL_STATE * pNewState);     // Routine that is called when the parent receives the WM_NOTIFY_PARENT message
X  void (* pfValueChanged)   (GUI_HWIN hParent, SCROLLER_Handle hScroller, WM_SCROLL_STATE * pNewState);     
N                                                                                                           // with a WM_NOTIFICATION_VALUE_CHANGED notification sent by SCROLLER widgets.
N                                                                                                           // This routine sets the new scroll state of the SCROLLER to the parent widget.
N  void (* pfGetContentRect) (WM_HWIN hParent, GUI_RECT * pRect);                                           // Routine for retrieving the content rectangle of the parent, called when parent
X  void (* pfGetContentRect) (GUI_HWIN hParent, GUI_RECT * pRect);                                           
N                                                                                                           // receives a WM_GET_CONTENT_RECT message.
N} SCROLLER_INTERFACE_API;
N
N/*********************************************************************
N*
N*       Create functions
N*
N**********************************************************************
N*/
NSCROLLER_Handle SCROLLER_CreateAttached(WM_HWIN hParent, int ExFlags);
XSCROLLER_Handle SCROLLER_CreateAttached(GUI_HWIN hParent, int ExFlags);
NSCROLLER_Handle SCROLLER_CreateIndirect(const GUI_WIDGET_CREATE_INFO * pCreateInfo, WM_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
XSCROLLER_Handle SCROLLER_CreateIndirect(const GUI_WIDGET_CREATE_INFO * pCreateInfo, GUI_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
NSCROLLER_Handle SCROLLER_CreateUser    (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int ExFlags, int Id, int NumExtraBytes);
XSCROLLER_Handle SCROLLER_CreateUser    (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int WinFlags, int ExFlags, int Id, int NumExtraBytes);
N
N/*********************************************************************
N*
N*       Macros
N*
N**********************************************************************
N*/
N#define SCROLLER_SetScrollState   WM_SetScrollState
N#define SCROLLER_GetScrollState   WM_GetScrollState
N
N/*********************************************************************
N*
N*       The callback ...
N*
N* Do not call it directly ! It is only to be used from within an
N* overwritten callback.
N*/
Nvoid SCROLLER_Callback(WM_MESSAGE * pMsg);
N
N/*********************************************************************
N*
N*       Member functions
N*
N**********************************************************************
N*/
Nvoid                 SCROLLER_AttachToWindow  (SCROLLER_Handle hObj, WM_HWIN hNewParent);
Xvoid                 SCROLLER_AttachToWindow  (SCROLLER_Handle hObj, GUI_HWIN hNewParent);
Nvoid                 SCROLLER_EnableAutoResize(int EnableAutoResize, int Vertical);
Nvoid                 SCROLLER_EnableFade      (SCROLLER_Handle hObj, U8 OnOff);
Xvoid                 SCROLLER_EnableFade      (SCROLLER_Handle hObj, unsigned char OnOff);
Nvoid                 SCROLLER_EnableTouch     (SCROLLER_Handle hObj, U8 OnOff);
Xvoid                 SCROLLER_EnableTouch     (SCROLLER_Handle hObj, unsigned char OnOff);
Nvoid                 SCROLLER_PreventIntersect(int Enable);
N//
N// Custom management
N//
Nint                  SCROLLER_OwnerDraw       (const WIDGET_ITEM_DRAW_INFO * pDrawItemInfo);
Nint                  SCROLLER_ParentMsgHandler(WM_MESSAGE * pMsg);
Nvoid                 SCROLLER_SetInterfaceAPI (SCROLLER_Handle hObj, const SCROLLER_INTERFACE_API * pAPI);
Nvoid                 SCROLLER_SetState        (SCROLLER_Handle hObj, U8 Active, U8 NoTimer);
Xvoid                 SCROLLER_SetState        (SCROLLER_Handle hObj, unsigned char Active, unsigned char NoTimer);
Nvoid                 SCROLLER_SetContentRect  (SCROLLER_Handle hObj, const GUI_RECT * pRect);
N//
N// Properties (getters)
N//
NU8                   SCROLLER_GetAlign        (SCROLLER_Handle hObj, unsigned int AlignIndex);
Xunsigned char                   SCROLLER_GetAlign        (SCROLLER_Handle hObj, unsigned int AlignIndex);
NI16                  SCROLLER_GetAlignOffset  (SCROLLER_Handle hObj);
Xsigned short                  SCROLLER_GetAlignOffset  (SCROLLER_Handle hObj);
NGUI_ANIM_GETPOS_FUNC SCROLLER_GetAnimEase     (SCROLLER_Handle hObj, unsigned int AnimIndex);
NGUI_COLOR            SCROLLER_GetBkColor      (SCROLLER_Handle hObj, unsigned int ColorIndex);
NGUI_COLOR            SCROLLER_GetColor        (SCROLLER_Handle hObj, unsigned int ColorIndex);
Nint                  SCROLLER_GetPeriod       (SCROLLER_Handle hObj, unsigned int PeriodIndex);
NI16                  SCROLLER_GetRadius       (SCROLLER_Handle hObj);
Xsigned short                  SCROLLER_GetRadius       (SCROLLER_Handle hObj);
NI16                  SCROLLER_GetSize         (SCROLLER_Handle hObj);
Xsigned short                  SCROLLER_GetSize         (SCROLLER_Handle hObj);
NI16                  SCROLLER_GetSpacing      (SCROLLER_Handle hObj);
Xsigned short                  SCROLLER_GetSpacing      (SCROLLER_Handle hObj);
Nvoid                 SCROLLER_GetThumbRect    (SCROLLER_Handle hObj, GUI_RECT * pRect);
NI16                  SCROLLER_GetThumbSizeMin (SCROLLER_Handle hObj);
Xsigned short                  SCROLLER_GetThumbSizeMin (SCROLLER_Handle hObj);
Nint                  SCROLLER_GetUserData     (SCROLLER_Handle hObj, void * pDest, int NumBytes);
N//
N// Properties (setters)
N//
Nvoid                 SCROLLER_SetAlign        (SCROLLER_Handle hObj, unsigned int AlignIndex, U8 Align);
Xvoid                 SCROLLER_SetAlign        (SCROLLER_Handle hObj, unsigned int AlignIndex, unsigned char Align);
Nvoid                 SCROLLER_SetAlignOffset  (SCROLLER_Handle hObj, I16 Offset);
Xvoid                 SCROLLER_SetAlignOffset  (SCROLLER_Handle hObj, signed short Offset);
Nvoid                 SCROLLER_SetAnimEase     (SCROLLER_Handle hObj, unsigned int AnimIndex, GUI_ANIM_GETPOS_FUNC pfEase);
Nvoid                 SCROLLER_SetBkColor      (SCROLLER_Handle hObj, unsigned int ColorIndex, GUI_COLOR BkColor);
Nvoid                 SCROLLER_SetColor        (SCROLLER_Handle hObj, unsigned int ColorIndex, GUI_COLOR Color);
Nvoid                 SCROLLER_SetOwnerDraw    (SCROLLER_Handle hObj, WIDGET_DRAW_ITEM_FUNC * pfDrawItem);
Nvoid                 SCROLLER_SetPeriod       (SCROLLER_Handle hObj, unsigned int PeriodIndex, int Period);
Nvoid                 SCROLLER_SetRadius       (SCROLLER_Handle hObj, I16 Radius);
Xvoid                 SCROLLER_SetRadius       (SCROLLER_Handle hObj, signed short Radius);
Nvoid                 SCROLLER_SetSize         (SCROLLER_Handle hObj, I16 Size);
Xvoid                 SCROLLER_SetSize         (SCROLLER_Handle hObj, signed short Size);
Nvoid                 SCROLLER_SetSpacing      (SCROLLER_Handle hObj, I16 Spacing);
Xvoid                 SCROLLER_SetSpacing      (SCROLLER_Handle hObj, signed short Spacing);
Nvoid                 SCROLLER_SetThumbSizeMin (SCROLLER_Handle hObj, I16 ThumbSize);
Xvoid                 SCROLLER_SetThumbSizeMin (SCROLLER_Handle hObj, signed short ThumbSize);
Nint                  SCROLLER_SetUserData     (SCROLLER_Handle hObj, const void * pSrc, int NumBytes);
N
N/*********************************************************************
N*
N*       Default values
N*
N**********************************************************************
N*/
N//
N// Default properties (getters)
N//
NU8                   SCROLLER_GetDefaultAlign       (unsigned int AlignIndex);
Xunsigned char                   SCROLLER_GetDefaultAlign       (unsigned int AlignIndex);
NI16                  SCROLLER_GetDefaultAlignOffset (void);
Xsigned short                  SCROLLER_GetDefaultAlignOffset (void);
NGUI_ANIM_GETPOS_FUNC SCROLLER_GetDefaultAnimEase    (unsigned int AnimIndex);
NGUI_COLOR            SCROLLER_GetDefaultBkColor     (unsigned int ColorIndex);
NGUI_COLOR            SCROLLER_GetDefaultColor       (unsigned int ColorIndex);
Nint                  SCROLLER_GetDefaultPeriod      (unsigned int PeriodIndex);
NI16                  SCROLLER_GetDefaultRadius      (void);
Xsigned short                  SCROLLER_GetDefaultRadius      (void);
NI16                  SCROLLER_GetDefaultThumbSizeMin(void);
Xsigned short                  SCROLLER_GetDefaultThumbSizeMin(void);
NI16                  SCROLLER_GetDefaultSize        (void);
Xsigned short                  SCROLLER_GetDefaultSize        (void);
NI16                  SCROLLER_GetDefaultSpacing     (void);
Xsigned short                  SCROLLER_GetDefaultSpacing     (void);
N//
N// Default properties (setters)
N//
Nvoid                 SCROLLER_SetDefaultAlign       (unsigned int AlignIndex, U8 Align);
Xvoid                 SCROLLER_SetDefaultAlign       (unsigned int AlignIndex, unsigned char Align);
Nvoid                 SCROLLER_SetDefaultAlignOffset (I16 Offset);
Xvoid                 SCROLLER_SetDefaultAlignOffset (signed short Offset);
Nvoid                 SCROLLER_SetDefaultAnimEase    (unsigned int AnimIndex, GUI_ANIM_GETPOS_FUNC pfEase);
Nvoid                 SCROLLER_SetDefaultBkColor     (unsigned int ColorIndex, GUI_COLOR BkColor);
Nvoid                 SCROLLER_SetDefaultColor       (unsigned int ColorIndex, GUI_COLOR Color);
Nvoid                 SCROLLER_SetDefaultPeriod      (unsigned int PeriodIndex, int Period);
Nvoid                 SCROLLER_SetDefaultRadius      (I16 Radius);
Xvoid                 SCROLLER_SetDefaultRadius      (signed short Radius);
Nvoid                 SCROLLER_SetDefaultThumbSizeMin(I16 ThumbSize);
Xvoid                 SCROLLER_SetDefaultThumbSizeMin(signed short ThumbSize);
Nvoid                 SCROLLER_SetDefaultSize        (I16 Size);
Xvoid                 SCROLLER_SetDefaultSize        (signed short Size);
Nvoid                 SCROLLER_SetDefaultSpacing     (I16 Spacing);
Xvoid                 SCROLLER_SetDefaultSpacing     (signed short Spacing);
N
N#if defined(__cplusplus)
X#if 0L
S  }
N#endif
N
N#endif  // GUI_WINSUPPORT
N#endif  // SCROLLER_H
N
N/*************************** End of file ****************************/
L 78 "..\..\..\..\ThirdParty\emWin\Include\DIALOG.h" 2
N#include "SLIDER.h"
L 1 "..\..\..\..\ThirdParty\emWin\Include\SLIDER.h" 1
N/*********************************************************************
N*                    SEGGER Microcontroller GmbH                     *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2023  SEGGER Microcontroller GmbH                *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V6.46 - Graphical user interface for embedded applications **
NemWin is protected by international copyright laws. Knowledge of the
Nsource code may not be used to write a similar product. 
NThis file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed by SEGGER Software GmbH to Nuvoton Technology Corporation
Nat the address: No. 4, Creation Rd. III, Hsinchu Science Park, Taiwan
Nfor the purposes  of  creating  libraries  for its 
NArm Cortex-A, Arm Cortex-M and  Arm9 32-bit microcontrollers, commercialized and distributed by Nuvoton Technology Corporation
Nunder  the terms and conditions  of  an  End  User  
NLicense  Agreement  supplied  with  the libraries.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NLicensing information
NLicensor:                 SEGGER Software GmbH
NLicensed to:              Nuvoton Technology Corporation, No. 4, Creation Rd. III, Hsinchu Science Park, 30077 Hsinchu City, Taiwan
NLicensed SEGGER software: emWin
NLicense number:           GUI-00735
NLicense model:            emWin License Agreement, signed February 27, 2018
NLicensed platform:        Cortex-M, Cortex-A, and ARM9 32-bit series microcontroller designed and manufactured by Nuvoton Technology Corporation.
N----------------------------------------------------------------------
NSupport and Update Agreement (SUA)
NSUA period:               2018-03-26 - 2025-09-04
NContact to extend SUA:    sales@segger.com
N----------------------------------------------------------------------
NFile        : SLIDER.h
NPurpose     : SLIDER include
N--------------------END-OF-HEADER-------------------------------------
N*/
N
N#ifndef SLIDER_H
N#define SLIDER_H
N
N#include "WM.h"
N#include "DIALOG_Type.h"      /* Req. for Create indirect data structure */
N#include "WIDGET.h"
N
N#if GUI_WINSUPPORT
X#if 1
N
N#if defined(__cplusplus)
X#if 0L
S  extern "C" {     /* Make sure we have C-declarations in C++ programs */
N#endif
N
N/************************************************************
N*
N*       Defines
N*
N*************************************************************
N*/
N/************************************************************
N*
N*       States
N*/
N#define SLIDER_STATE_PRESSED    WIDGET_STATE_USER0
N
N/************************************************************
N*
N*       Create / Status flags
N*/
N#define SLIDER_CF_HORIZONTAL 0
N#define SLIDER_CF_VERTICAL   WIDGET_CF_VERTICAL
N
N/************************************************************
N*
N*       Skinning property indices
N*/
N#define SLIDER_SKINFLEX_PI_PRESSED   0
N#define SLIDER_SKINFLEX_PI_UNPRESSED 1
N
N/*********************************************************************
N*
N*       Public Types
N*
N**********************************************************************
N*/
Ntypedef WM_HMEM SLIDER_Handle;
Xtypedef signed long SLIDER_Handle;
N
Ntypedef struct {
N  GUI_COLOR aColorFrame[2];
N  GUI_COLOR aColorInner[2];
N  GUI_COLOR aColorShaft[3];
N  GUI_COLOR ColorTick;
N  GUI_COLOR ColorFocus;
N  int TickSize;
N  int ShaftSize;
N} SLIDER_SKINFLEX_PROPS;
N
Ntypedef struct {
N  int Width;
N  int NumTicks;
N  int Size;
N  int IsPressed;
N  int IsVertical;
N} SLIDER_SKINFLEX_INFO;
N
N/*********************************************************************
N*
N*       Create functions
N*
N**********************************************************************
N*/
NSLIDER_Handle SLIDER_Create        (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int Id, int WinFlags, int SpecialFlags);
XSLIDER_Handle SLIDER_Create        (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int Id, int WinFlags, int SpecialFlags);
NSLIDER_Handle SLIDER_CreateEx      (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int ExFlags, int Id);
XSLIDER_Handle SLIDER_CreateEx      (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int WinFlags, int ExFlags, int Id);
NSLIDER_Handle SLIDER_CreateUser    (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int ExFlags, int Id, int NumExtraBytes);
XSLIDER_Handle SLIDER_CreateUser    (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int WinFlags, int ExFlags, int Id, int NumExtraBytes);
NSLIDER_Handle SLIDER_CreateIndirect(const GUI_WIDGET_CREATE_INFO * pCreateInfo, WM_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
XSLIDER_Handle SLIDER_CreateIndirect(const GUI_WIDGET_CREATE_INFO * pCreateInfo, GUI_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
N
N/*********************************************************************
N*
N*       The callback ...
N*
N* Do not call it directly ! It is only to be used from within an
N* overwritten callback.
N*/
Nvoid SLIDER_Callback(WM_MESSAGE * pMsg);
N
N/*********************************************************************
N*
N*       Member functions
N*
N**********************************************************************
N*/
Nvoid      SLIDER_Dec            (SLIDER_Handle hObj);
Nvoid      SLIDER_EnableFocusRect(SLIDER_Handle hObj, int OnOff);
NGUI_COLOR SLIDER_GetBarColor    (SLIDER_Handle hObj);
NGUI_COLOR SLIDER_GetBkColor     (SLIDER_Handle hObj);
NU8        SLIDER_GetFlag        (SLIDER_Handle hObj, U8 Flag);
Xunsigned char        SLIDER_GetFlag        (SLIDER_Handle hObj, unsigned char Flag);
NGUI_COLOR SLIDER_GetFocusColor  (SLIDER_Handle hObj);
Nvoid      SLIDER_GetRange       (SLIDER_Handle hObj, int * pMin, int * pMax);
NGUI_COLOR SLIDER_GetTickColor   (SLIDER_Handle hObj);
Nint       SLIDER_GetUserData    (SLIDER_Handle hObj, void * pDest, int NumBytes);
Nint       SLIDER_GetValue       (SLIDER_Handle hObj);
Nvoid      SLIDER_Inc            (SLIDER_Handle hObj);
Nvoid      SLIDER_SetBarColor    (SLIDER_Handle hObj, GUI_COLOR Color);
Nvoid      SLIDER_SetBkColor     (SLIDER_Handle hObj, GUI_COLOR Color);
NGUI_COLOR SLIDER_SetFocusColor  (SLIDER_Handle hObj, GUI_COLOR Color);
Nvoid      SLIDER_SetInvertDir   (SLIDER_Handle hObj, int OnOff);
Nvoid      SLIDER_SetNumTicks    (SLIDER_Handle hObj, int NumTicks);
Nvoid      SLIDER_SetRange       (SLIDER_Handle hObj, int Min, int Max);
Nvoid      SLIDER_SetTickColor   (SLIDER_Handle hObj, GUI_COLOR Color);
Nint       SLIDER_SetUserData    (SLIDER_Handle hObj, const void * pSrc, int NumBytes);
Nvoid      SLIDER_SetValue       (SLIDER_Handle hObj, int v);
Nvoid      SLIDER_SetWidth       (SLIDER_Handle hObj, int Width);
N
N/*********************************************************************
N*
N*       Member functions: Skinning
N*
N**********************************************************************
N*/
Nvoid SLIDER_GetSkinFlexProps     (SLIDER_SKINFLEX_PROPS * pProps, int Index);
Nvoid SLIDER_SetSkinClassic       (SLIDER_Handle hObj);
Nvoid SLIDER_SetSkin              (SLIDER_Handle hObj, WIDGET_DRAW_ITEM_FUNC * pfDrawSkin);
Nint  SLIDER_DrawSkinFlex         (const WIDGET_ITEM_DRAW_INFO * pDrawItemInfo);
Nvoid SLIDER_SetSkinFlexProps     (const SLIDER_SKINFLEX_PROPS * pProps, int Index);
Nvoid SLIDER_SetDefaultSkinClassic(void);
NWIDGET_DRAW_ITEM_FUNC * SLIDER_SetDefaultSkin(WIDGET_DRAW_ITEM_FUNC * pfDrawSkin);
N
N#define SLIDER_SKIN_FLEX    SLIDER_DrawSkinFlex
N
N/*********************************************************************
N*
N*       Managing default values
N*
N**********************************************************************
N*/
NGUI_COLOR SLIDER_GetDefaultBkColor   (void);
NGUI_COLOR SLIDER_GetDefaultBarColor  (void);
NGUI_COLOR SLIDER_GetDefaultFocusColor(void);
NGUI_COLOR SLIDER_GetDefaultTickColor (void);
Nvoid      SLIDER_SetDefaultBkColor   (GUI_COLOR Color);
Nvoid      SLIDER_SetDefaultBarColor  (GUI_COLOR Color);
NGUI_COLOR SLIDER_SetDefaultFocusColor(GUI_COLOR Color);
Nvoid      SLIDER_SetDefaultTickColor (GUI_COLOR Color);
N
N#if defined(__cplusplus)
X#if 0L
S  }
N#endif
N
N#endif  // GUI_WINSUPPORT
N#endif  // SLIDER_H
N
N/*************************** End of file ****************************/
L 79 "..\..\..\..\ThirdParty\emWin\Include\DIALOG.h" 2
N#include "SPINBOX.h"
L 1 "..\..\..\..\ThirdParty\emWin\Include\SPINBOX.h" 1
N/*********************************************************************
N*                    SEGGER Microcontroller GmbH                     *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2023  SEGGER Microcontroller GmbH                *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V6.46 - Graphical user interface for embedded applications **
NemWin is protected by international copyright laws. Knowledge of the
Nsource code may not be used to write a similar product. 
NThis file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed by SEGGER Software GmbH to Nuvoton Technology Corporation
Nat the address: No. 4, Creation Rd. III, Hsinchu Science Park, Taiwan
Nfor the purposes  of  creating  libraries  for its 
NArm Cortex-A, Arm Cortex-M and  Arm9 32-bit microcontrollers, commercialized and distributed by Nuvoton Technology Corporation
Nunder  the terms and conditions  of  an  End  User  
NLicense  Agreement  supplied  with  the libraries.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NLicensing information
NLicensor:                 SEGGER Software GmbH
NLicensed to:              Nuvoton Technology Corporation, No. 4, Creation Rd. III, Hsinchu Science Park, 30077 Hsinchu City, Taiwan
NLicensed SEGGER software: emWin
NLicense number:           GUI-00735
NLicense model:            emWin License Agreement, signed February 27, 2018
NLicensed platform:        Cortex-M, Cortex-A, and ARM9 32-bit series microcontroller designed and manufactured by Nuvoton Technology Corporation.
N----------------------------------------------------------------------
NSupport and Update Agreement (SUA)
NSUA period:               2018-03-26 - 2025-09-04
NContact to extend SUA:    sales@segger.com
N----------------------------------------------------------------------
NFile        : SPINBOX.h
NPurpose     : SPINBOX header file
N--------------------END-OF-HEADER-------------------------------------
N*/
N
N#ifndef SPINBOX_H
N#define SPINBOX_H
N
N#include "WM.h"
N#include "DIALOG_Type.h" // Required for Create indirect data structure
N#include "WIDGET.h"
N#include "EDIT.h"
N
N#if GUI_WINSUPPORT
X#if 1
N
N#if defined(__cplusplus)
X#if 0L
S  extern "C" {             // Make sure we have C-declarations in C++ programs
N#endif
N
N/*********************************************************************
N*
N*       Defines
N*
N**********************************************************************
N*/
N/*********************************************************************
N*
N*       States
N*/
N#define SPINBOX_STATE_PRESSED(x)     (U8)(1 << (U8)x)    // These flags are stored in (SPINBOX_OBJ->State)        | x must be 0 or 1
N#define SPINBOX_STATE_FOCUS          WIDGET_STATE_FOCUS  // This is read from         (SPINBOX_OBJ->Widget.State)
N
N#define SPINBOX_EDGE_RIGHT           0
N#define SPINBOX_EDGE_LEFT            1
N#define SPINBOX_EDGE_CENTER          2
N
N#define SPINBOX_EM_STEP              0
N#define SPINBOX_EM_EDIT              1
N
N#ifndef SPINBOX_EM_DEFAULT
N  #define SPINBOX_EM_DEFAULT         SPINBOX_EM_STEP
N#endif
N
N/*********************************************************************
N*
N*       Color indices
N*/
N#define SPINBOX_CI_DISABLED          EDIT_CI_DISABLED
N#define SPINBOX_CI_ENABLED           EDIT_CI_ENABLED
N#define SPINBOX_CI_PRESSED           2
N
N/*********************************************************************
N*
N*       SPINBOX timer indexes
N*
N*  Description
N*    Timer indexes used by the routine SPINBOX_SetTimerPeriod().
N*/
N#define SPINBOX_TI_TIMERSTART       0      // Time it takes to start auto increase/decrease of its value.
N#define SPINBOX_TI_TIMERINC         1      // Time between two increments/decrements.
N
N/*********************************************************************
N*
N*       Skinning property indices
N*/
N#define SPINBOX_SKIN_FLEX            SPINBOX_DrawSkinFlex
N
N#define SPINBOX_SKINFLEX_PI_PRESSED  0
N#define SPINBOX_SKINFLEX_PI_FOCUSED  1
N#define SPINBOX_SKINFLEX_PI_ENABLED  2
N#define SPINBOX_SKINFLEX_PI_DISABLED 3
N#define SPINBOX_SKIN_FLEX_RADIUS     2
N
N/*********************************************************************
N*
N*       Public Types
N*
N**********************************************************************
N*/
Ntypedef WM_HMEM SPINBOX_Handle;
Xtypedef signed long SPINBOX_Handle;
N
Ntypedef struct {
N  GUI_COLOR aColorFrame[2];   // [0] Outer color of surrounding frame.         [1] Inner color of surrounding frame.
N  GUI_COLOR aColorUpper[2];   // [0] Upper color of gradient for upper button. [1] Lower color of gradient for upper button.
N  GUI_COLOR aColorLower[2];   // [0] Upper color of gradient for lower button. [1] Lower color of gradient for lower button.
N  GUI_COLOR ColorArrow;       // Color of the button arrow.
N  GUI_COLOR ColorBk;          // Color of the background.                      // See WIDGET_ITEM_CREATE in SPINBOX_DrawSkinFlex()
N  GUI_COLOR ColorText;        // Color of the text.                            // See WIDGET_ITEM_CREATE in SPINBOX_DrawSkinFlex()
N  GUI_COLOR ColorButtonFrame; // Color of the button frame.
N} SPINBOX_SKINFLEX_PROPS;
N
N/*********************************************************************
N*
N*       Prototypes
N*
N**********************************************************************
N*/
N/*********************************************************************
N*
N*       Creation
N*/
NSPINBOX_Handle SPINBOX_CreateEx      (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int Id, int Min, int Max);
XSPINBOX_Handle SPINBOX_CreateEx      (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int WinFlags, int Id, int Min, int Max);
NSPINBOX_Handle SPINBOX_CreateUser    (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int Id, int Min, int Max, int NumExtraBytes);
XSPINBOX_Handle SPINBOX_CreateUser    (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int WinFlags, int Id, int Min, int Max, int NumExtraBytes);
NSPINBOX_Handle SPINBOX_CreateIndirect(const GUI_WIDGET_CREATE_INFO * pCreateInfo, WM_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
XSPINBOX_Handle SPINBOX_CreateIndirect(const GUI_WIDGET_CREATE_INFO * pCreateInfo, GUI_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
N
N/*********************************************************************
N*
N*       Callback, should be called only from within a custom callback.
N*/
Nvoid           SPINBOX_Callback(WM_MESSAGE * pMsg);
N
N/*********************************************************************
N*
N*       Get / Set properties
N*/
Nvoid             SPINBOX_EnableBlink     (SPINBOX_Handle hObj, int Period, int OnOff);
NGUI_COLOR        SPINBOX_GetBkColor      (SPINBOX_Handle hObj, unsigned int Index);
NGUI_COLOR        SPINBOX_GetButtonBkColor(SPINBOX_Handle hObj, unsigned int Index);
NEDIT_Handle      SPINBOX_GetEditHandle   (SPINBOX_Handle hObj);
Nconst GUI_FONT * SPINBOX_GetFont         (SPINBOX_Handle hObj);
Nvoid             SPINBOX_GetRange        (SPINBOX_Handle hObj, I32 * pMin, I32 * pMax);
Xvoid             SPINBOX_GetRange        (SPINBOX_Handle hObj, signed long * pMin, signed long * pMax);
NGUI_COLOR        SPINBOX_GetTextColor    (SPINBOX_Handle hObj, unsigned int Index);
NU32              SPINBOX_GetTimerPeriod  (SPINBOX_Handle hObj, U32 Index);
Xunsigned long              SPINBOX_GetTimerPeriod  (SPINBOX_Handle hObj, unsigned long Index);
Nint              SPINBOX_GetUserData     (SPINBOX_Handle hObj, void * pDest, int NumBytes);
NI32              SPINBOX_GetValue        (SPINBOX_Handle hObj);
Xsigned long              SPINBOX_GetValue        (SPINBOX_Handle hObj);
Nvoid             SPINBOX_SetBkColor      (SPINBOX_Handle hObj, unsigned int Index, GUI_COLOR Color);
Nvoid             SPINBOX_SetButtonBkColor(SPINBOX_Handle hObj, unsigned int Index, GUI_COLOR Color);
Nvoid             SPINBOX_SetButtonSize   (SPINBOX_Handle hObj, unsigned ButtonSize);
Nvoid             SPINBOX_SetEdge         (SPINBOX_Handle hObj, U8 Edge);
Xvoid             SPINBOX_SetEdge         (SPINBOX_Handle hObj, unsigned char Edge);
Nvoid             SPINBOX_SetEditMode     (SPINBOX_Handle hObj, U8 EditMode);
Xvoid             SPINBOX_SetEditMode     (SPINBOX_Handle hObj, unsigned char EditMode);
Nvoid             SPINBOX_SetFont         (SPINBOX_Handle hObj, const GUI_FONT * pFont);
Nvoid             SPINBOX_SetRange        (SPINBOX_Handle hObj, I32 Min, I32 Max);
Xvoid             SPINBOX_SetRange        (SPINBOX_Handle hObj, signed long Min, signed long Max);
NU16              SPINBOX_SetStep         (SPINBOX_Handle hObj, U16 Step);
Xunsigned short              SPINBOX_SetStep         (SPINBOX_Handle hObj, unsigned short Step);
Nvoid             SPINBOX_SetTextColor    (SPINBOX_Handle hObj, unsigned int Index, GUI_COLOR Color);
Nvoid             SPINBOX_SetTimerPeriod  (SPINBOX_Handle hObj, U32 Index, U32 Period);
Xvoid             SPINBOX_SetTimerPeriod  (SPINBOX_Handle hObj, unsigned long Index, unsigned long Period);
Nint              SPINBOX_SetUserData     (SPINBOX_Handle hObj, const void * pSrc, int NumBytes);
Nvoid             SPINBOX_SetValue        (SPINBOX_Handle hObj, I32 Value);
Xvoid             SPINBOX_SetValue        (SPINBOX_Handle hObj, signed long Value);
N
N/*********************************************************************
N*
N*       Managing default values
N*/
NU16  SPINBOX_GetDefaultButtonSize(void);
Xunsigned short  SPINBOX_GetDefaultButtonSize(void);
Nvoid SPINBOX_SetDefaultButtonSize(U16 ButtonSize);
Xvoid SPINBOX_SetDefaultButtonSize(unsigned short ButtonSize);
N
N/*********************************************************************
N*
N*       Skinning
N*/
Nvoid                    SPINBOX_GetSkinFlexProps     (SPINBOX_SKINFLEX_PROPS * pProps, int Index);
Nvoid                    SPINBOX_SetSkinClassic       (SPINBOX_Handle hObj);
Nvoid                    SPINBOX_SetSkin              (SPINBOX_Handle hObj, WIDGET_DRAW_ITEM_FUNC * pfDrawSkin);
Nint                     SPINBOX_DrawSkinFlex         (const WIDGET_ITEM_DRAW_INFO * pDrawItemInfo);
Nvoid                    SPINBOX_SetSkinFlexProps     (const SPINBOX_SKINFLEX_PROPS * pProps, int Index);
Nvoid                    SPINBOX_SetDefaultSkinClassic(void);
NWIDGET_DRAW_ITEM_FUNC * SPINBOX_SetDefaultSkin(WIDGET_DRAW_ITEM_FUNC * pfDrawSkin);
N
N#if defined(__cplusplus)
X#if 0L
S  }
N#endif
N
N#endif  // GUI_WINSUPPORT
N#endif  // SPINBOX_H
N
N/*************************** End of file ****************************/
L 80 "..\..\..\..\ThirdParty\emWin\Include\DIALOG.h" 2
N#include "SWIPELIST.h"
L 1 "..\..\..\..\ThirdParty\emWin\Include\SWIPELIST.h" 1
N/*********************************************************************
N*                    SEGGER Microcontroller GmbH                     *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2023  SEGGER Microcontroller GmbH                *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V6.46 - Graphical user interface for embedded applications **
NemWin is protected by international copyright laws. Knowledge of the
Nsource code may not be used to write a similar product. 
NThis file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed by SEGGER Software GmbH to Nuvoton Technology Corporation
Nat the address: No. 4, Creation Rd. III, Hsinchu Science Park, Taiwan
Nfor the purposes  of  creating  libraries  for its 
NArm Cortex-A, Arm Cortex-M and  Arm9 32-bit microcontrollers, commercialized and distributed by Nuvoton Technology Corporation
Nunder  the terms and conditions  of  an  End  User  
NLicense  Agreement  supplied  with  the libraries.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NLicensing information
NLicensor:                 SEGGER Software GmbH
NLicensed to:              Nuvoton Technology Corporation, No. 4, Creation Rd. III, Hsinchu Science Park, 30077 Hsinchu City, Taiwan
NLicensed SEGGER software: emWin
NLicense number:           GUI-00735
NLicense model:            emWin License Agreement, signed February 27, 2018
NLicensed platform:        Cortex-M, Cortex-A, and ARM9 32-bit series microcontroller designed and manufactured by Nuvoton Technology Corporation.
N----------------------------------------------------------------------
NSupport and Update Agreement (SUA)
NSUA period:               2018-03-26 - 2025-09-04
NContact to extend SUA:    sales@segger.com
N----------------------------------------------------------------------
NFile        : SWIPELIST.h
NPurpose     : SWIPELIST include
N--------------------END-OF-HEADER-------------------------------------
N*/
N
N#ifndef SWIPELIST_H
N#define SWIPELIST_H
N
N#include "WM.h"
N#include "DIALOG_Type.h"      // Req. for Create indirect data structure
N#include "WIDGET.h"
N
N#if GUI_WINSUPPORT
X#if 1
N
N#if defined(__cplusplus)
X#if 0L
S  extern "C" {                  // Make sure we have C-declarations in C++ programs
N#endif
N
N/*********************************************************************
N*
N*       Create flags
N*
N**********************************************************************
N*/
N#define SWIPELIST_CF_HORIZONTAL (0 << 0)
N#define SWIPELIST_CF_VERTICAL   (1 << 0)
N
N/*********************************************************************
N*
N*       SWIPELIST border indexes
N*
N*  Description
N*    Border indexes to e.g. change the border size of the SWIPELIST widget.
N*    A routine that uses these index flags is SWIPELIST_SetBorderSize().
N*/
N#define SWIPELIST_BI_LEFT   0               // Left border of the items.
N#define SWIPELIST_BI_RIGHT  1               // Right border of the items.
N#define SWIPELIST_BI_TOP    2               // Top border of the items.
N#define SWIPELIST_BI_BOTTOM 3               // Bottom border of the items.
N
N/*********************************************************************
N*
N*       SWIPELIST font indexes
N*
N*  Description
N*    Font indexes used for SWIPELIST routines.
N*/
N#define SWIPELIST_FI_SEP_ITEM    0          // Font used by the separator item.
N#define SWIPELIST_FI_ITEM_HEADER 1          // Font used by the header of the item.
N#define SWIPELIST_FI_ITEM_TEXT   2          // Font used by the text of the item.
N
N/*********************************************************************
N*
N*       SWIPELIST item color indexes
N*
N*  Description
N*    Color indexes used for SWIPELIST routines to return or set the
N*    color of an item.
N*/
N#define SWIPELIST_CI_ITEM_HEADER_UNSEL 0    // Color used for drawing the header text of an unselected item.
N#define SWIPELIST_CI_ITEM_HEADER_SEL   1    // Color used for drawing the header text of a selected item.
N#define SWIPELIST_CI_ITEM_TEXT_UNSEL   2    // Color used for drawing the text for an unselected item.
N#define SWIPELIST_CI_ITEM_TEXT_SEL     3    // Color used for drawing the text of a selected item.
N#define SWIPELIST_CI_SEP_ITEM_TEXT     4    // Color used for drawing the text of a separator item.
N
N/*********************************************************************
N*
N*       SWIPELIST background color indexes
N*
N*  Description
N*    Color indexes used for SWIPELIST routines to return or set the
N*    background color of SWIPELIST items.
N*/
N#define SWIPELIST_CI_BK_ITEM_UNSEL     0    // Background of an unselected item.
N#define SWIPELIST_CI_BK_ITEM_SEL       1    // Background of a selected item.
N#define SWIPELIST_CI_BK_SEP_ITEM       2    // Background of a separator item.
N#define SWIPELIST_CI_BK                3    // Background of unused area.
N
N/*********************************************************************
N*
N*       SWIPELIST bitmap alignment flags
N*
N*  Description
N*    Flags to align the bitmaps of a SWIPELIST widget.
N*    These flags are used by the routine SWIPELIST_SetBitmap() and can be OR-combined.
N*/
N#define SWIPELIST_BA_LEFT      (0 << 0)
N#define SWIPELIST_BA_RIGHT	   (1 << 0)
N#define SWIPELIST_BA_HCENTER	 (2 << 0)
N
N#define SWIPELIST_BA_VCENTER   (3 << 2)
N#define SWIPELIST_BA_TOP	     (0 << 2)
N#define SWIPELIST_BA_BOTTOM	   (1 << 2)
N
N/*********************************************************************
N*
N*       Compatability macros
N*/
N#define SWIPELIST_NOTIFICATION_OVERLAP_TOP_ENTERED       WM_NOTIFICATION_OVERLAP_TOP_ENTERED
N#define SWIPELIST_NOTIFICATION_OVERLAP_BOTTOM_ENTERED    WM_NOTIFICATION_OVERLAP_BOTTOM_ENTERED
N#define SWIPELIST_NOTIFICATION_OVERLAP_RELEASED          WM_NOTIFICATION_OVERLAP_RELEASED
N
N/*********************************************************************
N*
N*       Public Types
N*
N**********************************************************************
N*/
Ntypedef WM_HMEM SWIPELIST_Handle;
Xtypedef signed long SWIPELIST_Handle;
N
N/*********************************************************************
N*
N*       Create functions
N*
N**********************************************************************
N*/
NSWIPELIST_Handle SWIPELIST_CreateAsChild  (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int Id, int Flags);
XSWIPELIST_Handle SWIPELIST_CreateAsChild  (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int Id, int Flags);
NSWIPELIST_Handle SWIPELIST_CreateEx       (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int ExFlags, int Id);
XSWIPELIST_Handle SWIPELIST_CreateEx       (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int WinFlags, int ExFlags, int Id);
NSWIPELIST_Handle SWIPELIST_CreateIndirect (const GUI_WIDGET_CREATE_INFO * pCreateInfo, WM_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
XSWIPELIST_Handle SWIPELIST_CreateIndirect (const GUI_WIDGET_CREATE_INFO * pCreateInfo, GUI_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
NSWIPELIST_Handle SWIPELIST_CreateUser     (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int ExFlags, int Id, int NumExtraBytes);
XSWIPELIST_Handle SWIPELIST_CreateUser     (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int WinFlags, int ExFlags, int Id, int NumExtraBytes);
N
N/*********************************************************************
N*
N*       The callback ...
N*
N* Do not call it directly ! It is only to be used from within an
N* overwritten callback.
N*/
Nvoid SWIPELIST_Callback(WM_MESSAGE * pMsg);
N
N/*********************************************************************
N*
N*       Member functions
N*
N**********************************************************************
N*/
Nint                SWIPELIST_AddItem                 (SWIPELIST_Handle hObj, const char * sText, int ItemSize);
Nint                SWIPELIST_AddItemText             (SWIPELIST_Handle hObj, unsigned ItemIndex, const char * sText);
Nint                SWIPELIST_AddSepItem              (SWIPELIST_Handle hObj, const char * sText, int ItemSize);
Nvoid               SWIPELIST_DeleteItem              (SWIPELIST_Handle hObj, unsigned ItemIndex);
N
Nconst GUI_BITMAP * SWIPELIST_GetBitmap               (SWIPELIST_Handle hObj, unsigned ItemIndex);
Nint                SWIPELIST_GetBitmapSpace          (SWIPELIST_Handle hObj);
NGUI_COLOR          SWIPELIST_GetBkColor              (SWIPELIST_Handle hObj, unsigned Index);
Nint                SWIPELIST_GetBorderSize           (SWIPELIST_Handle hObj, unsigned Index);
Nconst GUI_FONT *   SWIPELIST_GetFont                 (SWIPELIST_Handle hObj, unsigned Index);
Nint                SWIPELIST_GetItemSize             (SWIPELIST_Handle hObj, unsigned ItemIndex);
NU32                SWIPELIST_GetItemUserData         (SWIPELIST_Handle hObj, unsigned ItemIndex);
Xunsigned long                SWIPELIST_GetItemUserData         (SWIPELIST_Handle hObj, unsigned ItemIndex);
Nint                SWIPELIST_GetNumItems             (SWIPELIST_Handle hObj);
Nint                SWIPELIST_GetNumText              (SWIPELIST_Handle hObj, unsigned ItemIndex);
Nunsigned           SWIPELIST_GetOverlap              (SWIPELIST_Handle hObj, int * pPeriod, U8 * pFlags);
Xunsigned           SWIPELIST_GetOverlap              (SWIPELIST_Handle hObj, int * pPeriod, unsigned char * pFlags);
Nint                SWIPELIST_GetReleasedItem         (SWIPELIST_Handle hObj);
Nint                SWIPELIST_GetScrollPos            (SWIPELIST_Handle hObj);
Nint                SWIPELIST_GetSelItem              (SWIPELIST_Handle hObj);
NGUI_COLOR          SWIPELIST_GetSepColor             (SWIPELIST_Handle hObj, unsigned ItemIndex);
Nint                SWIPELIST_GetSepSize              (SWIPELIST_Handle hObj, unsigned ItemIndex);
Nvoid               SWIPELIST_GetText                 (SWIPELIST_Handle hObj, unsigned ItemIndex, unsigned TextIndex, char * pBuffer, int MaxSize);
Nint                SWIPELIST_GetTextAlign            (SWIPELIST_Handle hObj, unsigned ItemIndex);
NGUI_COLOR          SWIPELIST_GetTextColor            (SWIPELIST_Handle hObj, unsigned Index);
Nint                SWIPELIST_GetThreshold            (SWIPELIST_Handle hObj);
Nint                SWIPELIST_GetUserData             (SWIPELIST_Handle hObj, void * pDest, int NumBytes);
N
Nint                SWIPELIST_IsSepItem               (SWIPELIST_Handle hObj, U32 ItemIndex);
Xint                SWIPELIST_IsSepItem               (SWIPELIST_Handle hObj, unsigned long ItemIndex);
Nint                SWIPELIST_ItemAttachWindow        (SWIPELIST_Handle hObj, unsigned ItemIndex, WM_HWIN hWin, int x0, int y0);
Xint                SWIPELIST_ItemAttachWindow        (SWIPELIST_Handle hObj, unsigned ItemIndex, GUI_HWIN hWin, int x0, int y0);
Nvoid               SWIPELIST_ItemDetachWindow        (SWIPELIST_Handle hObj, WM_HWIN hWin);
Xvoid               SWIPELIST_ItemDetachWindow        (SWIPELIST_Handle hObj, GUI_HWIN hWin);
Nint                SWIPELIST_OwnerDraw               (const WIDGET_ITEM_DRAW_INFO * pDrawItemInfo);
N
Nvoid               SWIPELIST_SetAttachedWindowPos    (SWIPELIST_Handle hObj, WM_HWIN hWin, int x0, int y0);
Xvoid               SWIPELIST_SetAttachedWindowPos    (SWIPELIST_Handle hObj, GUI_HWIN hWin, int x0, int y0);
Nvoid               SWIPELIST_SetBitmap               (SWIPELIST_Handle hObj, unsigned ItemIndex, int Align, const GUI_BITMAP * pBitmap);
Nvoid               SWIPELIST_SetBitmapEx             (SWIPELIST_Handle hObj, unsigned ItemIndex, int Align, const GUI_BITMAP * pBitmap, int x, int y);
Nvoid               SWIPELIST_SetBitmapSpace          (SWIPELIST_Handle hObj, unsigned Size);
Nvoid               SWIPELIST_SetBkColor              (SWIPELIST_Handle hObj, unsigned Index, GUI_COLOR Color);
Nvoid               SWIPELIST_SetBorderSize           (SWIPELIST_Handle hObj, unsigned Index, unsigned Size);
Nvoid               SWIPELIST_SetFont                 (SWIPELIST_Handle hObj, unsigned Index, const GUI_FONT * pFont);
Nvoid               SWIPELIST_SetItemSize             (SWIPELIST_Handle hObj, unsigned ItemIndex, unsigned Size);
Nvoid               SWIPELIST_SetItemUserData         (SWIPELIST_Handle hObj, unsigned ItemIndex, U32 UserData);
Xvoid               SWIPELIST_SetItemUserData         (SWIPELIST_Handle hObj, unsigned ItemIndex, unsigned long UserData);
Nvoid               SWIPELIST_SetOverlap              (SWIPELIST_Handle hObj, unsigned Overlap, int Period, U8 Flags);
Xvoid               SWIPELIST_SetOverlap              (SWIPELIST_Handle hObj, unsigned Overlap, int Period, unsigned char Flags);
Nvoid               SWIPELIST_SetOwnerDraw            (SWIPELIST_Handle hObj, WIDGET_DRAW_ITEM_FUNC * pfDrawItem);
Nvoid               SWIPELIST_SetScrollPos            (SWIPELIST_Handle hObj, int Pos);
Nvoid               SWIPELIST_SetScrollPosItem        (SWIPELIST_Handle hObj, unsigned ItemIndex);
Nvoid               SWIPELIST_SetSepColor             (SWIPELIST_Handle hObj, unsigned ItemIndex, GUI_COLOR Color);
Nvoid               SWIPELIST_SetSepSize              (SWIPELIST_Handle hObj, unsigned ItemIndex, int Size);
Nvoid               SWIPELIST_SetText                 (SWIPELIST_Handle hObj, unsigned ItemIndex, unsigned TextIndex, char * sText);
Nvoid               SWIPELIST_SetTextAlign            (SWIPELIST_Handle hObj, unsigned ItemIndex, int Align);
Nvoid               SWIPELIST_SetTextColor            (SWIPELIST_Handle hObj, unsigned Index, GUI_COLOR Color);
Nint                SWIPELIST_SetThreshold            (SWIPELIST_Handle hObj, int Threshold);
Nint                SWIPELIST_SetUserData             (SWIPELIST_Handle hObj, const void * pSrc, int NumBytes);
N
N/*********************************************************************
N*
N*       Global functions
N*
N**********************************************************************
N*/
Nint              SWIPELIST_GetDefaultBitmapSpace     (void);
NGUI_COLOR        SWIPELIST_GetDefaultBkColor         (unsigned Index);
Nint              SWIPELIST_GetDefaultBorderSize      (unsigned Index);
Nconst GUI_FONT * SWIPELIST_GetDefaultFont            (unsigned Index);
Nunsigned         SWIPELIST_GetDefaultOverlap         (int * pPeriod, U8 * pFlags);
Xunsigned         SWIPELIST_GetDefaultOverlap         (int * pPeriod, unsigned char * pFlags);
NGUI_COLOR        SWIPELIST_GetDefaultSepColor        (void);
Nunsigned         SWIPELIST_GetDefaultSepSize         (void);
NGUI_COLOR        SWIPELIST_GetDefaultTextColor       (unsigned Index);
Nint              SWIPELIST_GetDefaultTextAlign       (void);
Nint              SWIPELIST_GetDefaultThreshold       (void);
N
Nvoid             SWIPELIST_SetDefaultBitmapSpace     (unsigned Size);
Nvoid             SWIPELIST_SetDefaultBkColor         (unsigned Index, GUI_COLOR Color);
Nvoid             SWIPELIST_SetDefaultBorderSize      (unsigned Index, unsigned Size);
Nvoid             SWIPELIST_SetDefaultFont            (unsigned Index, const GUI_FONT * pFont);
Nvoid             SWIPELIST_SetDefaultOverlap         (unsigned Overlap, int Period, U8 Flags);
Xvoid             SWIPELIST_SetDefaultOverlap         (unsigned Overlap, int Period, unsigned char Flags);
Nvoid             SWIPELIST_SetDefaultSepColor        (GUI_COLOR Color);
Nvoid             SWIPELIST_SetDefaultSepSize         (unsigned Size);
Nvoid             SWIPELIST_SetDefaultTextColor       (unsigned Index, GUI_COLOR Color);
Nvoid             SWIPELIST_SetDefaultTextAlign       (int Align);
Nvoid             SWIPELIST_SetDefaultThreshold       (int Threshold);
N
N#if defined(__cplusplus)
X#if 0L
S  }
N#endif
N
N#endif  // GUI_WINSUPPORT
N#endif  // SWIPELIST_H
N
N/*************************** End of file ****************************/
L 81 "..\..\..\..\ThirdParty\emWin\Include\DIALOG.h" 2
N#include "SWITCH.h"
L 1 "..\..\..\..\ThirdParty\emWin\Include\SWITCH.h" 1
N/*********************************************************************
N*                    SEGGER Microcontroller GmbH                     *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2023  SEGGER Microcontroller GmbH                *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V6.46 - Graphical user interface for embedded applications **
NemWin is protected by international copyright laws. Knowledge of the
Nsource code may not be used to write a similar product. 
NThis file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed by SEGGER Software GmbH to Nuvoton Technology Corporation
Nat the address: No. 4, Creation Rd. III, Hsinchu Science Park, Taiwan
Nfor the purposes  of  creating  libraries  for its 
NArm Cortex-A, Arm Cortex-M and  Arm9 32-bit microcontrollers, commercialized and distributed by Nuvoton Technology Corporation
Nunder  the terms and conditions  of  an  End  User  
NLicense  Agreement  supplied  with  the libraries.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NLicensing information
NLicensor:                 SEGGER Software GmbH
NLicensed to:              Nuvoton Technology Corporation, No. 4, Creation Rd. III, Hsinchu Science Park, 30077 Hsinchu City, Taiwan
NLicensed SEGGER software: emWin
NLicense number:           GUI-00735
NLicense model:            emWin License Agreement, signed February 27, 2018
NLicensed platform:        Cortex-M, Cortex-A, and ARM9 32-bit series microcontroller designed and manufactured by Nuvoton Technology Corporation.
N----------------------------------------------------------------------
NSupport and Update Agreement (SUA)
NSUA period:               2018-03-26 - 2025-09-04
NContact to extend SUA:    sales@segger.com
N----------------------------------------------------------------------
NFile        : SWITCH.h
NPurpose     : SWITCH public header file (API)
N--------------------END-OF-HEADER-------------------------------------
N*/
N
N#ifndef SWITCH_H
N#define SWITCH_H
N
N#include "WM.h"
N#include "DIALOG_Type.h"      /* Req. for Create indirect data structure */
N#include "WIDGET.h"
N
N#if (GUI_WINSUPPORT && GUI_SUPPORT_MEMDEV)
X#if (1 && 1)
N
N#if defined(__cplusplus)
X#if 0L
S  extern "C" {     /* Make sure we have C-declarations in C++ programs */
N#endif
N
N/************************************************************
N*
N*       Defines
N*
N*************************************************************
N*/
N/*********************************************************************
N*
N*       SWITCH modes
N*
N*  Description
N*    Modes a SWITCH widget can be set to. See SWITCH_SetMode() for more
N*    information.
N*/
N#define SWITCH_MODE_FADE     (1 << 0)  // Fade mode. Both state bitmaps are faded into each other.
N#define SWITCH_MODE_DISCLOSE (1 << 1)  // Disclose mode. Bitmap of the new state is disclosed.
N
N/************************************************************
N*
N*       States
N*/
N#define SWITCH_STATE_PRESSED WIDGET_STATE_USER0
N
N/************************************************************
N*
N*       SWITCH states
N*
N*  Description
N*    List of defines of the possible states a SWITCH widget can be in.
N*/
N#define SWITCH_STATE_LEFT    0         // Left state, the thumb is on the left side of the widget.
N#define SWITCH_STATE_RIGHT   1         // Right state, the thumb is on the right side of the widget.
N
N/*********************************************************************
N*
N*       SWITCH color indexes
N*
N*  Description
N*    Color indexes used by the SWITCH widget.
N*/
N#define SWITCH_CI_LEFT     0           // Color for left state.
N#define SWITCH_CI_RIGHT    1           // Color for right state.
N#define SWITCH_CI_DISABLED 2           // Color for disabled state.
N
N/*********************************************************************
N*
N*       SWITCH bitmap indexes
N*
N*  Description
N*    Bitmap indexes used by the SWITCH widget for handling bitmaps.
N*/
N#define SWITCH_BI_BK_LEFT        0     // Background bitmap for left state.
N#define SWITCH_BI_BK_RIGHT       1     // Background bitmap for right state.
N#define SWITCH_BI_BK_DISABLED    2     // Background bitmap for disabled state.
N#define SWITCH_BI_THUMB_LEFT     3     // Thumb bitmap for left state.
N#define SWITCH_BI_THUMB_RIGHT    4     // Thumb bitmap for right state.
N#define SWITCH_BI_THUMB_DISABLED 5     // Thumb bitmap for disabled state.
N
N/*********************************************************************
N*
N*       SWITCH text indexes
N*
N*  Description
N*    Text indexes used by the SWITCH widget.
N*/
N#define SWITCH_TI_LEFT  0              // Text shown for the left state.
N#define SWITCH_TI_RIGHT 1              // Text shown for the right state.
N
N/*********************************************************************
N*
N*       Types
N*
N**********************************************************************
N*/
Ntypedef WM_HMEM SWITCH_Handle;
Xtypedef signed long SWITCH_Handle;
N
N/*********************************************************************
N*
N*       Create function(s)
N
N  Note: the parameters to a create function may vary.
N         Some widgets may have multiple create functions
N*/
NSWITCH_Handle SWITCH_CreateUser    (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int ExFlags, int Id, int NumExtraBytes);
XSWITCH_Handle SWITCH_CreateUser    (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int WinFlags, int ExFlags, int Id, int NumExtraBytes);
NSWITCH_Handle SWITCH_CreateIndirect(const GUI_WIDGET_CREATE_INFO * pCreateInfo, WM_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
XSWITCH_Handle SWITCH_CreateIndirect(const GUI_WIDGET_CREATE_INFO * pCreateInfo, GUI_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
N
N/*********************************************************************
N*
N*       Managing default values
N*
N**********************************************************************
N*/
NGUI_COLOR        SWITCH_GetDefaultTextColor(unsigned Index);
Nconst GUI_FONT * SWITCH_GetDefaultFont     (void);
Nunsigned         SWITCH_GetDefaultPeriod   (void);
Nvoid             SWITCH_SetDefaultTextColor(GUI_COLOR Color, unsigned Index);
Nvoid             SWITCH_SetDefaultFont     (const GUI_FONT * pFont);
Nvoid             SWITCH_SetDefaultPeriod   (unsigned Period);
N
N/*********************************************************************
N*
N*       The callback ...
N*
N* Do not call it directly ! It is only to be used from within an
N* overwritten callback.
N*/
Nvoid SWITCH_Callback(WM_MESSAGE *pMsg);
N
N/*********************************************************************
N*
N*       Member functions
N*
N**********************************************************************
N*/
Nvoid SWITCH_AnimState       (SWITCH_Handle hObj, int State);
Nvoid SWITCH_DisableAnimation(SWITCH_Handle hObj, U8 Disable);
Xvoid SWITCH_DisableAnimation(SWITCH_Handle hObj, unsigned char Disable);
Nint  SWITCH_GetState        (SWITCH_Handle hObj);
Nint  SWITCH_GetUserData     (SWITCH_Handle hObj, void * pDest, int NumBytes);
Nvoid SWITCH_SetBitmap       (SWITCH_Handle hObj, unsigned int Index, const GUI_BITMAP * pBitmap);
Nvoid SWITCH_SetFont         (SWITCH_Handle hObj, const GUI_FONT * pfont);
Nvoid SWITCH_SetMode         (SWITCH_Handle hObj, int Mode);
Nvoid SWITCH_SetPeriod       (SWITCH_Handle hObj, I32 Period);
Xvoid SWITCH_SetPeriod       (SWITCH_Handle hObj, signed long Period);
Nvoid SWITCH_SetState        (SWITCH_Handle hObj, int State);
Nint  SWITCH_SetText         (SWITCH_Handle hObj, unsigned int Index, const char * pText);
Nvoid SWITCH_SetTextColor    (SWITCH_Handle hObj, unsigned int Index, GUI_COLOR Color);
Nvoid SWITCH_SetThumbSize    (SWITCH_Handle hObj, int xSize, int ySize);
Nint  SWITCH_SetUserData     (SWITCH_Handle hObj, const void * pSrc, int NumBytes);
Nvoid SWITCH_Toggle          (SWITCH_Handle hObj);
N
N/*********************************************************************
N*
N*       Member functions: Skinning
N*
N**********************************************************************
N*/
Nint  SWITCH_DrawSkin(const WIDGET_ITEM_DRAW_INFO * pDrawItemInfo);
Nvoid SWITCH_SetSkin (SWITCH_Handle hObj, WIDGET_DRAW_ITEM_FUNC * pfDrawSkin);
N
N#define SWITCH_SKIN    SWITCH_DrawSkin
N
N#if defined(__cplusplus)
X#if 0L
S  }
N#endif
N
N#endif  // (GUI_WINSUPPORT && GUI_SUPPORT_MEMDEV)
N#endif  // SWITCH_H
N
N/*************************** End of file ****************************/
L 82 "..\..\..\..\ThirdParty\emWin\Include\DIALOG.h" 2
N#include "TEXT.h"
L 1 "..\..\..\..\ThirdParty\emWin\Include\TEXT.h" 1
N/*********************************************************************
N*                    SEGGER Microcontroller GmbH                     *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2023  SEGGER Microcontroller GmbH                *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V6.46 - Graphical user interface for embedded applications **
NemWin is protected by international copyright laws. Knowledge of the
Nsource code may not be used to write a similar product. 
NThis file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed by SEGGER Software GmbH to Nuvoton Technology Corporation
Nat the address: No. 4, Creation Rd. III, Hsinchu Science Park, Taiwan
Nfor the purposes  of  creating  libraries  for its 
NArm Cortex-A, Arm Cortex-M and  Arm9 32-bit microcontrollers, commercialized and distributed by Nuvoton Technology Corporation
Nunder  the terms and conditions  of  an  End  User  
NLicense  Agreement  supplied  with  the libraries.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NLicensing information
NLicensor:                 SEGGER Software GmbH
NLicensed to:              Nuvoton Technology Corporation, No. 4, Creation Rd. III, Hsinchu Science Park, 30077 Hsinchu City, Taiwan
NLicensed SEGGER software: emWin
NLicense number:           GUI-00735
NLicense model:            emWin License Agreement, signed February 27, 2018
NLicensed platform:        Cortex-M, Cortex-A, and ARM9 32-bit series microcontroller designed and manufactured by Nuvoton Technology Corporation.
N----------------------------------------------------------------------
NSupport and Update Agreement (SUA)
NSUA period:               2018-03-26 - 2025-09-04
NContact to extend SUA:    sales@segger.com
N----------------------------------------------------------------------
NFile        : TEXT.h
NPurpose     : TEXT include
N--------------------END-OF-HEADER-------------------------------------
N*/
N
N#ifndef TEXT_H
N#define TEXT_H
N
N#include "WM.h"
N#include "DIALOG_Type.h"      /* Req. for Create indirect data structure */
N#include "WIDGET.h"
N
N#if GUI_WINSUPPORT
X#if 1
N
N#if defined(__cplusplus)
X#if 0L
S  extern "C" {     /* Make sure we have C-declarations in C++ programs */
N#endif
N
N/************************************************************
N*
N*       #defines
N*
N*************************************************************
N*/
N
N/************************************************************
N*
N*       Create / Status flags
N*/
N#define TEXT_CF_LEFT    GUI_TA_LEFT
N#define TEXT_CF_RIGHT   GUI_TA_RIGHT
N#define TEXT_CF_HCENTER GUI_TA_HCENTER
N
N#define TEXT_CF_VCENTER GUI_TA_VCENTER
N#define TEXT_CF_TOP     GUI_TA_TOP
N#define TEXT_CF_BOTTOM  GUI_TA_BOTTOM
N
N
N/*********************************************************************
N*
N*       Public Types
N*
N**********************************************************************
N
N*/
Ntypedef WM_HMEM TEXT_Handle;
Xtypedef signed long TEXT_Handle;
N
N/*********************************************************************
N*
N*       Create functions
N*
N**********************************************************************
N*/
NTEXT_Handle TEXT_Create        (int x0, int y0, int xSize, int ySize, int Id, int Flags, const char * s, int Align);
NTEXT_Handle TEXT_CreateAsChild (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int Id, int Flags, const char * s, int Align);
XTEXT_Handle TEXT_CreateAsChild (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int Id, int Flags, const char * s, int Align);
NTEXT_Handle TEXT_CreateEx      (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int ExFlags, int Id, const char * pText);
XTEXT_Handle TEXT_CreateEx      (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int WinFlags, int ExFlags, int Id, const char * pText);
NTEXT_Handle TEXT_CreateUser    (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int ExFlags, int Id, const char * pText, int NumExtraBytes);
XTEXT_Handle TEXT_CreateUser    (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int WinFlags, int ExFlags, int Id, const char * pText, int NumExtraBytes);
NTEXT_Handle TEXT_CreateIndirect(const GUI_WIDGET_CREATE_INFO * pCreateInfo, WM_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
XTEXT_Handle TEXT_CreateIndirect(const GUI_WIDGET_CREATE_INFO * pCreateInfo, GUI_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
N
N/*********************************************************************
N*
N*       The callback ...
N*
N* Do not call it directly ! It is only to be used from within an
N* overwritten callback.
N*/
Nvoid TEXT_Callback(WM_MESSAGE * pMsg);
N
N/*********************************************************************
N*
N*       Member functions
N*
N**********************************************************************
N*/
N
N/* Methods changing properties */
N
NGUI_COLOR            TEXT_GetBkColor   (TEXT_Handle hObj); 
Nconst GUI_FONT *     TEXT_GetFont      (TEXT_Handle hObj);
Nint                  TEXT_GetNumLines  (TEXT_Handle hObj);
N#if GUI_SUPPORT_ROTATION
X#if 1
Nconst GUI_ROTATION * TEXT_GetRotation  (TEXT_Handle hObj);
Xconst tLCD_APIList * TEXT_GetRotation  (TEXT_Handle hObj);
N#endif
Nint                  TEXT_GetText      (TEXT_Handle hObj, char * pDest, U32 BufferSize);
Xint                  TEXT_GetText      (TEXT_Handle hObj, char * pDest, unsigned long BufferSize);
Nint                  TEXT_GetTextAlign (TEXT_Handle hObj);
NGUI_COLOR            TEXT_GetTextColor (TEXT_Handle hObj);
NGUI_COLOR            TEXT_GetFrameColor(TEXT_Handle hObj);
Nvoid                 TEXT_GetTextOffset(TEXT_Handle hObj, int * pxPos, int * pyPos);
Nint                  TEXT_GetUserData  (TEXT_Handle hObj, void * pDest, int NumBytes);
NGUI_WRAPMODE         TEXT_GetWrapMode  (TEXT_Handle hObj);
Nvoid                 TEXT_SetBkColor   (TEXT_Handle hObj, GUI_COLOR Color);
Nvoid                 TEXT_SetFont      (TEXT_Handle hObj, const GUI_FONT * pFont);
Nint                  TEXT_SetDec       (TEXT_Handle hObj, I32 v, U8 Len, U8 Shift, U8 Signed, U8 Space);
Xint                  TEXT_SetDec       (TEXT_Handle hObj, signed long v, unsigned char Len, unsigned char Shift, unsigned char Signed, unsigned char Space);
Nint                  TEXT_SetHex       (TEXT_Handle hObj, I32 v, U8 Len);
Xint                  TEXT_SetHex       (TEXT_Handle hObj, signed long v, unsigned char Len);
N#if GUI_SUPPORT_ROTATION
X#if 1
Nvoid                 TEXT_SetRotation  (TEXT_Handle hObj, const GUI_ROTATION * pLCD_Api);
Xvoid                 TEXT_SetRotation  (TEXT_Handle hObj, const tLCD_APIList * pLCD_Api);
N#endif
Nint                  TEXT_SetText      (TEXT_Handle hObj, const char * s);
Nvoid                 TEXT_SetTextAlign (TEXT_Handle hObj, int Align);
Nvoid                 TEXT_SetTextColor (TEXT_Handle hObj, GUI_COLOR Color);
Nvoid                 TEXT_SetFrameColor(TEXT_Handle hObj, GUI_COLOR Color);
Nvoid                 TEXT_SetTextOffset(TEXT_Handle hObj, int xPos, int yPos);
Nint                  TEXT_SetUserData  (TEXT_Handle hObj, const void * pSrc, int NumBytes);
Nvoid                 TEXT_SetWrapMode  (TEXT_Handle hObj, GUI_WRAPMODE WrapMode);
N
Nint                  TEXT__SetDec      (TEXT_Handle hObj, I32 v, U8 Len, U8 Shift, U8 Signed, U8 Space, I32 Min, I32 Max);
Xint                  TEXT__SetDec      (TEXT_Handle hObj, signed long v, unsigned char Len, unsigned char Shift, unsigned char Signed, unsigned char Space, signed long Min, signed long Max);
N
N/*********************************************************************
N*
N*       Managing default values
N*
N**********************************************************************
N*/
N
Nconst GUI_FONT *     TEXT_GetDefaultFont      (void);
NGUI_COLOR            TEXT_GetDefaultFrameColor(void);
N#if GUI_SUPPORT_ROTATION
X#if 1
Nconst GUI_ROTATION * TEXT_GetDefaultRotation  (void);
Xconst tLCD_APIList * TEXT_GetDefaultRotation  (void);
N#endif
NGUI_COLOR            TEXT_GetDefaultTextColor (void);
NGUI_WRAPMODE         TEXT_GetDefaultWrapMode  (void);
Nvoid                 TEXT_SetDefaultFrameColor(GUI_COLOR Color);
Nvoid                 TEXT_SetDefaultFont      (const GUI_FONT * pFont);
N#if GUI_SUPPORT_ROTATION
X#if 1
Nconst GUI_ROTATION * TEXT_SetDefaultRotation  (const GUI_ROTATION * pLCD_Api);
Xconst tLCD_APIList * TEXT_SetDefaultRotation  (const tLCD_APIList * pLCD_Api);
N#endif
Nvoid                 TEXT_SetDefaultTextColor (GUI_COLOR Color);
NGUI_WRAPMODE         TEXT_SetDefaultWrapMode  (GUI_WRAPMODE WrapMode);
N
N#if defined(__cplusplus)
X#if 0L
S  }
N#endif
N
N#endif  // GUI_WINSUPPORT
N#endif  // TEXT_H
N
N/*************************** End of file ****************************/
L 83 "..\..\..\..\ThirdParty\emWin\Include\DIALOG.h" 2
N#include "TICKER.h"
L 1 "..\..\..\..\ThirdParty\emWin\Include\TICKER.h" 1
N/*********************************************************************
N*                    SEGGER Microcontroller GmbH                     *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2023  SEGGER Microcontroller GmbH                *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V6.46 - Graphical user interface for embedded applications **
NemWin is protected by international copyright laws. Knowledge of the
Nsource code may not be used to write a similar product. 
NThis file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed by SEGGER Software GmbH to Nuvoton Technology Corporation
Nat the address: No. 4, Creation Rd. III, Hsinchu Science Park, Taiwan
Nfor the purposes  of  creating  libraries  for its 
NArm Cortex-A, Arm Cortex-M and  Arm9 32-bit microcontrollers, commercialized and distributed by Nuvoton Technology Corporation
Nunder  the terms and conditions  of  an  End  User  
NLicense  Agreement  supplied  with  the libraries.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NLicensing information
NLicensor:                 SEGGER Software GmbH
NLicensed to:              Nuvoton Technology Corporation, No. 4, Creation Rd. III, Hsinchu Science Park, 30077 Hsinchu City, Taiwan
NLicensed SEGGER software: emWin
NLicense number:           GUI-00735
NLicense model:            emWin License Agreement, signed February 27, 2018
NLicensed platform:        Cortex-M, Cortex-A, and ARM9 32-bit series microcontroller designed and manufactured by Nuvoton Technology Corporation.
N----------------------------------------------------------------------
NSupport and Update Agreement (SUA)
NSUA period:               2018-03-26 - 2025-09-04
NContact to extend SUA:    sales@segger.com
N----------------------------------------------------------------------
NFile        : TICKER.h
NPurpose     : TICKER include
N--------------------END-OF-HEADER-------------------------------------
N*/
N
N#ifndef TICKER_H
N#define TICKER_H
N
N#include "WM.h"
N#include "DIALOG_Type.h"      /* Req. for Create indirect data structure */
N#include "WIDGET.h"
N
N#if GUI_WINSUPPORT
X#if 1
N
N#if defined(__cplusplus)
X#if 0L
S  extern "C" {     /* Make sure we have C-declarations in C++ programs */
N#endif
N
N/************************************************************
N*
N*       #defines
N*
N*************************************************************
N*/
N
N/************************************************************
N*
N*       Create / Status flags
N*/
N#define TICKER_CF_LEFT         GUI_TA_LEFT
N#define TICKER_CF_RIGHT        GUI_TA_RIGHT
N#define TICKER_CF_HCENTER      GUI_TA_HCENTER
N
N#define TICKER_CF_VCENTER      GUI_TA_VCENTER
N#define TICKER_CF_TOP          GUI_TA_TOP
N#define TICKER_CF_BOTTOM       GUI_TA_BOTTOM
N
N#define TICKER_MODE_CONTINOUS  (0)
N#define TICKER_MODE_ANIMATED   (1)
N
N#define TICKER_DIR_HORIZONTAL  (0)
N#define TICKER_DIR_VERTICAL    (1)
N
N/*********************************************************************
N*
N*       Public Types
N*
N**********************************************************************
N
N*/
Ntypedef WM_HMEM TICKER_Handle;
Xtypedef signed long TICKER_Handle;
N
N/*********************************************************************
N*
N*       Create functions
N*
N**********************************************************************
N*/
NTICKER_Handle TICKER_CreateUser    (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int ExFlags, int Id, const char * pText, int NumExtraBytes);
XTICKER_Handle TICKER_CreateUser    (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int WinFlags, int ExFlags, int Id, const char * pText, int NumExtraBytes);
NTICKER_Handle TICKER_CreateIndirect(const GUI_WIDGET_CREATE_INFO * pCreateInfo, WM_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
XTICKER_Handle TICKER_CreateIndirect(const GUI_WIDGET_CREATE_INFO * pCreateInfo, GUI_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
N
N/*********************************************************************
N*
N*       The callback ...
N*
N* Do not call it directly ! It is only to be used from within an
N* overwritten callback.
N*/
Nvoid TICKER_Callback(WM_MESSAGE * pMsg);
N
N/*********************************************************************
N*
N*       Member functions
N*
N**********************************************************************
N*/
N
N/* Methods changing properties */
N
NGUI_COLOR            TICKER_GetBkColor          (TICKER_Handle hObj); 
NU32                  TICKER_GetCurrentItemIndex (TICKER_Handle hObj);
Xunsigned long                  TICKER_GetCurrentItemIndex (TICKER_Handle hObj);
NU32                  TICKER_GetClickedItemIndex (TICKER_Handle hObj);
Xunsigned long                  TICKER_GetClickedItemIndex (TICKER_Handle hObj);
Nconst GUI_FONT *     TICKER_GetFont             (TICKER_Handle hObj);
Nint                  TICKER_GetItemText         (TICKER_Handle hObj, char * pDest, U32 BufferSize, U32 ItemIndex);
Xint                  TICKER_GetItemText         (TICKER_Handle hObj, char * pDest, unsigned long BufferSize, unsigned long ItemIndex);
Nint                  TICKER_GetTextAlign        (TICKER_Handle hObj);
NGUI_COLOR            TICKER_GetTextColor        (TICKER_Handle hObj);
NGUI_COLOR            TICKER_GetFrameColor       (TICKER_Handle hObj);
Nint                  TICKER_GetUserData         (TICKER_Handle hObj, void * pDest, int NumBytes);
Nvoid                 TICKER_MoveToItem          (TICKER_Handle hObj, int ItemIndex, U8 Dir);
Xvoid                 TICKER_MoveToItem          (TICKER_Handle hObj, int ItemIndex, unsigned char Dir);
Nvoid                 TICKER_MoveToNextItem      (TICKER_Handle hObj, U8 Dir, U8 Auto);
Xvoid                 TICKER_MoveToNextItem      (TICKER_Handle hObj, unsigned char Dir, unsigned char Auto);
Nvoid                 TICKER_MoveToPrevItem      (TICKER_Handle hObj, U8 Dir, U8 Auto);
Xvoid                 TICKER_MoveToPrevItem      (TICKER_Handle hObj, unsigned char Dir, unsigned char Auto);
Nvoid                 TICKER_SetBkColor          (TICKER_Handle hObj, GUI_COLOR Color);
Nvoid                 TICKER_SetConsecutive      (TICKER_Handle hObj, int OnOff);
Nvoid                 TICKER_SetContinuousMode   (TICKER_Handle hObj);
Nvoid                 TICKER_SetCurrentItemIndex (TICKER_Handle hObj, U32 ItemIndex);
Xvoid                 TICKER_SetCurrentItemIndex (TICKER_Handle hObj, unsigned long ItemIndex);
Nvoid                 TICKER_SetFont             (TICKER_Handle hObj, const GUI_FONT * pFont);
Nvoid                 TICKER_SetFrameColor       (TICKER_Handle hObj, GUI_COLOR Color);
Nvoid                 TICKER_SetItemDist         (TICKER_Handle hObj, int Dist);
Nint                  TICKER_SetItems            (TICKER_Handle hObj, const char ** ppStrings, U32 NumItems);
Xint                  TICKER_SetItems            (TICKER_Handle hObj, const char ** ppStrings, unsigned long NumItems);
Nint                  TICKER_SetItemText         (TICKER_Handle hObj, const char * pString, U32 ItemIndex);
Xint                  TICKER_SetItemText         (TICKER_Handle hObj, const char * pString, unsigned long ItemIndex);
Nvoid                 TICKER_SetMovement         (TICKER_Handle hObj, int Dist, int Period);
Nvoid                 TICKER_SetTextAlign        (TICKER_Handle hObj, int Align);
Nvoid                 TICKER_SetTextColor        (TICKER_Handle hObj, GUI_COLOR Color);
Nvoid                 TICKER_SetWrapMode         (TICKER_Handle hObj, GUI_WRAPMODE WrapMode);
Nvoid                 TICKER_Start               (TICKER_Handle hObj);
Nvoid                 TICKER_Stop                (TICKER_Handle hObj);
Nint                  TICKER_SetUserData         (TICKER_Handle hObj, const void * pSrc, int NumBytes);
N
N/*********************************************************************
N*
N*       Managing default values
N*
N**********************************************************************
N*/
N
NU16              TICKER_GetDefaultAnimDist(void);
Xunsigned short              TICKER_GetDefaultAnimDist(void);
Nint              TICKER_GetDefaultAnimPeriod(void);
NGUI_COLOR        TICKER_GetDefaultBkColor(void);
NU16              TICKER_GetDefaultDist(void);
Xunsigned short              TICKER_GetDefaultDist(void);
Nconst GUI_FONT * TICKER_GetDefaultFont(void);
NGUI_COLOR        TICKER_GetDefaultFrameColor(void);
NGUI_COLOR        TICKER_GetDefaultTextColor(void);
Nvoid             TICKER_SetDefaultAnimDist(U16 AnimDist);
Xvoid             TICKER_SetDefaultAnimDist(unsigned short AnimDist);
Nvoid             TICKER_SetDefaultAnimPeriod(int AnimPeriod);
Nvoid             TICKER_SetDefaultBkColor(GUI_COLOR Color);
Nvoid             TICKER_SetDefaultDist(U16 Dist);
Xvoid             TICKER_SetDefaultDist(unsigned short Dist);
Nvoid             TICKER_SetDefaultFont(const GUI_FONT * pFont);
Nvoid             TICKER_SetDefaultFrameColor(GUI_COLOR Color);
Nvoid             TICKER_SetDefaultTextColor(GUI_COLOR Color);
N
N#if defined(__cplusplus)
X#if 0L
S  }
N#endif
N
N#endif  // GUI_WINSUPPORT
N#endif  // TICKER_H
N
N/*************************** End of file ****************************/
L 84 "..\..\..\..\ThirdParty\emWin\Include\DIALOG.h" 2
N#include "TREEVIEW.h"
L 1 "..\..\..\..\ThirdParty\emWin\Include\TREEVIEW.h" 1
N/*********************************************************************
N*                    SEGGER Microcontroller GmbH                     *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2023  SEGGER Microcontroller GmbH                *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V6.46 - Graphical user interface for embedded applications **
NemWin is protected by international copyright laws. Knowledge of the
Nsource code may not be used to write a similar product. 
NThis file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed by SEGGER Software GmbH to Nuvoton Technology Corporation
Nat the address: No. 4, Creation Rd. III, Hsinchu Science Park, Taiwan
Nfor the purposes  of  creating  libraries  for its 
NArm Cortex-A, Arm Cortex-M and  Arm9 32-bit microcontrollers, commercialized and distributed by Nuvoton Technology Corporation
Nunder  the terms and conditions  of  an  End  User  
NLicense  Agreement  supplied  with  the libraries.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NLicensing information
NLicensor:                 SEGGER Software GmbH
NLicensed to:              Nuvoton Technology Corporation, No. 4, Creation Rd. III, Hsinchu Science Park, 30077 Hsinchu City, Taiwan
NLicensed SEGGER software: emWin
NLicense number:           GUI-00735
NLicense model:            emWin License Agreement, signed February 27, 2018
NLicensed platform:        Cortex-M, Cortex-A, and ARM9 32-bit series microcontroller designed and manufactured by Nuvoton Technology Corporation.
N----------------------------------------------------------------------
NSupport and Update Agreement (SUA)
NSUA period:               2018-03-26 - 2025-09-04
NContact to extend SUA:    sales@segger.com
N----------------------------------------------------------------------
NFile        : TREEVIEW.h
NPurpose     : TREEVIEW include
N--------------------END-OF-HEADER-------------------------------------
N*/
N
N#ifndef TREEVIEW_H
N#define TREEVIEW_H
N
N#include "WM.h"
N#include "DIALOG_Type.h"      /* Req. for Create indirect data structure */
N#include "WIDGET.h"
N
N#if GUI_WINSUPPORT
X#if 1
N
N#if defined(__cplusplus)
X#if 0L
S  extern "C" {     /* Make sure we have C-declarations in C++ programs */
N#endif
N
N/*********************************************************************
N*
N*       Defines
N*
N**********************************************************************
N*/
N/************************************************************
N*
N*       TREEVIEW create flags
N*
N*  Description
N*    Create flags used by the TREEVIEW widget. These flags are used for the \a{ExFlags} parameter
N*    of TREEVIEW_CreateEx(). These values can be OR-combined.
N*/
N#define TREEVIEW_CF_HIDELINES       (1 << 0)   // Joining lines are not displayed.
N#define TREEVIEW_CF_ROWSELECT       (1 << 1)   // Activates row selection mode.
N#define TREEVIEW_CF_AUTOSCROLLBAR_H (1 << 2)   // Enables the use of an automatic horizontal scroll bar.
N#define TREEVIEW_CF_AUTOSCROLLBAR_V (1 << 3)   // Enables the use of an automatic vertical scroll bar.
N/* Status flags */
N#define TREEVIEW_SF_HIDELINES       TREEVIEW_CF_HIDELINES
N#define TREEVIEW_SF_ROWSELECT       TREEVIEW_CF_ROWSELECT
N#define TREEVIEW_SF_AUTOSCROLLBAR_H TREEVIEW_CF_AUTOSCROLLBAR_H
N#define TREEVIEW_SF_AUTOSCROLLBAR_V TREEVIEW_CF_AUTOSCROLLBAR_V
N
N/************************************************************
N*
N*       TREEVIEW bitmap indexes
N*
N*  Description
N*    Bitmap indexes used by the TREEVIEW widget. Refer to TREEVIEW_SetImage().
N*/
N#define TREEVIEW_BI_CLOSED          0          // Image of closed nodes.
N#define TREEVIEW_BI_OPEN            1          // Image of open nodes.
N#define TREEVIEW_BI_LEAF            2          // Image of leaf.
N#define TREEVIEW_BI_PLUS            3          // Plus sign of closed nodes.
N#define TREEVIEW_BI_MINUS           4          // Minus sign of open nodes.
N#define TREEVIEW_BI_PM              5          // Used by TREEVIEW_SetBitmapOffset() for setting the offset of the plus/minus bitmaps.
N
N/************************************************************
N*
N*       TREEVIEW color indexes
N*
N*  Description
N*    Color indexes used by the TREEVIEW widget.
N*/
N#define TREEVIEW_CI_UNSEL           0          // Color of unselected element.
N#define TREEVIEW_CI_SEL             1          // Color of selected element.
N#define TREEVIEW_CI_DISABLED        2          // Color of disabled element.
N
N/************************************************************
N*
N*       TREEVIEW position flags (insert)
N*
N*  Description
N*    These flags are used to specify a position when creating and inserting
N*    a new item into the TREEVIEW widget.
N*/
N#define TREEVIEW_INSERT_ABOVE       0          // Attaches the item above the given position at the same indent level as the given position.
N#define TREEVIEW_INSERT_BELOW       1          // Attaches the item below the given position at the same indent level as the given position.
N#define TREEVIEW_INSERT_FIRST_CHILD 2          // Attaches the item below the given position by indenting it. The given position needs to be a node level.
N
N/************************************************************
N*
N*       TREEVIEW position flags (get)
N*
N*  Description
N*    These flags are used to specify a position when retrieving an item
N*    of the TREEVIEW widget using the routine TREEVIEW_GetItem().
N*/
N#define TREEVIEW_GET_FIRST          0          // Returns the first item of the TREEVIEW widget. Parameter hItem is not required and can be 0.
N#define TREEVIEW_GET_LAST           1          // Returns the last item of the TREEVIEW widget. Parameter hItem is not required and can be 0.
N#define TREEVIEW_GET_NEXT_SIBLING   2          // Returns the next child item of the parent node of hItem.
N#define TREEVIEW_GET_PREV_SIBLING   3          // Returns the previous child item of the parent node of hItem.
N#define TREEVIEW_GET_FIRST_CHILD    4          // Returns the first child of the given node.
N#define TREEVIEW_GET_PARENT         5          // Returns the parent node of the given item.
N
N/************************************************************
N*
N*       TREEVIEW item flags
N*
N*  Description
N*    Flags that define the item type of a newly created TREEVIEW item.
N*/
N#define TREEVIEW_ITEM_TYPE_LEAF     (0 << 0)   // Used to create a leaf.
N#define TREEVIEW_ITEM_TYPE_NODE     (1 << 0)   // Used to create a node.
N
N/************************************************************
N*
N*       TREEVIEW selection modes
N*
N*  Description
N*    Flags that are used to define the selection mode of a TREEVIEW widget.
N*    Refer to TREEVIEW_SetSelMode() for more information.
N*/
N#define TREEVIEW_SELMODE_ROW        1          // Activates row selection mode.
N#define TREEVIEW_SELMODE_TEXT       0          // Activates text selection mode.
N
N/************************************************************
N*
N*       Types
N*
N*************************************************************
N*/
Ntypedef WM_HMEM TREEVIEW_Handle;
Xtypedef signed long TREEVIEW_Handle;
Ntypedef WM_HMEM TREEVIEW_ITEM_Handle;
Xtypedef signed long TREEVIEW_ITEM_Handle;
N
N/************************************************************
N*
N*       TREEVIEW_ITEM_INFO
N*
N*  Description
N*    Structure that contains information about a node in a TREEVIEW widget.
N*/
Ntypedef struct {
N  int IsNode;           // 1 if item is a node, 0 if not.
N  int IsExpanded;       // 1 if item (node) is open, 0 if closed.
N  int HasLines;         // 1 if joining lines are visible, 0 if not.
N  int HasRowSelect;     // 1 if row selection is active, 0 if not.
N  int Level;            // Indentation level of item.
N} TREEVIEW_ITEM_INFO;
N
Ntypedef struct {
N  GUI_COLOR ColorBk;
N  GUI_COLOR ColorText;
N  GUI_COLOR ColorTextBk;
N  GUI_COLOR ColorLines;
N  GUI_RECT rText;
N  TREEVIEW_ITEM_Handle hItem;
N  const GUI_FONT * pFont;
N  char * pText;
N  U8 NumLines;
X  unsigned char NumLines;
N  I16 ax0[3];
X  signed short ax0[3];
N  I16 ay0[3];
X  signed short ay0[3];
N  I16 ax1[3];
X  signed short ax1[3];
N  I16 ay1[3];
X  signed short ay1[3];
N  U8 NumConnectors;
X  unsigned char NumConnectors;
N  I16 axc[16];
X  signed short axc[16];
N  const GUI_BITMAP * pBmPM;
N  const GUI_BITMAP * pBmOCL;
N  I16 xPosPM, xPosOCL;
X  signed short xPosPM, xPosOCL;
N  U8 IndexPM;
X  unsigned char IndexPM;
N  U8 IndexOCL;
X  unsigned char IndexOCL;
N} TREEVIEW_ITEM_DRAW_INFO;
N
N/*********************************************************************
N*
N*       Create functions
N*
N**********************************************************************
N*/
NTREEVIEW_Handle      TREEVIEW_CreateEx      (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int ExFlags, int Id);
XTREEVIEW_Handle      TREEVIEW_CreateEx      (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int WinFlags, int ExFlags, int Id);
NTREEVIEW_Handle      TREEVIEW_CreateUser    (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int ExFlags, int Id, int NumExtraBytes);
XTREEVIEW_Handle      TREEVIEW_CreateUser    (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int WinFlags, int ExFlags, int Id, int NumExtraBytes);
NTREEVIEW_Handle      TREEVIEW_CreateIndirect(const GUI_WIDGET_CREATE_INFO * pCreateInfo, WM_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
XTREEVIEW_Handle      TREEVIEW_CreateIndirect(const GUI_WIDGET_CREATE_INFO * pCreateInfo, GUI_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
N
N/*********************************************************************
N*
N*       The callback ...
N*
N* Do not call it directly ! It is only to be used from within an
N* overwritten callback.
N*/
Nvoid TREEVIEW_Callback(WM_MESSAGE * pMsg);
N
N/*********************************************************************
N*
N*       Common functions
N*
N**********************************************************************
N*/
Nint                  TREEVIEW_AttachItem     (TREEVIEW_Handle hObj, TREEVIEW_ITEM_Handle hItem, TREEVIEW_ITEM_Handle hItemAt, int Position);
Nvoid                 TREEVIEW_DecSel         (TREEVIEW_Handle hObj);
NTREEVIEW_ITEM_Handle TREEVIEW_GetItem        (TREEVIEW_Handle hObj, TREEVIEW_ITEM_Handle hItem, int Flags);
NTREEVIEW_ITEM_Handle TREEVIEW_GetSel         (TREEVIEW_Handle hObj);
Nint                  TREEVIEW_GetUserData    (TREEVIEW_Handle hObj, void * pDest, int NumBytes);
Nvoid                 TREEVIEW_IncSel         (TREEVIEW_Handle hObj);
NTREEVIEW_ITEM_Handle TREEVIEW_InsertItem     (TREEVIEW_Handle hObj, int IsNode, TREEVIEW_ITEM_Handle hItemPrev, int Position, const char * s);
Nint                  TREEVIEW_OwnerDraw      (const WIDGET_ITEM_DRAW_INFO * pDrawItemInfo);
Nvoid                 TREEVIEW_ScrollToSel    (TREEVIEW_Handle hObj);
Nvoid                 TREEVIEW_SetAutoScrollH (TREEVIEW_Handle hObj, int State);
Nvoid                 TREEVIEW_SetAutoScrollV (TREEVIEW_Handle hObj, int State);
Nvoid                 TREEVIEW_SetBitmapOffset(TREEVIEW_Handle hObj, int Index, int xOff, int yOff);
Nvoid                 TREEVIEW_SetBkColor     (TREEVIEW_Handle hObj, int Index, GUI_COLOR Color);
Nvoid                 TREEVIEW_SetFont        (TREEVIEW_Handle hObj, const GUI_FONT * pFont);
Nvoid                 TREEVIEW_SetHasLines    (TREEVIEW_Handle hObj, int State);
Nvoid                 TREEVIEW_SetImage       (TREEVIEW_Handle hObj, int Index, const GUI_BITMAP * pBitmap);
Nint                  TREEVIEW_SetIndent      (TREEVIEW_Handle hObj, int Indent);
Nvoid                 TREEVIEW_SetLineColor   (TREEVIEW_Handle hObj, int Index, GUI_COLOR Color);
Nvoid                 TREEVIEW_SetOwnerDraw   (TREEVIEW_Handle hObj, WIDGET_DRAW_ITEM_FUNC * pfDrawItem);
Nvoid                 TREEVIEW_SetSel         (TREEVIEW_Handle hObj, TREEVIEW_ITEM_Handle hItem);
Nvoid                 TREEVIEW_SetSelMode     (TREEVIEW_Handle hObj, int Mode);
Nvoid                 TREEVIEW_SetTextColor   (TREEVIEW_Handle hObj, int Index, GUI_COLOR Color);
Nint                  TREEVIEW_SetTextIndent  (TREEVIEW_Handle hObj, int TextIndent);
Nint                  TREEVIEW_SetUserData    (TREEVIEW_Handle hObj, const void * pSrc, int NumBytes);
N
N
N/*********************************************************************
N*
N*       Treeview item related functions
N*
N**********************************************************************
N*/
Nvoid                 TREEVIEW_ITEM_Collapse   (TREEVIEW_ITEM_Handle hItem);
Nvoid                 TREEVIEW_ITEM_CollapseAll(TREEVIEW_ITEM_Handle hItem);
NTREEVIEW_ITEM_Handle TREEVIEW_ITEM_Create     (int IsNode, const char * s, U32 UserData);
XTREEVIEW_ITEM_Handle TREEVIEW_ITEM_Create     (int IsNode, const char * s, unsigned long UserData);
Nvoid                 TREEVIEW_ITEM_Delete     (TREEVIEW_ITEM_Handle hItem);
Nvoid                 TREEVIEW_ITEM_Detach     (TREEVIEW_ITEM_Handle hItem);
Nvoid                 TREEVIEW_ITEM_Expand     (TREEVIEW_ITEM_Handle hItem);
Nvoid                 TREEVIEW_ITEM_ExpandAll  (TREEVIEW_ITEM_Handle hItem);
Nvoid                 TREEVIEW_ITEM_GetInfo    (TREEVIEW_ITEM_Handle hItem, TREEVIEW_ITEM_INFO * pInfo);
Nvoid                 TREEVIEW_ITEM_GetText    (TREEVIEW_ITEM_Handle hItem, U8 * pBuffer, int MaxNumBytes);
Xvoid                 TREEVIEW_ITEM_GetText    (TREEVIEW_ITEM_Handle hItem, unsigned char * pBuffer, int MaxNumBytes);
NU32                  TREEVIEW_ITEM_GetUserData(TREEVIEW_ITEM_Handle hItem);
Xunsigned long                  TREEVIEW_ITEM_GetUserData(TREEVIEW_ITEM_Handle hItem);
Nvoid                 TREEVIEW_ITEM_SetImage   (TREEVIEW_ITEM_Handle hItem, int Index, const GUI_BITMAP * pBitmap);
NTREEVIEW_ITEM_Handle TREEVIEW_ITEM_SetText    (TREEVIEW_ITEM_Handle hItem, const char * s);
Nvoid                 TREEVIEW_ITEM_SetUserData(TREEVIEW_ITEM_Handle hItem, U32 UserData);
Xvoid                 TREEVIEW_ITEM_SetUserData(TREEVIEW_ITEM_Handle hItem, unsigned long UserData);
N
N/*********************************************************************
N*
N*       Managing default values
N*
N**********************************************************************
N*/
NGUI_COLOR        TREEVIEW_GetDefaultBkColor  (int Index);
Nconst GUI_FONT * TREEVIEW_GetDefaultFont     (void);
NGUI_COLOR        TREEVIEW_GetDefaultLineColor(int Index);
NGUI_COLOR        TREEVIEW_GetDefaultTextColor(int Index);
Nvoid             TREEVIEW_SetDefaultBkColor  (int Index, GUI_COLOR Color);
Nvoid             TREEVIEW_SetDefaultFont     (const GUI_FONT * pFont);
Nvoid             TREEVIEW_SetDefaultLineColor(int Index, GUI_COLOR Color);
Nvoid             TREEVIEW_SetDefaultTextColor(int Index, GUI_COLOR Color);
N
N#if defined(__cplusplus)
X#if 0L
S  }
N#endif
N
N#endif  // GUI_WINSUPPORT
N#endif  // TREEVIEW_H
N
N/*************************** End of file ****************************/
L 85 "..\..\..\..\ThirdParty\emWin\Include\DIALOG.h" 2
N#include "WHEEL.h"
L 1 "..\..\..\..\ThirdParty\emWin\Include\WHEEL.h" 1
N/*********************************************************************
N*                    SEGGER Microcontroller GmbH                     *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2023  SEGGER Microcontroller GmbH                *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V6.46 - Graphical user interface for embedded applications **
NemWin is protected by international copyright laws. Knowledge of the
Nsource code may not be used to write a similar product. 
NThis file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed by SEGGER Software GmbH to Nuvoton Technology Corporation
Nat the address: No. 4, Creation Rd. III, Hsinchu Science Park, Taiwan
Nfor the purposes  of  creating  libraries  for its 
NArm Cortex-A, Arm Cortex-M and  Arm9 32-bit microcontrollers, commercialized and distributed by Nuvoton Technology Corporation
Nunder  the terms and conditions  of  an  End  User  
NLicense  Agreement  supplied  with  the libraries.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NLicensing information
NLicensor:                 SEGGER Software GmbH
NLicensed to:              Nuvoton Technology Corporation, No. 4, Creation Rd. III, Hsinchu Science Park, 30077 Hsinchu City, Taiwan
NLicensed SEGGER software: emWin
NLicense number:           GUI-00735
NLicense model:            emWin License Agreement, signed February 27, 2018
NLicensed platform:        Cortex-M, Cortex-A, and ARM9 32-bit series microcontroller designed and manufactured by Nuvoton Technology Corporation.
N----------------------------------------------------------------------
NSupport and Update Agreement (SUA)
NSUA period:               2018-03-26 - 2025-09-04
NContact to extend SUA:    sales@segger.com
N----------------------------------------------------------------------
NFile        : WHEEL.h
NPurpose     : WHEEL include
N--------------------END-OF-HEADER-------------------------------------
N*/
N
N#ifndef WHEEL_H
N#define WHEEL_H
N
N#include "WM.h"
N#include "DIALOG_Type.h"      // Req. for Create indirect data structure
N#include "WIDGET.h"
N
N#if (GUI_SUPPORT_MEMDEV && GUI_WINSUPPORT)
X#if (1 && 1)
N
N#if defined(__cplusplus)
X#if 0L
S  extern "C" {                  // Make sure we have C-declarations in C++ programs
N#endif
N
N/*********************************************************************
N*
N*       Defines
N*
N**********************************************************************
N*/
N/************************************************************
N*
N*       WHEEL create flags
N* 
N*  Description
N*    Flags that are passed when the WHEEL is created.
N*/
N#define WHEEL_CF_HORIZONTAL 0                   // The WHEEL moves horizontally.
N#define WHEEL_CF_VERTICAL   WIDGET_CF_VERTICAL  // The WHEEL moves vertically.
N
N/************************************************************
N*
N*       WHEEL mode flags
N* 
N*  Description
N*   Flags that define the movement behavior of the widget and
N*   the WHEEL's cells.
N* 
N*  Additional information
N*    A more detailed explanation of the WHEEL modes can be found
N*    at the beginnging of the chapter.
N*/
N#define WHEEL_MODE_ENDLESS 0                   // The WHEEL's list moves continuously and does not stop when the end
N                                               // of the list has been reached.
N#define WHEEL_MODE_STOP    WIDGET_STATE_USER0  // The WHEEL's list moves from the first element to the last one and stops
N                                               // when the last element has been reached.
N#define WHEEL_MODE_PLAIN   0                   // Puts the WHEEL into plain mode. While the list is moving the items don't
N                                               // morph into one another, but the center item is highlighted.
N#define WHEEL_MODE_MORPH   WIDGET_STATE_USER1  // Puts the WHEEL into morph mode. While the list is moving one item
N                                               // morphs into the next item.
N
N/************************************************************
N*
N*       WHEEL overlay indexes
N* 
N*  Description
N*    Indexes for the WHEEL's overlay bitmaps.
N*/
N#define WHEEL_OI_FIRST  0  // First overlay bitmap that is drawn above the WHEEL.
N#define WHEEL_OI_SECOND 1  // Second overlay bitmap that is drawn above the WHEEL.
N#define WHEEL_OI_THIRD  2  // Third overlay bitmap that is drawn above the WHEEL.
N
N/*********************************************************************
N*
N*       Public Types
N*
N**********************************************************************
N*/
Ntypedef WM_HMEM WHEEL_Handle;
Xtypedef signed long WHEEL_Handle;
N
N/*********************************************************************
N*
N*       Create functions
N*
N**********************************************************************
N*/
NWHEEL_Handle WHEEL_CreateEx      (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int ExFlags, int Id);
XWHEEL_Handle WHEEL_CreateEx      (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int WinFlags, int ExFlags, int Id);
NWHEEL_Handle WHEEL_CreateUser    (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int ExFlags, int Id, int NumExtraBytes);
XWHEEL_Handle WHEEL_CreateUser    (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int WinFlags, int ExFlags, int Id, int NumExtraBytes);
NWHEEL_Handle WHEEL_CreateIndirect(const GUI_WIDGET_CREATE_INFO * pCreateInfo, WM_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
XWHEEL_Handle WHEEL_CreateIndirect(const GUI_WIDGET_CREATE_INFO * pCreateInfo, GUI_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
N
N/*********************************************************************
N*
N*       The callback ...
N*
N* Do not call it directly ! It is only to be used from within an
N* overwritten callback.
N*/
Nvoid WHEEL_Callback(WM_MESSAGE * pMsg);
N
N/*********************************************************************
N*
N*       Member functions
N*
N**********************************************************************
N*/
Nint  WHEEL_AddBitmaps            (WHEEL_Handle hObj, const GUI_BITMAP     ** ppBitmap, unsigned NumItems, U8 Align, I16 xOff, I16 yOff, GUI_COLOR Color);
Xint  WHEEL_AddBitmaps            (WHEEL_Handle hObj, const GUI_BITMAP     ** ppBitmap, unsigned NumItems, unsigned char Align, signed short xOff, signed short yOff, GUI_COLOR Color);
Nint  WHEEL_AddItemText           (WHEEL_Handle hObj, unsigned Index, const char * s);
Nint  WHEEL_AddText               (WHEEL_Handle hObj, const GUI_ConstString * ppText,   unsigned NumItems, U8 Align, I16 xOff, I16 yOff, GUI_COLOR Color, const GUI_FONT * pFont);
Xint  WHEEL_AddText               (WHEEL_Handle hObj, const GUI_ConstString * ppText,   unsigned NumItems, unsigned char Align, signed short xOff, signed short yOff, GUI_COLOR Color, const GUI_FONT * pFont);
Nvoid WHEEL_ClrCenterBox          (WHEEL_Handle hObj);
Nvoid WHEEL_ClrCenterBitmaps      (WHEEL_Handle hObj, unsigned Index);
Nvoid WHEEL_ClrCenterText         (WHEEL_Handle hObj, unsigned Index);
Nint  WHEEL_DelItemText           (WHEEL_Handle hObj, unsigned Index, unsigned Row);
Nint  WHEEL_GetItemText           (WHEEL_Handle hObj, unsigned Index, unsigned Row, char * pBuffer, int MaxLen);
Nint  WHEEL_GetNumText            (WHEEL_Handle hObj);
Nint  WHEEL_GetNumTextItems       (WHEEL_Handle hObj, unsigned Index);
Nint  WHEEL_GetReleasedItem       (WHEEL_Handle hObj);
Nint  WHEEL_GetSel                (WHEEL_Handle hObj);
Nint  WHEEL_GetUserData           (WHEEL_Handle hObj, void * pDest, int NumBytes);
Nint  WHEEL_InsertItemText        (WHEEL_Handle hObj, unsigned Index, unsigned Row, const char * s);
Nint  WHEEL_IsMoving              (WHEEL_Handle hObj);
Nint  WHEEL_OwnerDrawMorph        (const WIDGET_ITEM_DRAW_INFO * pDrawItemInfo);
Nint  WHEEL_OwnerDrawPlain        (const WIDGET_ITEM_DRAW_INFO * pDrawItemInfo);
Nvoid WHEEL_MoveToPos             (WHEEL_Handle hObj, int Index);
Nvoid WHEEL_MoveToPosEx           (WHEEL_Handle hObj, int Index, U32 Period);
Xvoid WHEEL_MoveToPosEx           (WHEEL_Handle hObj, int Index, unsigned long Period);
Nvoid WHEEL_SetAlign              (WHEEL_Handle hObj, U8 Align);
Xvoid WHEEL_SetAlign              (WHEEL_Handle hObj, unsigned char Align);
Nvoid WHEEL_SetBkColor            (WHEEL_Handle hObj, GUI_COLOR BkColor);
Nvoid WHEEL_SetBox                (WHEEL_Handle hObj, GUI_COLOR Color, GUI_COLOR FrameColor, U8 FrameRadius, U8 FrameSize);
Xvoid WHEEL_SetBox                (WHEEL_Handle hObj, GUI_COLOR Color, GUI_COLOR FrameColor, unsigned char FrameRadius, unsigned char FrameSize);
Nvoid WHEEL_SetCellBitmapAttrMorph(WHEEL_Handle hObj, unsigned Index, U8 Align, I16 xOff, I16 yOff, GUI_COLOR Color);
Xvoid WHEEL_SetCellBitmapAttrMorph(WHEEL_Handle hObj, unsigned Index, unsigned char Align, signed short xOff, signed short yOff, GUI_COLOR Color);
Nvoid WHEEL_SetCellColorPlain     (WHEEL_Handle hObj, GUI_COLOR Color);
Nvoid WHEEL_SetCenterBitmapAttr   (WHEEL_Handle hObj, unsigned Index, U8 Align, I16 xOff, I16 yOff, GUI_COLOR Color);
Xvoid WHEEL_SetCenterBitmapAttr   (WHEEL_Handle hObj, unsigned Index, unsigned char Align, signed short xOff, signed short yOff, GUI_COLOR Color);
Nvoid WHEEL_SetCenterBitmaps      (WHEEL_Handle hObj, unsigned Index, const GUI_BITMAP ** ppBitmap, unsigned NumItems, U8 Align, I16 xOff, I16 yOff, GUI_COLOR Color);
Xvoid WHEEL_SetCenterBitmaps      (WHEEL_Handle hObj, unsigned Index, const GUI_BITMAP ** ppBitmap, unsigned NumItems, unsigned char Align, signed short xOff, signed short yOff, GUI_COLOR Color);
Nvoid WHEEL_SetCenterBox          (WHEEL_Handle hObj, GUI_COLOR Color, GUI_COLOR FrameColor, U8 FrameRadius, U8 FrameSize);
Xvoid WHEEL_SetCenterBox          (WHEEL_Handle hObj, GUI_COLOR Color, GUI_COLOR FrameColor, unsigned char FrameRadius, unsigned char FrameSize);
Nvoid WHEEL_SetCenterColorPlain   (WHEEL_Handle hObj, GUI_COLOR Color);
Nvoid WHEEL_SetCenterTextAttrMorph(WHEEL_Handle hObj, unsigned Index, U8 Align, I16 xOff, I16 yOff, GUI_COLOR Color);
Xvoid WHEEL_SetCenterTextAttrMorph(WHEEL_Handle hObj, unsigned Index, unsigned char Align, signed short xOff, signed short yOff, GUI_COLOR Color);
Nvoid WHEEL_SetCenterTextAttrPlain(WHEEL_Handle hObj, unsigned Index, U8 Align, I16 xOff, I16 yOff, GUI_COLOR Color, const GUI_FONT * pFont);
Xvoid WHEEL_SetCenterTextAttrPlain(WHEEL_Handle hObj, unsigned Index, unsigned char Align, signed short xOff, signed short yOff, GUI_COLOR Color, const GUI_FONT * pFont);
Nvoid WHEEL_SetHBorder            (WHEEL_Handle hObj, U16 BorderText);
Xvoid WHEEL_SetHBorder            (WHEEL_Handle hObj, unsigned short BorderText);
Nint  WHEEL_SetItemText           (WHEEL_Handle hObj, unsigned Index, unsigned Row, const char * s);
Nvoid WHEEL_SetMode               (WHEEL_Handle hObj, U16 Mode);
Xvoid WHEEL_SetMode               (WHEEL_Handle hObj, unsigned short Mode);
Nvoid WHEEL_SetOwnerDraw          (WHEEL_Handle hObj, WIDGET_DRAW_ITEM_FUNC * pfDrawItem);
Nvoid WHEEL_SetOverlay            (WHEEL_Handle hObj, unsigned Index, const GUI_BITMAP * pBitmap, U8 Align, I16 xOff, I16 yOff);
Xvoid WHEEL_SetOverlay            (WHEEL_Handle hObj, unsigned Index, const GUI_BITMAP * pBitmap, unsigned char Align, signed short xOff, signed short yOff);
Nvoid WHEEL_SetOverlayColor       (WHEEL_Handle hObj, unsigned Index, GUI_COLOR Color);
Nvoid WHEEL_SetPeriod             (WHEEL_Handle hObj, U32 Period);
Xvoid WHEEL_SetPeriod             (WHEEL_Handle hObj, unsigned long Period);
Nvoid WHEEL_SetSel                (WHEEL_Handle hObj, int Index);
Nvoid WHEEL_SetSizesMorph         (WHEEL_Handle hObj, U16 CellSize, U16 CenterSize, U16 Cutaway, U8 Align);
Xvoid WHEEL_SetSizesMorph         (WHEEL_Handle hObj, unsigned short CellSize, unsigned short CenterSize, unsigned short Cutaway, unsigned char Align);
Nvoid WHEEL_SetSizesPlain         (WHEEL_Handle hObj, U16 CellSize, U16 CenterSize);
Xvoid WHEEL_SetSizesPlain         (WHEEL_Handle hObj, unsigned short CellSize, unsigned short CenterSize);
Nint  WHEEL_SetUserData           (WHEEL_Handle hObj, const void * pSrc, int NumBytes);
N
N/*********************************************************************
N*
N*       Global functions
N*
N**********************************************************************
N*/
Nvoid WHEEL_SetDefaultPeriod(int Period);
Nint  WHEEL_GetDefaultPeriod(void);
N
N#if defined(__cplusplus)
X#if 0L
S  }
N#endif
N
N#endif  // (GUI_SUPPORT_MEMDEV && GUI_WINSUPPORT)
N#endif  // WHEEL_H
N
N/*************************** End of file ****************************/
L 86 "..\..\..\..\ThirdParty\emWin\Include\DIALOG.h" 2
N
N#if GUI_WINSUPPORT
X#if 1
N
N#if defined(__cplusplus)
X#if 0L
S  extern "C" {     /* Make sure we have C-declarations in C++ programs */
N#endif
N
N/*********************************************************************
N*
N*       WINDOW API
N*/
NWM_HWIN   WINDOW_CreateEx         (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int ExFlags, int Id, WM_CALLBACK * cb);
XGUI_HWIN   WINDOW_CreateEx         (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int WinFlags, int ExFlags, int Id, WM_CALLBACK * cb);
NWM_HWIN   WINDOW_CreateUser       (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int ExFlags, int Id, WM_CALLBACK * cb, int NumExtraBytes);
XGUI_HWIN   WINDOW_CreateUser       (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int WinFlags, int ExFlags, int Id, WM_CALLBACK * cb, int NumExtraBytes);
NWM_HWIN   WINDOW_CreateIndirect   (const GUI_WIDGET_CREATE_INFO * pCreateInfo, WM_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
XGUI_HWIN   WINDOW_CreateIndirect   (const GUI_WIDGET_CREATE_INFO * pCreateInfo, GUI_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
NGUI_COLOR WINDOW_GetBkColor       (WM_HWIN hObj);
XGUI_COLOR WINDOW_GetBkColor       (GUI_HWIN hObj);
NGUI_COLOR WINDOW_GetDefaultBkColor(void);
Nint       WINDOW_GetUserData      (WM_HWIN hObj, void * pDest, int NumBytes);
Xint       WINDOW_GetUserData      (GUI_HWIN hObj, void * pDest, int NumBytes);
Nvoid      WINDOW_SetBkColor       (WM_HWIN hObj, GUI_COLOR Color);
Xvoid      WINDOW_SetBkColor       (GUI_HWIN hObj, GUI_COLOR Color);
Nvoid      WINDOW_SetDefaultBkColor(GUI_COLOR Color);
Nint       WINDOW_SetUserData      (WM_HWIN hObj, const void * pSrc, int NumBytes);
Xint       WINDOW_SetUserData      (GUI_HWIN hObj, const void * pSrc, int NumBytes);
N
Nvoid WINDOW_Callback(WM_MESSAGE * pMsg);
N
N#if defined(__cplusplus)
X#if 0L
S  }
N#endif
N
N#endif  // GUI_WINSUPPORT
N#endif  // DIALOG_H
N
N/*************************** End of file ****************************/
L 51 "..\..\..\..\ThirdParty\emWin\Include\AppWizard.h" 2
N
N#include "BUTTON_Private.h"
L 1 "..\..\..\..\ThirdParty\emWin\Include\BUTTON_Private.h" 1
N/*********************************************************************
N*                    SEGGER Microcontroller GmbH                     *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2023  SEGGER Microcontroller GmbH                *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V6.46 - Graphical user interface for embedded applications **
NemWin is protected by international copyright laws. Knowledge of the
Nsource code may not be used to write a similar product. 
NThis file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed by SEGGER Software GmbH to Nuvoton Technology Corporation
Nat the address: No. 4, Creation Rd. III, Hsinchu Science Park, Taiwan
Nfor the purposes  of  creating  libraries  for its 
NArm Cortex-A, Arm Cortex-M and  Arm9 32-bit microcontrollers, commercialized and distributed by Nuvoton Technology Corporation
Nunder  the terms and conditions  of  an  End  User  
NLicense  Agreement  supplied  with  the libraries.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NLicensing information
NLicensor:                 SEGGER Software GmbH
NLicensed to:              Nuvoton Technology Corporation, No. 4, Creation Rd. III, Hsinchu Science Park, 30077 Hsinchu City, Taiwan
NLicensed SEGGER software: emWin
NLicense number:           GUI-00735
NLicense model:            emWin License Agreement, signed February 27, 2018
NLicensed platform:        Cortex-M, Cortex-A, and ARM9 32-bit series microcontroller designed and manufactured by Nuvoton Technology Corporation.
N----------------------------------------------------------------------
NSupport and Update Agreement (SUA)
NSUA period:               2018-03-26 - 2025-09-04
NContact to extend SUA:    sales@segger.com
N----------------------------------------------------------------------
NFile        : BUTTON_Private.h
NPurpose     : BUTTON private header file
N--------------------END-OF-HEADER-------------------------------------
N*/
N
N#ifndef BUTTON_PRIVATE_H
N#define BUTTON_PRIVATE_H
N
N#include "WM_Intern.h"
L 1 "..\..\..\..\ThirdParty\emWin\Include\WM_Intern.h" 1
N/*********************************************************************
N*                    SEGGER Microcontroller GmbH                     *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2023  SEGGER Microcontroller GmbH                *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V6.46 - Graphical user interface for embedded applications **
NemWin is protected by international copyright laws. Knowledge of the
Nsource code may not be used to write a similar product. 
NThis file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed by SEGGER Software GmbH to Nuvoton Technology Corporation
Nat the address: No. 4, Creation Rd. III, Hsinchu Science Park, Taiwan
Nfor the purposes  of  creating  libraries  for its 
NArm Cortex-A, Arm Cortex-M and  Arm9 32-bit microcontrollers, commercialized and distributed by Nuvoton Technology Corporation
Nunder  the terms and conditions  of  an  End  User  
NLicense  Agreement  supplied  with  the libraries.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NLicensing information
NLicensor:                 SEGGER Software GmbH
NLicensed to:              Nuvoton Technology Corporation, No. 4, Creation Rd. III, Hsinchu Science Park, 30077 Hsinchu City, Taiwan
NLicensed SEGGER software: emWin
NLicense number:           GUI-00735
NLicense model:            emWin License Agreement, signed February 27, 2018
NLicensed platform:        Cortex-M, Cortex-A, and ARM9 32-bit series microcontroller designed and manufactured by Nuvoton Technology Corporation.
N----------------------------------------------------------------------
NSupport and Update Agreement (SUA)
NSUA period:               2018-03-26 - 2025-09-04
NContact to extend SUA:    sales@segger.com
N----------------------------------------------------------------------
NFile        : WM_Intern.h
NPurpose     : Windows manager internal include
N----------------------------------------------------------------------
N*/
N
N#ifndef WM_INTERN_H            /* Make sure we only include it once */
N#define WM_INTERN_H            /* Make sure we only include it once */
N
N#include "GUI_Private.h"
L 1 "..\..\..\..\ThirdParty\emWin\Include\GUI_Private.h" 1
N/*********************************************************************
N*                    SEGGER Microcontroller GmbH                     *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2023  SEGGER Microcontroller GmbH                *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V6.46 - Graphical user interface for embedded applications **
NemWin is protected by international copyright laws. Knowledge of the
Nsource code may not be used to write a similar product. 
NThis file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed by SEGGER Software GmbH to Nuvoton Technology Corporation
Nat the address: No. 4, Creation Rd. III, Hsinchu Science Park, Taiwan
Nfor the purposes  of  creating  libraries  for its 
NArm Cortex-A, Arm Cortex-M and  Arm9 32-bit microcontrollers, commercialized and distributed by Nuvoton Technology Corporation
Nunder  the terms and conditions  of  an  End  User  
NLicense  Agreement  supplied  with  the libraries.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NLicensing information
NLicensor:                 SEGGER Software GmbH
NLicensed to:              Nuvoton Technology Corporation, No. 4, Creation Rd. III, Hsinchu Science Park, 30077 Hsinchu City, Taiwan
NLicensed SEGGER software: emWin
NLicense number:           GUI-00735
NLicense model:            emWin License Agreement, signed February 27, 2018
NLicensed platform:        Cortex-M, Cortex-A, and ARM9 32-bit series microcontroller designed and manufactured by Nuvoton Technology Corporation.
N----------------------------------------------------------------------
NSupport and Update Agreement (SUA)
NSUA period:               2018-03-26 - 2025-09-04
NContact to extend SUA:    sales@segger.com
N----------------------------------------------------------------------
NFile        : GUI_Private.h
NPurpose     : GUI internal declarations
N---------------------------END-OF-HEADER------------------------------
N*/
N
N#ifndef GUI_PRIVATE_H
N#define GUI_PRIVATE_H
N
N#include "GUI.h"
N#include "LCD_Protected.h"
L 1 "..\..\..\..\ThirdParty\emWin\Include\LCD_Protected.h" 1
N/*********************************************************************
N*                    SEGGER Microcontroller GmbH                     *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2023  SEGGER Microcontroller GmbH                *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V6.46 - Graphical user interface for embedded applications **
NemWin is protected by international copyright laws. Knowledge of the
Nsource code may not be used to write a similar product. 
NThis file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed by SEGGER Software GmbH to Nuvoton Technology Corporation
Nat the address: No. 4, Creation Rd. III, Hsinchu Science Park, Taiwan
Nfor the purposes  of  creating  libraries  for its 
NArm Cortex-A, Arm Cortex-M and  Arm9 32-bit microcontrollers, commercialized and distributed by Nuvoton Technology Corporation
Nunder  the terms and conditions  of  an  End  User  
NLicense  Agreement  supplied  with  the libraries.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NLicensing information
NLicensor:                 SEGGER Software GmbH
NLicensed to:              Nuvoton Technology Corporation, No. 4, Creation Rd. III, Hsinchu Science Park, 30077 Hsinchu City, Taiwan
NLicensed SEGGER software: emWin
NLicense number:           GUI-00735
NLicense model:            emWin License Agreement, signed February 27, 2018
NLicensed platform:        Cortex-M, Cortex-A, and ARM9 32-bit series microcontroller designed and manufactured by Nuvoton Technology Corporation.
N----------------------------------------------------------------------
NSupport and Update Agreement (SUA)
NSUA period:               2018-03-26 - 2025-09-04
NContact to extend SUA:    sales@segger.com
N----------------------------------------------------------------------
NFile        : LCD_Protected.h
NPurpose     : LCD level - To be used only internally by the GUI
N----------------------------------------------------------------------
N*/
N
N#ifndef LCD_PROTECTED_H
N#define LCD_PROTECTED_H
N
N#include "LCD.h"
N
N#if defined(__cplusplus)
X#if 0L
Sextern "C" {     /* Make sure we have C-declarations in C++ programs */
N#endif
N
N//#ifndef NULL
N//  #define NULL ((void *)0)
N//#endif
N
N/*********************************************************************
N*
N*       Data types
N*/
Ntypedef struct {
N  LCD_COLOR * paColor;
N  I16         NumEntries;
X  signed short         NumEntries;
N} LCD_LUT_INFO;
N
Ntypedef struct {
N  tLCDDEV_DrawPixel  * pfDrawPixel;
N  tLCDDEV_DrawHLine  * pfDrawHLine;
N  tLCDDEV_DrawVLine  * pfDrawVLine;
N  tLCDDEV_FillRect   * pfFillRect;
N  tLCDDEV_DrawBitmap * pfDrawBitmap;
N} LCD_API_LIST;
N
N/*********************************************************************
N*
N*       External data
N*/
Nextern GUI_CONST_STORAGE U8 LCD_aMirror[256];
Xextern const unsigned char LCD_aMirror[256];
Nextern LCD_PIXELINDEX * LCD__aConvTable;
Xextern unsigned long * LCD__aConvTable;
N
N/*********************************************************************
N*
N*       Misc functions
N*/
Nvoid LCD_UpdateColorIndices   (void);
Nint  LCD_PassingBitmapsAllowed(void);
Nvoid LCD_EnableCursor         (int OnOff);
Nvoid LCD_SelectLCD            (void);
N
Nvoid LCD_DrawBitmap(int x0,    int y0,
N                    int xsize, int ysize,
N                    int xMul,  int yMul,
N                    int BitsPerPixel,
N                    int BytesPerLine,
N                    const U8 * pPixel,
X                    const unsigned char * pPixel,
N                    const LCD_PIXELINDEX * pTrans);
X                    const unsigned long * pTrans);
N
Nvoid LCD__DrawBitmap_1bpp(int x0,    int y0,
N                          int xsize, int ysize,
N                          int xMul,  int yMul,
N                          int BitsPerPixel,
N                          int BytesPerLine,
N                          const U8 * pPixel,
X                          const unsigned char * pPixel,
N                          const LCD_PIXELINDEX * pTrans,
X                          const unsigned long * pTrans,
N                          int OffData);
N
N/*********************************************************************
N*
N*       Internal used color conversion routines
N*/
NtLCDDEV_Index2Color LCD_Index2Color_444_12;
NtLCDDEV_Index2Color LCD_Index2Color_M444_12;
NtLCDDEV_Index2Color LCD_Index2Color_444_12_1;
NtLCDDEV_Index2Color LCD_Index2Color_M444_12_1;
NtLCDDEV_Index2Color LCD_Index2Color_444_16;
NtLCDDEV_Index2Color LCD_Index2Color_M444_16;
NtLCDDEV_Index2Color LCD_Index2Color_555;
NtLCDDEV_Index2Color LCD_Index2Color_565;
NtLCDDEV_Index2Color LCD_Index2Color_8666;
NtLCDDEV_Index2Color LCD_Index2Color_888;
NtLCDDEV_Index2Color LCD_Index2Color_8888;
NtLCDDEV_Index2Color LCD_Index2Color_M8888I;
NtLCDDEV_Index2Color LCD_Index2Color_M555;
NtLCDDEV_Index2Color LCD_Index2Color_M565;
NtLCDDEV_Index2Color LCD_Index2Color_M888;
N
NtLCDDEV_Color2Index LCD_Color2Index_8666;
N
N#if defined(__cplusplus)
X#if 0L
S}
N#endif
N
N#endif /* LCD_PROTECTED_H */
N
N/*************************** End of file ****************************/
N
L 50 "..\..\..\..\ThirdParty\emWin\Include\GUI_Private.h" 2
N#include "GUI_Debug.h"
N#if GUI_WINSUPPORT
X#if 1
N  #include "WM_GUI.h"
N#endif
N
N#if defined(__cplusplus)
X#if 0L
Sextern "C" {     /* Make sure we have C-declarations in C++ programs */
N#endif
N
N/*********************************************************************
N*
N*       Defaults for config switches
N*
N**********************************************************************
N
N  The config switches below do not affect the interface in GUI.h and
N  are therefor not required to be in GUI.h.
N*/
N
N/* Short address area.
N   For  most compilers, this is "near" or "__near"
N   We do not use this except for some CPUs which we know to always have some
N   near memory, because the GUI_Context and some other data will be declared
N   to be in this short address (near) memory area as it has a major effect
N   on performance.
N   Please define in GUIConf.h (if you want to use it)
N*/
N#ifndef GUI_SADDR
N  #define GUI_SADDR
N#endif
N
N#ifndef GUI_DEFAULT_FONT
S  #define GUI_DEFAULT_FONT    &GUI_Font6x8
N#endif
N
N#ifndef GUI_DEFAULT_CURSOR
N  #define GUI_DEFAULT_CURSOR  &GUI_CursorArrowM
N#endif
N
N#ifndef GUI_DEFAULT_BKCOLOR
N  #define GUI_DEFAULT_BKCOLOR GUI_BLACK
N#endif
N
N#ifndef GUI_DEFAULT_COLOR
N  #define GUI_DEFAULT_COLOR   GUI_WHITE
N#endif
N
N/*********************************************************************
N*
N*       Angles
N*
N**********************************************************************
N*/
N#define GUI_45DEG  512
N#define GUI_90DEG  (2 * GUI_45DEG)
N#define GUI_180DEG (4 * GUI_45DEG)
N#define GUI_360DEG (8 * GUI_45DEG)
N
N/*********************************************************************
N*
N*       Locking checks
N*
N**********************************************************************
N*/
N#if defined (WIN32) && defined (_DEBUG) && GUI_OS
X#if 0L && 0L && (0)
S  #define GUI_ASSERT_LOCK()    GUITASK_AssertLock()
S  #define GUI_ASSERT_NO_LOCK() GUITASK_AssertNoLock()
S  void GUITASK_AssertLock(void);
S  void GUITASK_AssertNoLock(void);
N#else
N  #define GUI_ASSERT_LOCK()
N  #define GUI_ASSERT_NO_LOCK()
N#endif
N
N/*********************************************************************
N*
N*       Division tables
N*
N**********************************************************************
N*/
Nextern const U8 GUI__aConvert_15_255[(1 << 4)];
Xextern const unsigned char GUI__aConvert_15_255[(1 << 4)];
Nextern const U8 GUI__aConvert_31_255[(1 << 5)];
Xextern const unsigned char GUI__aConvert_31_255[(1 << 5)];
Nextern const U8 GUI__aConvert_63_255[(1 << 6)];
Xextern const unsigned char GUI__aConvert_63_255[(1 << 6)];
Nextern const U8 GUI__aConvert_255_15[(1 << 8)];
Xextern const unsigned char GUI__aConvert_255_15[(1 << 8)];
Nextern const U8 GUI__aConvert_255_31[(1 << 8)];
Xextern const unsigned char GUI__aConvert_255_31[(1 << 8)];
Nextern const U8 GUI__aConvert_255_63[(1 << 8)];
Xextern const unsigned char GUI__aConvert_255_63[(1 << 8)];
N
N/*********************************************************************
N*
N*       Usage internals
N*
N**********************************************************************
N*/
Ntypedef GUI_HMEM GUI_USAGE_Handle;
Xtypedef signed long GUI_USAGE_Handle;
Ntypedef struct tsUSAGE_APIList tUSAGE_APIList;
Ntypedef struct GUI_Usage GUI_USAGE;
N#define GUI_USAGE_h GUI_USAGE_Handle
N
Ntypedef GUI_USAGE_h tUSAGE_CreateCompatible(GUI_USAGE * p);
Xtypedef GUI_USAGE_Handle tUSAGE_CreateCompatible(GUI_USAGE * p);
Ntypedef void        tUSAGE_AddPixel        (GUI_USAGE * p, int x, int y);
Ntypedef void        tUSAGE_AddHLine        (GUI_USAGE * p, int x0, int y0, int len);
Ntypedef void        tUSAGE_Clear           (GUI_USAGE * p);
Ntypedef void        tUSAGE_Delete          (GUI_USAGE_h h);
Xtypedef void        tUSAGE_Delete          (GUI_USAGE_Handle h);
Ntypedef int         tUSAGE_GetNextDirty    (GUI_USAGE * p, int * pxOff, int yOff);
N#define GUI_USAGE_LOCK_H(h) ((GUI_USAGE *)GUI_LOCK_H(h))
N
Nvoid GUI_USAGE_DecUseCnt(GUI_USAGE_Handle  hUsage);
N
NGUI_USAGE_Handle GUI_USAGE_BM_Create(int x0, int y0, int xsize, int ysize, int Flags);
Nvoid    GUI_USAGE_Select(GUI_USAGE_Handle hUsage);
Nvoid    GUI_USAGE_AddRect(GUI_USAGE * pUsage, int x0, int y0, int xSize, int ySize);
N#define GUI_USAGE_AddPixel(p, x,y)            p->pAPI->pfAddPixel(p,x,y)
N#define GUI_USAGE_AddHLine(p,x,y,len)         p->pAPI->pfAddHLine(p,x,y,len)
N#define GUI_USAGE_Clear(p)                    p->pAPI->pfClear(p)
N#define GUI_USAGE_Delete(p)                   p->pAPI->pfDelete(p)
N#define GUI_USAGE_GetNextDirty(p,pxOff, yOff) p->pAPI->pfGetNextDirty(p,pxOff, yOff)
N
Nstruct tsUSAGE_APIList {
N  tUSAGE_AddPixel         * pfAddPixel;
N  tUSAGE_AddHLine         * pfAddHLine;
N  tUSAGE_Clear            * pfClear;
N  tUSAGE_CreateCompatible * pfCreateCompatible;
N  tUSAGE_Delete           * pfDelete;
N  tUSAGE_GetNextDirty     * pfGetNextDirty;
N} ;
N
Nstruct GUI_Usage {
N  I16P x0, y0, XSize, YSize;
X  signed short x0, y0, XSize, YSize;
N  const tUSAGE_APIList * pAPI;
N  I16 UseCnt;
X  signed short UseCnt;
N};
N
N/*********************************************************************
N*
N*       GUI_MEMDEV
N*
N**********************************************************************
N*/
N#if GUI_SUPPORT_MEMDEV
X#if 1
N
Ntypedef struct {
N  GUI_DEVICE * pDevice;
N  I16P                   x0, y0, XSize, YSize;
X  signed short                   x0, y0, XSize, YSize;
N  unsigned               BytesPerLine;
N  unsigned               BitsPerPixel;
N  GUI_HMEM               hUsage;
X  signed long               hUsage;
N} GUI_MEMDEV;
N
Ntypedef struct {
N  GUI_USAGE Public;
N  struct {
N    int BytesPerLine;
N  } Private;
N} GUI_USAGE_BM;
N
N#define      GUI_MEMDEV_LOCK_H(h) ((GUI_MEMDEV *)GUI_LOCK_H(h))
N
Nvoid         GUI_MEMDEV__CopyFromLCD (GUI_MEMDEV_Handle hMem);
Nvoid         GUI_MEMDEV__GetRect     (GUI_RECT * pRect);
Nunsigned     GUI_MEMDEV__Color2Index (LCD_COLOR Color);
NLCD_COLOR    GUI_MEMDEV__Index2Color (int Index);
Nunsigned int GUI_MEMDEV__GetIndexMask(void);
Nvoid         GUI_MEMDEV__SetAlphaCallback(unsigned(* pcbSetAlpha)(U8));
Xvoid         GUI_MEMDEV__SetAlphaCallback(unsigned(* pcbSetAlpha)(unsigned char));
N
NGUI_MEMDEV_Handle GUI_MEMDEV__CreateFixed(int x0, int y0, int xSize, int ySize, int Flags,
N                                          const GUI_DEVICE_API     * pDeviceAPI,
N                                          const LCD_API_COLOR_CONV * pColorConvAPI);
N
Nvoid              GUI_MEMDEV__DrawSizedAt        (GUI_MEMDEV_Handle hMem, int xPos, int yPos, int xSize, int ySize);
NGUI_MEMDEV_Handle GUI_MEMDEV__GetEmptyCopy32     (GUI_MEMDEV_Handle hMem, int * pxSize, int * pySize, int * pxPos, int * pyPos);
Nvoid              GUI_MEMDEV__ReadLine           (int x0, int y, int x1, LCD_PIXELINDEX * pBuffer);
Xvoid              GUI_MEMDEV__ReadLine           (int x0, int y, int x1, unsigned long * pBuffer);
Nvoid              GUI_MEMDEV__WriteToActiveAlpha (GUI_MEMDEV_Handle hMem,int x, int y);
Nvoid              GUI_MEMDEV__WriteToActiveAt    (GUI_MEMDEV_Handle hMem,int x, int y);
Nvoid              GUI_MEMDEV__WriteToActiveOpaque(GUI_MEMDEV_Handle hMem,int x, int y);
Nvoid            * GUI_MEMDEV__XY2PTR             (int x,int y);
Nvoid            * GUI_MEMDEV__XY2PTREx           (GUI_MEMDEV * pDev, int x,int y);
Nvoid            * GUI_MEMDEV__XY2PTRStride       (int x, int y, int * pBytesPerLine);
Nvoid              GUI_MEMDEV__BlendColor32       (GUI_MEMDEV_Handle hMem, U32 BlendColor, U8 BlendIntens);
Xvoid              GUI_MEMDEV__BlendColor32       (GUI_MEMDEV_Handle hMem, unsigned long BlendColor, unsigned char BlendIntens);
N
Nunsigned GUI__AlphaPreserveTrans(int OnOff);
N
Nextern unsigned GUI_MEMDEV__TimePerFrame;
N
N#define GUI_TIME_PER_FRAME (GUI_TIMER_TIME)GUI_MEMDEV__TimePerFrame
N
N#define GUI_POS_AUTO -4095   /* Position value for auto-pos */
N
N#endif
N
N/*********************************************************************
N*
N*       LCD_HL_ level defines
N*
N**********************************************************************
N*/
N#define LCD_HL_DrawHLine             GUI_pContext->pLCD_HL->pfDrawHLine
N#define LCD_HL_DrawPixel             GUI_pContext->pLCD_HL->pfDrawPixel
N
N/*********************************************************************
N*
N*       Helper functions
N*
N**********************************************************************
N*/
N#define GUI_ZEROINIT(Obj) GUI__MEMSET(Obj, 0, sizeof(Obj))
Nint  GUI_cos(int angle);
Nint  GUI_sin(int angle);
Nextern const U32 GUI_Pow10[10];
Xextern const unsigned long GUI_Pow10[10];
N
N/* Multi-touch */
Nvoid GUI_MTOUCH__ManagePID(int OnOff);
N
N/* Anti-aliased drawing */
Nint  GUI_AA_Init       (int x0, int x1);
Nint  GUI_AA_Init_HiRes (int x0, int x1);
Nvoid GUI_AA_Exit       (void);
NI16  GUI_AA_HiRes2Pixel(int HiRes);
Xsigned short  GUI_AA_HiRes2Pixel(int HiRes);
N
Nvoid GL_DrawCircleAA_HiRes(int x0, int y0, int r);
Nvoid GL_FillCircleAA_HiRes (int x0, int y0, int r);
Nvoid GL_FillEllipseAA_HiRes(int x0, int y0, int rx, int ry);
Nvoid GL_FillEllipseAA_HiRes_XL(int x0, int y0, int rx, int ry);
N
Nvoid GUI_AA__DrawCharAA2(int x0, int y0, int XSize, int YSize, int BytesPerLine, const U8 * pData);
Xvoid GUI_AA__DrawCharAA2(int x0, int y0, int XSize, int YSize, int BytesPerLine, const unsigned char * pData);
Nvoid GUI_AA__DrawCharAA4(int x0, int y0, int XSize, int YSize, int BytesPerLine, const U8 * pData);
Xvoid GUI_AA__DrawCharAA4(int x0, int y0, int XSize, int YSize, int BytesPerLine, const unsigned char * pData);
Nvoid GUI_AA__DrawCharAA8(int x0, int y0, int XSize, int YSize, int BytesPerLine, const U8 * pData);
Xvoid GUI_AA__DrawCharAA8(int x0, int y0, int XSize, int YSize, int BytesPerLine, const unsigned char * pData);
N
N/* Default routine for drawing string characters with EXT fonts */
NU16 GUI__DrawCharEXT(int RemChars, const char ** ps);
Xunsigned short GUI__DrawCharEXT(int RemChars, const char ** ps);
N
N/* Alpha blending helper functions */
N#define GUI_ALPHABLENDING_DONE  (1 << 0)
N
Nint      GUI__GetAlphaBuffer    (U32 ** ppCurrent, U32 ** ppConvert, U32 ** ppData, int * pVXSizeMax);
Xint      GUI__GetAlphaBuffer    (unsigned long ** ppCurrent, unsigned long ** ppConvert, unsigned long ** ppData, int * pVXSizeMax);
Nint      GUI__AllocAlphaBuffer  (int AllocDataBuffer);
NU32    * GUI__DoAlphaBlending   (int x, int y, U32 * pData, int xSize, tLCDDEV_Index2Color * pfIndex2Color_DEV, int * pDone);
Xunsigned long    * GUI__DoAlphaBlending   (int x, int y, unsigned long * pData, int xSize, tLCDDEV_Index2Color * pfIndex2Color_DEV, int * pDone);
Nunsigned GUI__SetAlphaBufferSize(int xSize);
N
N/* System independent font routines */
Nint        GUI_SIF__GetCharDistX         (U16P c, int * pSizeX);
Xint        GUI_SIF__GetCharDistX         (unsigned short c, int * pSizeX);
Nvoid       GUI_SIF__GetFontInfo          (const GUI_FONT * pFont, GUI_FONTINFO * pfi);
Nchar       GUI_SIF__IsInFont             (const GUI_FONT * pFont, U16 c);
Xchar       GUI_SIF__IsInFont             (const GUI_FONT * pFont, unsigned short c);
Nconst U8 * GUI_SIF__GetpCharInfo         (const GUI_FONT * pFont, U16P c, unsigned SizeOfCharInfo);
Xconst unsigned char * GUI_SIF__GetpCharInfo         (const GUI_FONT * pFont, unsigned short c, unsigned SizeOfCharInfo);
Nint        GUI_SIF__GetNumCharAreas      (const GUI_FONT * pFont);
Nint        GUI_SIF__GetCharDistX_ExtFrm  (U16P c, int * pSizeX);
Xint        GUI_SIF__GetCharDistX_ExtFrm  (unsigned short c, int * pSizeX);
Nvoid       GUI_SIF__GetFontInfo_ExtFrm   (const GUI_FONT * pFont, GUI_FONTINFO * pfi);
Nchar       GUI_SIF__IsInFont_ExtFrm      (const GUI_FONT * pFont, U16 c);
Xchar       GUI_SIF__IsInFont_ExtFrm      (const GUI_FONT * pFont, unsigned short c);
Nint        GUI_SIF__GetCharInfo_ExtFrm   (U16P c, GUI_CHARINFO_EXT * pInfo);
Xint        GUI_SIF__GetCharInfo_ExtFrm   (unsigned short c, GUI_CHARINFO_EXT * pInfo);
Nvoid       GUI_SIF__ClearLine_ExtFrm     (const char * s, int Len);
Nint        GUI_SIF__GetStringDistX_ExtFrm(const char * s, int Len);
N
N/* External binary font routines */
Nint        GUI_XBF__GetOff        (const GUI_XBF_DATA * pXBF_Data, unsigned c, U32 * pOff);
Xint        GUI_XBF__GetOff        (const GUI_XBF_DATA * pXBF_Data, unsigned c, unsigned long * pOff);
Nint        GUI_XBF__GetOffAndSize (const GUI_XBF_DATA * pXBF_Data, unsigned c, U32 * pOff, U16 * pSize);
Xint        GUI_XBF__GetOffAndSize (const GUI_XBF_DATA * pXBF_Data, unsigned c, unsigned long * pOff, unsigned short * pSize);
Nint        GUI_XBF__GetCharDistX  (U16P c, int * pSizeX);
Xint        GUI_XBF__GetCharDistX  (unsigned short c, int * pSizeX);
Nvoid       GUI_XBF__GetFontInfo   (const GUI_FONT * pFont, GUI_FONTINFO * pInfo);
Nchar       GUI_XBF__IsInFont      (const GUI_FONT * pFont, U16 c);
Xchar       GUI_XBF__IsInFont      (const GUI_FONT * pFont, unsigned short c);
Nint        GUI_XBF__GetCharInfo   (U16P c, GUI_CHARINFO_EXT * pInfo);
Xint        GUI_XBF__GetCharInfo   (unsigned short c, GUI_CHARINFO_EXT * pInfo);
Nvoid       GUI_XBF__ClearLine     (const char * s, int Len);
Nint        GUI_XBF__GetStringDistX(const char * s, int Len);
N
N/* Conversion routines */
Nvoid GUI_AddHex     (U32 v, U8 Len, char ** ps);
Xvoid GUI_AddHex     (unsigned long v, unsigned char Len, char ** ps);
Nvoid GUI_AddBin     (U32 v, U8 Len, char ** ps);
Xvoid GUI_AddBin     (unsigned long v, unsigned char Len, char ** ps);
Nvoid GUI_AddDecMin  (I32 v, char ** ps);
Xvoid GUI_AddDecMin  (signed long v, char ** ps);
Nvoid GUI_AddDecShift(I32 v, U8 Len, U8 Shift, char ** ps);
Xvoid GUI_AddDecShift(signed long v, unsigned char Len, unsigned char Shift, char ** ps);
Nlong GUI_AddSign    (long v, char ** ps);
Nint  GUI_Long2Len   (I32 v);
Xint  GUI_Long2Len   (signed long v);
N
Nvoid * GUI__C2D(const void * c);
Nvoid * GUI__F2D(void (* pFunc)(void));
N
N#define GUI_UC__GetCharSize(sText)  GUI_pUC_API->pfGetCharSize(sText)
N#define GUI_UC__GetCharCode(sText)  GUI_pUC_API->pfGetCharCode(sText)
N
Nint   GUI_UC__CalcSizeOfChar    (U16 Char);
Xint   GUI_UC__CalcSizeOfChar    (unsigned short Char);
NU16   GUI_UC__GetCharCodeInc    (const char ** ps);
Xunsigned short   GUI_UC__GetCharCodeInc    (const char ** ps);
Nint   GUI_UC__NumBytes2NumChars (const char * s, int NumBytes);
Nint   GUI_UC__NumBytes2NumGlyphs(const char * s, int NumChars);
Nint   GUI_UC__NumChars2NumBytes (const char * s, int NumChars);
Nint   GUI_UC__NumGlyphs2NumBytes(const char * s, int NumChars);
Nint   GUI_UC__GetLigature       (U16 Char, U16 Next, int PrevAffectsJoining);
Xint   GUI_UC__GetLigature       (unsigned short Char, unsigned short Next, int PrevAffectsJoining);
Nvoid  GUI_UC__EnableLigatures   (void);
Nvoid  GUI_UC__DisableLigatures  (void);
NU16   GUI_UC__GetGlyphCode      (const char * s);
Xunsigned short   GUI_UC__GetGlyphCode      (const char * s);
Nint   GUI_UC__GetGlyphSize      (const char * s);
Nvoid  GUI_UC__Warn              (const char * s);
N
Nvoid (* GUI_UC__SetpfWarn(void(* pFuncNew)(const char *)))(const char *);
N
Nint  GUI__GetLineNumChars   (const char * s, int MaxNumChars);
Nint  GUI__GetNumChars       (const char * s);
Nint  GUI__GetOverlap        (U16 Char);
Xint  GUI__GetOverlap        (unsigned short Char);
Nint  GUI__GetLineDistX      (const char * s, int Len);
Nint  GUI__GetFontSizeY      (void);
Nvoid GUI__GetTextSize       (GUI_SIZE * pSize, const char * s);
Nint  GUI__HandleEOLine      (const char ** ps);
Nvoid GUI__InvertRectColors  (int x0, int y0, int x1, int y1);
Nvoid GUI__InvertRectColorsEx(GUI_RECT * pRect);
Nvoid GUI__DispLine          (const char * s, int Len, const GUI_RECT * pr);
Nvoid GUI__AddSpaceHex       (U32 v, U8 Len, char ** ps);
Xvoid GUI__AddSpaceHex       (unsigned long v, unsigned char Len, char ** ps);
Nvoid GUI__CalcTextRect      (const char * pText, const GUI_RECT * pTextRectIn, GUI_RECT * pTextRectOut, int TextAlign);
Nint  GUI__IsPointInRect     (GUI_RECT * pRect, int x, int y);
N
Nvoid GUI__DrawNonExistingCharacter(U16 c, LCD_DRAWMODE DrawMode);
Xvoid GUI__DrawNonExistingCharacter(unsigned short c, LCD_DRAWMODE DrawMode);
Nint  GUI__GetNonExistingCharWidth (U16 c, int * pSizeX);
Xint  GUI__GetNonExistingCharWidth (unsigned short c, int * pSizeX);
N
Nvoid GUI__ClearTextBackground(int xDist, int yDist);
N
Nint  GUI__WrapGetNumCharsDisp       (const char * pText, int xSize, GUI_WRAPMODE WrapMode);
Nint  GUI__WrapGetNumCharsToNextLine (const char * pText, int xSize, GUI_WRAPMODE WrapMode);
Nint  GUI__WrapGetNumBytesToNextLine (const char * pText, int xSize, GUI_WRAPMODE WrapMode);
Nvoid GUI__memset16   (U16 * p, U16 Fill, int NumWords);
Xvoid GUI__memset16   (unsigned short * p, unsigned short Fill, int NumWords);
Nint  GUI__strlen     (const char * s);
Nint  GUI__strcmp     (const char * s0, const char * s1);
Nint  GUI__strcmp_hp  (GUI_HMEM hs0, const char * s1);
Xint  GUI__strcmp_hp  (signed long hs0, const char * s1);
Nint  GUI__strncasecmp(const char * s1, const char * s2, size_t Length);
N
N
N/* Get cursor position */
Nint  GUI__GetCursorPosX     (const char * s, int Index, int MaxNumChars);
Nint  GUI__GetCursorPosChar  (const char * s, int x, int NumCharsToNextLine);
NU16  GUI__GetCursorCharacter(const char * s, int Index, int MaxNumChars, int * pIsRTL);
Xunsigned short  GUI__GetCursorCharacter(const char * s, int Index, int MaxNumChars, int * pIsRTL);
N
N/* Arabic support (tbd) */
NU16  GUI__GetPresentationForm     (U16 Char, U16 Next, U16 Prev, int * pIgnoreNext, const char * s);
Xunsigned short  GUI__GetPresentationForm     (unsigned short Char, unsigned short Next, unsigned short Prev, int * pIgnoreNext, const char * s);
Nint  GUI__IsArabicCharacter       (U16 c);
Xint  GUI__IsArabicCharacter       (unsigned short c);
N
N/* BiDi support */
Nint  GUI__BIDI_Log2Vis           (const char * s, int NumChars, char * pBuffer, int BufferSize);
Nint  GUI__BIDI_GetCursorPosX     (const char * s, int NumChars, int Index);
Nint  GUI__BIDI_GetCursorPosChar  (const char * s, int NumChars, int x);
NU16  GUI__BIDI_GetLogChar        (const char * s, int NumChars, int Index);
Xunsigned short  GUI__BIDI_GetLogChar        (const char * s, int NumChars, int Index);
Nint  GUI__BIDI_GetCharDir        (const char * s, int NumChars, int Index);
Nint  GUI__BIDI_IsNSM             (U16 Char);
Xint  GUI__BIDI_IsNSM             (unsigned short Char);
NU16  GUI__BIDI_GetCursorCharacter(const char * s, int Index, int MaxNumChars, int * pIsRTL);
Xunsigned short  GUI__BIDI_GetCursorCharacter(const char * s, int Index, int MaxNumChars, int * pIsRTL);
Nint  GUI__BIDI_GetWordWrap       (const char * s, int xSize, int * pxDist);
Nint  GUI__BIDI_GetCharWrap       (const char * s, int xSize);
NU16  GUI__BIDI_GetGlyph          (const char * s, int CursorPosByte, int * pByteSize);
Xunsigned short  GUI__BIDI_GetGlyph          (const char * s, int CursorPosByte, int * pByteSize);
N
Nconst char * GUI__NOBIDI_Log2VisBuffered   (const char * s, int * pMaxNumChars, int Mode);
Nint          GUI__NOBIDI_GetCursorPosX     (const char * s, int MaxNumChars, int Index);
Nint          GUI__NOBIDI_GetCursorPosChar  (const char * s, int MaxNumChars, int x);
NU16          GUI__NOBIDI_GetCursorCharacter(const char * s, int Index, int MaxNumChars, int * pIsRTL);
Xunsigned short          GUI__NOBIDI_GetCursorCharacter(const char * s, int Index, int MaxNumChars, int * pIsRTL);
Nint          GUI__NOBIDI_GetWordWrap       (const char * s, int xSize, int * pxDist);
Nint          GUI__NOBIDI_GetCharWrap       (const char * s, int xSize);
N
N#if (GUI_USE_BIDI2)
X#if (1)
N
N#define GUI__BIDI_Log2Vis            GUI__BIDI2_Log2Vis
N#define GUI__BIDI_GetCursorPosX      GUI__BIDI2_GetCursorPosX
N#define GUI__BIDI_GetCursorPosChar   GUI__BIDI2_GetCursorPosChar
N#define GUI__BIDI_GetLogChar         GUI__BIDI2_GetLogChar
N#define GUI__BIDI_GetCharDir         GUI__BIDI2_GetCharDir
N#define GUI__BIDI_IsNSM              GUI__BIDI2_IsNSM
N#define GUI__BIDI_GetCursorCharacter GUI__BIDI2_GetCursorCharacter
N#define GUI__BIDI_GetWordWrap        GUI__BIDI2_GetWordWrap
N#define GUI__BIDI_GetCharWrap        GUI__BIDI2_GetCharWrap
N#define GUI__BIDI_SetBaseDir         GUI__BIDI2_SetBaseDir
N#define GUI__BIDI_GetBaseDir         GUI__BIDI2_GetBaseDir
N#define GUI__BIDI_GetGlyph           GUI__BIDI2_GetGlyph
N
Nint  GUI__BIDI_Log2Vis           (const char * s, int NumChars, char * pBuffer, int BufferSize);
Xint  GUI__BIDI2_Log2Vis           (const char * s, int NumChars, char * pBuffer, int BufferSize);
Nint  GUI__BIDI_GetCursorPosX     (const char * s, int NumChars, int Index);
Xint  GUI__BIDI2_GetCursorPosX     (const char * s, int NumChars, int Index);
Nint  GUI__BIDI_GetCursorPosChar  (const char * s, int NumChars, int x);
Xint  GUI__BIDI2_GetCursorPosChar  (const char * s, int NumChars, int x);
NU16  GUI__BIDI_GetLogChar        (const char * s, int NumChars, int Index);
Xunsigned short  GUI__BIDI2_GetLogChar        (const char * s, int NumChars, int Index);
Nint  GUI__BIDI_GetCharDir        (const char * s, int NumChars, int Index);
Xint  GUI__BIDI2_GetCharDir        (const char * s, int NumChars, int Index);
Nint  GUI__BIDI_IsNSM             (U16 Char);
Xint  GUI__BIDI2_IsNSM             (unsigned short Char);
NU16  GUI__BIDI_GetCursorCharacter(const char * s, int Index, int MaxNumChars, int * pIsRTL);
Xunsigned short  GUI__BIDI2_GetCursorCharacter(const char * s, int Index, int MaxNumChars, int * pIsRTL);
Nint  GUI__BIDI_GetWordWrap       (const char * s, int xSize, int * pxDist);
Xint  GUI__BIDI2_GetWordWrap       (const char * s, int xSize, int * pxDist);
Nint  GUI__BIDI_GetCharWrap       (const char * s, int xSize);
Xint  GUI__BIDI2_GetCharWrap       (const char * s, int xSize);
Nvoid GUI__BIDI_SetBaseDir        (int Dir);
Xvoid GUI__BIDI2_SetBaseDir        (int Dir);
Nint  GUI__BIDI_GetBaseDir        (void);
Xint  GUI__BIDI2_GetBaseDir        (void);
NU16  GUI__BIDI_GetGlyph          (const char * s, int CursorPosByte, int * pByteSize);
Xunsigned short  GUI__BIDI2_GetGlyph          (const char * s, int CursorPosByte, int * pByteSize);
N
N#else
S
S#define GUI__BIDI_SetBaseDir
S#define GUI__BIDI_GetBaseDir
S
S#define GUI__BIDI_GetGlyph           NULL
S
N#endif
N
Nconst char * GUI__BIDI_Log2VisBuffered(const char * s, int * pMaxNumChars, int Mode);
N
Nextern int GUI__BIDI_Enabled;
N
Nextern int (* _pfGUI__BIDI_GetCursorPosX   )(const char * s, int NumChars, int Index);
Nextern int (* _pfGUI__BIDI_GetCursorPosChar)(const char * s, int NumChars, int x);
Nextern U16 (* _pfGUI__BIDI_GetLogChar      )(const char * s, int NumChars, int Index);
Xextern unsigned short (* _pfGUI__BIDI_GetLogChar      )(const char * s, int NumChars, int Index);
Nextern int (* _pfGUI__BIDI_GetCharDir      )(const char * s, int NumChars, int Index);
Nextern int (* _pfGUI__BIDI_IsNSM           )(U16 Char);
Xextern int (* _pfGUI__BIDI_IsNSM           )(unsigned short Char);
N
N/* BiDi-related function pointers */
Nextern const char * (* GUI_CharLine_pfLog2Vis)(const char * s, int * pMaxNumChars, int Mode);
N
Nextern int (* GUI__GetCursorPos_pfGetPosX)     (const char * s, int MaxNumChars, int Index);
Nextern int (* GUI__GetCursorPos_pfGetPosChar)  (const char * s, int MaxNumChars, int x);
Nextern U16 (* GUI__GetCursorPos_pfGetCharacter)(const char * s, int MaxNumChars, int Index, int * pIsRTL);
Xextern unsigned short (* GUI__GetCursorPos_pfGetCharacter)(const char * s, int MaxNumChars, int Index, int * pIsRTL);
N
Nextern int (* GUI__Wrap_pfGetWordWrap)(const char * s, int xSize, int * pxDist);
Nextern int (* GUI__Wrap_pfGetCharWrap)(const char * s, int xSize);
N
N/* Proportional  font support */
Nconst GUI_FONT_PROP * GUIPROP__FindChar(const GUI_FONT_PROP * pProp, U16P c);
Xconst GUI_FONT_PROP * GUIPROP__FindChar(const GUI_FONT_PROP * pProp, unsigned short c);
N
N/* Extended proportional font support */
Nconst GUI_FONT_PROP_EXT * GUIPROP_EXT__FindChar(const GUI_FONT_PROP_EXT * pPropExt, U16P c);
Xconst GUI_FONT_PROP_EXT * GUIPROP_EXT__FindChar(const GUI_FONT_PROP_EXT * pPropExt, unsigned short c);
Nvoid  GUIPROP_EXT__DispLine           (const char * s, int Len);
Nvoid  GUIPROP_EXT__ClearLine          (const char * s, int Len);
Nint   GUIPROP_EXT__GetStringDistX     (const char * s, int Len);
Nvoid  GUIPROP_EXT__SetfpClearLine     (void (* fpClearLine)(const char * s, int Len));
N
N/* Reading data routines */
NU16 GUI__Read16(const U8 ** ppData);
Xunsigned short GUI__Read16(const unsigned char ** ppData);
NU32 GUI__Read32(const U8 ** ppData);
Xunsigned long GUI__Read32(const unsigned char ** ppData);
N
N/* Virtual screen support */
Nvoid GUI__GetOrg(int * px, int * py);
N
N/* Timer support */
Nint              GUI_TIMER__IsActive       (void);
NGUI_TIMER_TIME   GUI_TIMER__GetPeriod      (void);
Xint   GUI_TIMER__GetPeriod      (void);
NGUI_TIMER_HANDLE GUI_TIMER__GetFirstTimer  (PTR_ADDR * pContext);
XGUI_TIMER_HANDLE GUI_TIMER__GetFirstTimer  (unsigned long * pContext);
NGUI_TIMER_HANDLE GUI_TIMER__GetNextTimerLin(GUI_TIMER_HANDLE hTimer, PTR_ADDR * pContext);
XGUI_TIMER_HANDLE GUI_TIMER__GetNextTimerLin(GUI_TIMER_HANDLE hTimer, unsigned long * pContext);
Nint              GUI_TIMER__IsTimer        (GUI_TIMER_HANDLE hObj);
N
N/* Get function pointers for color conversion */
NtLCDDEV_Index2Color * GUI_GetpfIndex2ColorEx(int LayerIndex);
NtLCDDEV_Color2Index * GUI_GetpfColor2IndexEx(int LayerIndex);
N
Nint GUI_GetBitsPerPixelEx(int LayerIndex);
N
N/*********************************************************************
N*
N*       Format definitions used by streamed bitmaps
N*
N*   IMPORTANT: DO NOT CHANGE THESE VALUES!
N*   THEY HAVE TO CORRESPOND TO THE DEFINITIONS WITHIN THE CODE OF THE BITMAPCONVERTER!
N*/
N#define GUI_STREAM_FORMAT_INDEXED    100 /* DO NOT CHANGE */
N#define GUI_STREAM_FORMAT_RLE1       32  /* DO NOT CHANGE */
N#define GUI_STREAM_FORMAT_RLE4       6   /* DO NOT CHANGE */
N#define GUI_STREAM_FORMAT_RLE8       7   /* DO NOT CHANGE */
N#define GUI_STREAM_FORMAT_565        8   /* DO NOT CHANGE */
N#define GUI_STREAM_FORMAT_M565       9   /* DO NOT CHANGE */
N#define GUI_STREAM_FORMAT_555        10  /* DO NOT CHANGE */
N#define GUI_STREAM_FORMAT_M555       11  /* DO NOT CHANGE */
N#define GUI_STREAM_FORMAT_RLE16      12  /* DO NOT CHANGE */
N#define GUI_STREAM_FORMAT_RLEM16     13  /* DO NOT CHANGE */
N#define GUI_STREAM_FORMAT_8888       16  /* DO NOT CHANGE */
N#define GUI_STREAM_FORMAT_RLE32      15  /* DO NOT CHANGE */
N#define GUI_STREAM_FORMAT_24         17  /* DO NOT CHANGE */
N#define GUI_STREAM_FORMAT_A8         33  /* DO NOT CHANGE */
N#define GUI_STREAM_FORMAT_RLEALPHA   18  /* DO NOT CHANGE */
N#define GUI_STREAM_FORMAT_444_12     19  /* DO NOT CHANGE */
N#define GUI_STREAM_FORMAT_M444_12    20  /* DO NOT CHANGE */
N#define GUI_STREAM_FORMAT_444_12_1   21  /* DO NOT CHANGE */
N#define GUI_STREAM_FORMAT_M444_12_1  22  /* DO NOT CHANGE */
N#define GUI_STREAM_FORMAT_444_16     23  /* DO NOT CHANGE */
N#define GUI_STREAM_FORMAT_M444_16    24  /* DO NOT CHANGE */
N#define GUI_STREAM_FORMAT_A555       25  /* DO NOT CHANGE */
N#define GUI_STREAM_FORMAT_AM555      26  /* DO NOT CHANGE */
N#define GUI_STREAM_FORMAT_A565       27  /* DO NOT CHANGE */
N#define GUI_STREAM_FORMAT_AM565      28  /* DO NOT CHANGE */
N#define GUI_STREAM_FORMAT_M8888I     29  /* DO NOT CHANGE */
N
Nvoid GUI__ReadHeaderFromStream  (GUI_BITMAP_STREAM * pBitmapHeader, const U8 * pData);
Xvoid GUI__ReadHeaderFromStream  (GUI_BITMAP_STREAM * pBitmapHeader, const unsigned char * pData);
Nvoid GUI__CreateBitmapFromStream(const GUI_BITMAP_STREAM * pBitmapHeader, const void * pData, GUI_BITMAP * pBMP, GUI_LOGPALETTE * pPAL, const GUI_BITMAP_METHODS * pMethods);
N
N/* Cache management */
Nint GUI__ManageCache  (int Cmd);
Nint GUI__ManageCacheEx(int LayerIndex, int Cmd);
N
N/*********************************************************************
N*
N*       2d - GL
N*
N**********************************************************************
N*/
Nvoid GL_DispChar         (U16 c);
Xvoid GL_DispChar         (unsigned short c);
Nvoid GL_DrawArc          (int x0, int y0, int rx, int ry, int a0, int a1);
Nvoid GL_DrawArcHR        (int x0, int y0, int rx, int ry, I32 a0, I32 a1);
Xvoid GL_DrawArcHR        (int x0, int y0, int rx, int ry, signed long a0, signed long a1);
Nvoid GL_DrawBitmap       (const GUI_BITMAP * pBM, int x0, int y0);
Nvoid GL_DrawCircle       (int x0, int y0, int r);
Nvoid GL_DrawEllipse      (int x0, int y0, int rx, int ry, int w);
Nvoid GL_DrawEllipseXL    (int xm, int ym, int rx, int ry, int w);
Nvoid GL_DrawHLine        (int y0, int x0, int x1);
Nvoid GL_DrawPolygon      (const GUI_POINT * pPoints, int NumPoints, int x0, int y0);
Nvoid GL_DrawPoint        (int x,  int y);
Nvoid GL_DrawLine1        (int x0, int y0, int x1, int y1);
Nvoid GL_DrawLineRel      (int dx, int dy);
Nvoid GL_DrawLineTo       (int x,  int y);
Nvoid GL_DrawLineToEx     (int x,  int y, unsigned * pPixelCnt);
Nvoid GL_DrawLine         (int x0, int y0, int x1, int y1);
Nvoid GL_DrawLineEx       (int x0, int y0, int x1, int y1, unsigned * pPixelCnt);
Nvoid GL_MoveTo           (int x,  int y);
Nvoid GL_FillCircle       (int x0, int y0, int r);
Nvoid GL_FillCircleAA     (int x0, int y0, int r);
Nvoid GL_FillEllipse      (int x0, int y0, int rx, int ry);
Nvoid GL_FillEllipseXL    (int x0, int y0, int rx, int ry);
Nvoid GL_FillPolygon      (const GUI_POINT * pPoints, int NumPoints, int x0, int y0);
Nvoid GL_SetDefault       (void);
N
N/*********************************************************************
N*
N*       Replacement of memcpy() and memset()
N*
N**********************************************************************
N*/
N//
N// Configurable function pointers
N//
Nextern void * (* GUI__pfMemset)(void * pDest, int Fill, size_t Cnt);
Nextern void * (* GUI__pfMemcpy)(void * pDest, const void * pSrc, size_t Cnt);
N
Nextern int    (* GUI__pfStrcmp)(const char *, const char *);
Nextern size_t (* GUI__pfStrlen)(const char *);
Nextern char * (* GUI__pfStrcpy)(char *, const char *);
N//
N// Macros for typesave use of function pointers
N//
N#define GUI__MEMSET(pDest, Fill, Cnt) GUI__pfMemset((void *)(pDest), (int)(Fill), (size_t)(Cnt))
N#define GUI__MEMCPY(pDest, pSrc, Cnt) GUI__pfMemcpy((void *)(pDest), (const void *)(pSrc), (size_t)(Cnt))
N
N/*********************************************************************
N*
N*       Callback pointers for dynamic linkage
N*
N**********************************************************************
NDynamic linkage pointers reduces configuration hassles.
N*/
Ntypedef int  GUI_tfTimer(void);
Ntypedef int  WM_tfHandlePID(void);
N
N/*********************************************************************
N*
N*       Text rotation
N*
N**********************************************************************
N*/
Nextern GUI_RECT  GUI_RectDispString; /* Used by LCD_Rotate...() and GUI_DispStringInRect() */
N
N/*********************************************************************
N*
N*       Flag for setting transparency for 'EXT' fonts
N*
N**********************************************************************
N*/
Nextern U8 GUI__CharHasTrans;
Xextern unsigned char GUI__CharHasTrans;
N
N/*********************************************************************
N*
N*       Multitasking support
N*
N**********************************************************************
N*/
Nextern int GUITASK__EntranceCnt;
N
N/*********************************************************************
N*
N*       Bitmap related functions
N*
N**********************************************************************
N*/
N
Nint       GUI_GetBitmapPixelIndex(const GUI_BITMAP * pBMP, unsigned x, unsigned y);
NGUI_COLOR GUI_GetBitmapPixelColor(const GUI_BITMAP * pBMP, unsigned x, unsigned y);
Nint       GUI_GetBitmapPixelIndexEx(int BitsPerPixel, int BytesPerLine, const U8 * pData, unsigned x, unsigned y);
Xint       GUI_GetBitmapPixelIndexEx(int BitsPerPixel, int BytesPerLine, const unsigned char * pData, unsigned x, unsigned y);
N
Nvoid      GUI__DrawBitmap16bpp (int x0, int y0, int xsize, int ysize, const U8 * pPixel, const LCD_LOGPALETTE * pLogPal, int xMag, int yMag, tLCDDEV_Index2Color * pfIndex2Color, const LCD_API_COLOR_CONV * pColorConvAPI);
Xvoid      GUI__DrawBitmap16bpp (int x0, int y0, int xsize, int ysize, const unsigned char * pPixel, const LCD_LOGPALETTE * pLogPal, int xMag, int yMag, tLCDDEV_Index2Color * pfIndex2Color, const LCD_API_COLOR_CONV * pColorConvAPI);
Nvoid      GUI__DrawBitmapA16bpp(int x0, int y0, int xSize, int ySize, const U8 * pPixel, const LCD_LOGPALETTE * pLogPal, int xMag, int yMag, tLCDDEV_Index2Color * pfIndex2Color);
Xvoid      GUI__DrawBitmapA16bpp(int x0, int y0, int xSize, int ySize, const unsigned char * pPixel, const LCD_LOGPALETTE * pLogPal, int xMag, int yMag, tLCDDEV_Index2Color * pfIndex2Color);
Nvoid      GUI__SetPixelAlpha   (int x, int y, U8 Alpha, LCD_COLOR Color);
Xvoid      GUI__SetPixelAlpha   (int x, int y, unsigned char Alpha, LCD_COLOR Color);
NLCD_COLOR GUI__MixColors       (LCD_COLOR Color, LCD_COLOR BkColor, U8 Intens);
XLCD_COLOR GUI__MixColors       (LCD_COLOR Color, LCD_COLOR BkColor, unsigned char Intens);
Nvoid      GUI__MixColorsBulk   (U32 * pFG, U32 * pBG, U32 * pDst, unsigned OffFG, unsigned OffBG, unsigned OffDest, unsigned xSize, unsigned ySize, U8 Intens);
Xvoid      GUI__MixColorsBulk   (unsigned long * pFG, unsigned long * pBG, unsigned long * pDst, unsigned OffFG, unsigned OffBG, unsigned OffDest, unsigned xSize, unsigned ySize, unsigned char Intens);
N
Nextern const GUI_UC_ENC_APILIST GUI_UC_None;
N
N/*********************************************************************
N*
N*       LCDDEV_L0_xxx
N*
N**********************************************************************
N*/
N#define LCDDEV_L0_Color2Index         GUI__apDevice[GUI_pContext->SelLayer]->pColorConvAPI->pfColor2Index
N#define LCDDEV_L0_Index2Color         GUI__apDevice[GUI_pContext->SelLayer]->pColorConvAPI->pfIndex2Color
N
N#define LCDDEV_L0_DrawBitmap          GUI__apDevice[GUI_pContext->SelLayer]->pDeviceAPI->pfDrawBitmap
N#define LCDDEV_L0_DrawHLine           GUI__apDevice[GUI_pContext->SelLayer]->pDeviceAPI->pfDrawHLine
N#define LCDDEV_L0_DrawVLine           GUI__apDevice[GUI_pContext->SelLayer]->pDeviceAPI->pfDrawVLine
N#define LCDDEV_L0_DrawPixel           GUI__apDevice[GUI_pContext->SelLayer]->pDeviceAPI->pfDrawPixel
N#define LCDDEV_L0_FillRect            GUI__apDevice[GUI_pContext->SelLayer]->pDeviceAPI->pfFillRect
N#define LCDDEV_L0_GetPixel            GUI__apDevice[GUI_pContext->SelLayer]->pDeviceAPI->pfGetPixel
N#define LCDDEV_L0_GetRect             GUI__apDevice[GUI_pContext->SelLayer]->pDeviceAPI->pfGetRect
N#define LCDDEV_L0_GetPixelIndex       GUI__apDevice[GUI_pContext->SelLayer]->pDeviceAPI->pfGetPixelIndex
N#define LCDDEV_L0_SetPixelIndex       GUI__apDevice[GUI_pContext->SelLayer]->pDeviceAPI->pfSetPixelIndex
N#define LCDDEV_L0_XorPixel            GUI__apDevice[GUI_pContext->SelLayer]->pDeviceAPI->pfXorPixel
N#define LCDDEV_L0_GetDevFunc          GUI__apDevice[GUI_pContext->SelLayer]->pDeviceAPI->pfGetDevFunc
N
Nvoid LCD_ReadRect  (int x0, int y0, int x1, int y1, LCD_PIXELINDEX * pBuffer, GUI_DEVICE * pDevice);
Xvoid LCD_ReadRect  (int x0, int y0, int x1, int y1, unsigned long * pBuffer, GUI_DEVICE * pDevice);
Nvoid GUI_ReadRect  (int x0, int y0, int x1, int y1, LCD_PIXELINDEX * pBuffer, GUI_DEVICE * pDevice);
Xvoid GUI_ReadRect  (int x0, int y0, int x1, int y1, unsigned long * pBuffer, GUI_DEVICE * pDevice);
Nvoid GUI_ReadRectEx(int x0, int y0, int x1, int y1, LCD_PIXELINDEX * pBuffer, GUI_DEVICE * pDevice);
Xvoid GUI_ReadRectEx(int x0, int y0, int x1, int y1, unsigned long * pBuffer, GUI_DEVICE * pDevice);
N
Nvoid LCD_ReadRectNoClip(int x0, int y0, int x1, int y1, LCD_PIXELINDEX * pBuffer, GUI_DEVICE * pDevice);
Xvoid LCD_ReadRectNoClip(int x0, int y0, int x1, int y1, unsigned long * pBuffer, GUI_DEVICE * pDevice);
N
N/*********************************************************************
N*
N*       Internal color management
N*
N**********************************************************************
N*/
Ntypedef struct {
N  void         (* pfSetColor)   (LCD_COLOR Index);
N  void         (* pfSetBkColor) (LCD_COLOR Index);
N  LCD_DRAWMODE (* pfSetDrawMode)(LCD_DRAWMODE dm);
N} LCD_SET_COLOR_API;
N
Nextern const LCD_SET_COLOR_API * LCD__pSetColorAPI;
N
N#define LCD__SetBkColorIndex(Index) (*GUI_pContext->LCD_pBkColorIndex = Index)
N#define LCD__SetColorIndex(Index)   (*GUI_pContext->LCD_pColorIndex   = Index)
N#define LCD__GetBkColorIndex()      (*GUI_pContext->LCD_pBkColorIndex)
N#define LCD__GetColorIndex()        (*GUI_pContext->LCD_pColorIndex)
N
N/* The following 2 defines are only required for compatibility to older versions of the TTF library */
N#define LCD_BKCOLORINDEX (*GUI_pContext->LCD_pBkColorIndex)
N#define LCD_COLORINDEX   (*GUI_pContext->LCD_pColorIndex)
N
N/*********************************************************************
N*
N*       EXTERNs for GL_CORE
N*
N**********************************************************************
N*/
Nextern const GUI_FONT * GUI__pFontDefault;
Nextern GUI_COLOR        GUI__ColorDefault;
Nextern GUI_COLOR        GUI__BkColorDefault;
N
Nextern GUI_SADDR GUI_CONTEXT * GUI_pContext;
Xextern  GUI_CONTEXT * GUI_pContext;
N
Nextern GUI_DEVICE * GUI__apDevice[GUI_NUM_LAYERS];
Xextern GUI_DEVICE * GUI__apDevice[4];
N
N//
N// Function pointer for drawing string characters with EXT fonts
N//
Nextern U16 (* GUI__pfDrawCharEXT)(int RemChars, const char ** ps);
Xextern unsigned short (* GUI__pfDrawCharEXT)(int RemChars, const char ** ps);
Nextern int (* GUI__pfGetShiftY)(U16 Code);
Xextern int (* GUI__pfGetShiftY)(unsigned short Code);
N
N//
N// Function pointer for converting a palette containing a color array into an index array
N//
Nextern LCD_PIXELINDEX * (* GUI_pfGetpPalConvTable)(const LCD_LOGPALETTE * pLogPal, const GUI_BITMAP * pBitmap, int LayerIndex);
Xextern unsigned long * (* GUI_pfGetpPalConvTable)(const LCD_LOGPALETTE * pLogPal, const GUI_BITMAP * pBitmap, int LayerIndex);
N
N//
N// Function pointer for mixing up 2 colors
N//
Nextern LCD_COLOR (* LCD__pfMixColors)(LCD_COLOR Color, LCD_COLOR BkColor, U8 Intens);
Xextern LCD_COLOR (* LCD__pfMixColors)(LCD_COLOR Color, LCD_COLOR BkColor, unsigned char Intens);
Nextern LCD_COLOR (* GUI__pfMixColors)(LCD_COLOR Color, LCD_COLOR BkColor, U8 Intens);
Xextern LCD_COLOR (* GUI__pfMixColors)(LCD_COLOR Color, LCD_COLOR BkColor, unsigned char Intens);
N
N//
N// Function pointer for mixing up arrays of colors
N//
Nextern void (* GUI__pfMixColorsBulk)(U32 * pFG, U32 * pBG, U32 * pDst, unsigned OffFG, unsigned OffBG, unsigned OffDest, unsigned xSize, unsigned ySize, U8 Intens);
Xextern void (* GUI__pfMixColorsBulk)(unsigned long * pFG, unsigned long * pBG, unsigned long * pDst, unsigned OffFG, unsigned OffBG, unsigned OffDest, unsigned xSize, unsigned ySize, unsigned char Intens);
N
N//
N// Function pointer for mixing color and gamma values
N//
Nextern LCD_COLOR (* LCD_AA_pfMixColors16)(LCD_COLOR Color, LCD_COLOR BkColor, U8 Intens);
Xextern LCD_COLOR (* LCD_AA_pfMixColors16)(LCD_COLOR Color, LCD_COLOR BkColor, unsigned char Intens);
N
N//
N// Function pointer for drawing alpha memory devices
N//
Nextern GUI_DRAWMEMDEV_FUNC   * GUI__pfDrawAlphaMemdevFunc;
Xextern GUI_DRAWMEMDEV_16BPP_FUNC   * GUI__pfDrawAlphaMemdevFunc;
Nextern GUI_DRAWMEMDEV_FUNC   * GUI__pfDrawM565MemdevFunc;
Xextern GUI_DRAWMEMDEV_16BPP_FUNC   * GUI__pfDrawM565MemdevFunc;
N
N//
N// Function pointer for drawing alpha bitmaps
N//
Nextern GUI_DRAWBITMAP_FUNC * GUI__pfDrawAlphaBitmapFunc;
Nextern GUI_DRAWBITMAP_FUNC * GUI__pfDrawM565BitmapFunc;
N
Nextern U8 GUI__DrawStreamedBitmap;
Xextern unsigned char GUI__DrawStreamedBitmap;
N
N//
N// API list to be used for MultiBuffering
N//
Nextern const GUI_MULTIBUF_API    GUI_MULTIBUF_APIList;
Nextern const GUI_MULTIBUF_API    GUI_MULTIBUF_APIListMasked;
Nextern const GUI_MULTIBUF_API_EX GUI_MULTIBUF_APIListEx;
N
Nextern void (* GUI_pfExecAnimations)(void);
Nextern int  (* GUI_pfUpdateSoftLayer)(void);
N
N#ifdef WIN32
S  extern void (* GUI_pfSoftlayerGetPixel)(int x, int y, void * p);
N#endif
N
Nextern void (* GUI_pfHookMTOUCH)(const GUI_MTOUCH_STATE * pState);
N
Nextern void (* GUI_pfManageCursor)(int Layer, int OnOff);
N
Nextern tGUI_GetGlyph * GUI_UC_pfGetGlyph;
N
Nextern const GUI_UC_ENC_APILIST * GUI_pUC_API; /* Unicode encoding API */
N
Nextern GUI_SADDR char             GUI_DecChar;
Xextern  char             GUI_DecChar;
Nextern           GUI_tfTimer    * GUI_pfTimerExec;
Nextern           WM_tfHandlePID * WM_pfHandlePID;
Nextern   void (* GUI_pfDispCharStyle)(U16 Char);
Xextern   void (* GUI_pfDispCharStyle)(unsigned short Char);
Nextern   void (* GUI_pfDispCharLine)(int x0);
N
Nextern           int GUI_AA__BufferSize;  // Required buffer size in pixels for alpha blending and/or antialiasing
Nextern           int GUI_AA__ClipX0;      // x0-clipping value for AA module
N
Nextern           I8  GUI__aNumBuffers[GUI_NUM_LAYERS]; // Number of buffers used per layer
Xextern           signed char  GUI__aNumBuffers[4]; 
Nextern           U8  GUI__PreserveTrans;
Xextern           unsigned char  GUI__PreserveTrans;
Nextern           U8  GUI__IsInitialized;
Xextern           unsigned char  GUI__IsInitialized;
N
Nextern           U8  GUI__NumLayersInUse;
Xextern           unsigned char  GUI__NumLayersInUse;
Nextern           U32 GUI__LayerMask;
Xextern           unsigned long GUI__LayerMask;
N
N#if GUI_SUPPORT_ROTATION
X#if 1
N  extern const tLCD_APIList * GUI_pLCD_APIList; /* Used for rotating text */
N#endif
N
Nextern I16 GUI_OrgX, GUI_OrgY;
Xextern signed short GUI_OrgX, GUI_OrgY;
N
N#if defined(__cplusplus)
X#if 0L
S}
N#endif
N
N#endif /* GUI_PRIVATE_H */
N
N/*************************** End of file ****************************/
L 49 "..\..\..\..\ThirdParty\emWin\Include\WM_Intern.h" 2
N#include "WM.h"
N
N#if defined(__cplusplus)
X#if 0L
Sextern "C" {     /* Make sure we have C-declarations in C++ programs */
N#endif
N
N#if GUI_WINSUPPORT
X#if 1
N
N/*********************************************************************
N*
N*       defines
N*
N**********************************************************************
N
N  The following could be placed in a file of its own as it is not
N  used outside of the window manager
N
N*/
N/* Basic Windows status flags.
N   For module-internally use only !
N*/
N#define WM_SF_HASTRANS          WM_CF_HASTRANS
N#define WM_SF_MEMDEV            WM_CF_MEMDEV
N#define WM_SF_MEMDEV_ON_REDRAW  WM_CF_MEMDEV_ON_REDRAW
N#define WM_SF_DISABLED          WM_CF_DISABLED  /* Disabled: Does not receive PID (mouse & touch) input */
N#define WM_SF_ISVIS             WM_CF_SHOW      /* Is visible flag */
N
N#define WM_SF_STAYONTOP         WM_CF_STAYONTOP
N#define WM_SF_LATE_CLIP         WM_CF_LATE_CLIP
N#define WM_SF_ANCHOR_RIGHT      WM_CF_ANCHOR_RIGHT
N#define WM_SF_ANCHOR_BOTTOM     WM_CF_ANCHOR_BOTTOM
N#define WM_SF_ANCHOR_LEFT       WM_CF_ANCHOR_LEFT
N#define WM_SF_ANCHOR_TOP        WM_CF_ANCHOR_TOP
N
N#define WM_SF_INVALID           WM_CF_ACTIVATE  /* We reuse this flag, as it is create only and Invalid is status only */
N
N#define WM_SF_CONST_OUTLINE     WM_CF_CONST_OUTLINE       /* Constant outline.*/
N
N#if WM_VALIDATE_HANDLE
X#if (0)
S  #define WM_H2P(hWin)            ((WM_Obj*)WM__GetValidPointer(hWin))
N#else
N  #define WM_H2P(hWin)            ((WM_Obj*)GUI_ALLOC_h2p(hWin))
N#endif
N
N
N#if GUI_DEBUG_LEVEL  >= GUI_DEBUG_LEVEL_LOG_WARNINGS
X#if 0  >= 4
S  #define WM_ASSERT_NOT_IN_PAINT() { if (WM__PaintCallbackCnt) \
S                                       GUI_DEBUG_ERROROUT("Function may not be called from within a paint event"); \
S                                   }
X  #define WM_ASSERT_NOT_IN_PAINT() { if (WM__PaintCallbackCnt)                                        GUI_DEBUG_ERROROUT("Function may not be called from within a paint event");                                    }
N#else
N  #define WM_ASSERT_NOT_IN_PAINT()
N#endif
N
N/*********************************************************************
N*
N*       Data types & structures
N*
N**********************************************************************
N*/
Ntypedef struct {
N  WM_HWIN hOld;
X  GUI_HWIN hOld;
N  WM_HWIN hNew;
X  GUI_HWIN hNew;
N} WM_NOTIFY_CHILD_HAS_FOCUS_INFO;
N
Ntypedef struct WM_CRITICAL_HANDLE {
N  struct  WM_CRITICAL_HANDLE * pNext;
N  volatile WM_HWIN hWin;
X  volatile GUI_HWIN hWin;
N} WM_CRITICAL_HANDLE;
N
N/*********************************************************************
N*
N*       Data (extern)
N*
N**********************************************************************
N*/
Nextern U32            WM__CreateFlags;
Xextern unsigned long            WM__CreateFlags;
Nextern WM_HWIN        WM__ahCapture[GUI_NUM_LAYERS];
Xextern GUI_HWIN        WM__ahCapture[4];
Nextern WM_HWIN        WM__ahWinFocus[GUI_NUM_LAYERS];
Xextern GUI_HWIN        WM__ahWinFocus[4];
Nextern char           WM__CaptureReleaseAuto;
Nextern WM_tfPollPID * WM_pfPollPID;
Nextern U8             WM__PaintCallbackCnt;      /* Public for assertions only */
Xextern unsigned char             WM__PaintCallbackCnt;       
Nextern WM_HWIN        WM__hCreateStatic;
Xextern GUI_HWIN        WM__hCreateStatic;
N
N#if WM_SUPPORT_TRANSPARENCY
X#if 1
N  extern int     WM__TransWindowCnt;
N  extern WM_HWIN WM__hATransWindow;
X  extern GUI_HWIN WM__hATransWindow;
N#endif
N
N#if WM_SUPPORT_DIAG
X#if 0
S  extern void (*WM__pfShowInvalid)(WM_HWIN hWin);
N#endif
N
Nextern WM_CRITICAL_HANDLE     WM__aCHWinModal[GUI_NUM_LAYERS];
Xextern WM_CRITICAL_HANDLE     WM__aCHWinModal[4];
Nextern WM_CRITICAL_HANDLE     WM__aCHWinLast[GUI_NUM_LAYERS];
Xextern WM_CRITICAL_HANDLE     WM__aCHWinLast[4];
Nextern int                    WM__ModalLayer;
N
N#if GUI_SUPPORT_MOUSE
X#if 1
N  extern WM_CRITICAL_HANDLE   WM__aCHWinMouseOver[GUI_NUM_LAYERS];
X  extern WM_CRITICAL_HANDLE   WM__aCHWinMouseOver[4];
N#endif
N
N#ifdef WM_C
S  #define GUI_EXTERN
N#else
N  #define GUI_EXTERN extern
N#endif
N
N#if (GUI_NUM_LAYERS > 1)
X#if (4 > 1)
N  extern U32                       WM__InvalidLayerMask;
X  extern unsigned long                       WM__InvalidLayerMask;
N  extern unsigned                  WM__TouchedLayer;
N  #define WM__TOUCHED_LAYER            WM__TouchedLayer
N#else
S  #define WM__TOUCHED_LAYER            GUI_CURSOR_LAYER
N#endif
N
Nextern U16     WM__NumWindows;
Xextern unsigned short     WM__NumWindows;
Nextern U16     WM__NumInvalidWindows;
Xextern unsigned short     WM__NumInvalidWindows;
Nextern WM_HWIN WM__FirstWin;
Xextern GUI_HWIN WM__FirstWin;
Nextern WM_CRITICAL_HANDLE * WM__pFirstCriticalHandle;
N
Nextern WM_HWIN   WM__ahDesktopWin[GUI_NUM_LAYERS];
Xextern GUI_HWIN   WM__ahDesktopWin[4];
Nextern GUI_COLOR WM__aBkColor[GUI_NUM_LAYERS];
Xextern GUI_COLOR WM__aBkColor[4];
N
Nextern U32 WM__DrawSprite;  // Required when using sprites in combination with the WM.
Xextern unsigned long WM__DrawSprite;  
N
N#undef GUI_EXTERN
N
N/*********************************************************************
N*
N*       Prototypes
N*
N**********************************************************************
N*/
Nvoid    WM__ActivateClipRect        (void);
Nint     WM__ClipAtParentBorders     (GUI_RECT * pRect, WM_HWIN hWin);
Xint     WM__ClipAtParentBorders     (GUI_RECT * pRect, GUI_HWIN hWin);
Nvoid    WM__Client2Screen           (const WM_Obj * pWin, GUI_RECT * pRect);
Nvoid    WM__DeactivateEx            (void);
Nvoid    WM__DeleteAssocTimer        (WM_HWIN hWin);
Xvoid    WM__DeleteAssocTimer        (GUI_HWIN hWin);
Nvoid    WM__DetachWindow            (WM_HWIN hChild);
Xvoid    WM__DetachWindow            (GUI_HWIN hChild);
Nvoid    WM__ForEachDesc             (WM_HWIN hWin, WM_tfForEach * pcb, void * pData);
Xvoid    WM__ForEachDesc             (GUI_HWIN hWin, WM_tfForEach * pcb, void * pData);
Nvoid    WM__GetClientRectWin        (const WM_Obj * pWin, GUI_RECT * pRect);
Nvoid    WM__GetClientRectEx         (WM_HWIN hWin, GUI_RECT * pRect);
Xvoid    WM__GetClientRectEx         (GUI_HWIN hWin, GUI_RECT * pRect);
NWM_HWIN WM__GetFirstSibling         (WM_HWIN hWin);
XGUI_HWIN WM__GetFirstSibling         (GUI_HWIN hWin);
NWM_HWIN WM__GetFocusedChild         (WM_HWIN hWin);
XGUI_HWIN WM__GetFocusedChild         (GUI_HWIN hWin);
NWM_HWIN WM__GetLastSibling          (WM_HWIN hWin);
XGUI_HWIN WM__GetLastSibling          (GUI_HWIN hWin);
NWM_HWIN WM__GetPrevSibling          (WM_HWIN hWin);
XGUI_HWIN WM__GetPrevSibling          (GUI_HWIN hWin);
Nint     WM__GetTopLevelLayer        (WM_HWIN hWin);
Xint     WM__GetTopLevelLayer        (GUI_HWIN hWin);
Nint     WM__GetWindowSizeX          (const WM_Obj * pWin);
Nint     WM__GetWindowSizeY          (const WM_Obj * pWin);
Nvoid    WM__InsertWindowIntoList    (WM_HWIN hWin, WM_HWIN hParent);
Xvoid    WM__InsertWindowIntoList    (GUI_HWIN hWin, GUI_HWIN hParent);
Nvoid    WM__Invalidate1Abs          (WM_HWIN hWin, const GUI_RECT * pRect);
Xvoid    WM__Invalidate1Abs          (GUI_HWIN hWin, const GUI_RECT * pRect);
Nvoid    WM__InvalidateDraw          (WM_HWIN hWin);
Xvoid    WM__InvalidateDraw          (GUI_HWIN hWin);
Nvoid    WM__InvalidateRectEx        (const GUI_RECT * pInvalidRect, WM_HWIN hWin, WM_HWIN hStop);
Xvoid    WM__InvalidateRectEx        (const GUI_RECT * pInvalidRect, GUI_HWIN hWin, GUI_HWIN hStop);
Nint     WM__IsAncestor              (WM_HWIN hChild, WM_HWIN hParent);
Xint     WM__IsAncestor              (GUI_HWIN hChild, GUI_HWIN hParent);
Nint     WM__IsAncestorOrSelf        (WM_HWIN hChild, WM_HWIN hParent);
Xint     WM__IsAncestorOrSelf        (GUI_HWIN hChild, GUI_HWIN hParent);
Nint     WM__IsChild                 (WM_HWIN hWin, WM_HWIN hParent);
Xint     WM__IsChild                 (GUI_HWIN hWin, GUI_HWIN hParent);
Nint     WM__IsEnabled               (WM_HWIN hWin);
Xint     WM__IsEnabled               (GUI_HWIN hWin);
Nint     WM__IsInModalArea           (WM_HWIN hWin);
Xint     WM__IsInModalArea           (GUI_HWIN hWin);
Nint     WM__IsInWindow              (WM_Obj * pWin, int x, int y);
Nint     WM__IsWindow                (WM_HWIN hWin);
Xint     WM__IsWindow                (GUI_HWIN hWin);
Nvoid    WM__MoveTo                  (WM_HWIN hWin, int x, int y);
Xvoid    WM__MoveTo                  (GUI_HWIN hWin, int x, int y);
Nvoid    WM__MoveWindow              (WM_HWIN hWin, int dx, int dy);
Xvoid    WM__MoveWindow              (GUI_HWIN hWin, int dx, int dy);
Nvoid    WM__NotifyVisChanged        (WM_HWIN hWin, GUI_RECT * pRect);
Xvoid    WM__NotifyVisChanged        (GUI_HWIN hWin, GUI_RECT * pRect);
Nint     WM__RectIsNZ                (const GUI_RECT * pr);
Nvoid    WM__RemoveWindowFromList    (WM_HWIN hWin);
Xvoid    WM__RemoveWindowFromList    (GUI_HWIN hWin);
Nvoid    WM__Screen2Client           (const WM_Obj * pWin, GUI_RECT * pRect);
Nvoid    WM__SelectTopLevelLayer     (WM_HWIN  hWin);
Xvoid    WM__SelectTopLevelLayer     (GUI_HWIN  hWin);
Nvoid    WM__SendMsgNoData           (WM_HWIN hWin, U8 MsgId);
Xvoid    WM__SendMsgNoData           (GUI_HWIN hWin, unsigned char MsgId);
Nvoid    WM__SendMessage             (WM_HWIN hWin, WM_MESSAGE * pm);
Xvoid    WM__SendMessage             (GUI_HWIN hWin, WM_MESSAGE * pm);
Nvoid    WM__SendMessageIfEnabled    (WM_HWIN hWin, WM_MESSAGE * pm);
Xvoid    WM__SendMessageIfEnabled    (GUI_HWIN hWin, WM_MESSAGE * pm);
Nvoid    WM__SendMessageNoPara       (WM_HWIN hWin, int MsgId);
Xvoid    WM__SendMessageNoPara       (GUI_HWIN hWin, int MsgId);
Nvoid    WM__SendPIDMessage          (WM_HWIN hWin, WM_MESSAGE * pMsg);
Xvoid    WM__SendPIDMessage          (GUI_HWIN hWin, WM_MESSAGE * pMsg);
Nint     WM__SetScrollbarH           (WM_HWIN hWin, int OnOff);
Xint     WM__SetScrollbarH           (GUI_HWIN hWin, int OnOff);
Nint     WM__SetScrollbarV           (WM_HWIN hWin, int OnOff);
Xint     WM__SetScrollbarV           (GUI_HWIN hWin, int OnOff);
Nvoid    WM__UpdateChildPositions    (WM_Obj * pObj, int dx0, int dy0, int dx1, int dy1);
Nvoid    WM_PID__GetPrevState        (GUI_PID_STATE * pPrevState, int Layer);
Nvoid    WM_PID__SetPrevState        (GUI_PID_STATE * pPrevState, int Layer);
Nvoid    WM__SendTouchMessage        (WM_HWIN hWin, WM_MESSAGE * pMsg);
Xvoid    WM__SendTouchMessage        (GUI_HWIN hWin, WM_MESSAGE * pMsg);
N
NU16     WM_GetFlags                 (WM_HWIN hWin);
Xunsigned short     WM_GetFlags                 (GUI_HWIN hWin);
Nint     WM__Paint                   (WM_HWIN hWin);
Xint     WM__Paint                   (GUI_HWIN hWin);
Nint     WM__Paint1                  (WM_HWIN hWin);
Xint     WM__Paint1                  (GUI_HWIN hWin);
Nvoid    WM__AddCriticalHandle       (WM_CRITICAL_HANDLE * pCH);
Nvoid    WM__RemoveCriticalHandle    (WM_CRITICAL_HANDLE * pCH);
Nvoid    WM__SetLastTouched          (WM_HWIN hWin);
Xvoid    WM__SetLastTouched          (GUI_HWIN hWin);
N
N#if WM_SUPPORT_STATIC_MEMDEV
X#if 1
N  void           WM__InvalidateDrawAndDescs(WM_HWIN hWin);
X  void           WM__InvalidateDrawAndDescs(GUI_HWIN hWin);
N  void           WM__ClearSMDs             (void);
N#else
S  #define WM__InvalidateDrawAndDescs(hWin)
N#endif
N
N/*********************************************************************
N*
N*       Performance measurement
N*/
N#if GUI_SUPPORT_MEMDEV
X#if 1
N
Nvoid WM_FPS__Enable (int xPos, int yPos, GUI_COLOR ColorFG, GUI_COLOR ColorBG);
Nvoid WM_FPS__Disable(void);
N
N#endif
N
N/*********************************************************************
N*
N*       Validate WM handles
N*/
N#if WM_VALIDATE_HANDLE
X#if (0)
S  void   * WM__GetValidPointer(WM_HWIN hWin);
S  WM_Obj * WM__LockValid      (WM_HWIN hWin);
N#endif
N
N/* Static memory devices */
N#if (GUI_SUPPORT_MEMDEV)
X#if (1)
N  typedef struct {
N    int xSize, ySize; // Size of bk window
N  } EFFECT_CONTEXT;
N
N  int  GUI_MEMDEV__CalcParaFadeIn    (int Period, int TimeUsed);
N  void GUI_MEMDEV__ClipBK            (EFFECT_CONTEXT * pContext);
N  void GUI_MEMDEV__RemoveStaticDevice(WM_HWIN hWin);
X  void GUI_MEMDEV__RemoveStaticDevice(GUI_HWIN hWin);
N  void GUI_MEMDEV__UndoClipBK        (EFFECT_CONTEXT * pContext);
N#endif
N
Nvoid WM__InvalidateRect(const GUI_RECT * pInvalidRect, WM_HWIN hWin, WM_HWIN hStop);
Xvoid WM__InvalidateRect(const GUI_RECT * pInvalidRect, GUI_HWIN hWin, GUI_HWIN hStop);
N
N#endif   /* GUI_WINSUPPORT */
N
N#if defined(__cplusplus)
X#if 0L
S  }
N#endif
N
N#endif   /* WM_INTERN_H */
N
N/*************************** End of file ****************************/
L 49 "..\..\..\..\ThirdParty\emWin\Include\BUTTON_Private.h" 2
N#include "BUTTON.h"
N
N#if GUI_WINSUPPORT
X#if 1
N
N/*********************************************************************
N*
N*       Defines
N*
N**********************************************************************
N*/
N#ifndef   BUTTON_3D_MOVE_X
N  #define BUTTON_3D_MOVE_X 1
N#endif
N#ifndef   BUTTON_3D_MOVE_Y
N  #define BUTTON_3D_MOVE_Y 1
N#endif
N
N/*********************************************************************
N*
N*       Object definition
N*
N**********************************************************************
N*/
Ntypedef struct {
N  WIDGET_DRAW_ITEM_FUNC * pfDrawSkin;
N} BUTTON_SKIN_PRIVATE;
N
Ntypedef struct {
N  GUI_COLOR           aBkColor[3];
N  GUI_COLOR           aTextColor[3];
N  GUI_COLOR           FocusColor;
N  GUI_COLOR           FrameColor;
N  const GUI_FONT    * pFont;
N  BUTTON_SKIN_PRIVATE SkinPrivate;
N  I16                 Align;
X  signed short                 Align;
N  I16                 xPosText, yPosText;
X  signed short                 xPosText, yPosText;
N} BUTTON_PROPS;
N
Ntypedef struct {
N  WIDGET              Widget;
N  BUTTON_PROPS        Props;
N  WIDGET_SKIN const * pWidgetSkin;
N  WM_HMEM             hpText;
X  signed long             hpText;
N  WM_HMEM             ahDrawObj[3];
X  signed long             ahDrawObj[3];
N} BUTTON_Obj;
N
N/*********************************************************************
N*
N*       Macros for internal use
N*
N**********************************************************************
N*/
N#if GUI_DEBUG_LEVEL >= GUI_DEBUG_LEVEL_CHECK_ALL
X#if 0 >= 2
S  #define BUTTON_INIT_ID(p) (p->Widget.DebugId = WIDGET_TYPE_BUTTON)
N#else
N  #define BUTTON_INIT_ID(p)
N#endif
N
N#if GUI_DEBUG_LEVEL >= GUI_DEBUG_LEVEL_CHECK_ALL
X#if 0 >= 2
S  BUTTON_Obj * BUTTON_LockH(BUTTON_Handle h);
S  #define BUTTON_LOCK_H(h)   BUTTON_LockH(h)
N#else
N  #define BUTTON_LOCK_H(h)   (BUTTON_Obj *)WM_LOCK_H(h)
N#endif
N
N/*********************************************************************
N*
N*       Public data (internal defaults)
N*
N**********************************************************************
N*/
Nextern BUTTON_PROPS BUTTON__DefaultProps;
N
Nextern const WIDGET_SKIN BUTTON__SkinClassic;
Nextern       WIDGET_SKIN BUTTON__Skin;
N
Nextern WIDGET_SKIN const * BUTTON__pSkinDefault;
N
N/*********************************************************************
N*
N*       Private functions
N*
N**********************************************************************
N*/
Nvoid BUTTON__SetDrawObj(BUTTON_Handle hObj, int Index, GUI_DRAW_HANDLE hDrawObj);
N
N
N#endif   /* GUI_WINSUPPORT */
N#endif   /* BUTTON_H */
N
N/*************************** End of file ****************************/
L 53 "..\..\..\..\ThirdParty\emWin\Include\AppWizard.h" 2
N#include "WINDOW_Private.h"
L 1 "..\..\..\..\ThirdParty\emWin\Include\WINDOW_Private.h" 1
N/*********************************************************************
N*                    SEGGER Microcontroller GmbH                     *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2023  SEGGER Microcontroller GmbH                *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V6.46 - Graphical user interface for embedded applications **
NemWin is protected by international copyright laws. Knowledge of the
Nsource code may not be used to write a similar product. 
NThis file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed by SEGGER Software GmbH to Nuvoton Technology Corporation
Nat the address: No. 4, Creation Rd. III, Hsinchu Science Park, Taiwan
Nfor the purposes  of  creating  libraries  for its 
NArm Cortex-A, Arm Cortex-M and  Arm9 32-bit microcontrollers, commercialized and distributed by Nuvoton Technology Corporation
Nunder  the terms and conditions  of  an  End  User  
NLicense  Agreement  supplied  with  the libraries.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NLicensing information
NLicensor:                 SEGGER Software GmbH
NLicensed to:              Nuvoton Technology Corporation, No. 4, Creation Rd. III, Hsinchu Science Park, 30077 Hsinchu City, Taiwan
NLicensed SEGGER software: emWin
NLicense number:           GUI-00735
NLicense model:            emWin License Agreement, signed February 27, 2018
NLicensed platform:        Cortex-M, Cortex-A, and ARM9 32-bit series microcontroller designed and manufactured by Nuvoton Technology Corporation.
N----------------------------------------------------------------------
NSupport and Update Agreement (SUA)
NSUA period:               2018-03-26 - 2025-09-04
NContact to extend SUA:    sales@segger.com
N----------------------------------------------------------------------
NFile        : WINDOW_Private.h
NPurpose     : WINDOW private header file
N--------------------END-OF-HEADER-------------------------------------
N*/
N
N#ifndef WINDOW_PRIVATE_H
N#define WINDOW_PRIVATE_H
N
N#if GUI_WINSUPPORT
X#if 1
N
N/*********************************************************************
N*
N*       Object definition
N*
N**********************************************************************
N*/
N
Ntypedef struct {
N  WIDGET Widget;
N  WM_CALLBACK * cb;
N  WM_HWIN hFocusedChild;
X  GUI_HWIN hFocusedChild;
N  WM_DIALOG_STATUS * pDialogStatus;
N  GUI_COLOR BkColor;
N} WINDOW_OBJ;
N
N/*********************************************************************
N*
N*       Externals
N*
N**********************************************************************
N*/
N
Nextern GUI_COLOR WINDOW__DefaultBkColor;
N
N#endif   /* GUI_WINSUPPORT */
N#endif   /* WINDOW_PRIVATE_H */
N
N/*************************** End of file ****************************/
L 54 "..\..\..\..\ThirdParty\emWin\Include\AppWizard.h" 2
N#include "IMAGE_Private.h"
L 1 "..\..\..\..\ThirdParty\emWin\Include\IMAGE_Private.h" 1
N/*********************************************************************
N*                    SEGGER Microcontroller GmbH                     *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2023  SEGGER Microcontroller GmbH                *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V6.46 - Graphical user interface for embedded applications **
NemWin is protected by international copyright laws. Knowledge of the
Nsource code may not be used to write a similar product. 
NThis file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed by SEGGER Software GmbH to Nuvoton Technology Corporation
Nat the address: No. 4, Creation Rd. III, Hsinchu Science Park, Taiwan
Nfor the purposes  of  creating  libraries  for its 
NArm Cortex-A, Arm Cortex-M and  Arm9 32-bit microcontrollers, commercialized and distributed by Nuvoton Technology Corporation
Nunder  the terms and conditions  of  an  End  User  
NLicense  Agreement  supplied  with  the libraries.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NLicensing information
NLicensor:                 SEGGER Software GmbH
NLicensed to:              Nuvoton Technology Corporation, No. 4, Creation Rd. III, Hsinchu Science Park, 30077 Hsinchu City, Taiwan
NLicensed SEGGER software: emWin
NLicense number:           GUI-00735
NLicense model:            emWin License Agreement, signed February 27, 2018
NLicensed platform:        Cortex-M, Cortex-A, and ARM9 32-bit series microcontroller designed and manufactured by Nuvoton Technology Corporation.
N----------------------------------------------------------------------
NSupport and Update Agreement (SUA)
NSUA period:               2018-03-26 - 2025-09-04
NContact to extend SUA:    sales@segger.com
N----------------------------------------------------------------------
NFile        : IMAGE_Private.h
NPurpose     : Private IMAGE include
N--------------------END-OF-HEADER-------------------------------------
N*/
N
N#ifndef IMAGE_PRIVATE_H
N#define IMAGE_PRIVATE_H
N
N#include "GUI_Private.h"
N#include "WM_Intern.h"
N#include "IMAGE.h"
N
N#if GUI_WINSUPPORT
X#if 1
N
N/*********************************************************************
N*
N*       Private config defaults
N*
N**********************************************************************
N*/
N#ifndef IMAGE_SUPPORT_TRANSPARENCY
N  #define IMAGE_SUPPORT_TRANSPARENCY WM_SUPPORT_TRANSPARENCY
N#endif
N
N/*********************************************************************
N*
N*       Object definition
N*
N**********************************************************************
N*/
Ntypedef struct {
N  U32 Flags;
X  unsigned long Flags;
N  GUI_COLOR BkColor;
N} IMAGE_PROPS;
N
Ntypedef struct {
N  WIDGET              Widget;
N  IMAGE_PROPS         Props;
N  const void        * pData;                                                          // Data pointer of the object to be drawn (Bitmap, BMP, GIF, JPEG, PNG)
N  void             (* pfDrawImageAt) (IMAGE_Handle hObj, int xPos, int yPos);         // Object specific (Bitmap, BMP, GIF, JPEG, PNG) code
N  void             (* pfPaint)       (IMAGE_Handle hObj);                             // Drawing method specific (Default, Tiled, Magnified) code
N  void             (* pfGetImageSize)(IMAGE_Handle hObj, int * pxSize, int * pySize); // Returns the image size of the attached item
N  void             (* pfOnTimer)     (IMAGE_Handle hObj);                             // Timer function for animated images (currently only animated GIFs are supported)
N  U32                 FileSize;
X  unsigned long                 FileSize;
N  //
N  // Data items used by IAMGE_GIF.c
N  //
N  int                 NumImages;    // Number of (sub)images
N  int                 CurrentImage; // Image index used for animated images
N  GUI_TIMER_HANDLE    hTimer;       // Timer used for animated images
N  //
N  // Data items used by IAMGE_DTA.c
N  //
N  GUI_BITMAP          Bitmap;       // Bitmap structure
N  GUI_LOGPALETTE      Palette;      // Palette structure
N  //
N  // Data items used by Image_...Ex() - functions
N  //
N  void              * pVoid;        // Void pointer passed to GetData() function
N  GUI_GET_DATA_FUNC * pfGetData;    // Pointer to GetData() function
N  //
N  // Alignment (Important: When tiling is active, alignment does not have any effect)
N  //
N  I16                 xOff, yOff;   // Additional offsets
X  signed short                 xOff, yOff;   
N  U8                  Align;        // Alignment
X  unsigned char                  Align;        
N  //
N  // Data items used if memory devices are available and IMAGE_CF_MEMDEV has been set
N  //
N  #if GUI_SUPPORT_MEMDEV
X  #if 1
N    GUI_MEMDEV_Handle hMem;
N    unsigned          Scale;
N    unsigned          Angle;
N    U8                Alpha;
X    unsigned char                Alpha;
N    U8                IsDirty;
X    unsigned char                IsDirty;
N    //
N    // Pointer to scaling function
N    //
N    void (* pFunc)(GUI_MEMDEV_Handle hSrc, GUI_MEMDEV_Handle hDst, int dx, int dy, int a, int Mag);
N  #endif
N} IMAGE_OBJ;
N
N/*********************************************************************
N*
N*       Macros for internal use
N*
N**********************************************************************
N*/
N#if GUI_DEBUG_LEVEL >= GUI_DEBUG_LEVEL_CHECK_ALL
X#if 0 >= 2
S  #define IMAGE_INIT_ID(p) (p->Widget.DebugId = WIDGET_TYPE_IMAGE)
N#else
N  #define IMAGE_INIT_ID(p)
N#endif
N
N#if GUI_DEBUG_LEVEL >= GUI_DEBUG_LEVEL_CHECK_ALL
X#if 0 >= 2
S  IMAGE_OBJ * IMAGE__LockH(IMAGE_Handle h);
S  #define IMAGE_LOCK_H(h)   IMAGE__LockH(h)
N#else
N  #define IMAGE_LOCK_H(h)   (IMAGE_OBJ *)WM_LOCK_H(h)
N#endif
N
N/*********************************************************************
N*
N*       Module internal data
N*
N**********************************************************************
N*/
Nextern IMAGE_PROPS IMAGE__DefaultProps;
N
N/*********************************************************************
N*
N*       Private functions
N*
N**********************************************************************
N*/
Nvoid IMAGE__SetWindowSize(IMAGE_Handle hObj);
Nvoid IMAGE__FreeAttached (IMAGE_Handle hObj, int LeaveTimer);
Nvoid IMAGE__SetVoid      (IMAGE_Handle hObj, const void * pData);
N
N#endif // GUI_WINSUPPORT
N#endif // IMAGE_PRIVATE_H
N
N/*************************** End of file ****************************/
L 55 "..\..\..\..\ThirdParty\emWin\Include\AppWizard.h" 2
N#include "TEXT_Private.h"
L 1 "..\..\..\..\ThirdParty\emWin\Include\TEXT_Private.h" 1
N/*********************************************************************
N*                    SEGGER Microcontroller GmbH                     *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2023  SEGGER Microcontroller GmbH                *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V6.46 - Graphical user interface for embedded applications **
NemWin is protected by international copyright laws. Knowledge of the
Nsource code may not be used to write a similar product. 
NThis file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed by SEGGER Software GmbH to Nuvoton Technology Corporation
Nat the address: No. 4, Creation Rd. III, Hsinchu Science Park, Taiwan
Nfor the purposes  of  creating  libraries  for its 
NArm Cortex-A, Arm Cortex-M and  Arm9 32-bit microcontrollers, commercialized and distributed by Nuvoton Technology Corporation
Nunder  the terms and conditions  of  an  End  User  
NLicense  Agreement  supplied  with  the libraries.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NLicensing information
NLicensor:                 SEGGER Software GmbH
NLicensed to:              Nuvoton Technology Corporation, No. 4, Creation Rd. III, Hsinchu Science Park, 30077 Hsinchu City, Taiwan
NLicensed SEGGER software: emWin
NLicense number:           GUI-00735
NLicense model:            emWin License Agreement, signed February 27, 2018
NLicensed platform:        Cortex-M, Cortex-A, and ARM9 32-bit series microcontroller designed and manufactured by Nuvoton Technology Corporation.
N----------------------------------------------------------------------
NSupport and Update Agreement (SUA)
NSUA period:               2018-03-26 - 2025-09-04
NContact to extend SUA:    sales@segger.com
N----------------------------------------------------------------------
NFile        : TEXT.h
NPurpose     : TEXT include
N--------------------END-OF-HEADER-------------------------------------
N*/
N
N#ifndef TEXT_PRIVATE_H
N#define TEXT_PRIVATE_H
N
N#include "WM_Intern.h"
N#include "TEXT.h"
N
N#if GUI_WINSUPPORT
X#if 1
N
N/*********************************************************************
N*
N*       Object definition
N*
N**********************************************************************
N*/
Ntypedef struct {
N  const GUI_FONT * pFont;
N  GUI_COLOR TextColor;
N  GUI_COLOR BkColor;
N  GUI_WRAPMODE WrapMode;
N#if GUI_SUPPORT_ROTATION
X#if 1
N  const GUI_ROTATION * pLCD_Api;
X  const tLCD_APIList * pLCD_Api;
N#endif
N  GUI_COLOR FrameColor;
N} TEXT_PROPS;
N
Ntypedef struct {
N  WIDGET Widget;
N  TEXT_PROPS Props;
N  WM_HMEM hpText;
X  signed long hpText;
N  I16 Align;
X  signed short Align;
N  I16 xPosText, yPosText;
X  signed short xPosText, yPosText;
N} TEXT_OBJ;
N
N/*********************************************************************
N*
N*       Macros for internal use
N*
N**********************************************************************
N*/
N#if GUI_DEBUG_LEVEL >= GUI_DEBUG_LEVEL_CHECK_ALL
X#if 0 >= 2
S  #define TEXT_INIT_ID(p) p->Widget.DebugId = WIDGET_TYPE_TEXT
N#else
N  #define TEXT_INIT_ID(p)
N#endif
N
N#if GUI_DEBUG_LEVEL >= GUI_DEBUG_LEVEL_CHECK_ALL
X#if 0 >= 2
S  TEXT_OBJ * TEXT_LockH(TEXT_Handle h);
S  #define TEXT_LOCK_H(h)   TEXT_LockH(h)
N#else
N  #define TEXT_LOCK_H(h)   (TEXT_OBJ *)WM_LOCK_H(h)
N#endif
N
N/*********************************************************************
N*
N*       Module internal data
N*
N**********************************************************************
N*/
Nextern TEXT_PROPS TEXT__DefaultProps;
N
N#endif   /* if GUI_WINSUPPORT */
N#endif   /* TEXT_PRIVATE_H */
N
N/*************************** End of file ****************************/
L 56 "..\..\..\..\ThirdParty\emWin\Include\AppWizard.h" 2
N#include "SLIDER_Private.h"
L 1 "..\..\..\..\ThirdParty\emWin\Include\SLIDER_Private.h" 1
N/*********************************************************************
N*                    SEGGER Microcontroller GmbH                     *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2023  SEGGER Microcontroller GmbH                *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V6.46 - Graphical user interface for embedded applications **
NemWin is protected by international copyright laws. Knowledge of the
Nsource code may not be used to write a similar product. 
NThis file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed by SEGGER Software GmbH to Nuvoton Technology Corporation
Nat the address: No. 4, Creation Rd. III, Hsinchu Science Park, Taiwan
Nfor the purposes  of  creating  libraries  for its 
NArm Cortex-A, Arm Cortex-M and  Arm9 32-bit microcontrollers, commercialized and distributed by Nuvoton Technology Corporation
Nunder  the terms and conditions  of  an  End  User  
NLicense  Agreement  supplied  with  the libraries.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NLicensing information
NLicensor:                 SEGGER Software GmbH
NLicensed to:              Nuvoton Technology Corporation, No. 4, Creation Rd. III, Hsinchu Science Park, 30077 Hsinchu City, Taiwan
NLicensed SEGGER software: emWin
NLicense number:           GUI-00735
NLicense model:            emWin License Agreement, signed February 27, 2018
NLicensed platform:        Cortex-M, Cortex-A, and ARM9 32-bit series microcontroller designed and manufactured by Nuvoton Technology Corporation.
N----------------------------------------------------------------------
NSupport and Update Agreement (SUA)
NSUA period:               2018-03-26 - 2025-09-04
NContact to extend SUA:    sales@segger.com
N----------------------------------------------------------------------
NFile        : SLIDER_Private.h
NPurpose     : SLIDER private header file
N--------------------END-OF-HEADER-------------------------------------
N*/
N
N#ifndef SLIDER_PRIVATE_H
N#define SLIDER_PRIVATE_H
N
N#include "WM_Intern.h"
N#include "WIDGET.h"
N#include "SLIDER.h"
N
N#if GUI_WINSUPPORT
X#if 1
N
N/*********************************************************************
N*
N*       Defines
N*
N**********************************************************************
N*/
N//
N// Flags
N//
N#define SLIDER_FLAG_DRAW_FOCUS_RECT  (1 << 0)
N#define SLIDER_FLAG_INVERT_DIRECTION (1 << 1)
N
N/*********************************************************************
N*
N*       Object definition
N*
N**********************************************************************
N*/
Ntypedef struct {
N  WIDGET_DRAW_ITEM_FUNC * pfDrawSkin;
N} SLIDER_SKIN_PRIVATE;
N
Ntypedef struct {
N  U8                  Flags;
X  unsigned char                  Flags;
N  GUI_COLOR           BkColor;
N  GUI_COLOR           BarColor;
N  GUI_COLOR           FocusColor;
N  GUI_COLOR           TickColor;
N  SLIDER_SKIN_PRIVATE SkinPrivate;
N} SLIDER_PROPS;
N
Ntypedef struct {
N  WIDGET              Widget;
N  SLIDER_PROPS        Props;
N  WIDGET_SKIN const * pWidgetSkin;
N  int                 NumTicks;
N  int                 Max;
N  int                 Min;
N  int                 v;
N  I16                 Width;
X  signed short                 Width;
N} SLIDER_Obj;
N
N/*********************************************************************
N*
N*       Macros for internal use
N*
N**********************************************************************
N*/
N#if GUI_DEBUG_LEVEL >= GUI_DEBUG_LEVEL_CHECK_ALL
X#if 0 >= 2
S  #define SLIDER_INIT_ID(p) (p->Widget.DebugId = WIDGET_TYPE_SLIDER)
N#else
N  #define SLIDER_INIT_ID(p)
N#endif
N
N#if GUI_DEBUG_LEVEL >= GUI_DEBUG_LEVEL_CHECK_ALL
X#if 0 >= 2
S  SLIDER_Obj * SLIDER_LockH(SLIDER_Handle h);
S  #define SLIDER_LOCK_H(h)  SLIDER_LockH(h)
N#else
N  #define SLIDER_LOCK_H(h)  (SLIDER_Obj *)WM_LOCK_H(h)
N#endif
N
N#ifndef   SLIDER_SUPPORT_TRANSPARENCY
N  #define SLIDER_SUPPORT_TRANSPARENCY WM_SUPPORT_TRANSPARENCY
N#endif
N
N/*********************************************************************
N*
N*       Public data (internal defaults)
N*
N**********************************************************************
N*/
Nextern       SLIDER_PROPS   SLIDER__DefaultProps;
Nextern const WIDGET_SKIN    SLIDER__SkinClassic;
Nextern       WIDGET_SKIN    SLIDER__Skin;
Nextern const WIDGET_SKIN  * SLIDER__pSkinDefault;
N
N#endif  // GUI_WINSUPPORT
N#endif  // SLIDER_PRIVATE_H
N
N/*************************** End of file ****************************/
L 57 "..\..\..\..\ThirdParty\emWin\Include\AppWizard.h" 2
N#include "ROTARY_Private.h"
L 1 "..\..\..\..\ThirdParty\emWin\Include\ROTARY_Private.h" 1
N/*********************************************************************
N*                    SEGGER Microcontroller GmbH                     *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2023  SEGGER Microcontroller GmbH                *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V6.46 - Graphical user interface for embedded applications **
NemWin is protected by international copyright laws. Knowledge of the
Nsource code may not be used to write a similar product. 
NThis file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed by SEGGER Software GmbH to Nuvoton Technology Corporation
Nat the address: No. 4, Creation Rd. III, Hsinchu Science Park, Taiwan
Nfor the purposes  of  creating  libraries  for its 
NArm Cortex-A, Arm Cortex-M and  Arm9 32-bit microcontrollers, commercialized and distributed by Nuvoton Technology Corporation
Nunder  the terms and conditions  of  an  End  User  
NLicense  Agreement  supplied  with  the libraries.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NLicensing information
NLicensor:                 SEGGER Software GmbH
NLicensed to:              Nuvoton Technology Corporation, No. 4, Creation Rd. III, Hsinchu Science Park, 30077 Hsinchu City, Taiwan
NLicensed SEGGER software: emWin
NLicense number:           GUI-00735
NLicense model:            emWin License Agreement, signed February 27, 2018
NLicensed platform:        Cortex-M, Cortex-A, and ARM9 32-bit series microcontroller designed and manufactured by Nuvoton Technology Corporation.
N----------------------------------------------------------------------
NSupport and Update Agreement (SUA)
NSUA period:               2018-03-26 - 2025-09-04
NContact to extend SUA:    sales@segger.com
N----------------------------------------------------------------------
NFile        : ROTARY.h
NPurpose     : ROTARY include
N--------------------END-OF-HEADER-------------------------------------
N*/
N
N#ifndef ROTARY_PRIVATE_H
N#define ROTARY_PRIVATE_H
N
N#include "WM_Intern.h"
N#include "ROTARY.h"
N
N#if (GUI_SUPPORT_MEMDEV && GUI_WINSUPPORT)
X#if (1 && 1)
N
N/*********************************************************************
N*
N*       Object definition
N*
N**********************************************************************
N*/
Ntypedef struct {
N  I32 Period;    // Time in ms it takes to stop the knob in ms
X  signed long Period;    
N  I32 TickSize;  // Movement range in 1/10 of degree for one key push
X  signed long TickSize;  
N} ROTARY_PROPS;
N
Ntypedef struct {
N  WIDGET            Widget;            // (obvious)
N  ROTARY_PROPS      Props;             // (obvious)
N  WM_HMEM           hContext;          // Motion context
X  signed long           hContext;          
N  I32               Angle;             // Current angle within the given range (AngNeg & AngPos)
X  signed long               Angle;             
N  I32               Snap;              // Snap section
X  signed long               Snap;              
N  I32               MinVRange;         // Minimum of value range
X  signed long               MinVRange;         
N  I32               MaxVRange;         // Maximum of value range
X  signed long               MaxVRange;         
N  I32               AngPos;            // Positive turning angle in 10th of degrees
X  signed long               AngPos;            
N  I32               AngNeg;            // Negative turning angle in 10th of degrees
X  signed long               AngNeg;            
N  I16               Align;             // Alignment of marker
X  signed short               Align;             
N  I16               xOff, yOff;        // Additional offset(s) for marker
X  signed short               xOff, yOff;        
N  int               Radius;            // Mid point difference between widget and marker
N  I32               Offset;            // Angle offset for drawing marker
X  signed long               Offset;            
N  U8                DoRotate;          // If set the marker image is rotated
X  unsigned char                DoRotate;          
N  WM_HMEM           hDrawObjBk;        // Background image
X  signed long           hDrawObjBk;        
N  WM_HMEM           hDrawObjMarker;    // Draw object for marker image
X  signed long           hDrawObjMarker;    
N  WM_HMEM           hDrawObjMarkerHR;  // Draw object for marker image (HR)
X  signed long           hDrawObjMarkerHR;  
N  GUI_MEMDEV_Handle hMemMarker;        // Handle of marker device
N  I32               Value;
X  signed long               Value;
N  //
N  // Pointer to rotation function
N  //
N  void (* pFunc)(GUI_MEMDEV_Handle hSrc, GUI_MEMDEV_Handle hDst, I32 dx, I32 dy, int a, int Mag);
X  void (* pFunc)(GUI_MEMDEV_Handle hSrc, GUI_MEMDEV_Handle hDst, signed long dx, signed long dy, int a, int Mag);
N} ROTARY_OBJ;
N
N/*********************************************************************
N*
N*       Macros for internal use
N*
N**********************************************************************
N*/
N#if GUI_DEBUG_LEVEL >= GUI_DEBUG_LEVEL_CHECK_ALL
X#if 0 >= 2
S  #define ROTARY_INIT_ID(p) p->Widget.DebugId = WIDGET_TYPE_ROTARY
N#else
N  #define ROTARY_INIT_ID(p)
N#endif
N
N#if GUI_DEBUG_LEVEL >= GUI_DEBUG_LEVEL_CHECK_ALL
X#if 0 >= 2
S  ROTARY_OBJ * ROTARY_LockH(ROTARY_Handle h);
S  #define ROTARY_LOCK_H(h)   ROTARY_LockH(h)
N#else
N  #define ROTARY_LOCK_H(h)   (ROTARY_OBJ *)WM_LOCK_H(h)
N#endif
N
N/*********************************************************************
N*
N*       Module internal data
N*
N**********************************************************************
N*/
Nextern ROTARY_PROPS ROTARY__DefaultProps;
N
N#endif   // (GUI_SUPPORT_MEMDEV && GUI_WINSUPPORT)
N#endif   // ROTARY_PRIVATE_H
N
N/************************* end of file ******************************/
L 58 "..\..\..\..\ThirdParty\emWin\Include\AppWizard.h" 2
N#include "SWITCH_Private.h"
L 1 "..\..\..\..\ThirdParty\emWin\Include\SWITCH_Private.h" 1
N/*********************************************************************
N*                    SEGGER Microcontroller GmbH                     *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2023  SEGGER Microcontroller GmbH                *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V6.46 - Graphical user interface for embedded applications **
NemWin is protected by international copyright laws. Knowledge of the
Nsource code may not be used to write a similar product. 
NThis file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed by SEGGER Software GmbH to Nuvoton Technology Corporation
Nat the address: No. 4, Creation Rd. III, Hsinchu Science Park, Taiwan
Nfor the purposes  of  creating  libraries  for its 
NArm Cortex-A, Arm Cortex-M and  Arm9 32-bit microcontrollers, commercialized and distributed by Nuvoton Technology Corporation
Nunder  the terms and conditions  of  an  End  User  
NLicense  Agreement  supplied  with  the libraries.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NLicensing information
NLicensor:                 SEGGER Software GmbH
NLicensed to:              Nuvoton Technology Corporation, No. 4, Creation Rd. III, Hsinchu Science Park, 30077 Hsinchu City, Taiwan
NLicensed SEGGER software: emWin
NLicense number:           GUI-00735
NLicense model:            emWin License Agreement, signed February 27, 2018
NLicensed platform:        Cortex-M, Cortex-A, and ARM9 32-bit series microcontroller designed and manufactured by Nuvoton Technology Corporation.
N----------------------------------------------------------------------
NSupport and Update Agreement (SUA)
NSUA period:               2018-03-26 - 2025-09-04
NContact to extend SUA:    sales@segger.com
N----------------------------------------------------------------------
NFile        : SWITCH_Private.h
NPurpose     : SWITCH private header file
N--------------------END-OF-HEADER-------------------------------------
N*/
N
N#ifndef SWITCH_PRIVATE_H
N#define SWITCH_PRIVATE_H
N
N#include "WM_Intern.h"
N#include "SWITCH.h"
N
N#if (GUI_WINSUPPORT && GUI_SUPPORT_MEMDEV)
X#if (1 && 1)
N
N/*********************************************************************
N*
N*       Defines
N*
N**********************************************************************
N*/
N/*********************************************************************
N*
N*       SWITCH Flags (first 2 bits are reserved for mode)
N*/
N#define SWITCH_ANIM_ACTIVE      (1 << 2)
N#define SWITCH_MOTION_ACTIVE    (1 << 3)
N#define SWITCH_THUMB_TOUCHED    (1 << 4)
N#define SWITCH_DISABLE_ANIM     (1 << 5)
N#define SWITCH_POS_RIGHT        (1 << 6)
N
N/*********************************************************************
N*
N*       Object definition
N*
N**********************************************************************
N*/
Ntypedef struct {
N  WIDGET_DRAW_ITEM_FUNC * pfDrawSkin;
N} SWITCH_SKIN_PRIVATE;
N
Ntypedef struct {
N  GUI_COLOR           aTextColor[3];
N  int                 Period;
N  const GUI_FONT    * pFont;
N  SWITCH_SKIN_PRIVATE SkinPrivate;
N} SWITCH_PROPS;
N
Ntypedef struct {
N  WIDGET              Widget;
N  SWITCH_PROPS        Props;
N  WIDGET_SKIN const * pWidgetSkin;
N  WM_HMEM             hContext;      // Motion context
X  signed long             hContext;      
N  int                 PosThumb;      // A value between 0 (left) and GUI_ANIM_RANGE (right)
N  int                 IndexThumb;    // Index to be used to draw thumb
N  WM_HMEM             ahpText[2];    // Left- and right rext
X  signed long             ahpText[2];    
N  WM_HMEM             ahDrawObj[6];  // Up to 6 images are required
X  signed long             ahDrawObj[6];  
N  int                 xSizeThumb;    // (obvious)
N  int                 ySizeThumb;    // (obvious)
N  int                 xAreaThumb;    // Size in pixels to be used for moving the thumb
N  int                 AnimStart;     // Start value of animation
N  int                 AnimEnd;       // End value of animation
N  GUI_ANIM_HANDLE     hAnim;         // Animation handle
N  GUI_MEMDEV_Handle   hMem_L;        // Memory device for fading mode containing left image
N  GUI_MEMDEV_Handle   hMem_R;        // Memory device for fading mode containing right image
N  GUI_MEMDEV_Handle   hMem_Work;     // Memory device for fading mode containing result
N  U8                  Flags;         // (obvious)
X  unsigned char                  Flags;         
N} SWITCH_Obj;
N
N/*********************************************************************
N*
N*       Macros for internal use
N*
N**********************************************************************
N*/
N#if GUI_DEBUG_LEVEL >= GUI_DEBUG_LEVEL_CHECK_ALL
X#if 0 >= 2
S  #define SWITCH_INIT_ID(p) (p->Widget.DebugId = WIDGET_TYPE_SWITCH)
N#else
N  #define SWITCH_INIT_ID(p)
N#endif
N
N#if GUI_DEBUG_LEVEL >= GUI_DEBUG_LEVEL_CHECK_ALL
X#if 0 >= 2
S  SWITCH_Obj * SWITCH_LockH(SWITCH_Handle h);
S  #define SWITCH_LOCK_H(h)   SWITCH_LockH(h)
N#else
N  #define SWITCH_LOCK_H(h)   (SWITCH_Obj *)WM_LOCK_H(h)
N#endif
N
N/*********************************************************************
N*
N*       Private interface
N*
N**********************************************************************
N*/
Nvoid SWITCH__SetDrawObj  (SWITCH_Handle hObj, int Index, GUI_DRAW_HANDLE hDrawObj);
N
N/*********************************************************************
N*
N*       Public data (internal defaults)
N*
N**********************************************************************
N*/
Nextern SWITCH_PROPS SWITCH__DefaultProps;
N
Nextern const WIDGET_SKIN SWITCH__SkinClassic;
Nextern       WIDGET_SKIN SWITCH__Skin;
N
Nextern WIDGET_SKIN const * SWITCH__pSkinDefault;
N
N
N#endif   /* (GUI_WINSUPPORT && GUI_SUPPORT_MEMDEV) */
N#endif   /* SWITCH_PRIVATE_H */
N
N/*************************** End of file ****************************/
L 59 "..\..\..\..\ThirdParty\emWin\Include\AppWizard.h" 2
N#include "EDIT_Private.h"
L 1 "..\..\..\..\ThirdParty\emWin\Include\EDIT_Private.h" 1
N/*********************************************************************
N*                    SEGGER Microcontroller GmbH                     *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2023  SEGGER Microcontroller GmbH                *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V6.46 - Graphical user interface for embedded applications **
NemWin is protected by international copyright laws. Knowledge of the
Nsource code may not be used to write a similar product. 
NThis file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed by SEGGER Software GmbH to Nuvoton Technology Corporation
Nat the address: No. 4, Creation Rd. III, Hsinchu Science Park, Taiwan
Nfor the purposes  of  creating  libraries  for its 
NArm Cortex-A, Arm Cortex-M and  Arm9 32-bit microcontrollers, commercialized and distributed by Nuvoton Technology Corporation
Nunder  the terms and conditions  of  an  End  User  
NLicense  Agreement  supplied  with  the libraries.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NLicensing information
NLicensor:                 SEGGER Software GmbH
NLicensed to:              Nuvoton Technology Corporation, No. 4, Creation Rd. III, Hsinchu Science Park, 30077 Hsinchu City, Taiwan
NLicensed SEGGER software: emWin
NLicense number:           GUI-00735
NLicense model:            emWin License Agreement, signed February 27, 2018
NLicensed platform:        Cortex-M, Cortex-A, and ARM9 32-bit series microcontroller designed and manufactured by Nuvoton Technology Corporation.
N----------------------------------------------------------------------
NSupport and Update Agreement (SUA)
NSUA period:               2018-03-26 - 2025-09-04
NContact to extend SUA:    sales@segger.com
N----------------------------------------------------------------------
NFile        : EDIT_Private.h
NPurpose     : Internal header file
N---------------------------END-OF-HEADER------------------------------
N*/
N
N#ifndef EDIT_PRIVATE_H
N#define EDIT_PRIVATE_H
N
N#include "EDIT.h"
N
N#if GUI_WINSUPPORT
X#if 1
N
N#include "WM_Intern.h"
N#include "WIDGET.h"
N
N/*********************************************************************
N*
N*       Defines
N*
N**********************************************************************
N*/
N#define EDIT_REALLOC_SIZE  16
N
N#ifndef EDIT_XOFF
N  #define EDIT_XOFF        1
N#endif
N
N/*********************************************************************
N*
N*       Types
N*
N**********************************************************************
N*/
Ntypedef struct EDIT_Obj_struct EDIT_Obj;
N
Ntypedef struct {
N  int              Align;
N  int              Border;
N  const GUI_FONT * pFont;
N  GUI_COLOR        aTextColor[3];
N  GUI_COLOR        aBkColor[3];
N} EDIT_PROPS;
N
Nstruct EDIT_Obj_struct {
N  WIDGET               Widget;
N  WM_HMEM              hpText;
X  signed long              hpText;
N  I16                  MaxLen;
X  signed short                  MaxLen;
N  U16                  BufferSize;
X  unsigned short                  BufferSize;
N  I32                  Min, Max;        // Min max values as normalized floats (integers)
X  signed long                  Min, Max;        
N  U8                   NumDecs;         // Number of decimals
X  unsigned char                   NumDecs;         
N  I32                  CurrentValue;    // Current value
X  signed long                  CurrentValue;    
N  int                  CursorPos;       // Cursor position. 0 means left most
N  unsigned             SelSize;         // Number of selected characters
N  U8                   EditMode;        // Insert or overwrite mode
X  unsigned char                   EditMode;        
N  U8                   XSizeCursor;     // Size of cursor when working in insert mode
X  unsigned char                   XSizeCursor;     
N  U8                   Flags;
X  unsigned char                   Flags;
N  U8                   Radius;          // Currently only used by AppWizard
X  unsigned char                   Radius;          
N  tEDIT_AddKeyEx     * pfAddKeyEx;      // Handle key input
N  tEDIT_UpdateBuffer * pfUpdateBuffer;  // Update textbuffer
N  EDIT_PROPS           Props;
N  WM_HTIMER            hTimer;
X  signed long            hTimer;
N  U8                   MinMaxMode;
X  unsigned char                   MinMaxMode;
N  int                  TimerPeriod;
N  int                  ScrollPos;       // Horizontal scrolling position
N  U16                  PrevStrLen;      // Previous string length, used for scrolling position calculation.
X  unsigned short                  PrevStrLen;      
N  char               * pDispText;       // Pointer to buffer with the password char.
N};
N
N/*********************************************************************
N*
N*       Macros for internal use
N*
N**********************************************************************
N*/
N#if GUI_DEBUG_LEVEL >= GUI_DEBUG_LEVEL_CHECK_ALL
X#if 0 >= 2
S  #define EDIT_INIT_ID(p) (p->Widget.DebugId = WIDGET_TYPE_EDIT)
N#else
N  #define EDIT_INIT_ID(p)
N#endif
N
N#if GUI_DEBUG_LEVEL >= GUI_DEBUG_LEVEL_CHECK_ALL
X#if 0 >= 2
S  EDIT_Obj * EDIT_LockH(EDIT_Handle h);
S  #define EDIT_LOCK_H(h)   EDIT_LockH(h)
N#else
N  #define EDIT_LOCK_H(h)   (EDIT_Obj *)WM_LOCK_H(h)
N#endif
N
N/*********************************************************************
N*
N*       Public data (internal defaults)
N*
N**********************************************************************
N*/
Nextern EDIT_PROPS EDIT__DefaultProps;
N
N/*********************************************************************
N*
N*       Public functions (internal)
N*
N**********************************************************************
N*/
NU16  EDIT__GetCurrentChar  (EDIT_Obj * pObj);
Xunsigned short  EDIT__GetCurrentChar  (EDIT_Obj * pObj);
Nvoid EDIT__SetCursorPos    (EDIT_Handle hObj, int CursorPos);
Nvoid EDIT__SetCursorPosEx  (EDIT_Handle hObj, int CursorPos, U8 Delete);
Xvoid EDIT__SetCursorPosEx  (EDIT_Handle hObj, int CursorPos, unsigned char Delete);
Nvoid EDIT__SetValueUnsigned(EDIT_Handle hObj, I32 Value);
Xvoid EDIT__SetValueUnsigned(EDIT_Handle hObj, signed long Value);
N
N#endif // GUI_WINSUPPORT
N
N#endif // EDIT_PRIVATE_H
N
N/*************************** End of file ****************************/
L 60 "..\..\..\..\ThirdParty\emWin\Include\AppWizard.h" 2
N#include "QRCODE_Private.h"
L 1 "..\..\..\..\ThirdParty\emWin\Include\QRCODE_Private.h" 1
N/*********************************************************************
N*                    SEGGER Microcontroller GmbH                     *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2023  SEGGER Microcontroller GmbH                *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V6.46 - Graphical user interface for embedded applications **
NemWin is protected by international copyright laws. Knowledge of the
Nsource code may not be used to write a similar product. 
NThis file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed by SEGGER Software GmbH to Nuvoton Technology Corporation
Nat the address: No. 4, Creation Rd. III, Hsinchu Science Park, Taiwan
Nfor the purposes  of  creating  libraries  for its 
NArm Cortex-A, Arm Cortex-M and  Arm9 32-bit microcontrollers, commercialized and distributed by Nuvoton Technology Corporation
Nunder  the terms and conditions  of  an  End  User  
NLicense  Agreement  supplied  with  the libraries.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NLicensing information
NLicensor:                 SEGGER Software GmbH
NLicensed to:              Nuvoton Technology Corporation, No. 4, Creation Rd. III, Hsinchu Science Park, 30077 Hsinchu City, Taiwan
NLicensed SEGGER software: emWin
NLicense number:           GUI-00735
NLicense model:            emWin License Agreement, signed February 27, 2018
NLicensed platform:        Cortex-M, Cortex-A, and ARM9 32-bit series microcontroller designed and manufactured by Nuvoton Technology Corporation.
N----------------------------------------------------------------------
NSupport and Update Agreement (SUA)
NSUA period:               2018-03-26 - 2025-09-04
NContact to extend SUA:    sales@segger.com
N----------------------------------------------------------------------
NFile        : QRCODE_Private.h
NPurpose     : Internal header file
N--------------------END-OF-HEADER-------------------------------------
N*/
N
N#ifndef QRCODE_PRIVATE_H
N#define QRCODE_PRIVATE_H
N
N#include "WM_Intern.h"
N#include "QRCODE.h"
N
N#if (GUI_WINSUPPORT)
X#if (1)
N
N/*********************************************************************
N*
N*       Object definition
N*
N**********************************************************************
N*/
Ntypedef struct {
N  GUI_COLOR Color;
N  GUI_COLOR BkColor;
N} QRCODE_PROPS;
N
Ntypedef struct {
N  WIDGET       Widget;
N  QRCODE_PROPS Props;
N  GUI_HMEM     hMem;
X  signed long     hMem;
N  WM_HMEM      hText;
X  signed long      hText;
N  int          PixelSize;
N  int          EccLevel;
N  int          Version;
N} QRCODE_OBJ;
N
N/*********************************************************************
N*
N*       Macros for internal use
N*
N**********************************************************************
N*/
N#if GUI_DEBUG_LEVEL >= GUI_DEBUG_LEVEL_CHECK_ALL
X#if 0 >= 2
S  #define QRCODE_INIT_ID(p) (p->Widget.DebugId = WIDGET_TYPE_QRCODE)
N#else
N  #define QRCODE_INIT_ID(p)
N#endif
N
N#if GUI_DEBUG_LEVEL >= GUI_DEBUG_LEVEL_CHECK_ALL
X#if 0 >= 2
S  QRCODE_OBJ * QRCODE_LockH(QRCODE_Handle h);
S  #define QRCODE_LOCK_H(h) QRCODE_LockH(h)
N#else
N  #define QRCODE_LOCK_H(h) (QRCODE_OBJ *)WM_LOCK_H(h)
N#endif
N
N/*********************************************************************
N*
N*       Public data (internal defaults)
N*
N**********************************************************************
N*/
Nextern QRCODE_PROPS QRCODE__DefaultProps;
N
N#endif  // (GUI_SUPPORT_MEMDEV && GUI_WINSUPPORT)
N#endif  // QRCODE_PRIVATE_H
L 61 "..\..\..\..\ThirdParty\emWin\Include\AppWizard.h" 2
N#include "GAUGE_Private.h"
L 1 "..\..\..\..\ThirdParty\emWin\Include\GAUGE_Private.h" 1
N/*********************************************************************
N*                    SEGGER Microcontroller GmbH                     *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2023  SEGGER Microcontroller GmbH                *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V6.46 - Graphical user interface for embedded applications **
NemWin is protected by international copyright laws. Knowledge of the
Nsource code may not be used to write a similar product. 
NThis file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed by SEGGER Software GmbH to Nuvoton Technology Corporation
Nat the address: No. 4, Creation Rd. III, Hsinchu Science Park, Taiwan
Nfor the purposes  of  creating  libraries  for its 
NArm Cortex-A, Arm Cortex-M and  Arm9 32-bit microcontrollers, commercialized and distributed by Nuvoton Technology Corporation
Nunder  the terms and conditions  of  an  End  User  
NLicense  Agreement  supplied  with  the libraries.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NLicensing information
NLicensor:                 SEGGER Software GmbH
NLicensed to:              Nuvoton Technology Corporation, No. 4, Creation Rd. III, Hsinchu Science Park, 30077 Hsinchu City, Taiwan
NLicensed SEGGER software: emWin
NLicense number:           GUI-00735
NLicense model:            emWin License Agreement, signed February 27, 2018
NLicensed platform:        Cortex-M, Cortex-A, and ARM9 32-bit series microcontroller designed and manufactured by Nuvoton Technology Corporation.
N----------------------------------------------------------------------
NSupport and Update Agreement (SUA)
NSUA period:               2018-03-26 - 2025-09-04
NContact to extend SUA:    sales@segger.com
N----------------------------------------------------------------------
NFile        : GAUGE.h
NPurpose     : GAUGE include
N--------------------END-OF-HEADER-------------------------------------
N*/
N
N#ifndef GAUGE_PRIVATE_H
N#define GAUGE_PRIVATE_H
N
N#include "WM_Intern.h"
N#include "GAUGE.h"
N
N#if (GUI_WINSUPPORT)
X#if (1)
N
N/*********************************************************************
N*
N*       Defines
N*
N**********************************************************************
N*/
N#define PRE_VOID                   \
N  {                                \
N    GAUGE_OBJ * pObj;              \
N    if (hObj) {                    \
N      GUI_LOCK();                  \
N      pObj = GAUGE_LOCK_H(hObj); {
X#define PRE_VOID                     {                                    GAUGE_OBJ * pObj;                  if (hObj) {                          GUI_LOCK();                        pObj = GAUGE_LOCK_H(hObj); {
N
N#define POST_VOID_INVALIDATE       \
N        WM_InvalidateWindow(hObj); \
N      } GUI_UNLOCK_H(pObj);        \
N      GUI_UNLOCK();                \
N    }                              \
N  }
X#define POST_VOID_INVALIDATE               WM_InvalidateWindow(hObj);       } GUI_UNLOCK_H(pObj);              GUI_UNLOCK();                    }                                }
N
N#define POST_VOID                  \
N      } GUI_UNLOCK_H(pObj);        \
N      GUI_UNLOCK();                \
N    }                              \
N  }
X#define POST_VOID                        } GUI_UNLOCK_H(pObj);              GUI_UNLOCK();                    }                                }
N
N/*********************************************************************
N*
N*       Object definition
N*
N**********************************************************************
N*/
Ntypedef struct {
N  GUI_COLOR aColor[2];
N  GUI_COLOR BkColor;
N  I16       Align;
X  signed short       Align;
N  I16       xOff, yOff;
X  signed short       xOff, yOff;
N} GAUGE_PROPS;
N
Ntypedef struct {
N  WIDGET      Widget;             // (obvious)
N  GAUGE_PROPS Props;              // (obvious)
N  int         Radius;             // 
N  int         aWidth[2];          // 
N  I32         Value;              // 
X  signed long         Value;              
N  I32         Ang0;               // 
X  signed long         Ang0;               
N  I32         Ang1;               // 
X  signed long         Ang1;               
N  I32         Angle;              // Current angle within the given range (Ang0 & Ang1)
X  signed long         Angle;              
N  I32         MinVRange;          // Minimum of value range
X  signed long         MinVRange;          
N  I32         MaxVRange;          // Maximum of value range
X  signed long         MaxVRange;          
N  U8          Flags;
X  unsigned char          Flags;
N} GAUGE_OBJ;
N
N/*********************************************************************
N*
N*       Macros for internal use
N*
N**********************************************************************
N*/
N#if GUI_DEBUG_LEVEL >= GUI_DEBUG_LEVEL_CHECK_ALL
X#if 0 >= 2
S  #define GAUGE_INIT_ID(p) (p->Widget.DebugId = WIDGET_TYPE_GAUGE)
N#else
N  #define GAUGE_INIT_ID(p)
N#endif
N
N#if GUI_DEBUG_LEVEL >= GUI_DEBUG_LEVEL_CHECK_ALL
X#if 0 >= 2
S  GAUGE_OBJ * GAUGE_LockH(GAUGE_Handle h);
S  #define GAUGE_LOCK_H(h) GAUGE_LockH(h)
N#else
N  #define GAUGE_LOCK_H(h) (GAUGE_OBJ *)WM_LOCK_H(h)
N#endif
N
N/*********************************************************************
N*
N*       Public data (internal defaults)
N*
N**********************************************************************
N*/
Nextern GAUGE_PROPS GAUGE__DefaultProps;
N
N#endif  // (GUI_SUPPORT_MEMDEV && GUI_WINSUPPORT)
N#endif  // GAUGE_PRIVATE_H
L 62 "..\..\..\..\ThirdParty\emWin\Include\AppWizard.h" 2
N#include "KEYBOARD_Private.h"
L 1 "..\..\..\..\ThirdParty\emWin\Include\KEYBOARD_Private.h" 1
N/*********************************************************************
N*                    SEGGER Microcontroller GmbH                     *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2023  SEGGER Microcontroller GmbH                *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V6.46 - Graphical user interface for embedded applications **
NemWin is protected by international copyright laws. Knowledge of the
Nsource code may not be used to write a similar product. 
NThis file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed by SEGGER Software GmbH to Nuvoton Technology Corporation
Nat the address: No. 4, Creation Rd. III, Hsinchu Science Park, Taiwan
Nfor the purposes  of  creating  libraries  for its 
NArm Cortex-A, Arm Cortex-M and  Arm9 32-bit microcontrollers, commercialized and distributed by Nuvoton Technology Corporation
Nunder  the terms and conditions  of  an  End  User  
NLicense  Agreement  supplied  with  the libraries.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NLicensing information
NLicensor:                 SEGGER Software GmbH
NLicensed to:              Nuvoton Technology Corporation, No. 4, Creation Rd. III, Hsinchu Science Park, 30077 Hsinchu City, Taiwan
NLicensed SEGGER software: emWin
NLicense number:           GUI-00735
NLicense model:            emWin License Agreement, signed February 27, 2018
NLicensed platform:        Cortex-M, Cortex-A, and ARM9 32-bit series microcontroller designed and manufactured by Nuvoton Technology Corporation.
N----------------------------------------------------------------------
NSupport and Update Agreement (SUA)
NSUA period:               2018-03-26 - 2025-09-04
NContact to extend SUA:    sales@segger.com
N----------------------------------------------------------------------
NFile        : KEYBOARD_Private.h
NPurpose     : Internal header file
N--------------------END-OF-HEADER-------------------------------------
N*/
N
N#ifndef KEYBOARD_PRIVATE_H
N#define KEYBOARD_PRIVATE_H
N
N#include "WM_Intern.h"
N#include "KEYBOARD.h"
N
N#if (GUI_WINSUPPORT)
X#if (1)
N
N/*********************************************************************
N*
N*       Defines
N*
N**********************************************************************
N*/
N#define FLAG_FIXED        (1 << 0)
N#define FLAG_CODES        (1 << 1)
N#define FLAG_SHIFT        (1 << 2)
N#define FLAG_EXTRA        (1 << 3)
N#define FLAG_KEYBACKSPACE (1 << 4)
N#define FLAG_KEYENTER     (1 << 5)
N#define FLAG_KEYSHIFT     (1 << 6)
N#define FLAG_KEYSWITCH    (1 << 7)
N#define FLAG_KEYSPACE     (1 << 8)
N
N/*********************************************************************
N*
N*       Types
N*
N**********************************************************************
N*/
Ntypedef struct {
N  GUI_RECT       Rect;
N  U16            Code;
X  unsigned short            Code;
N  U16            Long;
X  unsigned short            Long;
N  U16            Flags;
X  unsigned short            Flags;
N  KEYBOARD_CODES cLong;
N} KEYBOARD_KEY;
N
Ntypedef struct {
N  GUI_HMEM     hText;  // Handle to text
X  signed long     hText;  
N  const void * pBm;    // Pointer to GUI_BITMAP or pointer to streamed bitmap
N  U32          Size;   // In case of a streamed bitmap 'Size' contains its size
X  unsigned long          Size;   
N} KEYBOARD_BITMAP_KEY;
N
N/*********************************************************************
N*
N*       Object definition
N*
N**********************************************************************
N*/
Ntypedef struct {
N  GUI_COLOR aColor[7];       // Colors to be used
N  unsigned  aPeriod[2];      // Array for periods [0:long press, 1:repeat mode]
N  unsigned  FrameRadius;     // Radius to be used for all keys
N  unsigned  FrameSize;       // Frame size in pixels to be used for all keys
N  unsigned  SpaceX, SpaceY;  // Space in /1000 between the keys
N  unsigned  CursorSensy;     // Sensitivity of cursor control window
N} KEYBOARD_PROPS;
N
Ntypedef struct {
N  WIDGET           Widget;
N  KEYBOARD_PROPS   Props;
N  const GUI_FONT * apFont[2];  // 0: Key codes, 1: Longpress codes
N  //
N  // Common
N  //
N  U8           State;
X  unsigned char           State;
N  U8           IsPressed;
X  unsigned char           IsPressed;
N  U8           StateLocked;
X  unsigned char           StateLocked;
N  WM_HTIMER    hTimer;
X  signed long    hTimer;
N  KEYBOARD_KEY kPressed;
N  int          PressedIndex;
N  //
N  // Code keys
N  //
N  unsigned NumKeys;
N  GUI_HMEM hKeys;
X  signed long hKeys;
N  //
N  // Special keys
N  //
N  KEYBOARD_BITMAP_KEY aKeyShift[4];
N  KEYBOARD_BITMAP_KEY aKeySwitch[2];
N  KEYBOARD_BITMAP_KEY KeyBackspace;
N  KEYBOARD_BITMAP_KEY KeyEnter;
N  KEYBOARD_BITMAP_KEY KeySpace;
N  //
N  // Timer callback
N  //
N  void (* pfOnTimer)(KEYBOARD_Handle hObj);
N  //
N  // Size of longpress key
N  //
N  int xSizeKey, ySizeKey;
N} KEYBOARD_OBJ;
N
N/*********************************************************************
N*
N*       Macros for internal use
N*
N**********************************************************************
N*/
N#if GUI_DEBUG_LEVEL >= GUI_DEBUG_LEVEL_CHECK_ALL
X#if 0 >= 2
S  #define KEYBOARD_INIT_ID(p) (p->Widget.DebugId = WIDGET_TYPE_KEYBOARD)
N#else
N  #define KEYBOARD_INIT_ID(p)
N#endif
N
N#if GUI_DEBUG_LEVEL >= GUI_DEBUG_LEVEL_CHECK_ALL
X#if 0 >= 2
S  KEYBOARD_OBJ * KEYBOARD_LockH(KEYBOARD_Handle h);
S  #define KEYBOARD_LOCK_H(h) KEYBOARD_LockH(h)
N#else
N  #define KEYBOARD_LOCK_H(h) (KEYBOARD_OBJ *)WM_LOCK_H(h)
N#endif
N
N/*********************************************************************
N*
N*       Private functions
N*
N**********************************************************************
N*/
Nint KEYBOARD__SetStreamedLayoutEx(KEYBOARD_Handle hObj, const void * pVoid, U32 Size, void (* pFunc)(KEYDEF_KEYBOARD * pKeyboard));
Xint KEYBOARD__SetStreamedLayoutEx(KEYBOARD_Handle hObj, const void * pVoid, unsigned long Size, void (* pFunc)(KEYDEF_KEYBOARD * pKeyboard));
N
N/*********************************************************************
N*
N*       Public data (internal defaults)
N*
N**********************************************************************
N*/
Nextern KEYBOARD_PROPS KEYBOARD__DefaultProps;
N
N#endif  // GUI_WINSUPPORT
N#endif  // KEYBOARD_PRIVATE_H
N
N/*************************** End of file ****************************/
L 63 "..\..\..\..\ThirdParty\emWin\Include\AppWizard.h" 2
N#include "MULTIEDIT_Private.h"
L 1 "..\..\..\..\ThirdParty\emWin\Include\MULTIEDIT_Private.h" 1
N/*********************************************************************
N*                    SEGGER Microcontroller GmbH                     *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2023  SEGGER Microcontroller GmbH                *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V6.46 - Graphical user interface for embedded applications **
NemWin is protected by international copyright laws. Knowledge of the
Nsource code may not be used to write a similar product. 
NThis file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed by SEGGER Software GmbH to Nuvoton Technology Corporation
Nat the address: No. 4, Creation Rd. III, Hsinchu Science Park, Taiwan
Nfor the purposes  of  creating  libraries  for its 
NArm Cortex-A, Arm Cortex-M and  Arm9 32-bit microcontrollers, commercialized and distributed by Nuvoton Technology Corporation
Nunder  the terms and conditions  of  an  End  User  
NLicense  Agreement  supplied  with  the libraries.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NLicensing information
NLicensor:                 SEGGER Software GmbH
NLicensed to:              Nuvoton Technology Corporation, No. 4, Creation Rd. III, Hsinchu Science Park, 30077 Hsinchu City, Taiwan
NLicensed SEGGER software: emWin
NLicense number:           GUI-00735
NLicense model:            emWin License Agreement, signed February 27, 2018
NLicensed platform:        Cortex-M, Cortex-A, and ARM9 32-bit series microcontroller designed and manufactured by Nuvoton Technology Corporation.
N----------------------------------------------------------------------
NSupport and Update Agreement (SUA)
NSUA period:               2018-03-26 - 2025-09-04
NContact to extend SUA:    sales@segger.com
N----------------------------------------------------------------------
NFile        : MULTIEDIT_Private.h
NPurpose     : MULTIEDIT include
N--------------------END-OF-HEADER-------------------------------------
N*/
N
N#ifndef MULTIEDIT_PRIVATE_H
N#define MULTIEDIT_PRIVATE_H
N
N#include "GUI_Private.h"
N#include "WM_Intern.h"
N
N#if GUI_WINSUPPORT
X#if 1
N
N#include <stddef.h>
N
N#include "MULTIEDIT.h"
N
N#if defined(__cplusplus)
X#if 0L
S  extern "C" {     /* Make sure we have C-declarations in C++ programs */
N#endif
N
N/*********************************************************************
N*
N*       Object definition
N*
N**********************************************************************
N*/
N
N#define NUM_DISP_MODES 2
N
N/*********************************************************************
N*
N*       Invalid flags
N*
N*  Used for partial invalidation. Stored in pObj->InvalidFlags.
N*/
N#define INVALID_NUMCHARS   (1 << 0)
N#define INVALID_NUMLINES   (1 << 1)
N#define INVALID_TEXTSIZE   (1 << 2)
N#define INVALID_CURSORXY   (1 << 3)
N#define INVALID_CURSORLINE (1 << 4)
N#define INVALID_LINEPOSB   (1 << 5)
N#define INVALID_SCROLL     (1 << 6)
N
N//
N// MULTIEDIT properties
N//
Ntypedef struct {
N  GUI_COLOR        aBkColor    [NUM_DISP_MODES];
X  GUI_COLOR        aBkColor    [2];
N  GUI_COLOR        aColor      [NUM_DISP_MODES];
X  GUI_COLOR        aColor      [2];
N  GUI_COLOR        aCursorColor[2];
N  U16              Align;
X  unsigned short              Align;
N  const GUI_FONT * pFont;
N  U8               HBorder;
X  unsigned char               HBorder;
N} MULTIEDIT_PROPS;
N
N//
N// MULTIEDIT object
N//
Ntypedef struct {
N  WIDGET           Widget;
N  MULTIEDIT_PROPS  Props;
N  WIDGET_COPY      Copy;
N  WM_HMEM          hText;
X  signed long          hText;
N  U32              MaxNumChars;         // Maximum number of characters including the prompt
X  unsigned long              MaxNumChars;         
N  U32              NumChars;            // Number of characters (text and prompt) in object
X  unsigned long              NumChars;            
N  U32              NumCharsPrompt;      // Number of prompt characters
X  unsigned long              NumCharsPrompt;      
N  U32              NumLines;            // Number of text lines needed to show all data
X  unsigned long              NumLines;            
N  U16              TextSizeX;           // Size in X of text depending of wrapping mode
X  unsigned short              TextSizeX;           
N  U32              BufferSize;
X  unsigned long              BufferSize;
N  U32              CursorLine;          // Number of current cursor line
X  unsigned long              CursorLine;          
N  U32              CursorPosChar;       // Character offset number of cursor
X  unsigned long              CursorPosChar;       
N  U32              CursorPosByte;       // Byte offset number of cursor
X  unsigned long              CursorPosByte;       
N  I32              CursorPosX;          // Cursor position in X
X  signed long              CursorPosX;          
N  I32              CursorPosY;          // Cursor position in Y
X  signed long              CursorPosY;          
N  U32              CacheLinePosByte;
X  unsigned long              CacheLinePosByte;
N  U32              CacheLineNumber;
X  unsigned long              CacheLineNumber;
N  U32              CacheFirstVisibleLine;
X  unsigned long              CacheFirstVisibleLine;
N  U32              CacheFirstVisibleByte;
X  unsigned long              CacheFirstVisibleByte;
N  WM_SCROLL_STATE  ScrollStateV;
N  WM_SCROLL_STATE  ScrollStateH;
N  U16              Flags;
X  unsigned short              Flags;
N  WM_HTIMER        hTimer;
X  signed long        hTimer;
N  int              TimerPeriod;
N  GUI_WRAPMODE     WrapMode;
N  int              MotionPosY;
N  int              MotionPosOld;
N  WM_HMEM          hContext;             // Motion context.
X  signed long          hContext;             
N  U8               CursorVis;            // Indicates whether cursor is visible or not
X  unsigned char               CursorVis;            
N  U8               InvertCursor;
X  unsigned char               InvertCursor;
N  U8               InvalidFlags;         // Flags to save validation status
X  unsigned char               InvalidFlags;         
N  U8               EditMode;
X  unsigned char               EditMode;
N  U8               MotionActive;
X  unsigned char               MotionActive;
N  U8               Radius;               // Currently only used by AppWizard
X  unsigned char               Radius;               
N  U8               Frame;
X  unsigned char               Frame;
N  U8               Up;
X  unsigned char               Up;
N#if GUI_SUPPORT_MEMDEV
X#if 1
N  GUI_MEMDEV_Handle ahMemCursor[2];
N#endif
N} MULTIEDIT_OBJ;
N
N/*********************************************************************
N*
N*       Private (module internal) data
N*
N**********************************************************************
N*/
Nextern MULTIEDIT_PROPS MULTIEDIT_DefaultProps;
N
N#if defined(__cplusplus)
X#if 0L
S  }
N#endif
N
N#endif  // GUI_WINSUPPORT
N#endif  // MULTIEDIT_PRIVATE_H
N
N/*************************** End of file ****************************/
L 64 "..\..\..\..\ThirdParty\emWin\Include\AppWizard.h" 2
N#include "DROPDOWN_Private.h"
L 1 "..\..\..\..\ThirdParty\emWin\Include\DROPDOWN_Private.h" 1
N/*********************************************************************
N*                    SEGGER Microcontroller GmbH                     *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2023  SEGGER Microcontroller GmbH                *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V6.46 - Graphical user interface for embedded applications **
NemWin is protected by international copyright laws. Knowledge of the
Nsource code may not be used to write a similar product. 
NThis file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed by SEGGER Software GmbH to Nuvoton Technology Corporation
Nat the address: No. 4, Creation Rd. III, Hsinchu Science Park, Taiwan
Nfor the purposes  of  creating  libraries  for its 
NArm Cortex-A, Arm Cortex-M and  Arm9 32-bit microcontrollers, commercialized and distributed by Nuvoton Technology Corporation
Nunder  the terms and conditions  of  an  End  User  
NLicense  Agreement  supplied  with  the libraries.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NLicensing information
NLicensor:                 SEGGER Software GmbH
NLicensed to:              Nuvoton Technology Corporation, No. 4, Creation Rd. III, Hsinchu Science Park, 30077 Hsinchu City, Taiwan
NLicensed SEGGER software: emWin
NLicense number:           GUI-00735
NLicense model:            emWin License Agreement, signed February 27, 2018
NLicensed platform:        Cortex-M, Cortex-A, and ARM9 32-bit series microcontroller designed and manufactured by Nuvoton Technology Corporation.
N----------------------------------------------------------------------
NSupport and Update Agreement (SUA)
NSUA period:               2018-03-26 - 2025-09-04
NContact to extend SUA:    sales@segger.com
N----------------------------------------------------------------------
NFile        : DROPDOWN_Private.h
NPurpose     : DROPDOWN private header file
N--------------------END-OF-HEADER-------------------------------------
N*/
N
N#ifndef DROPDOWN_PRIVATE_H
N#define DROPDOWN_PRIVATE_H
N
N#include "WM_Intern.h"
N#include "DROPDOWN.h"
N#include "WIDGET.h"
N#include "GUI_ARRAY.h"
L 1 "..\..\..\..\ThirdParty\emWin\Include\GUI_ARRAY.h" 1
N/*********************************************************************
N*                    SEGGER Microcontroller GmbH                     *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2023  SEGGER Microcontroller GmbH                *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V6.46 - Graphical user interface for embedded applications **
NemWin is protected by international copyright laws. Knowledge of the
Nsource code may not be used to write a similar product. 
NThis file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed by SEGGER Software GmbH to Nuvoton Technology Corporation
Nat the address: No. 4, Creation Rd. III, Hsinchu Science Park, Taiwan
Nfor the purposes  of  creating  libraries  for its 
NArm Cortex-A, Arm Cortex-M and  Arm9 32-bit microcontrollers, commercialized and distributed by Nuvoton Technology Corporation
Nunder  the terms and conditions  of  an  End  User  
NLicense  Agreement  supplied  with  the libraries.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NLicensing information
NLicensor:                 SEGGER Software GmbH
NLicensed to:              Nuvoton Technology Corporation, No. 4, Creation Rd. III, Hsinchu Science Park, 30077 Hsinchu City, Taiwan
NLicensed SEGGER software: emWin
NLicense number:           GUI-00735
NLicense model:            emWin License Agreement, signed February 27, 2018
NLicensed platform:        Cortex-M, Cortex-A, and ARM9 32-bit series microcontroller designed and manufactured by Nuvoton Technology Corporation.
N----------------------------------------------------------------------
NSupport and Update Agreement (SUA)
NSUA period:               2018-03-26 - 2025-09-04
NContact to extend SUA:    sales@segger.com
N----------------------------------------------------------------------
NFile        : GUI_ARRAY.h
NPurpose     : Array handling routines
N---------------------------END-OF-HEADER------------------------------
N*/
N
N#ifndef GUI_ARRAY_H
N#define GUI_ARRAY_H
N
N#include "GUI_Private.h"
N
N/*********************************************************************
N*
N*       Public types
N*
N**********************************************************************
N*/
Ntypedef GUI_HMEM GUI_ARRAY;
Xtypedef signed long GUI_ARRAY;
N
Ntypedef struct {
N  void   ** ppItem;
N  unsigned  i;
N  GUI_ARRAY hArray;
N} GUI_ARRAY_ITERATOR;
N
Ntypedef void (GUI_ARRAY_ITERATE_CALLBACK)   (GUI_ARRAY hArray, unsigned i, void * pItem);
Ntypedef int  (GUI_ARRAY_ITERATE_EX_CALLBACK)(GUI_ARRAY hArray, unsigned i, void * pItem, void * pUser);
N
N/*********************************************************************
N*
N*       Public functions
N*
N**********************************************************************
N*/
NGUI_ARRAY GUI_ARRAY_Create          (void);
Nint       GUI_ARRAY_AddItem         (GUI_ARRAY hArray, const void * pNew, int Len);
Nvoid      GUI_ARRAY_Delete          (GUI_ARRAY hArray);
Nvoid      GUI_ARRAY_DeletePtr       (GUI_ARRAY * phArray);
NGUI_HMEM  GUI_ARRAY_GethItem        (GUI_ARRAY hArray, unsigned int Index);
Xsigned long  GUI_ARRAY_GethItem        (GUI_ARRAY hArray, unsigned int Index);
Nunsigned  GUI_ARRAY_GetNumItems     (GUI_ARRAY hArray);
Nvoid    * GUI_ARRAY_GetpItemLocked  (GUI_ARRAY hArray, unsigned int Index);
Nint       GUI_ARRAY_SethItem        (GUI_ARRAY hArray, unsigned int Index, GUI_HMEM hItem);
Xint       GUI_ARRAY_SethItem        (GUI_ARRAY hArray, unsigned int Index, signed long hItem);
NGUI_HMEM  GUI_ARRAY_SetItem         (GUI_ARRAY hArray, unsigned int Index, const void * pData, int Len);
Xsigned long  GUI_ARRAY_SetItem         (GUI_ARRAY hArray, unsigned int Index, const void * pData, int Len);
Nvoid      GUI_ARRAY_DeleteItem      (GUI_ARRAY hArray, unsigned int Index);
Nchar      GUI_ARRAY_InsertBlankItem (GUI_ARRAY hArray, unsigned int Index);
NGUI_HMEM  GUI_ARRAY_InsertItem      (GUI_ARRAY hArray, unsigned int Index, int Len);
Xsigned long  GUI_ARRAY_InsertItem      (GUI_ARRAY hArray, unsigned int Index, int Len);
Nvoid    * GUI_ARRAY_ResizeItemLocked(GUI_ARRAY hArray, unsigned int Index, int Len);
Nvoid      GUI_ARRAY_BeginIterator   (GUI_ARRAY hArray, void ** ppItem, GUI_ARRAY_ITERATOR * pIterator);
Nvoid    * GUI_ARRAY_GetNextItem     (GUI_ARRAY_ITERATOR * pIterator);
Nvoid      GUI_ARRAY_EndIterator     (GUI_ARRAY_ITERATOR * pIterator);
Nvoid      GUI_ARRAY_Iterate         (GUI_ARRAY hArray, GUI_ARRAY_ITERATE_CALLBACK * cbIterate);
Nvoid      GUI_ARRAY_IterateEx       (GUI_ARRAY hArray, GUI_ARRAY_ITERATE_EX_CALLBACK * cbIterate, void * pUser);
N
N#endif /* GUI_ARRAY_H */
N
N/*************************** End of file ****************************/
L 52 "..\..\..\..\ThirdParty\emWin\Include\DROPDOWN_Private.h" 2
N#include "SCROLLER_Private.h"
L 1 "..\..\..\..\ThirdParty\emWin\Include\SCROLLER_Private.h" 1
N/*********************************************************************
N*                    SEGGER Microcontroller GmbH                     *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2023  SEGGER Microcontroller GmbH                *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V6.46 - Graphical user interface for embedded applications **
NemWin is protected by international copyright laws. Knowledge of the
Nsource code may not be used to write a similar product. 
NThis file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed by SEGGER Software GmbH to Nuvoton Technology Corporation
Nat the address: No. 4, Creation Rd. III, Hsinchu Science Park, Taiwan
Nfor the purposes  of  creating  libraries  for its 
NArm Cortex-A, Arm Cortex-M and  Arm9 32-bit microcontrollers, commercialized and distributed by Nuvoton Technology Corporation
Nunder  the terms and conditions  of  an  End  User  
NLicense  Agreement  supplied  with  the libraries.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NLicensing information
NLicensor:                 SEGGER Software GmbH
NLicensed to:              Nuvoton Technology Corporation, No. 4, Creation Rd. III, Hsinchu Science Park, 30077 Hsinchu City, Taiwan
NLicensed SEGGER software: emWin
NLicense number:           GUI-00735
NLicense model:            emWin License Agreement, signed February 27, 2018
NLicensed platform:        Cortex-M, Cortex-A, and ARM9 32-bit series microcontroller designed and manufactured by Nuvoton Technology Corporation.
N----------------------------------------------------------------------
NSupport and Update Agreement (SUA)
NSUA period:               2018-03-26 - 2025-09-04
NContact to extend SUA:    sales@segger.com
N----------------------------------------------------------------------
NFile        : SCROLLER_Private.h
NPurpose     : SCROLLER internal header file
N---------------------------END-OF-HEADER------------------------------
N*/
N
N#ifndef SCROLLER_PRIVATE_H
N#define SCROLLER_PRIVATE_H
N
N#include "GUI_Private.h"
N#include "WM_Intern.h"
N#include "SCROLLER.h"
N#include "WIDGET.h"
N#include "GUI_Debug.h"
N
N#if GUI_WINSUPPORT
X#if 1
N
N/*********************************************************************
N*
N*       Defines
N*
N**********************************************************************
N*/
N//
N// Status flags
N//
N#define SCROLLER_SF_FADING                      SCROLLER_CF_FADING       // Enables fading in and out of the SCROLLER.
N#define SCROLLER_SF_TOUCH                       SCROLLER_CF_TOUCH        // Enables touch input for the SCROLLER.
N#define SCROLLER_SF_ACTIVE                      (1 <<  2)                // SCROLLER is drawn as active (pressed or swiped)
N#define SCROLLER_SF_VERTICAL                    SCROLLER_CF_VERTICAL     // SCROLLER is vertical (keep same as WIDGET_STATE_VERTICAL).
N#define SCROLLER_SF_CLICKED                     (1 <<  4)                // Clicked in SCROLLER area
N#define SCROLLER_SF_PID                         (1 <<  5)                // PID is active (e.g. through motion)
N#define SCROLLER_SF_PRESSED_INSIDE_THUMB        (1 <<  6)                // PID is pressed inside thumb (thumb is being dragged)
N#define SCROLLER_SF_MOTION_RUNNING              (1 <<  7)                // Guard to ensure the active/inactive fading is only done once
N#define SCROLLER_SF_MOTION_NOT_FINISHED         (1 <<  8)                // If PID was released but motion is still running
N#define SCROLLER_SF_SCROLL_ANIM_RUNNING         (1 <<  9)                // While scrolling animation is running
N#define SCROLLER_SF_TIMER_RESCHEDULE            (1 << 10)                // If inactive timer has run out, but fading was not done, so the timer had to be rescheduled.
N#define SCROLLER_SF_START_TIMER_ON_ANIM_END     (1 << 11)                // If flag is set, the inactive timer is immediately started when the fading animation has finished.
N#define SCROLLER_SF_NO_INACTIVE_TIMER           (1 << 12)                // Inactive timer will not be started.
N#define SCROLLER_SF_OVERRIDE_RECT               (1 << 13)                // Override the content rectangle to determine the SCROLLER size.
N//
N// Private messages
N//
N#define SCROLLER_MSG_ATTACHED                   (WM_USER + 0x123)       // Message sent to the parent when a SCROLLER widget has been attached.
N
N/*********************************************************************
N*
N*       Private config defaults
N*
N**********************************************************************
N*/
N#ifndef   SCROLLER_COLOR_ACTIVE_DEFAULT
N  #define SCROLLER_COLOR_ACTIVE_DEFAULT          GUI_MAKE_COLOR(0x50606060)
N#endif
N
N#ifndef   SCROLLER_COLOR_INACTIVE_DEFAULT
N  #define SCROLLER_COLOR_INACTIVE_DEFAULT        GUI_MAKE_COLOR(0x50AAAAAA)
N#endif
N
N#ifndef   SCROLLER_BKCOLOR_ACTIVE_DEFAULT
N  #define SCROLLER_BKCOLOR_ACTIVE_DEFAULT        GUI_TRANSPARENT
N#endif
N
N#ifndef   SCROLLER_BKCOLOR_INACTIVE_DEFAULT
N  #define SCROLLER_BKCOLOR_INACTIVE_DEFAULT      GUI_TRANSPARENT
N#endif
N
N#ifndef   SCROLLER_RADIUS_DEFAULT
N  #define SCROLLER_RADIUS_DEFAULT                3
N#endif
N
N#ifndef   SCROLLER_SIZE_DEFAULT
N  #define SCROLLER_SIZE_DEFAULT                  6
N#endif
N
N#ifndef   SCROLLER_SPACING_DEFAULT
N  #define SCROLLER_SPACING_DEFAULT               24
N#endif
N
N#ifndef   SCROLLER_FADE_IN_PERIOD_DEFAULT
N  #define SCROLLER_FADE_IN_PERIOD_DEFAULT        200
N#endif
N
N#ifndef   SCROLLER_FADE_OUT_PERIOD_DEFAULT
N  #define SCROLLER_FADE_OUT_PERIOD_DEFAULT       200
N#endif
N
N#ifndef   SCROLLER_INACTIVE_PERIOD_DEFAULT
N  #define SCROLLER_INACTIVE_PERIOD_DEFAULT       200
N#endif
N
N#ifndef   SCROLLER_ANIM_PERIOD_DEFAULT
N  #define SCROLLER_ANIM_PERIOD_DEFAULT           150
N#endif
N
N#ifndef   SCROLLER_ANIM_EASE_FADE_DEFAULT
N  #define SCROLLER_ANIM_EASE_FADE_DEFAULT        ANIM_ACCELDECEL
N#endif
N
N#ifndef   SCROLLER_ANIM_EASE_SCROLL_DEFAULT
N  #define SCROLLER_ANIM_EASE_SCROLL_DEFAULT      ANIM_ACCELDECEL
N#endif
N
N#ifndef   SCROLLER_ALIGNMENT_WIDGETPOS_DEFAULT
N  #define SCROLLER_ALIGNMENT_WIDGETPOS_DEFAULT   (GUI_ALIGN_RIGHT   | GUI_ALIGN_BOTTOM)
N#endif
N
N#ifndef   SCROLLER_ALIGNMENT_THUMB_DEFAULT
N  #define SCROLLER_ALIGNMENT_THUMB_DEFAULT       (GUI_ALIGN_RIGHT   | GUI_ALIGN_BOTTOM)
N#endif
N
N#ifndef   SCROLLER_ALIGNMENT_OFFSET_DEFAULT
N  #define SCROLLER_ALIGNMENT_OFFSET_DEFAULT     -3
N#endif
N
N#ifndef   SCROLLER_THUMB_SIZE_MIN_DEFAULT
N  #define SCROLLER_THUMB_SIZE_MIN_DEFAULT        10
N#endif
N
N/*********************************************************************
N*
N*       Types
N*
N**********************************************************************
N*/
N/*********************************************************************
N*
N*       SCROLLER_ANIM_DATA
N* 
N*  Description
N*    Data for an animation.
N*/
Ntypedef struct {
N  GUI_ANIM_HANDLE hAnim;
N  int             Start;
N  int             End;
N  I16             Pos;
X  signed short             Pos;
N} SCROLLER_ANIM_DATA;
N
N/*********************************************************************
N*
N*       ANIM_SCROLL_CONTEXT
N* 
N*  Description
N*    Context to be used during scrolling animation.
N*/
Ntypedef struct {
N  SCROLLER_Handle hScroller;
N  int             Mul;
N} ANIM_SCROLL_CONTEXT;
N
N/*********************************************************************
N*
N*       SCROLLER_WIDGET_API
N* 
N*  Description
N*    API functions used by the parent widget the SCROLLER is attached to.
N*/
Ntypedef struct {
N  const WIDGET_SCROLLSTATE_API * pConvAPI;       // API for scrollstate conversion. Optional, can be NULL.
N  const SCROLLER_INTERFACE_API * pInterfaceAPI;  // Interface between parent widget and SCROLLER. Must be set.
N} SCROLLER_WIDGET_API;
N
N/*********************************************************************
N*
N*       SCROLLER_CONTROL_API
N* 
N*  Description
N*    API that widget uses to access SCROLLER routines and control the SCROLLER.
N*    This API is used so that SCROLLER routines do have to be referenced by widgets.
N*/
Ntypedef struct {
N  //
N  // General functions
N  //
N  int             (* pfParentMsgHandler)   (WM_MESSAGE * pMsg);
N  void            (* pfAttachToWindow)     (SCROLLER_Handle hScroller, WM_HWIN hNewParent);
X  void            (* pfAttachToWindow)     (SCROLLER_Handle hScroller, GUI_HWIN hNewParent);
N  void            (* pfSetActive)          (WM_HWIN hParent, U8 Vertical);
X  void            (* pfSetActive)          (GUI_HWIN hParent, unsigned char Vertical);
N  void            (* pfResizeScrollers)    (WM_HWIN hParent);
X  void            (* pfResizeScrollers)    (GUI_HWIN hParent);
N  void            (* pfHideScroller)       (SCROLLER_Handle hScroller);
N  //
N  // Vertical scrollstate conversion
N  //
N  void            (* pfLinewiseToPixelwise)(WM_HWIN hParent, WM_SCROLL_STATE * pVState);
X  void            (* pfLinewiseToPixelwise)(GUI_HWIN hParent, WM_SCROLL_STATE * pVState);
N  void            (* pfPixelwiseToLinewise)(WM_HWIN hParent, WM_SCROLL_STATE * pVState);
X  void            (* pfPixelwiseToLinewise)(GUI_HWIN hParent, WM_SCROLL_STATE * pVState);
N} SCROLLER_CONTROL_API;
N
N/*********************************************************************
N*
N*       SCROLLER_API_STRUCT
N* 
N*  Description
N*    Struct with SCROLLER-side API and parent-side API for exchanging
N*    function pointers upon initialization.
N*/
Ntypedef struct {
N  SCROLLER_WIDGET_API        * pWidgetAPI;
N  const SCROLLER_CONTROL_API * pControlAPI;
N} SCROLLER_API_STRUCT;
N
N/*********************************************************************
N*
N*       Object definition
N*
N**********************************************************************
N*/
Ntypedef struct SCROLLER_Obj SCROLLER_Obj;
N
Ntypedef struct {
N  GUI_COLOR            aColor     [2];
N  GUI_COLOR            aBkColor   [2];
N  int                  aPeriod    [4];
N  GUI_ANIM_GETPOS_FUNC apfAnimEase[2];
N  U8                   aAlign     [2];
X  unsigned char                   aAlign     [2];
N  I16                  AlignOffset;
X  signed short                  AlignOffset;
N  I16                  Size;
X  signed short                  Size;
N  I16                  Spacing;
X  signed short                  Spacing;
N  I16                  Radius;
X  signed short                  Radius;
N  I16                  ThumbSizeMin;
X  signed short                  ThumbSizeMin;
N} SCROLLER_PROPS;
N
Nstruct SCROLLER_Obj {
N  WIDGET                   Widget;
N  SCROLLER_PROPS           Props;
N  WIDGET_DRAW_ITEM_FUNC  * pfOwnerDraw;
N  int                      NumItems;          // In pixels for H and V!
N  int                      v;                 // In pixels for H and V!
N  int                      PageSize;          // In pixels for H and V!
N  int                      Overlap;           // Overlapping distance in px (cached from parent widget)
N  GUI_TIMER_HANDLE         hTimerInactive;
N  GUI_HMEM                 hTimerMsg;         // Copy of GUI_TIMER_MESSAGE if inactive timer needs to be rescheduled.
X  signed long                 hTimerMsg;         
N  SCROLLER_ANIM_DATA       AnimFade;          // Animation handles and data for fading animation
N  SCROLLER_ANIM_DATA       AnimScroll;        // Animation handles and data for scrolling animation (when scroller is moved by touching)
N  GUI_POINT                TouchPos;
N  SCROLLER_WIDGET_API      WidgetAPI;
N  GUI_HMEM                 hCustomRect;       // Copy of rectangle set with SCROLLER_SetContentRect()
X  signed long                 hCustomRect;       
N  I16                      ClientRectOffset;  // Offset in px that is subtracted from the client rectangle during thumb rectangle calculation.
X  signed short                      ClientRectOffset;  
N  U16                      Flags;
X  unsigned short                      Flags;
N};
N
N/*********************************************************************
N*
N*       Private macros
N*
N**********************************************************************
N*/
N#if GUI_DEBUG_LEVEL >= GUI_DEBUG_LEVEL_CHECK_ALL
X#if 0 >= 2
S  #define SCROLLER_INIT_ID(p) (p->Widget.DebugId = WIDGET_TYPE_SCROLLER)
N#else
N  #define SCROLLER_INIT_ID(p)
N#endif
N
N#if GUI_DEBUG_LEVEL >= GUI_DEBUG_LEVEL_CHECK_ALL
X#if 0 >= 2
S  SCROLLER_Obj * SCROLLER_LockH(SCROLLER_Handle h);
S  #define SCROLLER_LOCK_H(h)   SCROLLER_LockH(h)
N#else
N  #define SCROLLER_LOCK_H(h)   (SCROLLER_Obj *)WM_LOCK_H(h)
N#endif
N
N/*********************************************************************
N*
N*       Private data
N*
N**********************************************************************
N*/
Nextern SCROLLER_PROPS SCROLLER__DefaultProps;
N
N#endif        /* GUI_WINSUPPORT */
N#endif        /* Avoid multiple inclusion */
N
N/*************************** End of file ****************************/
L 53 "..\..\..\..\ThirdParty\emWin\Include\DROPDOWN_Private.h" 2
N
N#if GUI_WINSUPPORT
X#if 1
N
N/*********************************************************************
N*
N*       Defines
N*
N**********************************************************************
N*/
N#define DROPDOWN_SF_AUTOSCROLLBAR DROPDOWN_CF_AUTOSCROLLBAR
N#define DROPDOWN_SF_MOTION        DROPDOWN_CF_MOTION
N
N/*********************************************************************
N*
N*       Object definition
N*
N**********************************************************************
N*/
Ntypedef struct {
N  WIDGET_DRAW_ITEM_FUNC * pfDrawSkin;
N} DROPDOWN_SKIN_PRIVATE;
N
Ntypedef struct {
N  const GUI_FONT * pFont;
N  GUI_COLOR aBackColor[3];
N  GUI_COLOR aTextColor[3];
N  GUI_COLOR aColor[2];
N  GUI_COLOR aScrollbarColor[3];
N  DROPDOWN_SKIN_PRIVATE SkinPrivate;
N  I16       TextBorderSize;
X  signed short       TextBorderSize;
N  I16       Align;
X  signed short       Align;
N} DROPDOWN_PROPS;
N
Ntypedef struct {
N  WIDGET                 Widget;
N  I16                    Sel;        // Current selection
X  signed short                    Sel;        
N  I16                    ySizeLB;    // ySize of assigned LISTBOX in expanded state
X  signed short                    ySizeLB;    
N  I16                    TextHeight;
X  signed short                    TextHeight;
N  GUI_ARRAY              Handles;
N  WM_SCROLL_STATE        ScrollState;
N  DROPDOWN_PROPS         Props;
N  WIDGET_SKIN const    * pWidgetSkin;
N  WM_HWIN                hListWin;
X  GUI_HWIN                hListWin;
N  U8                     Flags;
X  unsigned char                     Flags;
N  U16                    ItemSpacing;
X  unsigned short                    ItemSpacing;
N  U8                     ScrollbarWidth;
X  unsigned char                     ScrollbarWidth;
N  char                   IsPressed;
N  WM_HMEM                hDisabled;
X  signed long                hDisabled;
N  int                    LastMotionPosY;
N  SCROLLER_Handle        hScrollerV;
N  SCROLLER_Handle        hScrollerH;
N} DROPDOWN_Obj;
N
N/*********************************************************************
N*
N*       Macros for internal use
N*
N**********************************************************************
N*/
N#if GUI_DEBUG_LEVEL >= GUI_DEBUG_LEVEL_CHECK_ALL
X#if 0 >= 2
S  #define DROPDOWN_INIT_ID(p) (p->Widget.DebugId = WIDGET_TYPE_DROPDOWN)
N#else
N  #define DROPDOWN_INIT_ID(p)
N#endif
N
N#if GUI_DEBUG_LEVEL >= GUI_DEBUG_LEVEL_CHECK_ALL
X#if 0 >= 2
S  DROPDOWN_Obj * DROPDOWN_LockH(DROPDOWN_Handle h);
S  #define DROPDOWN_LOCK_H(h)   DROPDOWN_LockH(h)
N#else
N  #define DROPDOWN_LOCK_H(h)   (DROPDOWN_Obj *)WM_LOCK_H(h)
N#endif
N
N/*********************************************************************
N*
N*       Private (module internal) data
N*
N**********************************************************************
N*/
N
Nextern DROPDOWN_PROPS DROPDOWN__DefaultProps;
N
Nextern const WIDGET_SKIN DROPDOWN__SkinClassic;
Nextern       WIDGET_SKIN DROPDOWN__Skin;
N
Nextern WIDGET_SKIN const * DROPDOWN__pSkinDefault;
N
N/*********************************************************************
N*
N*       Private functions
N*
N**********************************************************************
N*/
N
Nvoid         DROPDOWN__AdjustHeight          (DROPDOWN_Handle hObj);
Nint          DROPDOWN__GetNumItems           (DROPDOWN_Obj * pObj);
Nvoid         DROPDOWN__Expand                (DROPDOWN_Handle hObj);
Nchar       * DROPDOWN__GetpItemLocked        (DROPDOWN_Handle hObj, unsigned int Index);
Nvoid         DROPDOWN__RegisterPostExpandHook(GUI_REGISTER_HOOK * pRegisterHook);
Nvoid         DROPDOWN__RegisterPreExpandHook (GUI_REGISTER_HOOK * pRegisterHook);
N
N#endif // GUI_WINSUPPORT
N#endif // DROPDOWN_PRIVATE_H
N
N/*************************** End of file ****************************/
L 65 "..\..\..\..\ThirdParty\emWin\Include\AppWizard.h" 2
N#include "LISTVIEW_Private.h"
L 1 "..\..\..\..\ThirdParty\emWin\Include\LISTVIEW_Private.h" 1
N/*********************************************************************
N*                    SEGGER Microcontroller GmbH                     *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2023  SEGGER Microcontroller GmbH                *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V6.46 - Graphical user interface for embedded applications **
NemWin is protected by international copyright laws. Knowledge of the
Nsource code may not be used to write a similar product. 
NThis file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed by SEGGER Software GmbH to Nuvoton Technology Corporation
Nat the address: No. 4, Creation Rd. III, Hsinchu Science Park, Taiwan
Nfor the purposes  of  creating  libraries  for its 
NArm Cortex-A, Arm Cortex-M and  Arm9 32-bit microcontrollers, commercialized and distributed by Nuvoton Technology Corporation
Nunder  the terms and conditions  of  an  End  User  
NLicense  Agreement  supplied  with  the libraries.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NLicensing information
NLicensor:                 SEGGER Software GmbH
NLicensed to:              Nuvoton Technology Corporation, No. 4, Creation Rd. III, Hsinchu Science Park, 30077 Hsinchu City, Taiwan
NLicensed SEGGER software: emWin
NLicense number:           GUI-00735
NLicense model:            emWin License Agreement, signed February 27, 2018
NLicensed platform:        Cortex-M, Cortex-A, and ARM9 32-bit series microcontroller designed and manufactured by Nuvoton Technology Corporation.
N----------------------------------------------------------------------
NSupport and Update Agreement (SUA)
NSUA period:               2018-03-26 - 2025-09-04
NContact to extend SUA:    sales@segger.com
N----------------------------------------------------------------------
NFile        : LISTVIEW_Private.h
NPurpose     : Private LISTVIEW include
N--------------------END-OF-HEADER-------------------------------------
N*/
N
N#ifndef LISTVIEW_PRIVATE_H
N#define LISTVIEW_PRIVATE_H
N
N#include "GUI_Private.h"
N#include "WM_Intern.h"
N
N#if GUI_WINSUPPORT
X#if 1
N
N#include <stddef.h>
N
N#include "LISTVIEW.h"
N#include "GUI_ARRAY.h"
N
N/*********************************************************************
N*
N*       Defines
N*
N**********************************************************************
N*/
N#define SORT_TYPE                 U16
N
N#define LISTVIEW_CELL_INFO_COLORS (1 << 0)
N#define LISTVIEW_CELL_INFO_BITMAP (1 << 1)
N
N/*********************************************************************
N*
N*       Object definition
N*
N**********************************************************************
N*/
N
Ntypedef struct {
N  GUI_COLOR                    aBkColor[4];
N  GUI_COLOR                    aTextColor[4];
N  GUI_COLOR                    GridColor;
N  const GUI_FONT             * pFont;
N  U16                          ScrollStepH;
X  unsigned short                          ScrollStepH;
N  GUI_WRAPMODE                 WrapMode;
N  int                          DefaultAlign;
N} LISTVIEW_PROPS;
N
Ntypedef struct {
N  void                      (* pfDraw)(LISTVIEW_Handle hObj, unsigned Column, unsigned Row, GUI_RECT * pRect);
N  void                       * pData;
N  GUI_COLOR                    aBkColor[4];
N  GUI_COLOR                    aTextColor[4];
N  I16                          xOff, yOff;
X  signed short                          xOff, yOff;
N  U8                           Flags;
X  unsigned char                           Flags;
N} LISTVIEW_CELL_INFO;
N
Ntypedef struct {
N  WM_HMEM                      hCellInfo;                                         // Optional cell info. If 0, there is no cell info. (Defaults used)
X  signed long                      hCellInfo;                                         
N  char                         acText[1];
N} LISTVIEW_CELL;
N
Ntypedef struct {
N  GUI_ARRAY                    hCellArray;
N  char                         Disabled;
N  U32                          UserData;
X  unsigned long                          UserData;
N} LISTVIEW_ROW;
N
Ntypedef struct {
N  U8                           Align;
X  unsigned char                           Align;
N  int                       (* fpCompare)    (const void * p0, const void * p1);  // User function to be called to compare the contents of 2 cells
N} LISTVIEW_COLUMN;
N
Ntypedef struct LISTVIEW_Obj LISTVIEW_Obj;
N
Ntypedef struct {
N  WM_HMEM                      hSortArray;
X  signed long                      hSortArray;
N  SORT_TYPE                    SortArrayNumItems;
X  unsigned short                    SortArrayNumItems;
N  int                       (* fpSort)(LISTVIEW_Handle hObj);                     // Function to be called to get a sorted array
N  void                      (* fpFree)(WM_HMEM hObj);                             // Function to be called to free the sort object
X  void                      (* fpFree)(signed long hObj);                             
N  U8                           Reverse;
X  unsigned char                           Reverse;
N} LISTVIEW_SORT;
N
Nstruct LISTVIEW_Obj {
N  WIDGET                       Widget;
N  HEADER_Handle                hHeader;
N  WIDGET_DRAW_ITEM_FUNC *      pfDrawItem;
N  GUI_ARRAY                    hRowArray;                                         // Each entry is a handle of LISTVIEW_ROW structure.
N  GUI_ARRAY                    hColumnArray;                                      // Each entry is a handle of LISTVIEW_COLUMN structure.
N  LISTVIEW_PROPS               Props;
N  WIDGET_COPY                  Copy;
N  int                          Sel;
N  int                          SelCol;
N  int                          ShowGrid;
N  int                          SortIndex;                                         // Column for sorting
N  int                          MotionPosY;
N  unsigned                     RowDistY;
N  unsigned                     LBorder;
N  unsigned                     RBorder;
N  unsigned                     Fixed;
N  WM_SCROLL_STATE              ScrollStateV;
N  WM_SCROLL_STATE              ScrollStateH;
N  WM_HMEM                      hSort;
X  signed long                      hSort;
N  WM_HMEM                      hContext;                                          // Motion context.
X  signed long                      hContext;                                          
N  unsigned                     OverlapDistance;
N  int                          OverlapPeriod;
N  U8                           OverlapFlags;
X  unsigned char                           OverlapFlags;
N  U8                           IsSorted;
X  unsigned char                           IsSorted;
N  U8                           IsPresorted;
X  unsigned char                           IsPresorted;
N  U8                           ReverseSort;                                       // Set to 1 if reverse sorting is required
X  unsigned char                           ReverseSort;                                       
N  U8                           Flags;
X  unsigned char                           Flags;
N  U8                           MotionStarted;                                     // Internal flag to check if motion swiping has been started
X  unsigned char                           MotionStarted;                                     
N  U8                           xOff, yOff;                                        // Internal offsets required for AppWizard
X  unsigned char                           xOff, yOff;                                        
N};
N
N/*********************************************************************
N*
N*       Macros for internal use
N*
N**********************************************************************
N*/
N#if GUI_DEBUG_LEVEL >= GUI_DEBUG_LEVEL_CHECK_ALL
X#if 0 >= 2
S  #define LISTVIEW_INIT_ID(p) (p->Widget.DebugId = WIDGET_TYPE_LISTVIEW)
N#else
N  #define LISTVIEW_INIT_ID(p)
N#endif
N
N#if GUI_DEBUG_LEVEL >= GUI_DEBUG_LEVEL_CHECK_ALL
X#if 0 >= 2
S  LISTVIEW_Obj * LISTVIEW_LockH(LISTVIEW_Handle h);
S  #define LISTVIEW_LOCK_H(h)   LISTVIEW_LockH(h)
N#else
N  #define LISTVIEW_LOCK_H(h)   (LISTVIEW_Obj *)WM_LOCK_H(h)
N#endif
N
N/*********************************************************************
N*
N*       Private (module internal) data
N*
N**********************************************************************
N*/
Nextern LISTVIEW_PROPS LISTVIEW_DefaultProps;
N
N/*********************************************************************
N*
N*       Private (module internal) functions
N*
N**********************************************************************
N*/
NLISTVIEW_CELL_INFO * LISTVIEW__CreateCellInfoLocked (LISTVIEW_Handle   hObj, unsigned Column, unsigned Row);
Nunsigned             LISTVIEW__GetNumColumns        (LISTVIEW_Obj    * pObj);
Nunsigned             LISTVIEW__GetNumRows           (LISTVIEW_Obj    * pObj);
Nunsigned             LISTVIEW__GetNumVisibleRows    (LISTVIEW_Handle hObj, LISTVIEW_Obj * pObj);
NLISTVIEW_CELL_INFO * LISTVIEW__GetpCellInfo         (LISTVIEW_Handle   hObj, unsigned Column, unsigned Row);
NLISTVIEW_ROW       * LISTVIEW__GetpRow              (LISTVIEW_Handle   hObj, int Row);
Nunsigned             LISTVIEW__GetRowDistY          (LISTVIEW_Obj    * pObj);
Nunsigned             LISTVIEW__GetRowSorted         (LISTVIEW_Handle   hObj, int Row);
Nvoid                 LISTVIEW__InvalidateInsideArea (LISTVIEW_Handle   hObj);
Nvoid                 LISTVIEW__InvalidateRow        (LISTVIEW_Handle   hObj, int Sel);
Nvoid                 LISTVIEW__InvalidateRowAndBelow(LISTVIEW_Handle   hObj, int Sel);
Nvoid                 LISTVIEW__SetOffset            (LISTVIEW_Handle   hObj, U8 xOff, U8 yOff);
Xvoid                 LISTVIEW__SetOffset            (LISTVIEW_Handle   hObj, unsigned char xOff, unsigned char yOff);
Nvoid                 LISTVIEW__SetSel               (LISTVIEW_Handle   hObj, int NewSel, int CheckPos);
Nvoid                 LISTVIEW__SetSelCol            (LISTVIEW_Handle   hObj, int NewSelCol);
Nint                  LISTVIEW__UpdateScrollParas    (LISTVIEW_Handle   hObj);
N
N#endif // GUI_WINSUPPORT
N#endif // LISTVIEW_PRIVATE_H
N
N/*************************** End of file ****************************/
L 66 "..\..\..\..\ThirdParty\emWin\Include\AppWizard.h" 2
N#include "LISTBOX_Private.h"
L 1 "..\..\..\..\ThirdParty\emWin\Include\LISTBOX_Private.h" 1
N/*********************************************************************
N*                    SEGGER Microcontroller GmbH                     *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2023  SEGGER Microcontroller GmbH                *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V6.46 - Graphical user interface for embedded applications **
NemWin is protected by international copyright laws. Knowledge of the
Nsource code may not be used to write a similar product. 
NThis file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed by SEGGER Software GmbH to Nuvoton Technology Corporation
Nat the address: No. 4, Creation Rd. III, Hsinchu Science Park, Taiwan
Nfor the purposes  of  creating  libraries  for its 
NArm Cortex-A, Arm Cortex-M and  Arm9 32-bit microcontrollers, commercialized and distributed by Nuvoton Technology Corporation
Nunder  the terms and conditions  of  an  End  User  
NLicense  Agreement  supplied  with  the libraries.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NLicensing information
NLicensor:                 SEGGER Software GmbH
NLicensed to:              Nuvoton Technology Corporation, No. 4, Creation Rd. III, Hsinchu Science Park, 30077 Hsinchu City, Taiwan
NLicensed SEGGER software: emWin
NLicense number:           GUI-00735
NLicense model:            emWin License Agreement, signed February 27, 2018
NLicensed platform:        Cortex-M, Cortex-A, and ARM9 32-bit series microcontroller designed and manufactured by Nuvoton Technology Corporation.
N----------------------------------------------------------------------
NSupport and Update Agreement (SUA)
NSUA period:               2018-03-26 - 2025-09-04
NContact to extend SUA:    sales@segger.com
N----------------------------------------------------------------------
NFile        : LISTBOX_Private.h
NPurpose     : Private LISTBOX include
N--------------------END-OF-HEADER-------------------------------------
N*/
N
N#ifndef LISTBOX_PRIVATE_H
N#define LISTBOX_PRIVATE_H
N
N#include "GUI_Private.h"
N#include "WM_Intern.h"
N#include "LISTBOX.h"
N#include "GUI_ARRAY.h"
N#include "WIDGET.h"
N
N#if GUI_WINSUPPORT
X#if 1
N
N/*********************************************************************
N*
N*       Defines
N*
N**********************************************************************
N*/
N#define LISTBOX_ITEM_SELECTED         (1 << 0)
N#define LISTBOX_ITEM_DISABLED         (1 << 1)
N//
N// Private flags
N//
N#define LISTBOX_MOTION_STARTED        (1 << 0)   // Set while motion is running.
N#define LISTBOX_MOTION_PID_PRESSED    (1 << 1)   // Set if PID is pressed during motion.
N#define LISTBOX_TIMER_SNAPPING        (1 << 2)   // Set at the start of a manual snapping operation (_SnapToNearestItem). Cleared when it is done.
N
N/*********************************************************************
N*
N*       Object definition
N*
N**********************************************************************
N*/
Ntypedef struct {
N  U16  xSize, ySize;
X  unsigned short  xSize, ySize;
N  I32  ItemPosY;
X  signed long  ItemPosY;
N  U8   Status;
X  unsigned char   Status;
N  char acText[1];
N} LISTBOX_ITEM;
N
Ntypedef struct {
N  const GUI_FONT * pFont;
N  U16              ScrollStepH;
X  unsigned short              ScrollStepH;
N  GUI_COLOR        aBackColor[4];
N  GUI_COLOR        aTextColor[4];
N  GUI_COLOR        aScrollbarColor[3];
N  I16              Align;
X  signed short              Align;
N} LISTBOX_PROPS;
N
Ntypedef struct {
N  WIDGET                  Widget;
N  GUI_ARRAY               ItemArray;
N  WIDGET_DRAW_ITEM_FUNC * pfDrawItem;
N  WM_SCROLL_STATE         ScrollStateV;
N  WM_SCROLL_STATE         ScrollStateH;
N  LISTBOX_PROPS           Props;
N  WIDGET_COPY             Copy;
N  WM_HWIN                 hOwner;
X  GUI_HWIN                 hOwner;
N  int                     MotionPosY;
N  int                     TotalRowHeight;            // Cached value
N  int                     yOffset;                   // Cached value
N  WM_HMEM                 hContext;                  // Motion context
X  signed long                 hContext;                  
N  GUI_TIMER_HANDLE        hTimer;                    // Timer for motion snapping
N  I16                     Sel;                       // current selection
X  signed short                     Sel;                       
N  U16                     ItemSpacing;
X  unsigned short                     ItemSpacing;
N  U16                     ContentSizeX;
X  unsigned short                     ContentSizeX;
N  U16                     FixedScrollPos;
X  unsigned short                     FixedScrollPos;
N  U8                      Flags;
X  unsigned char                      Flags;
N  U8                      ScrollbarWidth;
X  unsigned char                      ScrollbarWidth;
N  U8                      FlagsIntern;               // Internal flags, see above
X  unsigned char                      FlagsIntern;               
N} LISTBOX_Obj;
N
N/*********************************************************************
N*
N*       Macros for internal use
N*
N**********************************************************************
N*/
N#if GUI_DEBUG_LEVEL >= GUI_DEBUG_LEVEL_CHECK_ALL
X#if 0 >= 2
S  #define LISTBOX_INIT_ID(p) p->Widget.DebugId = WIDGET_TYPE_LISTBOX
N#else
N  #define LISTBOX_INIT_ID(p)
N#endif
N
N#if GUI_DEBUG_LEVEL >= GUI_DEBUG_LEVEL_CHECK_ALL
X#if 0 >= 2
S  LISTBOX_Obj * LISTBOX_LockH(LISTBOX_Handle h);
S  #define LISTBOX_LOCK_H(h)   LISTBOX_LockH(h)
N#else
N  #define LISTBOX_LOCK_H(h)   (LISTBOX_Obj *)WM_LOCK_H(h)
N#endif
N
N#define LISTBOX_H2P(h)       ((LISTBOX_Obj *)WM_H2P(h))
N
N/*********************************************************************
N*
N*       Private (module internal) data
N*
N**********************************************************************
N*/
N
Nextern LISTBOX_PROPS LISTBOX_DefaultProps;
N
N/*********************************************************************
N*
N*       Private (module internal) functions
N*
N**********************************************************************
N*/
Nint          LISTBOX__GetItemPosY           (LISTBOX_Handle hObj, unsigned Index);
Nint          LISTBOX__GetItemSizeY          (LISTBOX_Handle hObj, unsigned Index);
Nunsigned     LISTBOX__GetNumItems           (const LISTBOX_Obj * pObj);
Nconst char * LISTBOX__GetpStringLocked      (LISTBOX_Handle hObj, int Index, LISTBOX_ITEM ** ppItem);
Nvoid         LISTBOX__InvalidateInsideArea  (LISTBOX_Handle hObj);
Nvoid         LISTBOX__InvalidateItem        (LISTBOX_Handle hObj, int Sel);
Nvoid         LISTBOX__InvalidateItemAndBelow(LISTBOX_Handle hObj, int Sel);
Nvoid         LISTBOX__InvalidateItemSize    (const LISTBOX_Obj * pObj, unsigned Index);
Nvoid         LISTBOX__SetScrollbarColor     (LISTBOX_Handle hObj, const LISTBOX_Obj * pObj);
Nvoid         LISTBOX__SetScrollbarWidth     (LISTBOX_Handle hObj, const LISTBOX_Obj * pObj);
Nvoid         LISTBOX__AddSize               (LISTBOX_Obj * pObj, int Index);
N
N#endif /* GUI_WINSUPPORT */
N
N#endif /* LISTBOX_PRIVATE_H */
N
N/*************************** End of file ****************************/
L 67 "..\..\..\..\ThirdParty\emWin\Include\AppWizard.h" 2
N#include "WHEEL_Private.h"
L 1 "..\..\..\..\ThirdParty\emWin\Include\WHEEL_Private.h" 1
N/*********************************************************************
N*                    SEGGER Microcontroller GmbH                     *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2023  SEGGER Microcontroller GmbH                *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V6.46 - Graphical user interface for embedded applications **
NemWin is protected by international copyright laws. Knowledge of the
Nsource code may not be used to write a similar product. 
NThis file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed by SEGGER Software GmbH to Nuvoton Technology Corporation
Nat the address: No. 4, Creation Rd. III, Hsinchu Science Park, Taiwan
Nfor the purposes  of  creating  libraries  for its 
NArm Cortex-A, Arm Cortex-M and  Arm9 32-bit microcontrollers, commercialized and distributed by Nuvoton Technology Corporation
Nunder  the terms and conditions  of  an  End  User  
NLicense  Agreement  supplied  with  the libraries.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NLicensing information
NLicensor:                 SEGGER Software GmbH
NLicensed to:              Nuvoton Technology Corporation, No. 4, Creation Rd. III, Hsinchu Science Park, 30077 Hsinchu City, Taiwan
NLicensed SEGGER software: emWin
NLicense number:           GUI-00735
NLicense model:            emWin License Agreement, signed February 27, 2018
NLicensed platform:        Cortex-M, Cortex-A, and ARM9 32-bit series microcontroller designed and manufactured by Nuvoton Technology Corporation.
N----------------------------------------------------------------------
NSupport and Update Agreement (SUA)
NSUA period:               2018-03-26 - 2025-09-04
NContact to extend SUA:    sales@segger.com
N----------------------------------------------------------------------
NFile        : WHEEL.h
NPurpose     : WHEEL include
N--------------------END-OF-HEADER-------------------------------------
N*/
N
N#ifndef WHEEL_PRIVATE_H
N#define WHEEL_PRIVATE_H
N
N#include "WM_Intern.h"
N#include "WHEEL.h"
N#include "GUI_ARRAY.h"
N
N#if (GUI_SUPPORT_MEMDEV && GUI_WINSUPPORT)
X#if (1 && 1)
N
N/*********************************************************************
N*
N*       Defines
N*
N**********************************************************************
N*/
N#define INDEX_CELL   0
N#define INDEX_CENTER 1
N
N/*********************************************************************
N*
N*       Object definition
N*
N**********************************************************************
N*/
Ntypedef struct {
N  I16       Align;
X  signed short       Align;
N  I16       xOff;
X  signed short       xOff;
N  I16       yOff;
X  signed short       yOff;
N  GUI_COLOR Color;
N} WHEEL_ITEM_ATTR;
N
Ntypedef struct {
N  WHEEL_ITEM_ATTR  aAttr[2];        // Separate attributes for cell (0) & center (1)
N  GUI_ARRAY        TextArray;       // Single array of text to be used
N  const GUI_FONT * apFont[2];       // Font
N  U8               HasCenter;       // >0 if center properties are available
X  unsigned char               HasCenter;       
N} WHEEL_TEXT;
N
Ntypedef struct {
N  WHEEL_ITEM_ATTR  aAttr[2];        // Separate attributes for cell (0) & center (1)
N  GUI_HMEM         aDraw[2];        // Separate memory blocks of GUI_DRAW_HANDLEs for cell (0) & center (1)
X  signed long         aDraw[2];        
N  unsigned         aNumItems[2];    // Number of items of each block
N  U8               HasCenter;       // >0 if center properties are available
X  unsigned char               HasCenter;       
N} WHEEL_DRAW;
N
Ntypedef struct {
N  U8               FrameRadius;     // Radius of frame
X  unsigned char               FrameRadius;     
N  U8               FrameSize;       // Size of frame
X  unsigned char               FrameSize;       
N  GUI_COLOR        FrameColor;      // Color of frame
N  GUI_COLOR        Color;           // Inner color
N} WHEEL_BOX;
N
Ntypedef struct {
N  U32              Period;          // Time in ms it takes to stop the WHEEL in ms
X  unsigned long              Period;          
N} WHEEL_PROPS;
N
Ntypedef struct {
N  WIDGET           Widget;          // (obvious)
N  WHEEL_PROPS      Props;           // (obvious)
N  GUI_ARRAY        TextArray;       // Array of WHEEL_TEXT contains the text to be shown
N  GUI_ARRAY        DrawArray;       // Array of WHEEL_DRAW contains the images to be shown
N  WHEEL_BOX        aBox[2];         // Separate WHEEL_BOX objects for cell & center
N  GUI_COLOR        BkColor;         // Background color
N  unsigned         NumItems;        // Number of items
N  U16              CellSize;        // Size of cell
X  unsigned short              CellSize;        
N  U16              CenterSize;      // Size of center
X  unsigned short              CenterSize;      
N  U16              Cutaway;         // Size of cutaway
X  unsigned short              Cutaway;         
N  U16              HBorder;         // Additional horizontal border for boxes in morph mode and for text clipping in plain mode
X  unsigned short              HBorder;         
N  U8               AlignCutaway;    // Alignment of cutaway
X  unsigned char               AlignCutaway;    
N  U8               Align;           // Alignment of items
X  unsigned char               Align;           
N  U8               HasCenter;       // Has separate center attributes
X  unsigned char               HasCenter;       
N  U8               Index;           // Index of draw object currently in operation
X  unsigned char               Index;           
N  int              Pos;             // Motion pos
N  int              ReleasedItem;    // Index of last released item
N  GUI_ANIM_HANDLE  hAnim;           // Handle of animation used to move to a position
N  int              AnimDist;        // Distance to be moved
N  int              AnimStart;       // Start value of animation
N  GUI_HMEM         ahOverlay[3];    // Separate memory blocks of GUI_DRAW_HANDLEs for overlay bitmaps
X  signed long         ahOverlay[3];    
N  WHEEL_ITEM_ATTR  aAttrOverlay[3]; // Alignment & color of overlay bitmaps
N  WM_HMEM          hContext;        // Motion context
X  signed long          hContext;        
N  WIDGET_DRAW_ITEM_FUNC * pfDrawItem;
N} WHEEL_OBJ;
N
N/*********************************************************************
N*
N*       Private functions
N*
N**********************************************************************
N*/
Nvoid         WHEEL__SetMotionFlags        (WHEEL_OBJ * pObj);
Nvoid         WHEEL__AddBitmapObjects      (WHEEL_Handle hObj, const GUI_HMEM                    * phMem, unsigned NumItems, U8 Align, I16 xOff, I16 yOff, GUI_COLOR Color);
Xvoid         WHEEL__AddBitmapObjects      (WHEEL_Handle hObj, const signed long                    * phMem, unsigned NumItems, unsigned char Align, signed short xOff, signed short yOff, GUI_COLOR Color);
Nvoid         WHEEL__SetCenterBitmapObjects(WHEEL_Handle hObj, unsigned Index, const GUI_HMEM    * phMem, unsigned NumItems, U8 Align, I16 xOff, I16 yOff, GUI_COLOR Color);
Xvoid         WHEEL__SetCenterBitmapObjects(WHEEL_Handle hObj, unsigned Index, const signed long    * phMem, unsigned NumItems, unsigned char Align, signed short xOff, signed short yOff, GUI_COLOR Color);
Nchar       * WHEEL__GetItemTextLocked     (WHEEL_Handle hObj, unsigned Index, unsigned Row);
Nvoid         WHEEL__ClipPos               (WHEEL_OBJ * pObj);
N
N/*********************************************************************
N*
N*       Macros for internal use
N*
N**********************************************************************
N*/
N#if GUI_DEBUG_LEVEL >= GUI_DEBUG_LEVEL_CHECK_ALL
X#if 0 >= 2
S  #define WHEEL_INIT_ID(p) p->Widget.DebugId = WIDGET_TYPE_WHEEL
N#else
N  #define WHEEL_INIT_ID(p)
N#endif
N
N#if GUI_DEBUG_LEVEL >= GUI_DEBUG_LEVEL_CHECK_ALL
X#if 0 >= 2
S  WHEEL_OBJ * WHEEL_LockH(WHEEL_Handle h);
S  #define WHEEL_LOCK_H(h)   WHEEL_LockH(h)
N#else
N  #define WHEEL_LOCK_H(h)   (WHEEL_OBJ *)WM_LOCK_H(h)
N#endif
N
N/*********************************************************************
N*
N*       Module internal data
N*
N**********************************************************************
N*/
Nextern WHEEL_PROPS WHEEL__DefaultProps;
N
N#endif   // (GUI_SUPPORT_MEMDEV && GUI_WINSUPPORT)
N#endif   // WHEEL_PRIVATE_H
N
N/************************* end of file ******************************/
L 68 "..\..\..\..\ThirdParty\emWin\Include\AppWizard.h" 2
N#include "MOVIE_Private.h"
L 1 "..\..\..\..\ThirdParty\emWin\Include\MOVIE_Private.h" 1
N/*********************************************************************
N*                    SEGGER Microcontroller GmbH                     *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2023  SEGGER Microcontroller GmbH                *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V6.46 - Graphical user interface for embedded applications **
NemWin is protected by international copyright laws. Knowledge of the
Nsource code may not be used to write a similar product. 
NThis file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed by SEGGER Software GmbH to Nuvoton Technology Corporation
Nat the address: No. 4, Creation Rd. III, Hsinchu Science Park, Taiwan
Nfor the purposes  of  creating  libraries  for its 
NArm Cortex-A, Arm Cortex-M and  Arm9 32-bit microcontrollers, commercialized and distributed by Nuvoton Technology Corporation
Nunder  the terms and conditions  of  an  End  User  
NLicense  Agreement  supplied  with  the libraries.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NLicensing information
NLicensor:                 SEGGER Software GmbH
NLicensed to:              Nuvoton Technology Corporation, No. 4, Creation Rd. III, Hsinchu Science Park, 30077 Hsinchu City, Taiwan
NLicensed SEGGER software: emWin
NLicense number:           GUI-00735
NLicense model:            emWin License Agreement, signed February 27, 2018
NLicensed platform:        Cortex-M, Cortex-A, and ARM9 32-bit series microcontroller designed and manufactured by Nuvoton Technology Corporation.
N----------------------------------------------------------------------
NSupport and Update Agreement (SUA)
NSUA period:               2018-03-26 - 2025-09-04
NContact to extend SUA:    sales@segger.com
N----------------------------------------------------------------------
NFile        : MOVIE_Private.h
NPurpose     : MOVIE private header file
N--------------------END-OF-HEADER-------------------------------------
N*/
N
N#ifndef MOVIE_PRIVATE_H
N#define MOVIE_PRIVATE_H
N
N#include "WM_Intern.h"
N#include "MOVIE.h"
N
N#if GUI_WINSUPPORT
X#if 1
N
N/*********************************************************************
N*
N*       Defines
N*
N**********************************************************************
N*/
N#define MOVIE_FLAG_DOLOOP         (1 << 0)
N#define MOVIE_FLAG_TIMER          (1 << 1)
N#define MOVIE_FLAG_PROGBARPRESSED (1 << 2)
N
N/*********************************************************************
N*
N*       Object definition
N*
N**********************************************************************
N*/
Ntypedef struct {
N  GUI_ANIM_HANDLE hAnim;
N  int             Start;
N  int             End;
N  I16             Pos;
X  signed short             Pos;
N} MOVIE_ANIM_DATA;
N
Ntypedef struct {
N  GUI_COLOR aColor[5];
N  int       aPeriod[3];
N  int       ySizePanel;
N  int       ySizeBar;
N  int       Space;
N} MOVIE_PROPS;
N
Ntypedef struct {
N  WIDGET           Widget;
N  MOVIE_PROPS      Props;
N  GUI_MOVIE_INFO   Info;
N  GUI_MOVIE_HANDLE hMovie;
N  WM_HMEM          ahDrawObj[4];
X  signed long          ahDrawObj[4];
N  int              yOffPanel;
N  WM_HTIMER        hTimerPanel;
X  signed long        hTimerPanel;
N  MOVIE_ANIM_DATA  AnimShift;
N  GUI_MOVIE_FUNC * pfNotify;
N  U8               Flags;
X  unsigned char               Flags;
N  U8               BitmapIndex;
X  unsigned char               BitmapIndex;
N  U8               PanelVisible;
X  unsigned char               PanelVisible;
N} MOVIE_OBJ;
N
N/*********************************************************************
N*
N*       Macros for internal use
N*
N**********************************************************************
N*/
N#if GUI_DEBUG_LEVEL >= GUI_DEBUG_LEVEL_CHECK_ALL
X#if 0 >= 2
S  #define MOVIE_INIT_ID(p) (p->Widget.DebugId = WIDGET_TYPE_MOVIE)
N#else
N  #define MOVIE_INIT_ID(p)
N#endif
N
N#if GUI_DEBUG_LEVEL >= GUI_DEBUG_LEVEL_CHECK_ALL
X#if 0 >= 2
S  MOVIE_OBJ * MOVIE_LockH(MOVIE_Handle h);
S  #define MOVIE_LOCK_H(h)   MOVIE_LockH(h)
N#else
N  #define MOVIE_LOCK_H(h)   (MOVIE_OBJ *)WM_LOCK_H(h)
N#endif
N
N#endif   /* GUI_WINSUPPORT */
N#endif   /* MOVIE_PRIVATE_H */
N
N/*************************** End of file ****************************/
L 69 "..\..\..\..\ThirdParty\emWin\Include\AppWizard.h" 2
N#include "RADIO_Private.h"
L 1 "..\..\..\..\ThirdParty\emWin\Include\RADIO_Private.h" 1
N/*********************************************************************
N*                    SEGGER Microcontroller GmbH                     *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2023  SEGGER Microcontroller GmbH                *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V6.46 - Graphical user interface for embedded applications **
NemWin is protected by international copyright laws. Knowledge of the
Nsource code may not be used to write a similar product. 
NThis file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed by SEGGER Software GmbH to Nuvoton Technology Corporation
Nat the address: No. 4, Creation Rd. III, Hsinchu Science Park, Taiwan
Nfor the purposes  of  creating  libraries  for its 
NArm Cortex-A, Arm Cortex-M and  Arm9 32-bit microcontrollers, commercialized and distributed by Nuvoton Technology Corporation
Nunder  the terms and conditions  of  an  End  User  
NLicense  Agreement  supplied  with  the libraries.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NLicensing information
NLicensor:                 SEGGER Software GmbH
NLicensed to:              Nuvoton Technology Corporation, No. 4, Creation Rd. III, Hsinchu Science Park, 30077 Hsinchu City, Taiwan
NLicensed SEGGER software: emWin
NLicense number:           GUI-00735
NLicense model:            emWin License Agreement, signed February 27, 2018
NLicensed platform:        Cortex-M, Cortex-A, and ARM9 32-bit series microcontroller designed and manufactured by Nuvoton Technology Corporation.
N----------------------------------------------------------------------
NSupport and Update Agreement (SUA)
NSUA period:               2018-03-26 - 2025-09-04
NContact to extend SUA:    sales@segger.com
N----------------------------------------------------------------------
NFile        : RADIO_Private.h
NPurpose     : RADIO private header file
N--------------------END-OF-HEADER-------------------------------------
N*/
N
N#ifndef RADIO_PRIVATE_H
N#define RADIO_PRIVATE_H
N
N#include "WM_Intern.h"
N
N#if GUI_WINSUPPORT
X#if 1
N#include "RADIO.h"
N#include "WIDGET.h"
N#include "GUI_ARRAY.h"
N
N/*********************************************************************
N*
N*       Defines
N*
N**********************************************************************
N*/
N/* Define default image inactiv */
N#ifndef   RADIO_IMAGE0_DEFAULT
N  #define RADIO_IMAGE0_DEFAULT        &RADIO__abmRadio[0]
N#endif
N
N/* Define default image activ */
N#ifndef   RADIO_IMAGE1_DEFAULT
N  #define RADIO_IMAGE1_DEFAULT        &RADIO__abmRadio[1]
N#endif
N
N/* Define default image check */
N#ifndef   RADIO_IMAGE_CHECK_DEFAULT
N  #define RADIO_IMAGE_CHECK_DEFAULT   &RADIO__bmCheck
N#endif
N
N/* Define default font */
N#ifndef   RADIO_FONT_DEFAULT
N  #if   WIDGET_USE_SCHEME_SMALL
X  #if   1
N    #define RADIO_SPACING_DEFAULT 20
N    #define RADIO_FONT_DEFAULT &GUI_Font13_1
N  #elif WIDGET_USE_SCHEME_MEDIUM
S    #define RADIO_SPACING_DEFAULT 24
S    #define RADIO_FONT_DEFAULT &GUI_Font16_1
S  #elif WIDGET_USE_SCHEME_LARGE
S    #define RADIO_SPACING_DEFAULT 30
S    #define RADIO_FONT_DEFAULT &GUI_Font24_1
N  #endif
N#endif
N
N/* Define vertical default spacing */
N#ifndef   RADIO_SPACING_DEFAULT
S  #define RADIO_SPACING_DEFAULT 20
N#endif
N
N/* Define default text color */
N#ifndef   RADIO_DEFAULT_TEXT_COLOR
N  #define RADIO_DEFAULT_TEXT_COLOR    GUI_BLACK
N#endif
N
N/* Define default background color */
N#ifndef   RADIO_DEFAULT_BKCOLOR
N  #define RADIO_DEFAULT_BKCOLOR       GUI_GRAY_C0
N#endif
N
N#ifndef   RADIO_FOCUSCOLOR_DEFAULT
N  #define RADIO_FOCUSCOLOR_DEFAULT    GUI_BLACK
N#endif
N
N#define RADIO_BORDER                  2
N
N/*********************************************************************
N*
N*       Object definition
N*
N**********************************************************************
N*/
Ntypedef struct {
N  unsigned (* pfGetButtonSize)(RADIO_Handle hObj);
N  WIDGET_DRAW_ITEM_FUNC * pfDrawSkin;
N} RADIO_SKIN_PRIVATE;
N
Ntypedef struct {
N  GUI_COLOR BkColor;
N  GUI_COLOR TextColor;
N  GUI_COLOR FocusColor;
N  const GUI_FONT * pFont;
N  const GUI_BITMAP * apBmRadio[2];
N  const GUI_BITMAP * pBmCheck;
N  RADIO_SKIN_PRIVATE SkinPrivate;
N} RADIO_PROPS;
N
Ntypedef struct {
N  WIDGET Widget;
N  RADIO_PROPS Props;
N  WIDGET_SKIN const * pWidgetSkin;
N  GUI_ARRAY TextArray;
N  I16 Sel;                   /* current selection */
X  signed short Sel;                    
N  U16 Spacing;
X  unsigned short Spacing;
N  U16 NumItems;
X  unsigned short NumItems;
N  U8  GroupId;
X  unsigned char  GroupId;
N  U8  Offset;
X  unsigned char  Offset;
N} RADIO_Obj;
N
N/*********************************************************************
N*
N*       Macros for internal use
N*
N**********************************************************************
N*/
N#if GUI_DEBUG_LEVEL >= GUI_DEBUG_LEVEL_CHECK_ALL
X#if 0 >= 2
S  #define RADIO_INIT_ID(p) p->Widget.DebugId = WIDGET_TYPE_RADIO
N#else
N  #define RADIO_INIT_ID(p)
N#endif
N
N#if GUI_DEBUG_LEVEL >= GUI_DEBUG_LEVEL_CHECK_ALL
X#if 0 >= 2
S  RADIO_Obj * RADIO_LockH(RADIO_Handle h);
S  #define RADIO_LOCK_H(h)   RADIO_LockH(h)
N#else
N  #define RADIO_LOCK_H(h)   (RADIO_Obj *)WM_LOCK_H(h)
N#endif
N
N/*********************************************************************
N*
N*       Types
N*
N**********************************************************************
N*/
N
Ntypedef void tRADIO_SetValue(RADIO_Handle hObj, int v);
N
N/*********************************************************************
N*
N*       Extern data
N*
N**********************************************************************
N*/
N
Nextern RADIO_PROPS RADIO__DefaultProps;
N
Nextern const WIDGET_SKIN RADIO__SkinClassic;
Nextern       WIDGET_SKIN RADIO__Skin;
N
Nextern WIDGET_SKIN const * RADIO__pSkinDefault;
N
Nextern const GUI_BITMAP             RADIO__abmRadio[2];
Nextern const GUI_BITMAP             RADIO__bmCheck;
Nextern       tRADIO_SetValue*       RADIO__pfHandleSetValue;
N
N/*********************************************************************
N*
N*       public functions (internal)
N*
N**********************************************************************
N*/
Nvoid     RADIO__SetValue     (RADIO_Handle hObj, int v);
Nunsigned RADIO__GetButtonSize(RADIO_Handle hObj);
N
N#endif   /* GUI_WINSUPPORT */
N#endif   /* RADIO_PRIVATE_H */
N
N/************************* end of file ******************************/
L 70 "..\..\..\..\ThirdParty\emWin\Include\AppWizard.h" 2
N#include "CHECKBOX_Private.h"
L 1 "..\..\..\..\ThirdParty\emWin\Include\CHECKBOX_Private.h" 1
N/*********************************************************************
N*                    SEGGER Microcontroller GmbH                     *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2023  SEGGER Microcontroller GmbH                *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V6.46 - Graphical user interface for embedded applications **
NemWin is protected by international copyright laws. Knowledge of the
Nsource code may not be used to write a similar product. 
NThis file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed by SEGGER Software GmbH to Nuvoton Technology Corporation
Nat the address: No. 4, Creation Rd. III, Hsinchu Science Park, Taiwan
Nfor the purposes  of  creating  libraries  for its 
NArm Cortex-A, Arm Cortex-M and  Arm9 32-bit microcontrollers, commercialized and distributed by Nuvoton Technology Corporation
Nunder  the terms and conditions  of  an  End  User  
NLicense  Agreement  supplied  with  the libraries.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NLicensing information
NLicensor:                 SEGGER Software GmbH
NLicensed to:              Nuvoton Technology Corporation, No. 4, Creation Rd. III, Hsinchu Science Park, 30077 Hsinchu City, Taiwan
NLicensed SEGGER software: emWin
NLicense number:           GUI-00735
NLicense model:            emWin License Agreement, signed February 27, 2018
NLicensed platform:        Cortex-M, Cortex-A, and ARM9 32-bit series microcontroller designed and manufactured by Nuvoton Technology Corporation.
N----------------------------------------------------------------------
NSupport and Update Agreement (SUA)
NSUA period:               2018-03-26 - 2025-09-04
NContact to extend SUA:    sales@segger.com
N----------------------------------------------------------------------
NFile        : CHECKBOX_Private.h
NPurpose     : CHECKBOX private header file
N--------------------END-OF-HEADER-------------------------------------
N*/
N
N#ifndef CHECKBOX_PRIVATE_H
N#define CHECKBOX_PRIVATE_H
N
N#include "WM_Intern.h"
N#include "WM.h"
N#include "WIDGET.h"
N#include "CHECKBOX.h"
N
N#if GUI_WINSUPPORT
X#if 1
N
N/*********************************************************************
N*
N*       Defines
N*
N**********************************************************************
N*/
N#ifndef   CHECKBOX_BKCOLOR0_DEFAULT
N  #define CHECKBOX_BKCOLOR0_DEFAULT 0x808080           /* Inactive color */
N#endif
N
N#ifndef   CHECKBOX_BKCOLOR1_DEFAULT
N  #define CHECKBOX_BKCOLOR1_DEFAULT GUI_WHITE          /* Active color */
N#endif
N
N#ifndef   CHECKBOX_FGCOLOR0_DEFAULT
N  #define CHECKBOX_FGCOLOR0_DEFAULT 0x101010
N#endif
N
N#ifndef   CHECKBOX_FGCOLOR1_DEFAULT
N  #define CHECKBOX_FGCOLOR1_DEFAULT GUI_BLACK
N#endif
N
N#ifndef   CHECKBOX_DEFAULT_SIZE
N  #define CHECKBOX_DEFAULT_SIZE          15
N#endif
N
N/*********************************************************************
N*
N*       Object definition
N*
N**********************************************************************
N*/
Ntypedef struct {
N  unsigned              (* pfGetButtonSize)(void);
N  WIDGET_DRAW_ITEM_FUNC  * pfDrawSkin;
N} CHECKBOX_SKIN_PRIVATE;
N
Ntypedef struct {
N  const GUI_FONT      * pFont;
N  GUI_COLOR             aBkColorBox[2]; /* Colors used to draw the box background */
N  GUI_COLOR             BkColor;        /* Widget background color */
N  GUI_COLOR             TextColor;
N  GUI_COLOR             FocusColor;
N  CHECKBOX_SKIN_PRIVATE SkinPrivate;
N  I16                   Align;
X  signed short                   Align;
N  U8                    Spacing;
X  unsigned char                    Spacing;
N  const GUI_BITMAP    * apBm[6];
N} CHECKBOX_PROPS;
N
Ntypedef struct {
N  WIDGET              Widget;
N  CHECKBOX_PROPS      Props;
N  WIDGET_SKIN const * pWidgetSkin;
N  U8                  NumStates;
X  unsigned char                  NumStates;
N  U8                  CurrentState;
X  unsigned char                  CurrentState;
N  WM_HMEM             hpText;
X  signed long             hpText;
N  U32                 ButtonSize;
X  unsigned long                 ButtonSize;
N} CHECKBOX_Obj;
N
N/*********************************************************************
N*
N*       Macros for internal use
N*
N**********************************************************************
N*/
N#if GUI_DEBUG_LEVEL >= GUI_DEBUG_LEVEL_CHECK_ALL
X#if 0 >= 2
S  #define CHECKBOX_INIT_ID(p) (p->Widget.DebugId = WIDGET_TYPE_CHECKBOX)
N#else
N  #define CHECKBOX_INIT_ID(p)
N#endif
N
N#if GUI_DEBUG_LEVEL >= GUI_DEBUG_LEVEL_CHECK_ALL
X#if 0 >= 2
S  CHECKBOX_Obj * CHECKBOX_LockH(CHECKBOX_Handle h);
S  #define CHECKBOX_LOCK_H(h)   CHECKBOX_LockH(h)
N#else
N  #define CHECKBOX_LOCK_H(h)   (CHECKBOX_Obj *)WM_LOCK_H(h)
N#endif
N
N/*********************************************************************
N*
N*       Private functions
N*
N**********************************************************************
N*/
Nunsigned CHECKBOX__GetButtonSize(void);
N
N/*********************************************************************
N*
N*       Public data (internal defaults)
N*
N**********************************************************************
N*/
Nextern CHECKBOX_PROPS      CHECKBOX__DefaultProps;
N
Nextern const WIDGET_SKIN   CHECKBOX__SkinClassic;
Nextern       WIDGET_SKIN   CHECKBOX__Skin;
N
Nextern WIDGET_SKIN const * CHECKBOX__pSkinDefault;
N
N/*********************************************************************
N*
N*       Extern data
N*
N**********************************************************************
N*/
Nextern const GUI_BITMAP    CHECKBOX__abmCheck[2];
N
N#endif   /* GUI_WINSUPPORT */
N#endif   /* CHECKBOX_PRIVATE_H */
N
N/*************************** End of file ****************************/
L 71 "..\..\..\..\ThirdParty\emWin\Include\AppWizard.h" 2
N
N#if (GUI_WINSUPPORT && GUI_SUPPORT_MEMDEV && WM_SUPPORT_TRANSPARENCY && GUI_SUPPORT_ROTATION)
X#if (1 && 1 && 1 && 1)
N
N#if defined(__cplusplus)
X#if 0L
S  extern "C" {             // Make sure we have C-declarations in C++ programs
N#endif
N
N/*####################################################################
N#
N#       Defines & enums
N#
N######################################################################
N*/
N//
N// Dispose flags (coordinates)
N//
N#define APPW_DISPOSE_FLAG_X0 (1 << 0)
N#define APPW_DISPOSE_FLAG_Y0 (1 << 1)
N#define APPW_DISPOSE_FLAG_X1 (1 << 2)
N#define APPW_DISPOSE_FLAG_Y1 (1 << 3)
N
N#define APPW_DISPOSE_DONE (APPW_DISPOSE_FLAG_X0 | APPW_DISPOSE_FLAG_Y0 | APPW_DISPOSE_FLAG_X1 | APPW_DISPOSE_FLAG_Y1)
N
N#define APPW_DISPOSE_FLAG_ISROOT    (1 << 0)
N
N//
N// Manage screens as persistent
N//
N#define APPW_STATE_PERSISTENT (1 << 0)
N
N//
N// Interaction flag(s)
N//
N#define APPW_ACTION_FLAG_DONTGETVALUEFROMEMITTER (1UL << 16)
N#define APPW_ACTION_FLAG_DEACTIVATED             (1UL << 17)
N
N//
N// Dispose modes
N//
N#define DISPOSE_MODE_NULL        0  // No dispose information
N#define DISPOSE_MODE_REL_DISPLAY 1  // Relative to display
N#define DISPOSE_MODE_REL_PARENT  2  // Relative to parent
N#define DISPOSE_MODE_REL_SIBLING 3  // Relative to sibling (opposite edge)
N#define DISPOSE_MODE_REL_PARTNER 4  // Relative to sibling (same edge)
N// The following 4 modes are currently not supported by the AppWizard:
N#define DISPOSE_MODE_MID_DISPLAY 5  // Relative to center of display
N#define DISPOSE_MODE_MID_PARENT  6  // Relative to center of parent
N#define DISPOSE_MODE_TAB_DISPLAY 7  // Tabular layout relative to display
N#define DISPOSE_MODE_TAB_PARENT  8  // Tabular layout relative to parent
N
N//
N// Dispose indices
N//
N#define DISPOSE_INDEX_X0 0
N#define DISPOSE_INDEX_Y0 1
N#define DISPOSE_INDEX_X1 2
N#define DISPOSE_INDEX_Y1 3
N#define DISPOSE_INDEX_MX 4  // Not used for disposing
N#define DISPOSE_INDEX_MY 5  // Not used for disposing
N
N//
N// Edges
N//
N#define APPW_EDGE_LEFT   0
N#define APPW_EDGE_RIGHT  1
N#define APPW_EDGE_TOP    2
N#define APPW_EDGE_BOTTOM 3
N
N//
N// Messages
N//
N#define APPW_MSG_GET_DISPOSE    (APPW_MSG +  0)
N#define APPW_MSG_GET_FUNCSETUP  (APPW_MSG +  1)
N#define APPW_MSG_SET_LANG       (APPW_MSG +  2)
N#define APPW_MSG_GET_JOBS       (APPW_MSG +  3)
N#define APPW_MSG_SETUP_FINISHED (APPW_MSG +  4)
N#define APPW_MSG_GET_STATE      (APPW_MSG +  5)
N#define APPW_MSG_SET_VALUE      (APPW_MSG +  6)
N#define APPW_MSG_SET_VAR        (APPW_MSG +  7)
N#define APPW_MSG_SET_TEXT       (APPW_MSG +  8)
N#define APPW_MSG_DISPOSE_DONE   (APPW_MSG +  9)
N#define APPW_MSG_GET_VALUE      (APPW_MSG + 10)
N#define APPW_MSG_GET_TEXT       (APPW_MSG + 11)
N#define APPW_MSG_GET_FOCUSRECT  (APPW_MSG + 12)
N#define APPW_MSG_GET_TYPE       (APPW_MSG + 13)
N#define APPW_MSG_SET_DRAW       (APPW_MSG + 14)
N#define APPW_MSG_GET_CONTENT    (APPW_MSG + 15)
N#define APPW_MSG_GET_PROP       (APPW_MSG + 16)
N#define APPW_MSG_GET_ITEM       (APPW_MSG + 17)
N
N//
N// Draw modes
N//
N#define APPW_DRAW_MODE_FILL  0
N#define APPW_DRAW_MODE_GRADH 1
N#define APPW_DRAW_MODE_GRADV 2
N
N//
N// Swiping modes
N//
N#define APPW_SWIPE_REPLACE  0
N#define APPW_SWIPE_DISCLOSE 1
N#define APPW_SWIPE_CUSTOM   2
N
N//
N// Off, On, Toggle
N//
N#define APPW_SET_OFF    0
N#define APPW_SET_ON     1
N#define APPW_SET_TOGGLE 2
N
N//
N// Actuating
N//
N#define APPW_DO_DRAG_LIN 0
N#define APPW_DO_DRAG_CCW 1
N#define APPW_DO_DRAG_CW  2
N#define APPW_DO_ACTUATE  3
N#define APPW_DO_DOWN     4
N#define APPW_DO_UP       5
N
N//
N// Please do not change existing values because they are used to determine the font type when reading XBF fonts!
N//
N#define MODE_FONT_1BPP     0       // Monochrome mode
N#define MODE_FONT_2BPP     1       // 4  gray scales for antialiased fonts
N#define MODE_FONT_4BPP     2       // 16 gray scales for antialiased fonts
N#define MODE_FONT_1EXT     3       // Monochrome mode with extended character information
N#define MODE_FONT_1FRM     4       // Monochrome mode with extended character information and frame
N#define MODE_FONT_2BPP_EXT 5       // 4  gray scales for antialiased fonts with extended character information
N#define MODE_FONT_4BPP_EXT 6       // 16 gray scales for antialiased fonts with extended character information
N
N//
N// Modes of Text-object
N//
N#define APPW_TEXTMODE_TEXT 0
N#define APPW_TEXTMODE_DEC  1
N#define APPW_TEXTMODE_HEX  2
N
N//
N// Modes of Edit-object
N//
N#define APPW_EDITMODE_TEXT 0
N#define APPW_EDITMODE_DEC  1
N
N//
N// Flags for Listview-object
N//
N#define APPW_FLAGS_LISTVIEW_SHOWGRID_HEADER (1 << 0)
N#define APPW_FLAGS_LISTVIEW_SHOWGRID_H      (1 << 1)
N#define APPW_FLAGS_LISTVIEW_SHOWGRID_V      (1 << 2)
N
N//
N// Text state
N//
N#define APPW_STATE_TEXT_INVALID  (1U << 0)
N#define APPW_STATE_TEXT_HASTEXT  (1U << 1)
N#define APPW_STATE_TEXT_HASVALUE (1U << 2)
N
N//
N// Listview compare modes
N//
N#define APPW_LISTVIEW_COMPARE_NONE 0
N#define APPW_LISTVIEW_COMPARE_TEXT 1
N#define APPW_LISTVIEW_COMPARE_DEC  2
N#define APPW_LISTVIEW_COMPARE_USER 3
N
N//
N// Conditions
N//
N#define APPW_IS_VAL 0  // Constant
N#define APPW_IS_VAR 1  // Variable
N#define APPW_IS_OBJ 2  // Object
N
N//
N// Modes of file access
N//
N#define APPW_IMAGE_MODE_INTERN 0
N#define APPW_IMAGE_MODE_EXTERN 1
N
N//
N// Spy jobs
N//
N#define APPW_JOB_REQUEST_OBJECTS   (JOB_QUIT + 1)
N#define APPW_JOB_REQUEST_VARIABLES (JOB_QUIT + 2)
N#define APPW_JOB_REQUEST_TIME      (JOB_QUIT + 3)
N#define APPW_JOB_SEND_PID          (JOB_QUIT + 4)
N#define APPW_JOB_SEND_KEY          (JOB_QUIT + 5)
N
N//
N// Macros
N//
N#ifndef GENERATE_JOB
N  #define GENERATE_JOB(Action, pFunc, HasReceiver) { Action, (int(*)(WM_HWIN, WM_HWIN, APPW_PARA_ITEM *, int))pFunc, HasReceiver }
N#endif
N
N//
N// Object types
N//
Nenum {
N  TYPE_OBJECT_GROUP = -1,
N  TYPE_OBJECT_ROOT,
N  TYPE_OBJECT_WINDOW,
N  TYPE_OBJECT_BOX,
N  TYPE_OBJECT_BUTTON,
N  TYPE_OBJECT_IMAGE,
N  TYPE_OBJECT_TEXT,
N  TYPE_OBJECT_SLIDER,
N  TYPE_OBJECT_ROTARY,
N  TYPE_OBJECT_SWITCH,
N  TYPE_OBJECT_EDIT,
N  TYPE_OBJECT_QRCODE,
N  TYPE_OBJECT_GAUGE,
N  TYPE_OBJECT_KEYBOARD,
N  TYPE_OBJECT_PROGBAR,
N  TYPE_OBJECT_TIMER,
N  TYPE_OBJECT_MULTIEDIT,
N  TYPE_OBJECT_DROPDOWN,
N  TYPE_OBJECT_LISTVIEW,
N  TYPE_OBJECT_LISTBOX,
N  TYPE_OBJECT_WHEEL,
N  TYPE_OBJECT_MOVIE,
N  TYPE_OBJECT_RADIO,
N  TYPE_OBJECT_CHECKBOX
N};
N
N//
N// Notification codes
N//
Nenum {
N  APPW_NOTIFICATION_INITDIALOG = (WM_NOTIFICATION_WIDGET + 0),
X  APPW_NOTIFICATION_INITDIALOG = (30 + 0),
N  APPW_NOTIFICATION_CREATE,
N  APPW_NOTIFICATION_DELETE,
N  APPW_NOTIFICATION_MOTION,
N  APPW_NOTIFICATION_ANIMEND,
N  APPW_NOTIFICATION_ANIMSTART,
N  APPW_NOTIFICATION_TIMER,
N  APPW_NOTIFICATION_PIDPRESSED,
N  APPW_NOTIFICATION_PIDRELEASED,
N  APPW_NOTIFICATION_FIXED,
N  APPW_NOTIFICATION_UNPINNED,
N  APPW_NOTIFICATION_ROTATED,
N  APPW_NOTIFICATION_LANGCHANGED
N};
N
N//
N// Atom index for start, end and destination
N//
Nenum {
N  ATOM_INDEX_START = 0,
N  ATOM_INDEX_END,
N  ATOM_INDEX_DEST
N};
N
N//
N// Time index for start and end
N//
Nenum {
N  ANIM_INDEX_TS = 0,
N  ANIM_INDEX_TE
N};
N
N//
N// Elementary particles of 'atoms'
N//
Nenum {
N  ATOM_OBJECT_VALUE = 0,
N  ATOM_VARIABLE,
N  ATOM_OBJECT_GEO,
N  ATOM_SCREEN_GEO,
N  ATOM_OBJECT_PROP,
N  ATOM_CONSTANT,
N  ATOM_ACTIVE        // WM_GetActiveWindow() is used here, Makes only sense for drawings.
N};
N
N//
N// Atom geo details
N//
Nenum {
N  ATOM_DETAIL_X0 = DISPOSE_INDEX_X0,
X  ATOM_DETAIL_X0 = 0,
N  ATOM_DETAIL_Y0 = DISPOSE_INDEX_Y0,
X  ATOM_DETAIL_Y0 = 1,
N  ATOM_DETAIL_X1 = DISPOSE_INDEX_X1,
X  ATOM_DETAIL_X1 = 2,
N  ATOM_DETAIL_Y1 = DISPOSE_INDEX_Y1,
X  ATOM_DETAIL_Y1 = 3,
N  ATOM_DETAIL_XCENTER,
N  ATOM_DETAIL_YCENTER,
N  ATOM_DETAIL_XSIZE,
N  ATOM_DETAIL_YSIZE
N};
N
N//
N// Atom property definitions
N//
Nenum {
N  ATOM_PROP_NUMCOLS = 0,  // Number of columns
N  ATOM_PROP_NUMROWS,      // Number of rows
N  ATOM_PROP_NUMFRAMES,    // Number of frames
N  ATOM_PROP_VALUE,        // Current value
N  ATOM_PROP_RELEASED      // Released item
N};
N
N//
N// Drawing functions for APPW__aDrawingFunc[]
N//
Nenum {
N  /*  0 */ APPW_ID_CLEAR = 0,
N  /*  1 */ APPW_ID_COPY_RECT,
N  /*  2 */ APPW_ID_DRAW_ARC,
N  /*  3 */ APPW_ID_DRAW_CIRCLE,
N  /*  4 */ APPW_ID_DRAW_ELLIPSE,
N  /*  5 */ APPW_ID_DRAW_GRADIENT_H,
N  /*  6 */ APPW_ID_DRAW_GRADIENT_V,
N  /*  7 */ APPW_ID_DRAW_GRADIENT_ROUNDED_H,
N  /*  8 */ APPW_ID_DRAW_GRADIENT_ROUNDED_V,
N  /*  9 */ APPW_ID_DRAW_HLINE,
N  /* 10 */ APPW_ID_DRAW_LINE,
N  /* 11 */ APPW_ID_DRAW_LINE_REL,
N  /* 12 */ APPW_ID_DRAW_LINE_TO,
N  /* 13 */ APPW_ID_DRAW_PIE,
N  /* 14 */ APPW_ID_DRAW_PIXEL,
N  /* 15 */ APPW_ID_DRAW_POINT,
N  /* 16 */ APPW_ID_DRAW_RECT,
N  /* 17 */ APPW_ID_DRAW_ROUNDED_FRAME,
N  /* 18 */ APPW_ID_DRAW_ROUNDED_RECT,
N  /* 19 */ APPW_ID_DRAW_VLINE,
N  /* 20 */ APPW_ID_ENABLE_ALPHA,
N  /* 21 */ APPW_ID_FILL_CIRCLE,
N  /* 22 */ APPW_ID_FILL_ELLIPSE,
N  /* 23 */ APPW_ID_FILL_RECT,
N  /* 24 */ APPW_ID_FILL_ROUNDED_RECT,
N  /* 25 */ APPW_ID_INVERT_RECT,
N  /* 26 */ APPW_ID_MOVE_REL,
N  /* 27 */ APPW_ID_MOVE_TO,
N  /* 28 */ APPW_ID_SET_BLENDBKCOLOR,
N  /* 29 */ APPW_ID_SET_BLENDBKCOLOREX,
N  /* 30 */ APPW_ID_SET_BLENDCOLOR,
N  /* 31 */ APPW_ID_SET_BLENDCOLOREX,
N  /* 32 */ APPW_ID_SET_BKCOLOR,
N  /* 33 */ APPW_ID_SET_COLOR,
N  /* 34 */ APPW_ID_SET_PENSIZE,
N  /* 35 */ APPW_ID_SET_LINESTYLE,
N  /* 36 */ APPW_ID_AA_DISABLE_HIRES,
N  /* 37 */ APPW_ID_AA_DRAW_ARC,
N  /* 38 */ APPW_ID_AA_DRAW_CIRCLE,
N  /* 39 */ APPW_ID_AA_DRAW_LINE,
N  /* 40 */ APPW_ID_AA_DRAW_PIE,
N  /* 41 */ APPW_ID_AA_DRAW_ROUNDED_FRAME,
N  /* 42 */ APPW_ID_AA_ENABLE_HIRES,
N  /* 43 */ APPW_ID_AA_FILL_CIRCLE,
N  /* 44 */ APPW_ID_AA_FILL_ELLIPSE,
N  /* 45 */ APPW_ID_AA_FILL_ROUNDED_RECT,
N  /* 46 */ APPW_ID_AA_SET_FACTOR
N};
N
N//
N// Indices for prev and post draw
N//
Nenum {
N  APPW_DRAWING_INDEX_PREV = 0,
N  APPW_DRAWING_INDEX_POST
N};
N
N//
N// Modes for source object of APPW_JOB_SETITEM, APPW_JOB_ADDITEM and APPW_JOB_INSITEM
N//
Nenum {
N  APPW_ITEM_MODE_UNDEFINED = 0,
N  APPW_ITEM_MODE_RESOURCE,
N  APPW_ITEM_MODE_OBJECT,
N};
N
N//
N// Jobs of interactions
N//
Nenum {
N//--------------------------------------------------------------------------------
N// Value                               Purpose
N//--------------------------------------------------------------------------------
N  APPW_JOB_NULL = -1,
N  /*  1 */ APPW_JOB_SETENABLE = 1,  // (pPara + 0)->v     - 1 = On, 0 = Off
N  /*  2 */ APPW_JOB_SETVIS,         // (pPara + 0)->v     - 1 = On, 0 = Off
N  /*  3 */ APPW_JOB_SETCOORD,       // (pPara + 0)->v     - Value
N                                    // (pPara + 1)->v     - Index of coordinate
N  /*  4 */ APPW_JOB_SETCOLOR,       // (pPara + 0)->v     - Color to be used
N                                    // (pPara + 1)->v     - Index of color
N  /*  5 */ APPW_JOB_SETBKCOLOR,     // (pPara + 0)->v     - BkColor to be used
N  /*  6 */ APPW_JOB_ADDVALUE,       // (pPara + 0)->v     - Value to be added
N  /*  7 */ APPW_JOB_SETVALUE,       // (pPara + 0)->v     - Value to be set
N  /*  8 */ APPW_JOB_SETPERIOD,      // (pPara + 0)->v     - Value to be set
N  /*  9 */ APPW_JOB_SETSCALE,       // (pPara + 0)->v     - Value to be set
N  /* 10 */ APPW_JOB_SETANGLE,       // (pPara + 0)->v     - Value to be set
N  /* 11 */ APPW_JOB_SETALPHA,       // (pPara + 0)->v     - Value to be set
N  /* 12 */ APPW_JOB_SETSIZE,        // (pPara + 0)->v     - Value to be used
N                                    // (pPara + 1)->v     - Index of axis
N  /* 13 */ APPW_JOB_SETFONT,        // (pPara + 0)->v     - Number of items
N                                    // (pPara + 0)->p     - Pointer to first APPW_PARA_ITEM required for font creation
N                                    // (pPara + 0)->pFunc - Source file names separated by semicolon (=== In AppWizard application only ===)
N  /* 14 */ APPW_JOB_SHIFTSCREEN,    // (pPara + 0)->v     - Screen Id
N                                    // (pPara + 1)->v     - Index of edge
N                                    // (pPara + 2)->pFunc - Ease func
N                                    // (pPara + 3)->v     - Period
N                                    // (pPara + 4)->v     - Disclose
N  /* 15 */ APPW_JOB_SHIFTWINDOW,    // (pPara + 0)->v     - Window Id
N                                    // (pPara + 1)->v     - Index of edge
N                                    // (pPara + 2)->pFunc - Ease func
N                                    // (pPara + 3)->v     - Period
N                                    // (pPara + 4)->v     - Disclose
N  /* 16 */ APPW_JOB_SET,            // === NO PARAMETERS ===
N  /* 17 */ APPW_JOB_CLEAR,          // === NO PARAMETERS ===
N  /* 18 */ APPW_JOB_TOGGLE,         // === NO PARAMETERS ===
N  /* 19 */ APPW_JOB_START,          // === NO PARAMETERS ===
N  /* 20 */ APPW_JOB_STOP,           // === NO PARAMETERS ===
N  /* 21 */ APPW_JOB_SETTEXT,        // (pPara + 0)->v     - Text resource Id (if (pPara + 0)->p == NULL)
N                                    // (pPara + 0)->p     - Handle           (if (pPara + 0)->v < 0)
N  /* 22 */ APPW_JOB_SHOWSCREEN,     // (pPara + 0)->v     - Screen Id
N  /* 23 */ APPW_JOB_SETLANG,        // (pPara + 0)->v     - Index of language 
N  /* 24 */ APPW_JOB_SETFOCUS,       // === NO PARAMETERS ===
N  /* 25 */ APPW_JOB_ENABLEPID,      // (pPara + 0)->v     - 1 = On, 0 = Off
N  /* 26 */ APPW_JOB_CLOSESCREEN,    // (pPara + 0)->v     - Screen Id
N  /* 27 */ APPW_JOB_SETX0,          // (pPara + 0)->v     - Value
N  /* 28 */ APPW_JOB_SETY0,          // (pPara + 0)->v     - Value
N  /* 29 */ APPW_JOB_SETX1,          // (pPara + 0)->v     - Value
N  /* 30 */ APPW_JOB_SETY1,          // (pPara + 0)->v     - Value
N  /* 31 */ APPW_JOB_MODALMESSAGE,   // (pPara + 0)->v     - Screen Id
N  /* 32 */ APPW_JOB_CALC,           // === NO PARAMETERS ===
N  /* 33 */ APPW_JOB_ANIMCREATE,     // (pPara + 0)->p     - GUI: Pointer to APPW_ANIM_DATA structure, AppWizard: NULL
N                                    // (pPara + 0)->v     - GUI: 0,                                   AppWizard: Animation Id
N  /* 34 */ APPW_JOB_ANIMSTOP,       // (pPara + 0)->v     - Animation Id
N                                    // (pPara + 1)->v     - 1 = Delete animation, 0 = Remain animation
N  /* 35 */ APPW_JOB_ANIMSTART,      // (pPara + 0)->v     - Animation Id
N                                    // (pPara + 1)->v     - Number of loops (<0 = endless)
N  /* 36 */ APPW_JOB_SETBITMAP,      // (pPara + 0)->v     - Index
N                                    // (pPara + 1)->p     - INT: Pointer to Image-Data / EXT: Pointer to Image-Filename (EXT)
N                                    // (pPara + 1)->v     - 0 (INT) / 1 (EXT)
N                                    // (pPara + 2)->v     - FileSize
N                                    // (pPara + 3)->p     - Source file name (=== In AppWizard application only ===)
N                                    // (pPara + 3)->v     - If set to 1 the source file name is in const memory
N  /* 37 */ APPW_JOB_SETSTART,       // (pPara + 0)->v     - Value
N  /* 38 */ APPW_JOB_SETEND,         // (pPara + 0)->v     - Value
N  /* 39 */ APPW_JOB_INVALIDATE,     // === NO PARAMETERS ===
N  /* 40 */ APPW_JOB_SETITEM,        // (pPara + 0)->v     - Type: 0 = text resource, 1 = object
N                                    // (pPara + 1)->v     - 0: Text resource Id, 1: HB/LB: screen Id/object Id
N                                    // (pPara + 2)->v     - Source: Row index    (Listview, Dropdown, Listbox)
N                                    // (pPara + 3)->v     - Source: Column index (Listview only)
N                                    // (pPara + 4)->v     - Target: Row index    (Listview, Dropdown, Listbox)
N                                    // (pPara + 5)->v     - Target: Column index (Listview only)
N  /* 41 */ APPW_JOB_ADDITEM,        // (pPara + 0)->v     - Type: 0 = text resource, 1 = object
N                                    // (pPara + 1)->v     - 0: Text resource Id, 1: HB/LB: screen Id/object Id
N                                    // (pPara + 2)->v     - Source: Row index    (Listview, Dropdown, Listbox)
N                                    // (pPara + 3)->v     - Source: Column index (Listview only)
N                                    // (pPara + 4)->v     - Target: Column index (Listview only)
N  /* 42 */ APPW_JOB_INSITEM,        // (pPara + 0)->v     - Type: 0 = text resource, 1 = object
N                                    // (pPara + 1)->v     - 0: Text resource Id, 1: HB/LB: screen Id/object Id
N                                    // (pPara + 2)->v     - Source: Row index    (Listview, Dropdown, Listbox)
N                                    // (pPara + 3)->v     - Source: Column index (Listview only)
N                                    // (pPara + 4)->v     - Target: Row index    (Listview, Dropdown, Listbox)
N                                    // (pPara + 5)->v     - Target: Column index (Listview only)
N  /* 43 */ APPW_JOB_DELITEM,        // (pPara + 0)->v     - Item index to be deleted
N  /* 44 */ APPW_JOB_MOVETO,         // (pPara + 0)->v     - Value
N  /* 45 */ APPW_JOB_SETRANGE,       // (pPara + 0)->v     - Start value
N                                    // (pPara + 1)->v     - End value
N  /* 46 */ APPW_JOB_ROTATEDISPLAY,  // (pPara + 0)->v     - Rotation command (0, CW, CCW, 180, LEFT, RIGHT) to be used
N  /* 47 */ APPW_JOB_EXIT,           // === NO PARAMETERS ===
N  /* 48 */ APPW_JOB_SCREENSHOT,     // === NO PARAMETERS ===
N  /* 49 */ APPW_JOB_ACTUATE         // (pPara + 0)->v     - Object Id
N                                    // (pPara + 1)->v     - DRAG_LIN: xPos0 (LWord) yPos0 (HWord), DRAG_CCW/DRAG_CW: start angle (LWord) end angle (HWord), ACTUATE: xPos down (LWord) yPos down (HWord), DOWN/UP: xPos (LWord) yPos (HWord)
N                                    // (pPara + 2)->v     - DRAG_LIN: xPos1 (LWord) yPos1 (HWord), DRAG_CCW/DRAG_CW: radius (LWord), ACTUATE: xPos up (LWord) yPos up (HWord)
N                                    // (pPara + 3)->v     - Type: 0 = DRAG_LIN, 1 = DRAG_CCW, 2 = DRAG_CW, 3 = ACTUATE, 4 = DOWN, 5 = UP
N                                    // (pPara + 4)->pFunc - DRAG, DRAGUP: Ease func
N                                    // (pPara + 5)->v     - DRAG, DRAGUP: Period
N};
N
N//
N// Commands for setting properties
N//
Nenum {
N  /*  0 */ APPW_SET_PROP_COLOR = 0   ,
N  /*  1 */ APPW_SET_PROP_SCALE       ,
N  /*  2 */ APPW_SET_PROP_ALPHA       ,
N  /*  3 */ APPW_SET_PROP_ANGLE       ,
N  /*  4 */ APPW_SET_PROP_OPAQUE      ,
N  /*  5 */ APPW_SET_PROP_TILE        ,
N  /*  6 */ APPW_SET_PROP_TOGGLE      ,
N  /*  7 */ APPW_SET_PROP_ALIGNTEXT   ,
N  /*  8 */ APPW_SET_PROP_ALIGNBITMAP ,
N  /*  9 */ APPW_SET_PROP_ALIGNBITMAP2,
N  /* 10 */ APPW_SET_PROP_ALIGNBITMAP3,
N  /*  1 */ APPW_SET_PROP_SBITMAP     ,
N  /*  2 */ APPW_SET_PROP_JPEG        ,
N  /*  3 */ APPW_SET_PROP_BMP         ,
N  /*  4 */ APPW_SET_PROP_GIF         ,
N  /*  5 */ APPW_SET_PROP_MOVIE       ,
N  /*  6 */ APPW_SET_PROP_DECMODE     ,
N  /*  7 */ APPW_SET_PROP_HEXMODE     ,
N  /*  8 */ APPW_SET_PROP_MORPHMODE   ,
N  /*  9 */ APPW_SET_PROP_GRADH       ,
N  /* 20 */ APPW_SET_PROP_GRADV       ,
N  /*  1 */ APPW_SET_PROP_REPEAT      ,
N  /*  2 */ APPW_SET_PROP_TEXTID      ,
N  /*  3 */ APPW_SET_PROP_SIZE        ,
N  /*  4 */ APPW_SET_PROP_GRADH2      ,
N  /*  5 */ APPW_SET_PROP_GRADV2      ,
N  /*  6 */ APPW_SET_PROP_COLOR2      ,
N  /*  7 */ APPW_SET_PROP_COLOR3      ,
N  /*  8 */ APPW_SET_PROP_TEXTID2     ,
N  /*  9 */ APPW_SET_PROP_COLORS      ,
N  /* 30 */ APPW_SET_PROP_COLORS2     ,
N  /*  1 */ APPW_SET_PROP_COLORS3     ,
N  /*  2 */ APPW_SET_PROP_BKCOLOR     ,
N  /*  3 */ APPW_SET_PROP_BKCOLORS    ,
N  /*  4 */ APPW_SET_PROP_SBITMAPS    ,
N  /*  5 */ APPW_SET_PROP_FONT        ,
N  /*  6 */ APPW_SET_PROP_FONT2       ,
N  /*  7 */ APPW_SET_PROP_MOTIONH     ,
N  /*  8 */ APPW_SET_PROP_MOTIONV     ,
N  /*  9 */ APPW_SET_PROP_RANGE       ,
N  /* 40 */ APPW_SET_PROP_SPAN        ,
N  /*  1 */ APPW_SET_PROP_VALUES      ,
N  /*  2 */ APPW_SET_PROP_SLAYOUT     ,
N  /*  3 */ APPW_SET_PROP_CONTENT     ,
N  /*  4 */ APPW_SET_PROP_SORTCOLS    ,
N  /*  5 */ APPW_SET_PROP_OFFSET      ,
N  /*  6 */ APPW_SET_PROP_GROUPID     ,
N  /*  7 */ APPW_SET_PROP_POS         ,
N  /*  8 */ APPW_SET_PROP_VALUE       ,
N  /*  9 */ APPW_SET_PROP_PERIOD      ,
N  /* 50 */ APPW_SET_PROP_PERIOD2     ,
N  /*  1 */ APPW_SET_PROP_PERIOD3     ,
N  /*  2 */ APPW_SET_PROP_SNAP        ,
N  /*  3 */ APPW_SET_PROP_ALIGN       ,
N  /*  4 */ APPW_SET_PROP_RADIUS      ,
N  /*  5 */ APPW_SET_PROP_RADIUS2     ,
N  /*  6 */ APPW_SET_PROP_FRAME       ,
N  /*  7 */ APPW_SET_PROP_FRAME2      ,
N  /*  8 */ APPW_SET_PROP_FRAME3      ,
N  /*  9 */ APPW_SET_PROP_BORDER      ,
N  /* 60 */ APPW_SET_PROP_LENGTH      ,
N  /*  1 */ APPW_SET_PROP_HEIGHT      ,
N  /*  2 */ APPW_SET_PROP_HEIGHT2     ,
N  /*  3 */ APPW_SET_PROP_FIXED       ,
N  /*  4 */ APPW_SET_PROP_SPACING     ,
N  /*  5 */ APPW_SET_PROP_ROTATION    ,
N  /*  6 */ APPW_SET_PROP_ECCLEVEL    ,
N  /*  7 */ APPW_SET_PROP_VERSION     ,
N  /*  8 */ APPW_SET_PROP_FOCUSABLE   ,
N  /*  9 */ APPW_SET_PROP_MOTION      ,
N  /* 70 */ APPW_SET_PROP_INVERT      ,
N  /*  1 */ APPW_SET_PROP_VERTICAL    ,
N  /*  2 */ APPW_SET_PROP_HORIZONTAL  ,
N  /*  3 */ APPW_SET_PROP_ENDLESS     ,
N  /*  4 */ APPW_SET_PROP_PERSISTENT  ,
N  /*  5 */ APPW_SET_PROP_ROTATE      ,
N  /*  6 */ APPW_SET_PROP_FADE        ,
N  /*  7 */ APPW_SET_PROP_WRAP        ,
N  /*  8 */ APPW_SET_PROP_ROUNDEDVAL  ,
N  /*  9 */ APPW_SET_PROP_ROUNDEDEND  ,
N  /* 80 */ APPW_SET_PROP_OVERWRITE   ,
N  /*  1 */ APPW_SET_PROP_AUTORESTART ,
N  /*  2 */ APPW_SET_PROP_LQ          ,
N  /*  3 */ APPW_SET_PROP_STAYONTOP   ,
N  /*  4 */ APPW_SET_PROP_UNTOUCHABLE ,
N  /*  5 */ APPW_SET_PROP_PWMODE      ,
N  /*  6 */ APPW_SET_PROP_ROMODE      ,
N  /*  7 */ APPW_SET_PROP_CELLSELECT  ,
N  /*  8 */ APPW_SET_PROP_VISIBLE     ,
N  /*  9 */ APPW_SET_PROP_VISIBLE2    ,
N  /* 90 */ APPW_SET_PROP_VISIBLE3    ,
N  /*  1 */ APPW_SET_PROP_SWITCHOFF   ,
N  /*  2 */ APPW_SET_PROP_3STATE      ,
N  /*  3 */ APPW_SET_PROP_FIXED2      ,
N  /*  4 */ APPW_SET_PROP_WHEELTEXT   ,
N  /*  5 */ APPW_SET_PROP_WHEELBITMAPS,
N  /*  6 */ APPW_SET_PROP_SCROLLERH   ,
N  /*  7 */ APPW_SET_PROP_SCROLLERV   ,
N};
N
N//
N// Bitmap indices
N//
N#define APPW_BI_UNPRESSED 0
N#define APPW_BI_PRESSED   1
N#define APPW_BI_DISABLED  2
N
N#define APPW_MAX_RANGE    0xFFFFu
N
N//
N// Use of parameter
N//
N#define ARG_V(v)             { (U32)v, (const void *)0, (void (*)(void))NULL  }
N#define ARG_P(p)             { (U32)0, (const void *)p, (void (*)(void))NULL  }
N#define ARG_VP(v, p)         { (U32)v, (const void *)p, (void (*)(void))NULL  }
N#define ARG_VPF(v, p, pFunc) { (U32)v, (const void *)p, (void (*)(void))pFunc }
N#define ARG_F(pFunc)         { (U32)0, (const void *)0, (void (*)(void))pFunc }
N
N//
N// Distinguishing between different possible text sources in APPW_GetLockedText()
N//
N#define APPW_USE_TEXT_HANDLE (-2)
N#define APPW_USE_OBJECT_ID   (-3)
N
N//
N// Internal configuration macros
N//
N#ifndef   APPW_SETUP_ITEM_EXT
N  #define APPW_SETUP_ITEM_EXT
N#endif
N
N#ifndef   APPW_ACTION_ITEM_EXT
N  #define APPW_ACTION_ITEM_EXT
N#endif
N
N#ifndef   APPW_JOB_EXT
N  #define APPW_JOB_EXT
N#endif
N
N//
N// Internal macros
N//
N#define MANAGE_GET_DISPOSE_FUNCSETUP_JOBS(OBJECT_TYPE)                                    \
N  case APPW_MSG_GET_DISPOSE:                                                              \
N    pMsg->Data.pData = (void *)&((WM_##OBJECT_TYPE *)GUI_ALLOC_h2p(pMsg->hWin))->Dispose; \
N    break;                                                                                \
N  case APPW_MSG_GET_TYPE:                                                                 \
N    pMsg->Data.v = TYPE_##OBJECT_TYPE;                                                    \
N    break;                                                                                \
N  case APPW_MSG_GET_FUNCSETUP:                                                            \
N    pMsg->Data.pFunc = (void(*)(void))_Setup;                                             \
N    break;                                                                                \
N  case APPW_MSG_GET_JOBS:                                                                 \
N    pMsg->Data.p = (const void *)_aJobs;                                                  \
N    pMsg->MsgId  = GUI_COUNTOF(_aJobs);                                                   \
N    break
X#define MANAGE_GET_DISPOSE_FUNCSETUP_JOBS(OBJECT_TYPE)                                      case APPW_MSG_GET_DISPOSE:                                                                  pMsg->Data.pData = (void *)&((WM_##OBJECT_TYPE *)GUI_ALLOC_h2p(pMsg->hWin))->Dispose;     break;                                                                                  case APPW_MSG_GET_TYPE:                                                                     pMsg->Data.v = TYPE_##OBJECT_TYPE;                                                        break;                                                                                  case APPW_MSG_GET_FUNCSETUP:                                                                pMsg->Data.pFunc = (void(*)(void))_Setup;                                                 break;                                                                                  case APPW_MSG_GET_JOBS:                                                                     pMsg->Data.p = (const void *)_aJobs;                                                      pMsg->MsgId  = GUI_COUNTOF(_aJobs);                                                       break
N
N#define MANAGE_GET_DISPOSE_FUNCSETUP(OBJECT_TYPE)                                         \
N  case APPW_MSG_GET_DISPOSE:                                                              \
N    pMsg->Data.pData = (void *)&((WM_##OBJECT_TYPE *)GUI_ALLOC_h2p(pMsg->hWin))->Dispose; \
N    break;                                                                                \
N  case APPW_MSG_GET_TYPE:                                                                 \
N    pMsg->Data.v = TYPE_##OBJECT_TYPE;                                                    \
N    break;                                                                                \
N  case APPW_MSG_GET_FUNCSETUP:                                                            \
N    pMsg->Data.pFunc = (void(*)(void))_Setup;                                             \
N    break
X#define MANAGE_GET_DISPOSE_FUNCSETUP(OBJECT_TYPE)                                           case APPW_MSG_GET_DISPOSE:                                                                  pMsg->Data.pData = (void *)&((WM_##OBJECT_TYPE *)GUI_ALLOC_h2p(pMsg->hWin))->Dispose;     break;                                                                                  case APPW_MSG_GET_TYPE:                                                                     pMsg->Data.v = TYPE_##OBJECT_TYPE;                                                        break;                                                                                  case APPW_MSG_GET_FUNCSETUP:                                                                pMsg->Data.pFunc = (void(*)(void))_Setup;                                                 break
N
N//
N// Macros for drawing objects
N//
N#define MANAGE_PREPAINT(OBJ_CAST)                     \
N    pObj = (OBJ_CAST *)GUI_LOCK_H(pMsg->hWin); {      \
N      APPW_DrawingPrepare(pObj->aIdDraw, pMsg->hWin); \
N    } GUI_UNLOCK_H(pObj)
X#define MANAGE_PREPAINT(OBJ_CAST)                         pObj = (OBJ_CAST *)GUI_LOCK_H(pMsg->hWin); {            APPW_DrawingPrepare(pObj->aIdDraw, pMsg->hWin);     } GUI_UNLOCK_H(pObj)
N
N#define MANAGE_POSTPAINT() APPW_DrawingCleanup()
N
N#define MANAGE_SET_DRAW(OBJ_CAST)                                          \
N  case APPW_MSG_SET_DRAW:                                                  \
N    pObj = (OBJ_CAST *)GUI_LOCK_H(pMsg->hWin); {                           \
N      pObj->aIdDraw[APPW_DRAWING_INDEX_PREV] = (U32)pMsg->Data.v & 0xFFFF; \
N      pObj->aIdDraw[APPW_DRAWING_INDEX_POST] = (U32)pMsg->Data.v >> 16;    \
N    } GUI_UNLOCK_H(pObj);                                                  \
N    break
X#define MANAGE_SET_DRAW(OBJ_CAST)                                            case APPW_MSG_SET_DRAW:                                                      pObj = (OBJ_CAST *)GUI_LOCK_H(pMsg->hWin); {                                 pObj->aIdDraw[APPW_DRAWING_INDEX_PREV] = (U32)pMsg->Data.v & 0xFFFF;       pObj->aIdDraw[APPW_DRAWING_INDEX_POST] = (U32)pMsg->Data.v >> 16;        } GUI_UNLOCK_H(pObj);                                                      break
N
N#define MANAGE_DRAWING(OBJ_CAST) \
N  MANAGE_SET_DRAW(OBJ_CAST);     \
N  case WM_PRE_PAINT:             \
N    MANAGE_PREPAINT(OBJ_CAST);   \
N    break;                       \
N  case WM_POST_PAINT:            \
N    MANAGE_POSTPAINT();          \
N    break
X#define MANAGE_DRAWING(OBJ_CAST)   MANAGE_SET_DRAW(OBJ_CAST);       case WM_PRE_PAINT:                 MANAGE_PREPAINT(OBJ_CAST);       break;                         case WM_POST_PAINT:                MANAGE_POSTPAINT();              break
N
N//
N// Macros for defining drawing items used in exported code only
N//
N#define APPW_DRAWING_ITEM_DEF_X(Name, NumAtoms) \
Nstatic const struct {                           \
N  U16                       IndexFunc;          \
N  const APPW_DRAWING_ITEM * pNextItem;          \
N  APPW_ATOM                 aAtom[NumAtoms];    \
N} Name =
X#define APPW_DRAWING_ITEM_DEF_X(Name, NumAtoms) static const struct {                             U16                       IndexFunc;            const APPW_DRAWING_ITEM * pNextItem;            APPW_ATOM                 aAtom[NumAtoms];    } Name =
N
N#define APPW_DRAWING_ITEM_DEF_0(Name)  \
Nstatic const struct {                  \
N  U16                       IndexFunc; \
N  const APPW_DRAWING_ITEM * pNextItem; \
N} Name =
X#define APPW_DRAWING_ITEM_DEF_0(Name)  static const struct {                    U16                       IndexFunc;   const APPW_DRAWING_ITEM * pNextItem; } Name =
N
N//
N// Macros for interface definitions
N//
N#define DEFAULT_CRCB(Object)                                                             \
N  void    WM_OBJECT_##Object##_cb    (WM_MESSAGE * pMsg);                                \
N  WM_HWIN WM_OBJECT_##Object##_Create(APPW_DISPOSE * pDispose, WM_HWIN hParent, int Id)
X#define DEFAULT_CRCB(Object)                                                               void    WM_OBJECT_##Object##_cb    (WM_MESSAGE * pMsg);                                  WM_HWIN WM_OBJECT_##Object##_Create(APPW_DISPOSE * pDispose, WM_HWIN hParent, int Id)
N
N#define DEFAULT_FUNC(Object)                                                             \
N  DEFAULT_CRCB(Object);                                                                  \
N  int     WM_OBJECT_##Object##_Setup (WM_HWIN hWin, APPW_SETUP_ITEM * pSetup)
X#define DEFAULT_FUNC(Object)                                                               DEFAULT_CRCB(Object);                                                                    int     WM_OBJECT_##Object##_Setup (WM_HWIN hWin, APPW_SETUP_ITEM * pSetup)
N
N/*####################################################################
N#
N#       Types
N#
N######################################################################
N*/
N/*********************************************************************
N*
N*       APPW_DISPOSE_COORD
N*/
Ntypedef struct {
N  int Mode;
N  int Off;
N  int Id;
N  int Valid;
N} APPW_DISPOSE_COORD;
N
N/*********************************************************************
N*
N*       APPW_DISPOSE
N*/
Ntypedef struct {
N  APPW_DISPOSE_COORD aDisposeCoord[4];
N  int                xSize;
N  int                ySize;
N  int                xSizeMin;
N  int                ySizeMin;
N  U8                 State;
X  unsigned char                 State;
N  U32                Flags;
X  unsigned long                Flags;
N} APPW_DISPOSE;
N
N/*********************************************************************
N*
N*       APPW_TEXT_INIT
N*/
Ntypedef struct {
N  const char ** appData;
N  int           NumItems;
N} APPW_TEXT_INIT;
N
N/*********************************************************************
N*
N*       APPW_ANIM_PARA
N*/
Ntypedef struct  {
N  I32                Start;
X  signed long                Start;
N  I32                End;
X  signed long                End;
N  WM_CRITICAL_HANDLE chItem;
N  WM_CRITICAL_HANDLE chWinSrc;
N  U16                IdSrc;
X  unsigned short                IdSrc;
N  U16                IdDst;
X  unsigned short                IdDst;
N  int                RootIndex;
N} APPW_ANIM_PARA;
N
N/*********************************************************************
N*
N*       APPW_ANIM_COORD_PARA (obsolete)
N*/
Ntypedef struct {
N  APPW_ANIM_PARA AnimPara;
N  int            Index;
N} APPW_ANIM_COORD_PARA;
N
N/*********************************************************************
N*
N*       APPW_ANIM_SHIFT_PARA
N*/
Ntypedef struct {
N  int                EdgeIndex;
N  I32                x0, x1;
X  signed long                x0, x1;
N  I32                y0, y1;
X  signed long                y0, y1;
N  WM_CRITICAL_HANDLE chWinOld;
N  WM_CRITICAL_HANDLE chWinNew;
N  APPW_DISPOSE       DisposeOld;
N  APPW_DISPOSE       DisposeNew;
N  GUI_ANIM_HANDLE    hAnim;
N  U8                 Disclose;
X  unsigned char                 Disclose;
N} APPW_ANIM_SHIFT_PARA;
N
N/*********************************************************************
N*
N*       APPW_ATOM
N*/
Ntypedef struct {
N  U32 Value;   // LW: ObjectGeo | ObjectValue | ObjectProp ? ObjectId : Variable ? VariableId : Value (LW)
X  unsigned long Value;   
N               // HW: ObjectGeo | ObjectValue | ScreenGeo | ObjectProp  ? ScreenId : Value (HW)
N  I16 Offset;  // ObjectGeo | ScreenGeo | ObjectProp ? Offset : unused
X  signed short Offset;  
N  U8  Item;    // Item specification
X  unsigned char  Item;    
N  U8  Detail;  // Detail to be used
X  unsigned char  Detail;  
N} APPW_ATOM;
N
N/*********************************************************************
N*
N*       APPW_ATOM_INFO
N*/
Ntypedef struct {
N  U16     IdScreen;  // Id of screen
X  unsigned short     IdScreen;  
N  U16     IdObject;  // Id of object
X  unsigned short     IdObject;  
N  U16     IdVar;     // Id of variable
X  unsigned short     IdVar;     
N  WM_HWIN hScreen;   // Screen handle
X  GUI_HWIN hScreen;   
N  WM_HWIN hObject;   // Object handle
X  GUI_HWIN hObject;   
N} APPW_ATOM_INFO;
N
N/*********************************************************************
N*
N*       APPW_ANIM_ITEM
N*/
Ntypedef struct {
N  GUI_ANIM_GETPOS_FUNC Ease;      // Ease function
N  GUI_TIMER_TIME       aTime[2];  // Timeline coordinates for start and end
X  int       aTime[2];  
N  APPW_ATOM            aAtom[3];  // Item definitions for start, end and destination
N} APPW_ANIM_ITEM;
N
N/*********************************************************************
N*
N*       APPW_ANIM_ITEM_INFO
N*/
Ntypedef struct {
N  I32 Start;               // Used to save the start value of the item
X  signed long Start;               
N  I32 End;                 // Used to save the end value of the item
X  signed long End;                 
N  APPW_ANIM_ITEM * pItem;  // Pointer to item
N} APPW_ANIM_ITEM_INFO;
N
N/*********************************************************************
N*
N*       APPW_ANIM_DATA
N*/
Ntypedef struct {
N  U16                    Id;         // Anmation Id to be used
X  unsigned short                    Id;         
N  GUI_TIMER_TIME         Period;     // Period of complete animation
X  int         Period;     
N  U8                     AutoStart;  // If != 0 the animation immediately starts after creation
X  unsigned char                     AutoStart;  
N  int                    NumLoops;   // Number of loops, <0 means endless loop
N  int                    NumItems;   // Number of animation items
N  const APPW_ANIM_ITEM * pItem;      // Pointer to first item
N} APPW_ANIM_DATA;
N
N/*********************************************************************
N*
N*       APPW_CREATE_ITEM
N*/
Ntypedef struct {
N  WM_HWIN   (* pfCreate)(APPW_DISPOSE * pDispose, WM_HWIN hParent, int Id);
X  GUI_HWIN   (* pfCreate)(APPW_DISPOSE * pDispose, GUI_HWIN hParent, int Id);
N  int          Id;
N  int          IdParent;
N  APPW_DISPOSE Dispose;
N  U16          aIdDraw[2];
X  unsigned short          aIdDraw[2];
N} APPW_CREATE_ITEM;
N
N/*********************************************************************
N*
N*       APPW_COMP_ITEM
N*
N* Purpose:
N*   Comparison item which could be a constant, a variable id or an object id
N*/
Ntypedef struct {
N  U8  What;
X  unsigned char  What;
N  I32 Value;
X  signed long Value;
N} APPW_COMP_ITEM;
N
N/*********************************************************************
N*
N*       APPW_CALC_ITEM
N*
N* Purpose:
N*   Calculation item which could be a constant, a variable id or an object id
N*/
Ntypedef struct {
N  U8  What;
X  unsigned char  What;
N  U16 Index;
X  unsigned short Index;
N  I32 Value;
X  signed long Value;
N} APPW_CALC_ITEM;
N
N/*********************************************************************
N*
N*       APPW_COND_COMP
N*
N* Purpose:
N*   Comparison with 2 items to be compared by the given function pointer
N*/
Ntypedef struct {
N  APPW_ATOM aAtom[2];
N  int    (* pFunc)(I32 v0, I32 v1);
X  int    (* pFunc)(signed long v0, signed long v1);
N} APPW_COND_COMP;
N
N/*********************************************************************
N*
N*       APPW_COND
N*
N* Purpose:
N*   Condition with pointer to comparison table and a pointer to a
N*   term to be evaluated.
N*/
Ntypedef struct {
N  const char           * pTerm;  // Pointer to term to be calculated
N  const APPW_COND_COMP * pComp;  // Pointer to first comparison
N  unsigned               nComp;  // Number of comparisons
N} APPW_COND;
N
N/*********************************************************************
N*
N*       APPW_CALC
N*
N* Purpose:
N*   Pointer to a term to be calculated, a pointer to operands to be
N*   used and a pointer to an I32 array for the operands values.
N*/
Ntypedef struct {
N  const char           * pTerm;  // Pointer to term to be calculated
N  unsigned               nItem;  // Number of operands
N  const APPW_ATOM      * pAtom;  // Pointer to first operand (TBD...)
N  I32                  * pVal;   // Array for calculating operand values
X  signed long                  * pVal;   
N} APPW_CALC;
N
N/*********************************************************************
N*
N*       APPW_PARA_ITEM
N*/
Ntypedef struct {
N  U32          v;
X  unsigned long          v;
N  const void * p;
N  void      (* pFunc)(void);
N} APPW_PARA_ITEM;
N
N/*********************************************************************
N*
N*       APPW_SETUP_ITEM
N*/
Ntypedef struct {
N  int            Id;
N  unsigned       Command;
N  APPW_PARA_ITEM aPara[6];
N  APPW_SETUP_ITEM_EXT
X  
N} APPW_SETUP_ITEM;
N
N/*********************************************************************
N*
N*       APPW_ACTION_ITEM
N*
N* Purpose:
N*   Represents an interaction (including parameters) associated to a root object.
N*   Each root object contains a list of interactions defining the behavior of the screen.
N*/
Ntypedef struct APPW_ACTION_ITEM APPW_ACTION_ITEM;
N
Nstruct APPW_ACTION_ITEM {
N  int               IdSrc;                               // Emitter
N  int               NCode;                               // Signal
N  int               IdDst;                               // Receiver
N  int               IdJob;                               // Job
N  void           (* pfSlot)(APPW_ACTION_ITEM * pAction,  // Pointer to action
N                            WM_HWIN            hScreen,  // Handle of screen
X                            GUI_HWIN            hScreen,  
N                            WM_MESSAGE       * pMsg,     // pMsg->hWnd: receiver, pMsg->hWndSrc: emitter
N                            int * pResult);              // Pointer to result
N  APPW_PARA_ITEM    aPara[6];                            // Optional job specific parameters
N  U32               Flags;                               // Bitmask: 0 means -> aPara[x].v = value
X  unsigned long               Flags;                               
N                                                         //          1 means -> aPara[x].v = Variable-Id
N  const APPW_COND * pCond;                               // Condition to be fulfilled
N  APPW_ACTION_ITEM_EXT
X  
N};
N
N/*********************************************************************
N*
N*       APPW_JOB
N*
N* Purpose:
N*   Defines the function to be called for a specific job
N*/
Ntypedef struct {
N  int          IdJob;                               // Id of job
N  APPW_JOB_EXT
X  
N  int       (* pFunc)(WM_HWIN          hWinDst,     // Handle of receiver
X  int       (* pFunc)(GUI_HWIN          hWinDst,     
N                      WM_HWIN          hWinSrc,     // Handle of emitter
X                      GUI_HWIN          hWinSrc,     
N                      APPW_PARA_ITEM * pPara,       // Parameters to be used
N                      int              RootIndex);
N  int          HasReceiver;
N} APPW_JOB;
N
N/*********************************************************************
N*
N*       APPW_OBJ_SETUP_T
N*
N* Purpose:
N*   Common type definition of setup function
N*/
Ntypedef int APPW_OBJ_SETUP_T(const APPW_SETUP_ITEM * pSetup, WM_HWIN hParent);
Xtypedef int APPW_OBJ_SETUP_T(const APPW_SETUP_ITEM * pSetup, GUI_HWIN hParent);
N
N/*********************************************************************
N*
N*       APPW_ROOT_INFO
N*
N* Purpose:
N*   Structure to be passed to APPW_CreateRoot()
N*/
Ntypedef struct {
N  U16                      RootId;
X  unsigned short                      RootId;
N  APPW_CREATE_ITEM       * pCreateInfo;
N  unsigned                 NumCreateInfo;
N  const APPW_SETUP_ITEM  * pSetupInfo;
N  unsigned                 NumSetupInfo;
N  const APPW_ACTION_ITEM * pActionInfo;
N  unsigned                 NumActionInfo;
N  WM_CALLBACK            * cb;
N  WM_HWIN                  hWin;
X  GUI_HWIN                  hWin;
N} APPW_ROOT_INFO;
N
N/*********************************************************************
N*
N*       APPW_CONTENT
N*
N* Purpose:
N*   Structure for holding the text content, header labels and column size
N*   information for text related objects like dropdown, listview and listbox.
N*/
Ntypedef struct {
N  const char *** pppText;     // Array of pointers:
N                              //   <p>pp: - Pointer to an array containing pointers to arrays
N                              //            with pointers to zero terminated strings
N                              //            containing the text of one column.
N                              //   p<p>p: - Pointer to an array containing pointers to zero
N                              //            terminated strings for the content of one column.
N                              //   pp<p>: - Pointer to zero terminated string.
N  int            NumRows;     // Number of rows
N  int            NumColumns;  // Number of columns
N  const char  ** ppHead;      // Array of pointers to the zero terminated header text strings.
N  const U16    * pSize;       // Pointer to an U16 array containing the column sizes.
X  const unsigned short    * pSize;       
N  const U8     * pHeadAlign;  // Pointer to an U8 array containing the header alignment.
X  const unsigned char     * pHeadAlign;  
N  const U8     * pTextAlign;  // Pointer to an U8 array containing the column alignment.
X  const unsigned char     * pTextAlign;  
N} APPW_CONTENT;
N
N/*********************************************************************
N*
N*       APPW_VAR_OBJECT
N*
N* Purpose:
N*   Configurable variables to be used
N*/
Ntypedef struct {
N  U16               Id;       // Used to address the variables
X  unsigned short               Id;       
N  U8                IsDirty;  // Is set to 1 if content is 'dirty' and needs to be processed
X  unsigned char                IsDirty;  
N  U32               Data;     // Could be anything except a pointer
X  unsigned long               Data;     
N  const APPW_CALC * pCalc;    // Pointer to calculation object containing term and operands
N} APPW_VAR_OBJECT;
N
N/*********************************************************************
N*
N*       APPW_FILE_INFO
N*
N* Purpose:
N*   Structure for holding file name and file handle.
N*/
Ntypedef struct {
N  const char * pFileName;
N  void       * pVoid;
N} APPW_FILE_INFO;
N
N/*********************************************************************
N*
N*       APPW_DFILE_INFO
N*
N* Purpose:
N*   Structure for holding file name and 2 file handles.
N*   Using an additional file handle avoids jerking when playing
N*   large movies. It is used for accessing the offset table.
N*/
Ntypedef struct {
N  const char * pFileName;
N  void       * apVoid[2];
N} APPW_DFILE_INFO;
N
N/*********************************************************************
N*
N*       APPW_DRAW_OBJECT
N*
N* Purpose:
N*   Structure for drawing bitmaps (streamed or C)
N*/
Ntypedef struct {
N  void      (* pfDraw)(const void * p, int x, int y);  // Drawing function
N  const void * pData;                                  // Data pointer (bitmap) or file name (streamed bitmap)
N  int          xSize;                                  // (obvious)
N  int          ySize;                                  // (obvious)
N  U32          FileSize;                               // (obvious)
X  unsigned long          FileSize;                               
N} APPW_DRAW_OBJECT;
N
N/*********************************************************************
N*
N*       APPW_FILEACCESS
N*
N* Purpose:
N*   File access
N*/
Ntypedef struct {
N  GUI_GET_DATA_FUNC_I      * pfGetDataBGJ;                                                   // Function for getting data of (B)MP, (G)IF and (J)PEG files
N  GUI_GET_DATA_FUNC_II     * pfGetDataImage;                                                 // Function for getting data of streamed bitmaps and text resource files
N  GUI_XBF_GET_DATA_FUNC    * pfGetDataFont;                                                  // Function for getting data of XBF fonts
N  U32                     (* pfGetDataFile)  (void * p, U8 * pData, U32 NumBytes, U32 Off);  // Function for getting data of generic files
X  unsigned long                     (* pfGetDataFile)  (void * p, unsigned char * pData, unsigned long NumBytes, unsigned long Off);  
N  void                  * (* pfOpenFontFile) (const char * pFilename);                       // Opens a file in resource (sub)folder 'Font'
N  void                  * (* pfOpenImageFile)(const char * pFilename);                       // Opens a file in resource (sub)folder 'Image'
N  void                  * (* pfOpenMovieFile)(const char * pFilename);                       // Opens a file in resource (sub)folder 'Movie'
N  void                  * (* pfOpenTextFile) (const char * pFilename);                       // Opens a file in resource (sub)folder 'Text'
N  void                    (* pfCloseFile)    (void *);                                       // (obvious)
N  U32                     (* pfGetFileSize)  (void *);                                       // (obvious)
X  unsigned long                     (* pfGetFileSize)  (void *);                                       
N} APPW_FILEACCESS;
N
N/*********************************************************************
N*
N*       APPW_X_FILEACCESS
N*
N* Purpose:
N*   Bare file access
N*/
Ntypedef struct {
N  void * (* pfOpen   )(const char * pFilename);
N  int    (* pfSeek   )(const void * p, U32 Off);
X  int    (* pfSeek   )(const void * p, unsigned long Off);
N  U32    (* pfRead   )(const void * p, void * pData, U32 NumBytes);
X  unsigned long    (* pfRead   )(const void * p, void * pData, unsigned long NumBytes);
N  void   (* pfClose  )(const void * p);
N  U32    (* pfGetSize)(const void * p);
X  unsigned long    (* pfGetSize)(const void * p);
N} APPW_X_FILEACCESS;
N
N/*********************************************************************
N*
N*       APPW_MEMACCESS
N*
N* Purpose:
N*   Accessing object data located in memory
N*/
Ntypedef struct {
N  GUI_GET_DATA_FUNC        * pfGetDataImage;
N  GUI_XBF_GET_DATA_FUNC    * pfGetDataFont;
N  U32                     (* pfGetDataFile)(void * p, U8 * pData, U32 NumBytes, U32 Off);
X  unsigned long                     (* pfGetDataFile)(void * p, unsigned char * pData, unsigned long NumBytes, unsigned long Off);
N} APPW_MEMACCESS;
N
N/*********************************************************************
N*
N*       APPW_OBJECT_INFO
N*
N* Purpose:
N*   Object info to be transferred by spy
N*/
Ntypedef struct {
N  WM_WINDOW_INFO Info;
N  U16            Id;
X  unsigned short            Id;
N  I16            RootIndex;
X  signed short            RootIndex;
N} APPW_OBJECT_INFO;
N
N/*********************************************************************
N*
N*       APPW_DRAW_FOCUS
N*
N* Purpose:
N*   Defines how a focus should look like
N*/
Ntypedef struct {
N  GUI_COLOR Color;   // Color of focus rect
N  U8        Radius;  // Radius if required
X  unsigned char        Radius;  
N  U8        Width;   // Width  if required (minimum 1)
X  unsigned char        Width;   
N} APPW_DRAW_FOCUS_INFO;
N
N/*********************************************************************
N*
N*       APPW_DRAWING_INFO
N*
N* Purpose:
N*   Info structure containing id, function pointer and number of items of one function
N*/
Ntypedef struct {
N  void  (* pFunc)(const I32 * pData);
X  void  (* pFunc)(const signed long * pData);
N  unsigned NumAtoms;
N} APPW_DRAWING_INFO;
N
N/*********************************************************************
N*
N*       APPW_DRAWING_ITEM
N*
N* Purpose:
N*   One single drawing item with atom pointer containing parameters for functions
N*/
Ntypedef struct APPW_DRAWING_ITEM APPW_DRAWING_ITEM;
N
Nstruct APPW_DRAWING_ITEM {
N  U16                       IndexFunc;
X  unsigned short                       IndexFunc;
N  const APPW_DRAWING_ITEM * pNextItem;
N  APPW_ATOM                 aAtom[1];  // Further atoms will be attached at the end of the structure
N};
N
N/*********************************************************************
N*
N*       APPW_FONT
N*
N* Purpose:
N*   Font structure and XBF data required to create fonts
N*/
Ntypedef struct {
N  GUI_FONT     Font;
N  GUI_XBF_DATA FontData;
N} APPW_FONT;
N
N/*********************************************************************
N*
N*       APPW_WHEEL_ADDTEXT
N*
N* Purpose:
N*   Structure to be able to pass data APPW_SET_PROP_WHEELTEXT
N*/
Ntypedef struct {
N  APPW_PARA_ITEM  ParaText;  // Parameters to be used to reference the text content
N  APPW_PARA_ITEM  aPara[2];  // Parameters to be used to create the actual font in OWheel
N  WHEEL_ITEM_ATTR aAttr[2];  // Alignment parameters and text color
N} APPW_WHEEL_ADDTEXT;
N
N/*********************************************************************
N*
N*       APPW_WHEEL_ADDBITMAPS
N*
N* Purpose:
N*   Structure to be able to pass data on APPW_SET_PROP_WHEELBITMAPS
N*/
Ntypedef struct {
N  unsigned         aNumItems[2];  // Cell- and center number of draw objects
N  APPW_PARA_ITEM * apPara   [2];  // Parameters to be used to create the draw objects in OWheel
N  WHEEL_ITEM_ATTR  aAttr    [2];  // Cell- and center alignment parameters and (alpha)image color
N} APPW_WHEEL_ADDBITMAPS;
N
N/*********************************************************************
N*
N*       WHEEL_DRAW_OBJECT
N*
N* Purpose:
N*   Replacement for GUI_DRAW objects
N*/
Ntypedef struct {
N  GUI_DRAW         GUI_Draw;  // Important: Must be the first item
N  APPW_DRAW_OBJECT APP_Draw;  // Additional data required for AppWizard
N} WHEEL_DRAW_OBJECT;
N
N/*********************************************************************
N*
N*       APPW_SCROLLER_DEF
N*
N* Purpose:
N*   Definition structure to be used to create scrollers on demand
N*/
Ntypedef struct {
N  GUI_COLOR aColor [2];   // Color definitions:  SCROLLER_CI_ACTIVE, SCROLLER_CI_INACTIVE
N  U16       aPeriod[3];   // Period definitions: SCROLLER_PI_FADE_IN, SCROLLER_PI_FADE_OUT, SCROLLER_PI_INACTIVE
X  unsigned short       aPeriod[3];   
N  I16       aMisc  [5];   // Common propperties: Size, Spacing, Radius, AlignOffset, ThumbSizeMin
X  signed short       aMisc  [5];   
N  U8        Interactive;  // Scroller is interactive
X  unsigned char        Interactive;  
N} APPW_SCROLLER_DEF;
N
N/*####################################################################
N#
N#       Object definitions
N#
N######################################################################
N*/
N/*********************************************************************
N*
N*       WM_OBJECT_BOX
N*/
Ntypedef struct {
N  WIDGET              Widget;      // GUI/WM-Widget
N  APPW_DISPOSE        Dispose;     // Dispose structure
N  U16                 aIdDraw[2];  // Pre- and Post-draw
X  unsigned short                 aIdDraw[2];  
N  unsigned            Mode;
N  GUI_COLOR           Color0;
N  int                 NumColors;
N  int                 Radius;
N  GUI_GRADIENT_INFO * pGradVal;
N  GUI_HMEM            hGradPix;
X  signed long            hGradPix;
N} WM_OBJECT_BOX;
N
N/*********************************************************************
N*
N*       WM_OBJECT_BUTTON
N*/
Ntypedef struct {
N  BUTTON_Obj          Widget;      // GUI/WM-Widget
N  APPW_DISPOSE        Dispose;     // Dispose structure
N  U16                 aIdDraw[2];  // Pre- and Post-draw
X  unsigned short                 aIdDraw[2];  
N  U32                 State;
X  unsigned long                 State;
N  unsigned            Mode;
N  unsigned            Delay;
N  unsigned            Period;
N  unsigned            Toggle;
N  unsigned            AlignBm;
N  int                 xOffBm;
N  int                 yOffBm;
N  APPW_DRAW_OBJECT    apDraw[3];
N  GUI_COLOR           aColor[3];
N  int                 TextId;
N  WM_HTIMER           hTimer;
X  signed long           hTimer;
N  U16                 FrameRadius;
X  unsigned short                 FrameRadius;
N  U16                 FrameSize;
X  unsigned short                 FrameSize;
N} WM_OBJECT_BUTTON;
N
N/*********************************************************************
N*
N*       WM_OBJECT_IMAGE
N*/
Ntypedef struct {
N  IMAGE_OBJ           Widget;      // GUI/WM-Widget
N  APPW_DISPOSE        Dispose;     // Dispose structure
N  U16                 aIdDraw[2];  // Pre- and Post-draw
X  unsigned short                 aIdDraw[2];  
N  unsigned            Mode;
N  GUI_COLOR           Color;
N  const void        * pData;
N  void              * pFile;
N} WM_OBJECT_IMAGE;
N
N/*********************************************************************
N*
N*       WM_OBJECT_ROTARY
N*/
Ntypedef struct {
N  ROTARY_OBJ          Widget;      // GUI/WM-Widget
N  APPW_DISPOSE        Dispose;     // Dispose structure
N  U16                 aIdDraw[2];  // Pre- and Post-draw
X  unsigned short                 aIdDraw[2];  
N  APPW_DRAW_OBJECT    apDraw[3];   // 0 = Bk, 1 = Marker, 2 = MarkerHR
N  WM_HMEM             hMarkerPara;
X  signed long             hMarkerPara;
N} WM_OBJECT_ROTARY;
N
N/*********************************************************************
N*
N*       WM_OBJECT_SLIDER
N*/
Ntypedef struct {
N  SLIDER_Obj          Widget;      // GUI/WM-Widget
N  APPW_DISPOSE        Dispose;     // Dispose structure
N  U16                 aIdDraw[2];  // Pre- and Post-draw
X  unsigned short                 aIdDraw[2];  
N  unsigned            Mode;
N  APPW_DRAW_OBJECT    apDraw[4];
N  GUI_COLOR           aColor[2];
N  GUI_COLOR         * apStretchLine[2];  // Pointer for bitmap pixels to be stretched
N  U8                  HasValue;
X  unsigned char                  HasValue;
N} WM_OBJECT_SLIDER;
N
N/*********************************************************************
N*
N*       WM_OBJECT_SWITCH
N*/
Ntypedef struct {
N  SWITCH_Obj          Widget;      // GUI/WM-Widget
N  APPW_DISPOSE        Dispose;     // Dispose structure
N  U16                 aIdDraw[2];  // Pre- and Post-draw
X  unsigned short                 aIdDraw[2];  
N  U32                 State;
X  unsigned long                 State;
N  APPW_DRAW_OBJECT    apDraw[6];
N  int                 aTextId[2];
N} WM_OBJECT_SWITCH;
N
N/*********************************************************************
N*
N*       WM_OBJECT_TEXT
N*/
Ntypedef struct {
N  TEXT_OBJ            Widget;      // GUI/WM-Widget
N  APPW_DISPOSE        Dispose;     // Dispose structure
N  U16                 aIdDraw[2];  // Pre- and Post-draw
X  unsigned short                 aIdDraw[2];  
N  U32                 State;
X  unsigned long                 State;
N  unsigned            Mode;
N  unsigned            AlignText;
N  int                 xOffText;
N  int                 yOffText;
N  int                 TextId;
N  //
N  // Elements required for decimal mode
N  //
N  I32                 Value;
X  signed long                 Value;
N  I32                 Min;
X  signed long                 Min;
N  I32                 Max;
X  signed long                 Max;
N  //
N  // Parameters for decimal mode
N  //
N  U8                  Len;
X  unsigned char                  Len;
N  U8                  Shift;
X  unsigned char                  Shift;
N  U8                  Signed;
X  unsigned char                  Signed;
N  U8                  Space;
X  unsigned char                  Space;
N} WM_OBJECT_TEXT;
N
N/*********************************************************************
N*
N*       WM_OBJECT_EDIT
N*/
Ntypedef struct {
N  EDIT_Obj            Widget;      // GUI/WM-Widget
N  APPW_DISPOSE        Dispose;     // Dispose structure
N  U16                 aIdDraw[2];  // Pre- and Post-draw
X  unsigned short                 aIdDraw[2];  
N  U32                 State;
X  unsigned long                 State;
N  unsigned            Mode;
N  U16                 FrameRadius;
X  unsigned short                 FrameRadius;
N  U16                 FrameSize;
X  unsigned short                 FrameSize;
N  GUI_COLOR           FrameColor;
N  int                 IndexText;
N  //
N  // Elements required for decimal mode
N  //
N  I32                 Value;
X  signed long                 Value;
N  I32                 Min;
X  signed long                 Min;
N  I32                 Max;
X  signed long                 Max;
N  //
N  // Parameters for decimal mode
N  //
N  U8                  Len;
X  unsigned char                  Len;
N  U8                  Shift;
X  unsigned char                  Shift;
N  U8                  Signed;
X  unsigned char                  Signed;
N  U8                  Space;
X  unsigned char                  Space;
N} WM_OBJECT_EDIT;
N
N/*********************************************************************
N*
N*       WM_OBJECT_QRCODE
N*/
Ntypedef struct {
N  QRCODE_OBJ          Widget;      // GUI/WM-Widget
N  APPW_DISPOSE        Dispose;     // Dispose structure
N  U16                 aIdDraw[2];  // Pre- and Post-draw
X  unsigned short                 aIdDraw[2];  
N  int                 Size;
N  //
N  // Elements required for setup
N  //
N  int                 TextId;
N} WM_OBJECT_QRCODE;
N
N/*********************************************************************
N*
N*       WM_OBJECT_GAUGE
N*/
Ntypedef struct {
N  GAUGE_OBJ           Widget;      // GUI/WM-Widget
N  APPW_DISPOSE        Dispose;     // Dispose structure
N  U16                 aIdDraw[2];  // Pre- and Post-draw
X  unsigned short                 aIdDraw[2];  
N  int                 Value;
N} WM_OBJECT_GAUGE;
N
N/*********************************************************************
N*
N*       WM_OBJECT_KEYBOARD
N*/
Ntypedef struct {
N  KEYBOARD_OBJ        Widget;      // GUI/WM-Widget
N  APPW_DISPOSE        Dispose;     // Dispose structure
N  U16                 aIdDraw[2];  // Pre- and Post-draw
X  unsigned short                 aIdDraw[2];  
N  APPW_FONT         * apFont[2];
N  //
N  // Layout
N  //
N  const void        * pLayout;
N  U32                 FileSize;
X  unsigned long                 FileSize;
N} WM_OBJECT_KEYBOARD;
N
N/*********************************************************************
N*
N*       WM_OBJECT_PROGBAR
N*/
Ntypedef struct {
N  WIDGET              Widget;      // GUI/WM-Widget
N  APPW_DISPOSE        Dispose;     // Dispose structure
N  U16                 aIdDraw[2];  // Pre- and Post-draw
X  unsigned short                 aIdDraw[2];  
N  GUI_COLOR           aColor[2];
N  APPW_DRAW_OBJECT    apDraw[2];
N  U32                 Value;
X  unsigned long                 Value;
N  U32                 Min;
X  unsigned long                 Min;
N  U32                 Max;
X  unsigned long                 Max;
N  U32                 Radius;
X  unsigned long                 Radius;
N  U32                 Flags;
X  unsigned long                 Flags;
N  U8                  FrameSize;
X  unsigned char                  FrameSize;
N  GUI_COLOR           FrameColor;
N  U32                 AlignBm;
X  unsigned long                 AlignBm;
N  I32                 xOffBm;
X  signed long                 xOffBm;
N  I32                 yOffBm;
X  signed long                 yOffBm;
N  U32                 Period;
X  unsigned long                 Period;
N  WM_HTIMER           hTimer;
X  signed long           hTimer;
N  I32                 Offset;
X  signed long                 Offset;
N  U32                 TimeStart;
X  unsigned long                 TimeStart;
N  U8                  Tiling;
X  unsigned char                  Tiling;
N} WM_OBJECT_PROGBAR;
N
N/*********************************************************************
N*
N*       WM_OBJECT_TIMER
N*/
Ntypedef struct {
N  WIDGET              Widget;      // GUI/WM-Widget
N  APPW_DISPOSE        Dispose;
N  WM_HTIMER           hTimer;
X  signed long           hTimer;
N  U32                 Period;
X  unsigned long                 Period;
N  unsigned            Mode;
N} WM_OBJECT_TIMER;
N
N/*********************************************************************
N*
N*       WM_OBJECT_MULTIEDIT
N*/
Ntypedef struct {
N  MULTIEDIT_OBJ       Widget;      // GUI/WM-Widget
N  APPW_DISPOSE        Dispose;     // Dispose structure
N  U16                 aIdDraw[2];  // Pre- and Post-draw
X  unsigned short                 aIdDraw[2];  
N  U32                 State;
X  unsigned long                 State;
N  unsigned            Mode;
N  int                 IndexText;
N  U16                 FrameRadius;
X  unsigned short                 FrameRadius;
N  U16                 FrameSize;
X  unsigned short                 FrameSize;
N  GUI_COLOR           FrameColor;
N} WM_OBJECT_MULTIEDIT;
N
N/*********************************************************************
N*
N*       WM_OBJECT_DROPDOWN
N*/
Ntypedef struct {
N  DROPDOWN_Obj        Widget;      // GUI/WM-Widget
N  APPW_DISPOSE        Dispose;     // Dispose structure
N  U16                 aIdDraw[2];  // Pre- and Post-draw
X  unsigned short                 aIdDraw[2];  
N  APPW_DRAW_OBJECT    apDraw[2];
N  U8                  FrameRadius;
X  unsigned char                  FrameRadius;
N  U8                  FrameSize;
X  unsigned char                  FrameSize;
N  GUI_COLOR           FrameColor;
N  const APPW_CONTENT* pContent;
N} WM_OBJECT_DROPDOWN;
N
N/*********************************************************************
N*
N*       WM_OBJECT_LISTVIEW
N*/
Ntypedef struct {
N  LISTVIEW_Obj        Widget;      // GUI/WM-Widget
N  APPW_DISPOSE        Dispose;     // Dispose structure
N  U16                 aIdDraw[2];  // Pre- and Post-draw
X  unsigned short                 aIdDraw[2];  
N  APPW_DRAW_OBJECT    apDraw[2];
N  APPW_FONT         * apFont[2];
N  GUI_COLOR           FrameColorHeader;
N  GUI_COLOR           FrameColorList;
N  GUI_COLOR           ColorFocus;
N  U8                  FrameRadius;
X  unsigned char                  FrameRadius;
N  U8                  FrameSize;
X  unsigned char                  FrameSize;
N  U8                  FocusSize;
X  unsigned char                  FocusSize;
N  U8                  Flags;
X  unsigned char                  Flags;
N  const APPW_CONTENT* pContent;
N} WM_OBJECT_LISTVIEW;
N
N/*********************************************************************
N*
N*       WM_OBJECT_LISTBOX
N*/
Ntypedef struct {
N  LISTBOX_Obj         Widget;      // GUI/WM-Widget
N  APPW_DISPOSE        Dispose;     // Dispose structure
N  U16                 aIdDraw[2];  // Pre- and Post-draw
X  unsigned short                 aIdDraw[2];  
N  GUI_COLOR           FrameColor;
N  U8                  FrameSize;
X  unsigned char                  FrameSize;
N  const APPW_CONTENT* pContent;
N} WM_OBJECT_LISTBOX;
N
N/*********************************************************************
N*
N*       WM_OBJECT_WHEEL
N*/
Ntypedef struct {
N  WHEEL_OBJ           Widget;      // GUI/WM-Widget
N  APPW_DISPOSE        Dispose;     // Dispose structure
N  U16                 aIdDraw[2];  // Pre- and Post-draw
X  unsigned short                 aIdDraw[2];  
N  APPW_DRAW_OBJECT    apDraw[3];   // Draw objects for overlay images
N} WM_OBJECT_WHEEL;
N
N/*********************************************************************
N*
N*       WM_OBJECT_MOVIE
N*/
Ntypedef struct {
N  MOVIE_OBJ           Widget;      // GUI/WM-Widget
N  APPW_DISPOSE        Dispose;     // Dispose structure
N  U16                 aIdDraw[2];  // Pre- and Post-draw
X  unsigned short                 aIdDraw[2];  
N  APPW_DRAW_OBJECT    apDraw[4];   // Draw objects for button images
N  APPW_DFILE_INFO     FileInfo;    // File info structure with handles and pointer to file name
N} WM_OBJECT_MOVIE;
N
N/*********************************************************************
N*
N*       WM_OBJECT_RADIO
N*/
Ntypedef struct {
N  RADIO_Obj           Widget;      // GUI/WM-Widget
N  APPW_DISPOSE        Dispose;     // Dispose structure
N  U16                 aIdDraw[2];  // Pre- and Post-draw
X  unsigned short                 aIdDraw[2];  
N  GUI_COLOR           aColor[2];   // Optional colors for alpha bitmaps (0: normal, 1: disabled)
N  APPW_DRAW_OBJECT    apDraw[4];
N  U16                 Offset;
X  unsigned short                 Offset;
N  const APPW_CONTENT* pContent;
N} WM_OBJECT_RADIO;
N
N/*********************************************************************
N*
N*       WM_OBJECT_CHECKBOX
N*/
Ntypedef struct {
N  CHECKBOX_Obj        Widget;      // GUI/WM-Widget
N  APPW_DISPOSE        Dispose;     // Dispose structure
N  U16                 aIdDraw[2];  // Pre- and Post-draw
X  unsigned short                 aIdDraw[2];  
N  U32                 State;
X  unsigned long                 State;
N  GUI_COLOR           aColor[2];   // Optional colors for alpha bitmaps (0: normal, 1: disabled)
N  APPW_DRAW_OBJECT    apDraw[6];
N  int                 TextId;
N  U16                 Offset;
X  unsigned short                 Offset;
N} WM_OBJECT_CHECKBOX;
N
N/*********************************************************************
N*
N*       WM_OBJECT_WINDOW
N*/
Ntypedef struct {
N  WINDOW_OBJ          Widget;      // GUI/WM-Widget
N  APPW_DISPOSE        Dispose;     // Dispose structure
N  U16                 aIdDraw[2];  // Pre- and Post-draw
X  unsigned short                 aIdDraw[2];  
N  U32                 State;
X  unsigned long                 State;
N  APPW_ROOT_INFO    * pRoot;
N  APPW_SETUP_ITEM   * pSetupMotionH;
N  APPW_SETUP_ITEM   * pSetupMotionV;
N  GUI_COLOR           Color;
N} WM_OBJECT_WINDOW;
N
N/*********************************************************************
N*
N*       Public Data
N*
N**********************************************************************
N*/
Nextern       APPW_ROOT_INFO    ** APPW_ppRootList;     // Pointer to array of root information pointers
Nextern       APPW_VAR_OBJECT    * APPW_paVarList;      // Pointer to variables
Nextern       APPW_DRAWING_ITEM ** APPW_ppDrawingList;  // Pointer to array of drawing pointers
Nextern const APPW_SCROLLER_DEF  * APPW_paScrollerDef;  // Pointer to scroller definitions
N
Nextern       unsigned             APPW_NumScreens;     // Number of screens
Nextern       unsigned             APPW_NumVars;        // Number of variabless
Nextern       unsigned             APPW_NumDrawings;    // Number of drawings
Nextern       unsigned             APPW_NumScrollers;   // Number of scroller definitions
N
Nextern       U8                   APPW_Run;
Xextern       unsigned char                   APPW_Run;
Nextern       void              (* APPW__pfInvalidateWindow)(WM_HWIN hWin);
Xextern       void              (* APPW__pfInvalidateWindow)(GUI_HWIN hWin);
N
Nextern const APPW_DRAWING_INFO    APPW__aDrawingFunc[];
Nextern const int                  APPW__NumDrawingFuncs;
N
N/*####################################################################
N#
N#       Interface
N#
N######################################################################
N*/
N//
N// Interface for callback-, create- & setup-function
N//
NDEFAULT_FUNC(BOX);
Xvoid WM_OBJECT_BOX_cb (WM_MESSAGE * pMsg); GUI_HWIN WM_OBJECT_BOX_Create(APPW_DISPOSE * pDispose, GUI_HWIN hParent, int Id); int WM_OBJECT_BOX_Setup (GUI_HWIN hWin, APPW_SETUP_ITEM * pSetup);
NDEFAULT_FUNC(BUTTON);
Xvoid WM_OBJECT_BUTTON_cb (WM_MESSAGE * pMsg); GUI_HWIN WM_OBJECT_BUTTON_Create(APPW_DISPOSE * pDispose, GUI_HWIN hParent, int Id); int WM_OBJECT_BUTTON_Setup (GUI_HWIN hWin, APPW_SETUP_ITEM * pSetup);
NDEFAULT_FUNC(EDIT);
Xvoid WM_OBJECT_EDIT_cb (WM_MESSAGE * pMsg); GUI_HWIN WM_OBJECT_EDIT_Create(APPW_DISPOSE * pDispose, GUI_HWIN hParent, int Id); int WM_OBJECT_EDIT_Setup (GUI_HWIN hWin, APPW_SETUP_ITEM * pSetup);
NDEFAULT_FUNC(GAUGE);
Xvoid WM_OBJECT_GAUGE_cb (WM_MESSAGE * pMsg); GUI_HWIN WM_OBJECT_GAUGE_Create(APPW_DISPOSE * pDispose, GUI_HWIN hParent, int Id); int WM_OBJECT_GAUGE_Setup (GUI_HWIN hWin, APPW_SETUP_ITEM * pSetup);
NDEFAULT_FUNC(IMAGE);
Xvoid WM_OBJECT_IMAGE_cb (WM_MESSAGE * pMsg); GUI_HWIN WM_OBJECT_IMAGE_Create(APPW_DISPOSE * pDispose, GUI_HWIN hParent, int Id); int WM_OBJECT_IMAGE_Setup (GUI_HWIN hWin, APPW_SETUP_ITEM * pSetup);
NDEFAULT_FUNC(KEYBOARD);
Xvoid WM_OBJECT_KEYBOARD_cb (WM_MESSAGE * pMsg); GUI_HWIN WM_OBJECT_KEYBOARD_Create(APPW_DISPOSE * pDispose, GUI_HWIN hParent, int Id); int WM_OBJECT_KEYBOARD_Setup (GUI_HWIN hWin, APPW_SETUP_ITEM * pSetup);
NDEFAULT_FUNC(PROGBAR);
Xvoid WM_OBJECT_PROGBAR_cb (WM_MESSAGE * pMsg); GUI_HWIN WM_OBJECT_PROGBAR_Create(APPW_DISPOSE * pDispose, GUI_HWIN hParent, int Id); int WM_OBJECT_PROGBAR_Setup (GUI_HWIN hWin, APPW_SETUP_ITEM * pSetup);
NDEFAULT_FUNC(QRCODE);
Xvoid WM_OBJECT_QRCODE_cb (WM_MESSAGE * pMsg); GUI_HWIN WM_OBJECT_QRCODE_Create(APPW_DISPOSE * pDispose, GUI_HWIN hParent, int Id); int WM_OBJECT_QRCODE_Setup (GUI_HWIN hWin, APPW_SETUP_ITEM * pSetup);
NDEFAULT_FUNC(ROTARY);
Xvoid WM_OBJECT_ROTARY_cb (WM_MESSAGE * pMsg); GUI_HWIN WM_OBJECT_ROTARY_Create(APPW_DISPOSE * pDispose, GUI_HWIN hParent, int Id); int WM_OBJECT_ROTARY_Setup (GUI_HWIN hWin, APPW_SETUP_ITEM * pSetup);
NDEFAULT_FUNC(SLIDER);
Xvoid WM_OBJECT_SLIDER_cb (WM_MESSAGE * pMsg); GUI_HWIN WM_OBJECT_SLIDER_Create(APPW_DISPOSE * pDispose, GUI_HWIN hParent, int Id); int WM_OBJECT_SLIDER_Setup (GUI_HWIN hWin, APPW_SETUP_ITEM * pSetup);
NDEFAULT_FUNC(SWITCH);
Xvoid WM_OBJECT_SWITCH_cb (WM_MESSAGE * pMsg); GUI_HWIN WM_OBJECT_SWITCH_Create(APPW_DISPOSE * pDispose, GUI_HWIN hParent, int Id); int WM_OBJECT_SWITCH_Setup (GUI_HWIN hWin, APPW_SETUP_ITEM * pSetup);
NDEFAULT_FUNC(TEXT);
Xvoid WM_OBJECT_TEXT_cb (WM_MESSAGE * pMsg); GUI_HWIN WM_OBJECT_TEXT_Create(APPW_DISPOSE * pDispose, GUI_HWIN hParent, int Id); int WM_OBJECT_TEXT_Setup (GUI_HWIN hWin, APPW_SETUP_ITEM * pSetup);
NDEFAULT_FUNC(MULTIEDIT);
Xvoid WM_OBJECT_MULTIEDIT_cb (WM_MESSAGE * pMsg); GUI_HWIN WM_OBJECT_MULTIEDIT_Create(APPW_DISPOSE * pDispose, GUI_HWIN hParent, int Id); int WM_OBJECT_MULTIEDIT_Setup (GUI_HWIN hWin, APPW_SETUP_ITEM * pSetup);
NDEFAULT_FUNC(DROPDOWN);
Xvoid WM_OBJECT_DROPDOWN_cb (WM_MESSAGE * pMsg); GUI_HWIN WM_OBJECT_DROPDOWN_Create(APPW_DISPOSE * pDispose, GUI_HWIN hParent, int Id); int WM_OBJECT_DROPDOWN_Setup (GUI_HWIN hWin, APPW_SETUP_ITEM * pSetup);
NDEFAULT_FUNC(LISTVIEW);
Xvoid WM_OBJECT_LISTVIEW_cb (WM_MESSAGE * pMsg); GUI_HWIN WM_OBJECT_LISTVIEW_Create(APPW_DISPOSE * pDispose, GUI_HWIN hParent, int Id); int WM_OBJECT_LISTVIEW_Setup (GUI_HWIN hWin, APPW_SETUP_ITEM * pSetup);
NDEFAULT_FUNC(LISTBOX);
Xvoid WM_OBJECT_LISTBOX_cb (WM_MESSAGE * pMsg); GUI_HWIN WM_OBJECT_LISTBOX_Create(APPW_DISPOSE * pDispose, GUI_HWIN hParent, int Id); int WM_OBJECT_LISTBOX_Setup (GUI_HWIN hWin, APPW_SETUP_ITEM * pSetup);
NDEFAULT_FUNC(WHEEL);
Xvoid WM_OBJECT_WHEEL_cb (WM_MESSAGE * pMsg); GUI_HWIN WM_OBJECT_WHEEL_Create(APPW_DISPOSE * pDispose, GUI_HWIN hParent, int Id); int WM_OBJECT_WHEEL_Setup (GUI_HWIN hWin, APPW_SETUP_ITEM * pSetup);
NDEFAULT_FUNC(MOVIE);
Xvoid WM_OBJECT_MOVIE_cb (WM_MESSAGE * pMsg); GUI_HWIN WM_OBJECT_MOVIE_Create(APPW_DISPOSE * pDispose, GUI_HWIN hParent, int Id); int WM_OBJECT_MOVIE_Setup (GUI_HWIN hWin, APPW_SETUP_ITEM * pSetup);
NDEFAULT_FUNC(RADIO);
Xvoid WM_OBJECT_RADIO_cb (WM_MESSAGE * pMsg); GUI_HWIN WM_OBJECT_RADIO_Create(APPW_DISPOSE * pDispose, GUI_HWIN hParent, int Id); int WM_OBJECT_RADIO_Setup (GUI_HWIN hWin, APPW_SETUP_ITEM * pSetup);
NDEFAULT_FUNC(CHECKBOX);
Xvoid WM_OBJECT_CHECKBOX_cb (WM_MESSAGE * pMsg); GUI_HWIN WM_OBJECT_CHECKBOX_Create(APPW_DISPOSE * pDispose, GUI_HWIN hParent, int Id); int WM_OBJECT_CHECKBOX_Setup (GUI_HWIN hWin, APPW_SETUP_ITEM * pSetup);
NDEFAULT_CRCB(WINDOW);
Xvoid WM_OBJECT_WINDOW_cb (WM_MESSAGE * pMsg); GUI_HWIN WM_OBJECT_WINDOW_Create(APPW_DISPOSE * pDispose, GUI_HWIN hParent, int Id);
N
N//
N// OWindow
N//
Nint WM_OBJECT_WINDOW_SetPara(WM_HWIN hWin, APPW_ROOT_INFO * pRoot);
Xint WM_OBJECT_WINDOW_SetPara(GUI_HWIN hWin, APPW_ROOT_INFO * pRoot);
N
N//
N// OTimer
N//
NWM_HWIN WM_OBJECT_TIMER_Create(APPW_DISPOSE * pDispose, WM_HWIN hParent, int Id);
XGUI_HWIN WM_OBJECT_TIMER_Create(APPW_DISPOSE * pDispose, GUI_HWIN hParent, int Id);
N
N//
N// AppWizard.c (private functions, not to be documented)
N//
Nint                       APPW__DisposeObject          (WM_HWIN hWin, int Index);
Xint                       APPW__DisposeObject          (GUI_HWIN hWin, int Index);
Nvoid                      APPW__EnableMove             (unsigned OnOff);
Nvoid                      APPW__EnableUntouchable      (int OnOff);
NAPPW_DISPOSE            * APPW__GetDispose             (WM_HWIN hWin);
XAPPW_DISPOSE            * APPW__GetDispose             (GUI_HWIN hWin);
NGUI_HMEM                  APPW__GetTextItem            (int Mode, U32 Para, U16 Row, U16 Col);
Xsigned long                  APPW__GetTextItem            (int Mode, unsigned long Para, unsigned short Row, unsigned short Col);
Nvoid                      APPW__RegisterPID_Hook       (void);
Nvoid                      APPW__SetStreamedBitmap      (APPW_DRAW_OBJECT * pDraw, APPW_PARA_ITEM * pPara, GUI_BITMAPSTREAM_INFO * pInfo);
Nvoid                      APPW__SetStreamedBitmap_HR   (APPW_DRAW_OBJECT * pDraw, APPW_PARA_ITEM * pPara, GUI_BITMAPSTREAM_INFO * pInfo);
Nvoid                      APPW__SetUnTouchable         (WM_HWIN hWin);
Xvoid                      APPW__SetUnTouchable         (GUI_HWIN hWin);
Nvoid                      APPW_CreateScroller          (WM_HWIN hWin, U8 Index, int ExFlags);
Xvoid                      APPW_CreateScroller          (GUI_HWIN hWin, unsigned char Index, int ExFlags);
Nvoid                      APPW_CreatePersistentScreens (void);
NWM_HWIN                   APPW_CreateRoot              (APPW_ROOT_INFO * pRoot, WM_HWIN hParent);
XGUI_HWIN                   APPW_CreateRoot              (APPW_ROOT_INFO * pRoot, GUI_HWIN hParent);
Nint                       APPW_Dispose                 (WM_HWIN hWin, unsigned Invalidate);
Xint                       APPW_Dispose                 (GUI_HWIN hWin, unsigned Invalidate);
Nvoid                      APPW_DragCoord               (APPW_DISPOSE * pDisposeOld, APPW_DISPOSE * pDisposeNew, unsigned Index, int Delta, U8 AllowSetSize);
Xvoid                      APPW_DragCoord               (APPW_DISPOSE * pDisposeOld, APPW_DISPOSE * pDisposeNew, unsigned Index, int Delta, unsigned char AllowSetSize);
Nvoid                      APPW_DrawFocusRect           (WM_HWIN hWin);
Xvoid                      APPW_DrawFocusRect           (GUI_HWIN hWin);
Nvoid                      APPW_DrawObject              (APPW_DRAW_OBJECT * pDraw, GUI_RECT * pRect, int AlignBm, int xOffBm, int yOffBm);
Nvoid                      APPW_DrawObjectAt            (APPW_DRAW_OBJECT * pDraw, int xPos, int yPos);
Nvoid                      APPW_DrawStreamedBitmapINT   (const APPW_DRAW_OBJECT * pDraw, int x, int y);
Nvoid                      APPW_DrawStreamedBitmapINT_HR(const APPW_DRAW_OBJECT * pDraw, int x, int y);
Nvoid                      APPW_GetAtomInfo             (const APPW_ATOM * pAtom, APPW_ATOM_INFO * pInfo);
NI32                       APPW_GetAtomValue            (const APPW_ATOM * pAtom);
Xsigned long                       APPW_GetAtomValue            (const APPW_ATOM * pAtom);
NAPPW_ROOT_INFO          * APPW_GetCurrentRootInfo      (WM_HWIN hWin);
XAPPW_ROOT_INFO          * APPW_GetCurrentRootInfo      (GUI_HWIN hWin);
Nint                       APPW_GetFocusWidth           (void);
Nconst GUI_FONT          * APPW_GetFontFromPara         (APPW_PARA_ITEM * pPara);
NGUI_HMEM                  APPW_GetLockedText           (char ** ppBuffer, APPW_PARA_ITEM * pPara);
Xsigned long                  APPW_GetLockedText           (char ** ppBuffer, APPW_PARA_ITEM * pPara);
Nint                       APPW_GetOpponent             (int Index);
Nconst char              * APPW_GetResourcePath         (void);
NGUI_HMEM                  APPW_GetResourceStringLocked (const char * pText, const char ** ppData);
Xsigned long                  APPW_GetResourceStringLocked (const char * pText, const char ** ppData);
NWM_HWIN                   APPW_GetRoot                 (WM_HWIN hWin);
XGUI_HWIN                   APPW_GetRoot                 (GUI_HWIN hWin);
NAPPW_ROOT_INFO          * APPW_GetRootInfo             (WM_HWIN hRoot, int * pRootIndex);
XAPPW_ROOT_INFO          * APPW_GetRootInfo             (GUI_HWIN hRoot, int * pRootIndex);
NAPPW_ROOT_INFO          * APPW_GetRootInfoByHandle     (WM_HWIN hWin);
XAPPW_ROOT_INFO          * APPW_GetRootInfoByHandle     (GUI_HWIN hWin);
NAPPW_ROOT_INFO          * APPW_GetRootInfoByIndex      (int RootIndex);
NAPPW_ROOT_INFO          * APPW_GetRootInfoByRootId     (U16 RootId);
XAPPW_ROOT_INFO          * APPW_GetRootInfoByRootId     (unsigned short RootId);
Nvoid                   (* APPW_GetScreenshotFunc(void))(void);
NU8                        APPW_GetSupportFocus         (void);
Xunsigned char                        APPW_GetSupportFocus         (void);
NU8                        APPW_GetSupportScroller      (void);
Xunsigned char                        APPW_GetSupportScroller      (void);
Nvoid                      APPW_Init                    (const char * pResourcePath);
Nvoid                      APPW_InitResourcePath        (const char * pResourcePath);
Nint                       APPW_IsValid                 (WM_HWIN hWin);
Xint                       APPW_IsValid                 (GUI_HWIN hWin);
Nint                       APPW_IsRoot                  (WM_HWIN hWin);
Xint                       APPW_IsRoot                  (GUI_HWIN hWin);
Nvoid                      APPW_MoveDispose             (APPW_DISPOSE * pDisposeOld, APPW_DISPOSE * pDisposeNew, int dx, int dy);
Nvoid                      APPW_MULTIBUF_Enable         (int OnOff);
Nvoid                      APPW_RequestContent          (WM_HWIN hWin, void (* pFunc)(WM_HWIN, const APPW_CONTENT *));
Xvoid                      APPW_RequestContent          (GUI_HWIN hWin, void (* pFunc)(GUI_HWIN, const APPW_CONTENT *));
NAPPW_ROOT_INFO         ** APPW_SetData                 (APPW_ROOT_INFO         ** ppRootInfo,    int NumScreens,
N                                                        APPW_VAR_OBJECT         * paVarList,     int NumVars,
N                                                        const APPW_SCROLLER_DEF * paScrollerDef, int NumScrollers,
N                                                        APPW_DRAWING_ITEM      ** ppDrawingList, int NumDrawings);
Nvoid                      APPW_SetDefaultPosition      (WM_HWIN hRoot, U16 Id);
Xvoid                      APPW_SetDefaultPosition      (GUI_HWIN hRoot, unsigned short Id);
Nvoid                      APPW_SetDefaultPositionRoot  (WM_HWIN hRoot);
Xvoid                      APPW_SetDefaultPositionRoot  (GUI_HWIN hRoot);
Nvoid                      APPW_SetFocusInfo            (APPW_DRAW_FOCUS_INFO * pInfo);
Nvoid                      APPW_SetpfInitFS             (void (* pFunc)(void));
Nvoid                      APPW_SetpfInitText           (void (* pFunc)(void));
Nvoid                      APPW_SetScreenshotFunc       (void (* pFunc)(void));
Nvoid                      APPW_SetSupportFocus         (U8 SupportFocus);
Xvoid                      APPW_SetSupportFocus         (unsigned char SupportFocus);
Nvoid                      APPW_SetSupportScroller      (U8 SupportScroller);
Xvoid                      APPW_SetSupportScroller      (unsigned char SupportScroller);
Nvoid                      APPW_SetWidgetFocusable      (WM_HWIN hWin, APPW_PARA_ITEM * pPara);
Xvoid                      APPW_SetWidgetFocusable      (GUI_HWIN hWin, APPW_PARA_ITEM * pPara);
Nvoid                      APPW_TextInitMem             (const APPW_TEXT_INIT * pPara);
Nvoid                      APPW_TextInitExt             (const APPW_TEXT_INIT * pPara);
N
N//
N// AppWizard.c (public functions, to be documented)
N//
Nvoid                      APPW_CalcVar                 (U16 IdVar);
Xvoid                      APPW_CalcVar                 (unsigned short IdVar);
Nint                       APPW_DoJob                   (U16 IdScreen, U16 IdWidget, int IdJob, APPW_PARA_ITEM * pPara);
Xint                       APPW_DoJob                   (unsigned short IdScreen, unsigned short IdWidget, int IdJob, APPW_PARA_ITEM * pPara);
Nvoid                      APPW_Exec                    (void);
Nint                       APPW_GetFont                 (U16 IdScreen, U16 IdWidget, GUI_FONT * pFont, GUI_XBF_DATA * pData);
Xint                       APPW_GetFont                 (unsigned short IdScreen, unsigned short IdWidget, GUI_FONT * pFont, GUI_XBF_DATA * pData);
Nint                       APPW_GetText                 (U16 IdScreen, U16 IdWidget, char * pBuffer, U32 SizeOfBuffer);
Xint                       APPW_GetText                 (unsigned short IdScreen, unsigned short IdWidget, char * pBuffer, unsigned long SizeOfBuffer);
Nint                       APPW_GetValue                (U16 IdScreen, U16 IdWidget, int * pError);
Xint                       APPW_GetValue                (unsigned short IdScreen, unsigned short IdWidget, int * pError);
Nvoid                      APPW_SetCustCallback         (void (* pFunc)(void));
Nvoid                      APPW_SetPos                  (WM_HWIN hItem, int xPos, int yPos);
Xvoid                      APPW_SetPos                  (GUI_HWIN hItem, int xPos, int yPos);
Nvoid                      APPW_SetStreamedBitmap       (U16 IdScreen, U16 IdWidget, int Index, const void * pData);
Xvoid                      APPW_SetStreamedBitmap       (unsigned short IdScreen, unsigned short IdWidget, int Index, const void * pData);
Nvoid                      APPW_SetStreamedBitmapEx     (U16 IdScreen, U16 IdWidget, int Index, const char * pFileName);
Xvoid                      APPW_SetStreamedBitmapEx     (unsigned short IdScreen, unsigned short IdWidget, int Index, const char * pFileName);
Nint                       APPW_SetText                 (U16 IdScreen, U16 IdWidget, char * pText);
Xint                       APPW_SetText                 (unsigned short IdScreen, unsigned short IdWidget, char * pText);
Nint                       APPW_SetValue                (U16 IdScreen, U16 IdWidget, int Value);
Xint                       APPW_SetValue                (unsigned short IdScreen, unsigned short IdWidget, int Value);
N//
N// AppWizard_Action.c
N//
Nint                       APPW_ACTION_SetEnable        (WM_HWIN hWinDst, WM_HWIN hWinSrc, APPW_PARA_ITEM * pPara, int RootIndex);
Xint                       APPW_ACTION_SetEnable        (GUI_HWIN hWinDst, GUI_HWIN hWinSrc, APPW_PARA_ITEM * pPara, int RootIndex);
Nvoid                      APPW_ClearShiftScreenActive  (void);
Nconst APPW_JOB          * APPW_GetJob                  (int Id);
Nconst APPW_JOB          * APPW_GetJobs                 (int * pNumJobs);
Nconst APPW_JOB          * APPW_GetJobsVar              (int * pNumJobs);
NU8                        APPW_GetTimerActive          (void);
Xunsigned char                        APPW_GetTimerActive          (void);
Nint                       APPW_ProcessActions          (WM_MESSAGE * pMsg, int RootIndex);
Nint                       APPW_ProcessMotion           (WM_MESSAGE * pMsg, APPW_SETUP_ITEM * pSetupMotion);
Nvoid                      APPW_SendNotification        (WM_HWIN hWin, int Notification);
Xvoid                      APPW_SendNotification        (GUI_HWIN hWin, int Notification);
Nvoid                      APPW_SetTimerActive          (U8 TimerActive);
Xvoid                      APPW_SetTimerActive          (unsigned char TimerActive);
N
N//
N// AppWizard_Condition.c
N//
Nint                       APPW__CompareIsLess          (I32 v0, I32 v1);
Xint                       APPW__CompareIsLess          (signed long v0, signed long v1);
Nint                       APPW__CompareIsLessOrEqual   (I32 v0, I32 v1);
Xint                       APPW__CompareIsLessOrEqual   (signed long v0, signed long v1);
Nint                       APPW__CompareIsEqual         (I32 v0, I32 v1);
Xint                       APPW__CompareIsEqual         (signed long v0, signed long v1);
Nint                       APPW__CompareIsGreaterOrEqual(I32 v0, I32 v1);
Xint                       APPW__CompareIsGreaterOrEqual(signed long v0, signed long v1);
Nint                       APPW__CompareIsGreater       (I32 v0, I32 v1);
Xint                       APPW__CompareIsGreater       (signed long v0, signed long v1);
Nint                       APPW__CompareIsNotEqual      (I32 v0, I32 v1);
Xint                       APPW__CompareIsNotEqual      (signed long v0, signed long v1);
Nint                       APPW_CalcCond                (const APPW_COND * pCond, U32 * pResult, WM_HWIN hRoot);
Xint                       APPW_CalcCond                (const APPW_COND * pCond, unsigned long * pResult, GUI_HWIN hRoot);
N
N//
N// AppWizard_Drawing.c
N//
Nvoid                      APPW_DrawingPrepare          (U16 * pIdDraw, WM_HWIN hWin);
Xvoid                      APPW_DrawingPrepare          (unsigned short * pIdDraw, GUI_HWIN hWin);
Nvoid                      APPW_DrawingDraw             (int DrawingIndex);
Nvoid                      APPW_DrawingCleanup          (void);
NWM_HWIN                   APPW_GetActiveWindow         (void);
XGUI_HWIN                   APPW_GetActiveWindow         (void);
N
N//
N// AppWizard_FileAccess.c
N//
Nvoid                      APPW_DrawStreamedBitmapEXT   (const APPW_DRAW_OBJECT * pDraw, int x, int y);
Nvoid                      APPW_DrawStreamedBitmapEXT_HR(const APPW_DRAW_OBJECT * pDraw, int x, int y);
Nconst APPW_FILEACCESS   * APPW_GetFileAccess           (void);
Nconst APPW_X_FILEACCESS * APPW_GetFileAccessLowLevel   (void);
Nconst GUI_XBF_TYPE      * APPW_GetFileType             (U8 Type);
Xconst tGUI_XBF_APIList      * APPW_GetFileType             (unsigned char Type);
Nconst APPW_MEMACCESS    * APPW_GetMemAccess            (void);
Nvoid                      APPW_GetStreamedBitmapInfoEXT(const APPW_DRAW_OBJECT * pDraw, GUI_BITMAPSTREAM_INFO * pInfo);
Nint                       APPW_MakeFont                (const APPW_SETUP_ITEM * pSetup);
Nint                       APPW_MakeFontEx              (const APPW_PARA_ITEM * pPara);
Nvoid                      APPW_SetFileAccess           (APPW_X_FILEACCESS * pFileAccess);
N
N//
N// AppWizard_Spy.c
N//
Nint                       APPW_SPY_Process             (U8 Cmd, void * pVoid);
Xint                       APPW_SPY_Process             (unsigned char Cmd, void * pVoid);
N
N//
N// AppWizard_Var.c
N//
NWM_HWIN                   APPW_GethWinVar              (void);
XGUI_HWIN                   APPW_GethWinVar              (void);
NAPPW_VAR_OBJECT         * APPW_GetVar                  (U16 Id);
XAPPW_VAR_OBJECT         * APPW_GetVar                  (unsigned short Id);
Nint                       APPW_SetVarData              (U16 Id, I32 Data);
Xint                       APPW_SetVarData              (unsigned short Id, signed long Data);
NI32                       APPW_GetVarData              (U16 Id, int * pError);
Xsigned long                       APPW_GetVarData              (unsigned short Id, int * pError);
NWM_HWIN                   APPW_GetVarWin               (void);
XGUI_HWIN                   APPW_GetVarWin               (void);
Nint                       APPW_CalcTerm                (const APPW_CALC * pCalc);
N
N//
N// APPWConf.c,   generated by export function(s)
N//
Nvoid                      APPW__GetResource            (APPW_ROOT_INFO         *** pppRootInfo,    int * pNumScreens,
N                                                        APPW_VAR_OBJECT         ** ppaVarList,     int * pNumVars,
N                                                        const APPW_SCROLLER_DEF ** ppaScrollerDef, int * pNumScrollers,
N                                                        APPW_DRAWING_ITEM      *** pppDrawingList, int * pNumDrawings,
N                                                                                                   int * pCreateFlags);
N//
N// Resource.c,   generated by export function(s)
N//
Nvoid                      APPW__GetTextInit            (GUI_CONST_STORAGE APPW_TEXT_INIT ** ppTextInit);
Xvoid                      APPW__GetTextInit            (const APPW_TEXT_INIT ** ppTextInit);
N
N//
N// APPW_X_xxx.c, generated by export function(s)
N//
Nvoid                      APPW_X_Config                (void);
Nvoid                      APPW_X_InitText              (void);
Nvoid                      APPW_X_FS_Init               (void);
Nvoid                      APPW_X_Setup                 (void);
N
N#if defined(__cplusplus)
X#if 0L
S  }
N#endif
N
N#endif  // GUI_WINSUPPORT
N
N#endif  // APPWIZARD_H
N
N/*************************** End of file ****************************/
L 18 "..\Application\Source\Generated\APPWConf.c" 2
N#include "Resource.h"
L 1 "..\Application\Source\Generated\Resource.h" 1
N/*********************************************************************
N*                     SEGGER Microcontroller GmbH                    *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2025  SEGGER Microcontroller GmbH                *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N----------------------------------------------------------------------
NFile        : Resource.h
NPurpose     : Generated file do NOT edit!
N---------------------------END-OF-HEADER------------------------------
N*/
N
N#ifndef RESOURCE_H
N#define RESOURCE_H
N
N#include "AppWizard.h"
N
N/*********************************************************************
N*
N*       Text
N*/
N#define ID_TEXT_0 0
N#define ID_TEXT_1 1
N#define ID_TEXT_2 2
N#define ID_TEXT_3 3
N#define ID_TEXT_4 4
N
Nextern GUI_CONST_STORAGE unsigned char acAPPW_Language_0[];
Xextern const unsigned char acAPPW_Language_0[];
N
N/*********************************************************************
N*
N*       Font data
N*/
Nextern APPW_FONT APPW__aFont[5];
N
N/*********************************************************************
N*
N*       Fonts
N*/
Nextern GUI_CONST_STORAGE unsigned char acRoboto_150_Normal_EXT_AA4[];
Xextern const unsigned char acRoboto_150_Normal_EXT_AA4[];
Nextern GUI_CONST_STORAGE unsigned char acRoboto_40_Normal_EXT_AA4[];
Xextern const unsigned char acRoboto_40_Normal_EXT_AA4[];
Nextern GUI_CONST_STORAGE unsigned char acNettoOT_32_Normal_EXT_AA4[];
Xextern const unsigned char acNettoOT_32_Normal_EXT_AA4[];
Nextern GUI_CONST_STORAGE unsigned char acNettoOT_16_Normal_EXT_AA4[];
Xextern const unsigned char acNettoOT_16_Normal_EXT_AA4[];
Nextern GUI_CONST_STORAGE unsigned char acRoboto_16_Normal_EXT_AA4[];
Xextern const unsigned char acRoboto_16_Normal_EXT_AA4[];
N
N/*********************************************************************
N*
N*       Images
N*/
Nextern GUI_CONST_STORAGE unsigned char acScale_240x240[];
Xextern const unsigned char acScale_240x240[];
Nextern GUI_CONST_STORAGE unsigned char acLeaf_30x39[];
Xextern const unsigned char acLeaf_30x39[];
Nextern GUI_CONST_STORAGE unsigned char acIndicatorActual_18x2[];
Xextern const unsigned char acIndicatorActual_18x2[];
Nextern GUI_CONST_STORAGE unsigned char acIndicatorTarget_24x3[];
Xextern const unsigned char acIndicatorTarget_24x3[];
N
N/*********************************************************************
N*
N*       Content
N*/
Nextern GUI_CONST_STORAGE APPW_CONTENT ID_CONTENT_000_Data;
Xextern const APPW_CONTENT ID_CONTENT_000_Data;
Nextern GUI_CONST_STORAGE APPW_CONTENT ID_CONTENT_001_Data;
Xextern const APPW_CONTENT ID_CONTENT_001_Data;
Nextern GUI_CONST_STORAGE APPW_CONTENT ID_CONTENT_002_Data;
Xextern const APPW_CONTENT ID_CONTENT_002_Data;
N
N/*********************************************************************
N*
N*       Screens
N*/
N#define ID_SCREEN_00 (GUI_ID_USER + 0)
N
Nextern APPW_ROOT_INFO ID_SCREEN_00_RootInfo;
N
N#define APPW_INITIAL_SCREEN &ID_SCREEN_00_RootInfo
N
N/*********************************************************************
N*
N*       Project path
N*/
N#define APPW_PROJECT_PATH "C:/temp/AppWizard/ClimateControl8"
N
N#endif  // RESOURCE_H
N
N/*************************** End of file ****************************/
L 19 "..\Application\Source\Generated\APPWConf.c" 2
N
N#ifdef WIN32
S  #include "GUIDRV_Win32R.h"
N#endif
N
N/*********************************************************************
N*
N*       Defines
N*
N**********************************************************************
N*/
N#define XSIZE_PHYS       320
N#define YSIZE_PHYS       240
N#define COLOR_CONVERSION GUICC_565
N#define DISPLAY_DRIVER   GUIDRV_WIN32R
N#define NUM_BUFFERS      2
N
N/*********************************************************************
N*
N*       Static data
N*
N**********************************************************************
N*/
N/*********************************************************************
N*
N*       Multibuffering
N*/
Nstatic U8 _MultibufEnable = 1;
Xstatic unsigned char _MultibufEnable = 1;
N
N/*********************************************************************
N*
N*       _ShowMissingCharacters
N*/
Nstatic U8 _ShowMissingCharacters = 1;
Xstatic unsigned char _ShowMissingCharacters = 1;
N
N/*********************************************************************
N*
N*       Static code
N*
N**********************************************************************
N*/
N/*********************************************************************
N*
N*       _InitText
N*/
Nstatic void _InitText(void) {
N  GUI_CONST_STORAGE APPW_TEXT_INIT * pTextInit;
X  const APPW_TEXT_INIT * pTextInit;
N
N  APPW__GetTextInit(&pTextInit);
N  APPW_TextInitMem(pTextInit);
N}
N
N/*********************************************************************
N*
N*       Public code
N*
N**********************************************************************
N*/
N/*********************************************************************
N*
N*       APPW_X_Setup
N*/
Nvoid APPW_X_Setup(void) {
N  APPW_ROOT_INFO         ** ppRootInfo;
N  APPW_VAR_OBJECT         * paVarList;
N  const APPW_SCROLLER_DEF * paScrollerDef;
N  APPW_DRAWING_ITEM      ** ppDrawingList;
N  int                       NumScreens;
N  int                       NumVars;
N  int                       NumScrollers;
N  int                       NumDrawings;
N  int                       CreateFlags;
N
N  APPW_SetpfInitText(_InitText);
N  APPW_X_FS_Init();
N  APPW_MULTIBUF_Enable(_MultibufEnable);
N  APPW__GetResource(&ppRootInfo,
N                    &NumScreens,
N                    &paVarList,
N                    &NumVars,
N                    &paScrollerDef,
N                    &NumScrollers,
N                    &ppDrawingList,
N                    &NumDrawings,
N                    &CreateFlags);
N  WM_SetCreateFlags(CreateFlags);
N  APPW_SetData(ppRootInfo, NumScreens, paVarList, NumVars, paScrollerDef, NumScrollers, ppDrawingList, NumDrawings);
N  APPW_SetSupportScroller(0);
N  GUI_ShowMissingCharacters(_ShowMissingCharacters);
N}
N
N/*********************************************************************
N*
N*       APPW_X_Config
N*/
N#ifdef WIN32
Svoid APPW_X_Config(void) {
S  GUI_MULTIBUF_Config(NUM_BUFFERS);
S  GUI_DEVICE_CreateAndLink(DISPLAY_DRIVER, COLOR_CONVERSION, 0, 0);
S  if (LCD_GetSwapXY()) {
S    LCD_SetSizeEx (0, YSIZE_PHYS, XSIZE_PHYS);
S    LCD_SetVSizeEx(0, YSIZE_PHYS, XSIZE_PHYS);
S  } else {
S    LCD_SetSizeEx (0, XSIZE_PHYS, YSIZE_PHYS);
S    LCD_SetVSizeEx(0, XSIZE_PHYS, YSIZE_PHYS);
S  }
S}
N#endif
N
N/*************************** End of file ****************************/
