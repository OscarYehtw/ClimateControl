; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\obj\clk.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\clk.d --cpu=Cortex-M4.fp --apcs=interwork -O3 --diag_suppress=9931 -I..\..\..\..\Library\Device\Nuvoton\M480\Include -I..\..\..\..\Library\StdDriver\inc -I..\..\..\..\ThirdParty\emWin\Config -I..\..\..\..\ThirdParty\emWin\Include -I..\tslib -I..\..\..\..\Library\CMSIS\Include -I..\Thermostat -I..\Application\Source\Generated -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=523 --omf_browse=.\obj\clk.crf ..\..\..\..\Library\StdDriver\src\clk.c]
                          THUMB

                          AREA ||i.CLK_DisableCKO||, CODE, READONLY, ALIGN=2

                  CLK_DisableCKO PROC
;;;31       */
;;;32     void CLK_DisableCKO(void)
000000  4801              LDR      r0,|L1.8|
;;;33     {
;;;34         /* Disable CKO clock source */
;;;35         CLK_DisableModuleClock(CLKO_MODULE);
000002  f7ffbffe          B.W      CLK_DisableModuleClock
;;;36     }
;;;37     
                          ENDP

000006  0000              DCW      0x0000
                  |L1.8|
                          DCD      0x57c00006

                          AREA ||i.CLK_DisableModuleClock||, CODE, READONLY, ALIGN=2

                  CLK_DisableModuleClock PROC
;;;769      */
;;;770    void CLK_DisableModuleClock(uint32_t u32ModuleIdx)
000000  f000021f          AND      r2,r0,#0x1f
;;;771    {
;;;772        uint32_t u32tmpVal = 0UL, u32tmpAddr = 0UL;
;;;773    
;;;774        u32tmpVal = ~(1UL << MODULE_IP_EN_Pos(u32ModuleIdx));
000004  2101              MOVS     r1,#1
000006  4091              LSLS     r1,r1,r2
;;;775        u32tmpAddr = (uint32_t)&CLK->AHBCLK;
000008  4a03              LDR      r2,|L2.24|
;;;776        u32tmpAddr += ((MODULE_APBCLK(u32ModuleIdx) * 4UL));
00000a  0f80              LSRS     r0,r0,#30
00000c  eb020080          ADD      r0,r2,r0,LSL #2
;;;777    
;;;778        *(uint32_t *)u32tmpAddr &= u32tmpVal;
000010  6802              LDR      r2,[r0,#0]
000012  438a              BICS     r2,r2,r1
000014  6002              STR      r2,[r0,#0]
;;;779    }
000016  4770              BX       lr
;;;780    
                          ENDP

                  |L2.24|
                          DCD      0x40000204

                          AREA ||i.CLK_DisablePLL||, CODE, READONLY, ALIGN=1

                  CLK_DisablePLL PROC
;;;948      */
;;;949    void CLK_DisablePLL(void)
000000  f04f4080          MOV      r0,#0x40000000
;;;950    {
;;;951        CLK->PLLCTL |= CLK_PLLCTL_PD_Msk;
000004  f8d01240          LDR      r1,[r0,#0x240]
000008  f4413180          ORR      r1,r1,#0x10000
00000c  f8c01240          STR      r1,[r0,#0x240]
;;;952    }
000010  4770              BX       lr
;;;953    
                          ENDP


                          AREA ||i.CLK_DisableSysTick||, CODE, READONLY, ALIGN=1

                  CLK_DisableSysTick PROC
;;;1033     */
;;;1034   void CLK_DisableSysTick(void)
000000  f04f21e0          MOV      r1,#0xe000e000
;;;1035   {
;;;1036       /* Set System Tick counter disabled */
;;;1037       SysTick->CTRL = 0UL;
000004  2000              MOVS     r0,#0
000006  6108              STR      r0,[r1,#0x10]
;;;1038   }
000008  4770              BX       lr
;;;1039   
                          ENDP


                          AREA ||i.CLK_DisableXtalRC||, CODE, READONLY, ALIGN=1

                  CLK_DisableXtalRC PROC
;;;609      */
;;;610    void CLK_DisableXtalRC(uint32_t u32ClkMask)
000000  f04f4180          MOV      r1,#0x40000000
;;;611    {
;;;612        CLK->PWRCTL &= ~u32ClkMask;
000004  f8d12200          LDR      r2,[r1,#0x200]
000008  4382              BICS     r2,r2,r0
00000a  f8c12200          STR      r2,[r1,#0x200]
;;;613    }
00000e  4770              BX       lr
;;;614    
                          ENDP


                          AREA ||i.CLK_EnableCKO||, CODE, READONLY, ALIGN=2

                  CLK_EnableCKO PROC
;;;54       */
;;;55     void CLK_EnableCKO(uint32_t u32ClkSrc, uint32_t u32ClkDiv, uint32_t u32ClkDivBy1En)
000000  4603              MOV      r3,r0
;;;56     {
;;;57         /* CKO = clock source / 2^(u32ClkDiv + 1) */
;;;58         CLK->CLKOCTL = CLK_CLKOCTL_CLKOEN_Msk | (u32ClkDiv) | (u32ClkDivBy1En << CLK_CLKOCTL_DIV1EN_Pos);
000002  ea411042          ORR      r0,r1,r2,LSL #5
000006  b510              PUSH     {r4,lr}               ;56
000008  f04f4180          MOV      r1,#0x40000000
00000c  f0400010          ORR      r0,r0,#0x10
000010  f8c10260          STR      r0,[r1,#0x260]
;;;59     
;;;60         /* Enable CKO clock source */
;;;61         CLK_EnableModuleClock(CLKO_MODULE);
000014  4c05              LDR      r4,|L6.44|
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       CLK_EnableModuleClock
;;;62     
;;;63         /* Select CKO clock source */
;;;64         CLK_SetModuleClock(CLKO_MODULE, u32ClkSrc, 0UL);
00001c  4620              MOV      r0,r4
00001e  e8bd4010          POP      {r4,lr}
000022  2200              MOVS     r2,#0
000024  4619              MOV      r1,r3
000026  f7ffbffe          B.W      CLK_SetModuleClock
;;;65     }
;;;66     
                          ENDP

00002a  0000              DCW      0x0000
                  |L6.44|
                          DCD      0x57c00006

                          AREA ||i.CLK_EnableDPDWKPin||, CODE, READONLY, ALIGN=1

                  CLK_EnableDPDWKPin PROC
;;;1110   
;;;1111   void CLK_EnableDPDWKPin(uint32_t u32TriggerType)
000000  b530              PUSH     {r4,r5,lr}
;;;1112   {
;;;1113       uint32_t u32Pin1, u32Pin2, u32Pin3, u32Pin4;
;;;1114   
;;;1115       if ((SYS->CSERVER & SYS_CSERVER_VERSION_Msk) == 0x1) // M480LD
000002  f04f4180          MOV      r1,#0x40000000
000006  f8d121f4          LDR      r2,[r1,#0x1f4]
00000a  b2d2              UXTB     r2,r2
00000c  2a01              CMP      r2,#1
00000e  d122              BNE      |L7.86|
;;;1116       {
;;;1117   
;;;1118           u32Pin1 = ((u32TriggerType) & CLK_PMUCTL_WKPINEN1_Msk);
000010  f0107f40          TST      r0,#0x3000000
;;;1119           u32Pin2 = ((u32TriggerType) & CLK_PMUCTL_WKPINEN2_Msk);
000014  f0006240          AND      r2,r0,#0xc000000
;;;1120           u32Pin3 = ((u32TriggerType) & CLK_PMUCTL_WKPINEN3_Msk);
000018  f0005540          AND      r5,r0,#0x30000000
;;;1121           u32Pin4 = ((u32TriggerType) & CLK_PMUCTL_WKPINEN4_Msk);
00001c  f0004440          AND      r4,r0,#0xc0000000
;;;1122   
;;;1123           if(u32Pin1)
000020  d007              BEQ      |L7.50|
;;;1124           {
;;;1125               CLK->PMUCTL = (CLK->PMUCTL & ~(CLK_PMUCTL_WKPINEN1_Msk)) | u32TriggerType;
000022  f8d12290          LDR      r2,[r1,#0x290]
000026  f0227240          BIC      r2,r2,#0x3000000
                  |L7.42|
;;;1126           }
;;;1127           else if(u32Pin2)
;;;1128           {
;;;1129               CLK->PMUCTL = (CLK->PMUCTL & ~(CLK_PMUCTL_WKPINEN2_Msk)) | u32TriggerType;
;;;1130           }
;;;1131           else if(u32Pin3)
;;;1132           {
;;;1133               CLK->PMUCTL = (CLK->PMUCTL & ~(CLK_PMUCTL_WKPINEN3_Msk)) | u32TriggerType;
;;;1134           }
;;;1135           else if(u32Pin4)
;;;1136           {
;;;1137               CLK->PMUCTL = (CLK->PMUCTL & ~(CLK_PMUCTL_WKPINEN4_Msk)) | u32TriggerType;
;;;1138           }
;;;1139           else
;;;1140           {
;;;1141               CLK->PMUCTL = (CLK->PMUCTL & ~(CLK_PMUCTL_WKPINEN_Msk)) | u32TriggerType;
;;;1142           }
;;;1143       }
;;;1144       else
;;;1145       {
;;;1146           CLK->PMUCTL = (CLK->PMUCTL & ~(CLK_PMUCTL_WKPINEN_Msk)) | u32TriggerType;
00002a  4302              ORRS     r2,r2,r0
00002c  f8c12290          STR      r2,[r1,#0x290]
;;;1147       }
;;;1148   }
000030  bd30              POP      {r4,r5,pc}
                  |L7.50|
000032  b122              CBZ      r2,|L7.62|
000034  f8d12290          LDR      r2,[r1,#0x290]        ;1129
000038  f0226240          BIC      r2,r2,#0xc000000      ;1129
00003c  e7f5              B        |L7.42|
                  |L7.62|
00003e  b125              CBZ      r5,|L7.74|
000040  f8d12290          LDR      r2,[r1,#0x290]        ;1133
000044  f0225240          BIC      r2,r2,#0x30000000     ;1133
000048  e7ef              B        |L7.42|
                  |L7.74|
00004a  b124              CBZ      r4,|L7.86|
00004c  f8d12290          LDR      r2,[r1,#0x290]        ;1137
000050  f0224240          BIC      r2,r2,#0xc0000000     ;1137
000054  e7e9              B        |L7.42|
                  |L7.86|
000056  f8d12290          LDR      r2,[r1,#0x290]        ;1141
00005a  f4223240          BIC      r2,r2,#0x30000        ;1141
00005e  e7e4              B        |L7.42|
;;;1149   
                          ENDP


                          AREA ||i.CLK_EnableModuleClock||, CODE, READONLY, ALIGN=2

                  CLK_EnableModuleClock PROC
;;;686      */
;;;687    void CLK_EnableModuleClock(uint32_t u32ModuleIdx)
000000  f000021f          AND      r2,r0,#0x1f
;;;688    {
;;;689        uint32_t u32tmpVal = 0UL, u32tmpAddr = 0UL;
;;;690    
;;;691        u32tmpVal = (1UL << MODULE_IP_EN_Pos(u32ModuleIdx));
000004  2101              MOVS     r1,#1
000006  4091              LSLS     r1,r1,r2
;;;692        u32tmpAddr = (uint32_t)&CLK->AHBCLK;
000008  4a03              LDR      r2,|L8.24|
;;;693        u32tmpAddr += ((MODULE_APBCLK(u32ModuleIdx) * 4UL));
00000a  0f80              LSRS     r0,r0,#30
00000c  eb020080          ADD      r0,r2,r0,LSL #2
;;;694    
;;;695        *(volatile uint32_t *)u32tmpAddr |= u32tmpVal;
000010  6802              LDR      r2,[r0,#0]
000012  430a              ORRS     r2,r2,r1
000014  6002              STR      r2,[r0,#0]
;;;696    }
000016  4770              BX       lr
;;;697    
                          ENDP

                  |L8.24|
                          DCD      0x40000204

                          AREA ||i.CLK_EnablePLL||, CODE, READONLY, ALIGN=2

                  CLK_EnablePLL PROC
;;;791      */
;;;792    uint32_t CLK_EnablePLL(uint32_t u32PllClkSrc, uint32_t u32PllFreq)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;793    {
000004  460c              MOV      r4,r1
000006  4607              MOV      r7,r0
;;;794        uint32_t u32PllSrcClk, u32NR, u32NF, u32NO, u32CLK_SRC, u32PllClk;
;;;795        uint32_t u32Tmp, u32Tmp2, u32Tmp3, u32Min, u32MinNF, u32MinNR, u32MinNO, u32basFreq;
;;;796    
;;;797        /* Disable PLL first to avoid unstable when setting PLL */
;;;798        CLK_DisablePLL();
000008  f7fffffe          BL       CLK_DisablePLL
;;;799    
;;;800        /* PLL source clock is from HXT */
;;;801        if(u32PllClkSrc == CLK_PLLCTL_PLLSRC_HXT)
;;;802        {
;;;803            /* Enable HXT clock */
;;;804            CLK->PWRCTL |= CLK_PWRCTL_HXTEN_Msk;
;;;805    
;;;806            /* Wait for HXT clock ready */
;;;807            CLK_WaitClockReady(CLK_STATUS_HXTSTB_Msk);
;;;808    
;;;809            /* Select PLL source clock from HXT */
;;;810            u32CLK_SRC = CLK_PLLCTL_PLLSRC_HXT;
;;;811            u32PllSrcClk = __HXT;
;;;812    
;;;813            /* Check HXT range. Set u32NR start value */
;;;814            /* Constraint 1: 4MHz <= FREF <= 8MHz */
;;;815            if((u32PllSrcClk >= 4000000UL) && (u32PllSrcClk <= 8000000UL))
;;;816                u32NR = 1UL;
;;;817            else
;;;818                u32NR = 2UL;
;;;819        }
;;;820    
;;;821        /* PLL source clock is from HIRC */
;;;822        else
;;;823        {
;;;824            /* Enable HIRC clock */
;;;825            CLK->PWRCTL |= CLK_PWRCTL_HIRCEN_Msk;
00000c  f04f4080          MOV      r0,#0x40000000
000010  4d4a              LDR      r5,|L9.316|
000012  f8d01200          LDR      r1,[r0,#0x200]
000016  b1bf              CBZ      r7,|L9.72|
000018  f0410104          ORR      r1,r1,#4
00001c  f8c01200          STR      r1,[r0,#0x200]
;;;826    
;;;827            /* Wait for HIRC clock ready */
;;;828            CLK_WaitClockReady(CLK_STATUS_HIRCSTB_Msk);
000020  2010              MOVS     r0,#0x10
000022  f7fffffe          BL       CLK_WaitClockReady
;;;829    
;;;830            /* Select PLL source clock from HIRC */
;;;831            u32CLK_SRC = CLK_PLLCTL_PLLSRC_HIRC;
000026  f44f2000          MOV      r0,#0x80000
                  |L9.42|
00002a  4686              MOV      lr,r0                 ;810
;;;832            u32PllSrcClk = __HIRC;
;;;833    
;;;834            /* u32NR start from 4 when FIN = 22.1184MHz to avoid calculation overflow */
;;;835            u32NR = 4UL;
;;;836        }
;;;837    
;;;838        if((u32PllFreq <= FREQ_500MHZ) && (u32PllFreq >= FREQ_50MHZ))
00002c  4844              LDR      r0,|L9.320|
00002e  4945              LDR      r1,|L9.324|
000030  4420              ADD      r0,r0,r4
000032  4288              CMP      r0,r1
000034  d871              BHI      |L9.282|
;;;839        {
;;;840    
;;;841            /* Find best solution */
;;;842            u32Min = (uint32_t) - 1;
;;;843            u32MinNR = 0UL;
000036  f04f0b00          MOV      r11,#0
00003a  f04f37ff          MOV      r7,#0xffffffff        ;842
;;;844            u32MinNF = 0UL;
00003e  46da              MOV      r10,r11
;;;845            u32MinNO = 0UL;
000040  46d9              MOV      r9,r11
;;;846            u32basFreq = u32PllFreq;
;;;847    
;;;848            for(u32NO = 1UL; u32NO <= 4UL; u32NO++)
000042  2001              MOVS     r0,#1
000044  9400              STR      r4,[sp,#0]
000046  e015              B        |L9.116|
                  |L9.72|
000048  f0410101          ORR      r1,r1,#1              ;804
00004c  f8c01200          STR      r1,[r0,#0x200]        ;804
000050  2001              MOVS     r0,#1                 ;807
000052  f7fffffe          BL       CLK_WaitClockReady
000056  2000              MOVS     r0,#0                 ;810
000058  e7e7              B        |L9.42|
                  |L9.90|
;;;849            {
;;;850                /* Break when get good results */
;;;851                if (u32Min == 0UL)
00005a  b3ef              CBZ      r7,|L9.216|
;;;852                {
;;;853                    break;
;;;854                }
;;;855    
;;;856                if (u32NO != 3UL)
00005c  2803              CMP      r0,#3
00005e  d059              BEQ      |L9.276|
;;;857                {
;;;858    
;;;859                    if(u32NO == 4UL)
000060  2804              CMP      r0,#4
000062  d002              BEQ      |L9.106|
;;;860                    {
;;;861                        u32PllFreq = u32basFreq << 2;
;;;862                    }
;;;863                    else if(u32NO == 2UL)
000064  2802              CMP      r0,#2
000066  d105              BNE      |L9.116|
000068  e002              B        |L9.112|
                  |L9.106|
00006a  9900              LDR      r1,[sp,#0]            ;861
00006c  008c              LSLS     r4,r1,#2              ;861
00006e  e001              B        |L9.116|
                  |L9.112|
;;;864                    {
;;;865                        u32PllFreq = u32basFreq << 1;
000070  9900              LDR      r1,[sp,#0]
000072  004c              LSLS     r4,r1,#1
                  |L9.116|
;;;866                    }
;;;867                    else
;;;868                    {
;;;869                    }
;;;870    
;;;871                    for(u32NR = 1UL; u32NR <= 32UL; u32NR++)
000074  2201              MOVS     r2,#1
000076  e000              B        |L9.122|
                  |L9.120|
;;;872                    {
;;;873                        /* Break when get good results */
;;;874                        if (u32Min == 0UL)
000078  b35f              CBZ      r7,|L9.210|
                  |L9.122|
;;;875                        {
;;;876                            break;
;;;877                        }
;;;878    
;;;879                        u32Tmp = u32PllSrcClk / u32NR;
00007a  fbb5f1f2          UDIV     r1,r5,r2
;;;880                        if((u32Tmp >= 4000000UL) && (u32Tmp <= 8000000UL))
00007e  4b32              LDR      r3,|L9.328|
000080  18ce              ADDS     r6,r1,r3
000082  425b              RSBS     r3,r3,#0
000084  429e              CMP      r6,r3
000086  d821              BHI      |L9.204|
;;;881                        {
;;;882                            for(u32NF = 2UL; u32NF <= 513UL; u32NF++)
000088  2302              MOVS     r3,#2
;;;883                            {
;;;884                                /* u32Tmp2 is shifted 2 bits to avoid overflow */
;;;885                                u32Tmp2 = (((u32Tmp * 2UL) >> 2) * u32NF);
00008a  f3c1065d          UBFX     r6,r1,#1,#30
00008e  bf00              NOP      
                  |L9.144|
;;;886    
;;;887                                if((u32Tmp2 >= FREQ_50MHZ) && (u32Tmp2 <= FREQ_125MHZ))
000090  f8dfc0ac          LDR      r12,|L9.320|
000094  fb06f103          MUL      r1,r6,r3              ;885
000098  eb01080c          ADD      r8,r1,r12
00009c  f8dfc0ac          LDR      r12,|L9.332|
0000a0  45e0              CMP      r8,r12
0000a2  d80e              BHI      |L9.194|
;;;888                                {
;;;889                                    u32Tmp3 = (u32Tmp2 > (u32PllFreq>>2)) ? u32Tmp2 - (u32PllFreq>>2) : (u32PllFreq>>2) - u32Tmp2;
0000a4  ebb10f94          CMP      r1,r4,LSR #2
0000a8  d902              BLS      |L9.176|
0000aa  eba10194          SUB      r1,r1,r4,LSR #2
0000ae  e001              B        |L9.180|
                  |L9.176|
0000b0  ebc10194          RSB      r1,r1,r4,LSR #2
                  |L9.180|
;;;890                                    if(u32Tmp3 < u32Min)
0000b4  42b9              CMP      r1,r7
0000b6  d204              BCS      |L9.194|
;;;891                                    {
;;;892                                        u32Min = u32Tmp3;
0000b8  000f              MOVS     r7,r1
;;;893                                        u32MinNR = u32NR;
0000ba  4693              MOV      r11,r2
;;;894                                        u32MinNF = u32NF;
0000bc  469a              MOV      r10,r3
;;;895                                        u32MinNO = u32NO;
0000be  4681              MOV      r9,r0
;;;896    
;;;897                                        /* Break when get good results */
;;;898                                        if(u32Min == 0UL)
0000c0  d004              BEQ      |L9.204|
                  |L9.194|
0000c2  f2402101          MOV      r1,#0x201             ;882
0000c6  1c5b              ADDS     r3,r3,#1              ;882
0000c8  428b              CMP      r3,r1                 ;882
0000ca  d9e1              BLS      |L9.144|
                  |L9.204|
0000cc  1c52              ADDS     r2,r2,#1              ;882
0000ce  2a20              CMP      r2,#0x20              ;871
0000d0  d9d2              BLS      |L9.120|
                  |L9.210|
0000d2  1c40              ADDS     r0,r0,#1              ;871
0000d4  2804              CMP      r0,#4                 ;848
0000d6  e000              B        |L9.218|
                  |L9.216|
0000d8  e000              B        |L9.220|
                  |L9.218|
0000da  d9be              BLS      |L9.90|
                  |L9.220|
;;;899                                        {
;;;900                                            break;
;;;901                                        }
;;;902                                    }
;;;903                                }
;;;904                            }
;;;905                        }
;;;906                    }
;;;907                }
;;;908            }
;;;909    
;;;910            /* Enable and apply new PLL setting. */
;;;911            CLK->PLLCTL = u32CLK_SRC | ((u32MinNO - 1UL) << 14) | ((u32MinNR - 1UL) << 9) | (u32MinNF - 2UL);
0000dc  491c              LDR      r1,|L9.336|
0000de  eb013089          ADD      r0,r1,r9,LSL #14
0000e2  114a              ASRS     r2,r1,#5
0000e4  ea40000e          ORR      r0,r0,lr
0000e8  eb02214b          ADD      r1,r2,r11,LSL #9
0000ec  4308              ORRS     r0,r0,r1
0000ee  f1aa0102          SUB      r1,r10,#2
0000f2  4308              ORRS     r0,r0,r1
0000f4  f04f4180          MOV      r1,#0x40000000
0000f8  f8c10240          STR      r0,[r1,#0x240]
;;;912    
;;;913            /* Wait for PLL clock stable */
;;;914            CLK_WaitClockReady(CLK_STATUS_PLLSTB_Msk);
0000fc  2004              MOVS     r0,#4
0000fe  f7fffffe          BL       CLK_WaitClockReady
;;;915    
;;;916            /* Actual PLL output clock frequency */
;;;917            u32PllClk = u32PllSrcClk / (u32MinNO * (u32MinNR)) * (u32MinNF) * 2UL;
000102  fb09f00b          MUL      r0,r9,r11
000106  fbb5f0f0          UDIV     r0,r5,r0
00010a  fb00f00a          MUL      r0,r0,r10
00010e  0040              LSLS     r0,r0,#1
;;;918        }
;;;919        else
;;;920        {
;;;921            /* Wrong frequency request. Just return default setting. */
;;;922            /* Apply default PLL setting and return */
;;;923            if(u32PllClkSrc == CLK_PLLCTL_PLLSRC_HXT)
;;;924            {
;;;925                CLK->PLLCTL = CLK_PLLCTL_192MHz_HXT;
;;;926            }
;;;927            else
;;;928            {
;;;929                CLK->PLLCTL = CLK_PLLCTL_192MHz_HIRC;
;;;930            }
;;;931    
;;;932            /* Wait for PLL clock stable */
;;;933            CLK_WaitClockReady(CLK_STATUS_PLLSTB_Msk);
;;;934    
;;;935            /* Actual PLL output clock frequency */
;;;936            u32PllClk = CLK_GetPLLClockFreq();
;;;937        }
;;;938    
;;;939        return u32PllClk;
;;;940    }
000110  e8bd8ff8          POP      {r3-r11,pc}
                  |L9.276|
000114  2004              MOVS     r0,#4                 ;848
000116  e7a0              B        |L9.90|
000118  e7ff              B        |L9.282|
                  |L9.282|
00011a  b167              CBZ      r7,|L9.310|
00011c  490d              LDR      r1,|L9.340|
00011e  bf00              NOP                            ;929
                  |L9.288|
000120  f04f4080          MOV      r0,#0x40000000        ;929
000124  f8c01240          STR      r1,[r0,#0x240]        ;929
000128  2004              MOVS     r0,#4                 ;933
00012a  f7fffffe          BL       CLK_WaitClockReady
00012e  e8bd4ff8          POP      {r3-r11,lr}           ;936
000132  f7ffbffe          B.W      CLK_GetPLLClockFreq
                  |L9.310|
000136  f244211e          MOV      r1,#0x421e            ;925
00013a  e7f1              B        |L9.288|
;;;941    
                          ENDP

                  |L9.316|
                          DCD      0x00b71b00
                  |L9.320|
                          DCD      0xfd050f80
                  |L9.324|
                          DCD      0x1ad27480
                  |L9.328|
                          DCD      0xffc2f700
                  |L9.332|
                          DCD      0x047868c0
                  |L9.336|
                          DCD      0xffffc000
                  |L9.340|
                          DCD      0x0008421e

                          AREA ||i.CLK_EnableSPDWKPin||, CODE, READONLY, ALIGN=2

                  CLK_EnableSPDWKPin PROC
;;;1179    */
;;;1180   void CLK_EnableSPDWKPin(uint32_t u32Port, uint32_t u32Pin, uint32_t u32TriggerType, uint32_t u32DebounceEn)
000000  b530              PUSH     {r4,r5,lr}
;;;1181   {
;;;1182       uint32_t u32tmpAddr = 0UL;
;;;1183       uint32_t u32tmpVal = 0UL;
;;;1184   
;;;1185       /* GPx Stand-by Power-down Wake-up Pin Select */
;;;1186       u32tmpAddr = (uint32_t)&CLK->PASWKCTL;
000002  4c07              LDR      r4,|L10.32|
;;;1187       u32tmpAddr += (0x4UL * u32Port);
000004  eb040080          ADD      r0,r4,r0,LSL #2
;;;1188   
;;;1189       u32tmpVal = inpw((uint32_t *)u32tmpAddr);
000008  6804              LDR      r4,[r0,#0]
;;;1190       u32tmpVal = (u32tmpVal & ~(CLK_PASWKCTL_WKPSEL_Msk | CLK_PASWKCTL_PRWKEN_Msk | CLK_PASWKCTL_PFWKEN_Msk | CLK_PASWKCTL_DBEN_Msk | CLK_PASWKCTL_WKEN_Msk)) |
00000a  f24015f7          MOV      r5,#0x1f7
00000e  43ac              BICS     r4,r4,r5
000010  ea441101          ORR      r1,r4,r1,LSL #4
000014  4311              ORRS     r1,r1,r2
000016  4319              ORRS     r1,r1,r3
000018  f0410101          ORR      r1,r1,#1
;;;1191                   (u32Pin << CLK_PASWKCTL_WKPSEL_Pos) | u32TriggerType | u32DebounceEn | CLK_SPDWKPIN_ENABLE;
;;;1192       outpw((uint32_t *)u32tmpAddr, u32tmpVal);
00001c  6001              STR      r1,[r0,#0]
;;;1193   }
00001e  bd30              POP      {r4,r5,pc}
;;;1194   
                          ENDP

                  |L10.32|
                          DCD      0x400002a0

                          AREA ||i.CLK_EnableSysTick||, CODE, READONLY, ALIGN=1

                  CLK_EnableSysTick PROC
;;;1002     */
;;;1003   void CLK_EnableSysTick(uint32_t u32ClkSrc, uint32_t u32Count)
000000  b530              PUSH     {r4,r5,lr}
;;;1004   {
;;;1005       /* Set System Tick counter disabled */
;;;1006       SysTick->CTRL = 0UL;
000002  f04f22e0          MOV      r2,#0xe000e000
000006  2300              MOVS     r3,#0
000008  6113              STR      r3,[r2,#0x10]
;;;1007   
;;;1008       /* Set System Tick clock source */
;;;1009       if( u32ClkSrc == CLK_CLKSEL0_STCLKSEL_HCLK )
00000a  2804              CMP      r0,#4
00000c  d00f              BEQ      |L11.46|
;;;1010       {
;;;1011           SysTick->CTRL |= SysTick_CTRL_CLKSOURCE_Msk;
;;;1012       }
;;;1013       else
;;;1014       {
;;;1015           CLK->CLKSEL0 = (CLK->CLKSEL0 & ~CLK_CLKSEL0_STCLKSEL_Msk) | u32ClkSrc;
00000e  f04f4480          MOV      r4,#0x40000000
000012  f8d45210          LDR      r5,[r4,#0x210]
000016  f0250538          BIC      r5,r5,#0x38
00001a  4305              ORRS     r5,r5,r0
00001c  f8c45210          STR      r5,[r4,#0x210]
                  |L11.32|
;;;1016       }
;;;1017   
;;;1018       /* Set System Tick reload value */
;;;1019       SysTick->LOAD = u32Count;
000020  6151              STR      r1,[r2,#0x14]
;;;1020   
;;;1021       /* Clear System Tick current value and counter flag */
;;;1022       SysTick->VAL = 0UL;
000022  6193              STR      r3,[r2,#0x18]
;;;1023   
;;;1024       /* Set System Tick interrupt enabled and counter enabled */
;;;1025       SysTick->CTRL |= SysTick_CTRL_TICKINT_Msk | SysTick_CTRL_ENABLE_Msk;
000024  6910              LDR      r0,[r2,#0x10]
000026  f0400003          ORR      r0,r0,#3
00002a  6110              STR      r0,[r2,#0x10]
;;;1026   }
00002c  bd30              POP      {r4,r5,pc}
                  |L11.46|
00002e  6910              LDR      r0,[r2,#0x10]         ;1011
000030  f0400004          ORR      r0,r0,#4              ;1011
000034  6110              STR      r0,[r2,#0x10]         ;1011
000036  e7f3              B        |L11.32|
;;;1027   
                          ENDP


                          AREA ||i.CLK_EnableXtalRC||, CODE, READONLY, ALIGN=1

                  CLK_EnableXtalRC PROC
;;;593      */
;;;594    void CLK_EnableXtalRC(uint32_t u32ClkMask)
000000  f04f4180          MOV      r1,#0x40000000
;;;595    {
;;;596        CLK->PWRCTL |= u32ClkMask;
000004  f8d12200          LDR      r2,[r1,#0x200]
000008  4302              ORRS     r2,r2,r0
00000a  f8c12200          STR      r2,[r1,#0x200]
;;;597    }
00000e  4770              BX       lr
;;;598    
                          ENDP


                          AREA ||i.CLK_GetCPUFreq||, CODE, READONLY, ALIGN=2

                  CLK_GetCPUFreq PROC
;;;258      */
;;;259    uint32_t CLK_GetCPUFreq(void)
000000  b510              PUSH     {r4,lr}
;;;260    {
;;;261        SystemCoreClockUpdate();
000002  f7fffffe          BL       SystemCoreClockUpdate
;;;262        return SystemCoreClock;
000006  4801              LDR      r0,|L13.12|
000008  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
;;;263    }
00000a  bd10              POP      {r4,pc}
;;;264    
                          ENDP

                  |L13.12|
                          DCD      SystemCoreClock

                          AREA ||i.CLK_GetHCLKFreq||, CODE, READONLY, ALIGN=2

                  CLK_GetHCLKFreq PROC
;;;245      */
;;;246    uint32_t CLK_GetHCLKFreq(void)
000000  b510              PUSH     {r4,lr}
;;;247    {
;;;248        SystemCoreClockUpdate();
000002  f7fffffe          BL       SystemCoreClockUpdate
;;;249        return SystemCoreClock;
000006  4801              LDR      r0,|L14.12|
000008  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
;;;250    }
00000a  bd10              POP      {r4,pc}
;;;251    
                          ENDP

                  |L14.12|
                          DCD      SystemCoreClock

                          AREA ||i.CLK_GetHXTFreq||, CODE, READONLY, ALIGN=2

                  CLK_GetHXTFreq PROC
;;;121      */
;;;122    uint32_t CLK_GetHXTFreq(void)
000000  f04f4080          MOV      r0,#0x40000000
;;;123    {
;;;124        uint32_t u32Freq;
;;;125    
;;;126        if((CLK->PWRCTL & CLK_PWRCTL_HXTEN_Msk) == CLK_PWRCTL_HXTEN_Msk)
000004  f8d00200          LDR      r0,[r0,#0x200]
000008  07c0              LSLS     r0,r0,#31
00000a  d000              BEQ      |L15.14|
;;;127        {
;;;128            u32Freq = __HXT;
00000c  4800              LDR      r0,|L15.16|
                  |L15.14|
;;;129        }
;;;130        else
;;;131        {
;;;132            u32Freq = 0UL;
;;;133        }
;;;134    
;;;135        return u32Freq;
;;;136    }
00000e  4770              BX       lr
;;;137    
                          ENDP

                  |L15.16|
                          DCD      0x00b71b00

                          AREA ||i.CLK_GetLXTFreq||, CODE, READONLY, ALIGN=1

                  CLK_GetLXTFreq PROC
;;;144      */
;;;145    uint32_t CLK_GetLXTFreq(void)
000000  f04f4080          MOV      r0,#0x40000000
;;;146    {
;;;147        uint32_t u32Freq;
;;;148        if((CLK->PWRCTL & CLK_PWRCTL_LXTEN_Msk) == CLK_PWRCTL_LXTEN_Msk)
000004  f8d00200          LDR      r0,[r0,#0x200]
000008  0780              LSLS     r0,r0,#30
00000a  d502              BPL      |L16.18|
;;;149        {
;;;150            u32Freq = __LXT;
00000c  f44f4000          MOV      r0,#0x8000
;;;151        }
;;;152        else
;;;153        {
;;;154            u32Freq = 0UL;
;;;155        }
;;;156    
;;;157        return u32Freq;
;;;158    }
000010  4770              BX       lr
                  |L16.18|
000012  2000              MOVS     r0,#0                 ;154
000014  4770              BX       lr
;;;159    
                          ENDP


                          AREA ||i.CLK_GetModuleClockDivider||, CODE, READONLY, ALIGN=2

                  CLK_GetModuleClockDivider PROC
;;;1335     */
;;;1336   uint32_t CLK_GetModuleClockDivider(uint32_t u32ModuleIdx)
000000  b51f              PUSH     {r0-r4,lr}
;;;1337   {
;;;1338       uint32_t u32div = 0;
;;;1339       uint32_t u32DivTbl[4] = {0x0, 0x4, 0xc, 0x10};
000002  4c14              LDR      r4,|L17.84|
;;;1340   
;;;1341       if(MODULE_CLKDIV_Msk(u32ModuleIdx) != MODULE_NoMsk)
000004  f4103f7f          TST      r0,#0x3fc00
000008  cc1e              LDM      r4,{r1-r4}            ;1339
00000a  e88d001e          STM      sp,{r1-r4}            ;1339
00000e  d01f              BEQ      |L17.80|
;;;1342       {
;;;1343           /* Get clock divider control register address */
;;;1344           u32div = (uint32_t)&CLK->CLKDIV0 + (u32DivTbl[MODULE_CLKDIV(u32ModuleIdx)]);
000010  f3c04281          UBFX     r2,r0,#18,#2
000014  f85d1022          LDR      r1,[sp,r2,LSL #2]
000018  4a0f              LDR      r2,|L17.88|
00001a  4411              ADD      r1,r1,r2
;;;1345           if ((SYS->CSERVER & SYS_CSERVER_VERSION_Msk) == 0x1) // M480LD
00001c  0652              LSLS     r2,r2,#25
00001e  f8d221f4          LDR      r2,[r2,#0x1f4]
000022  b2d2              UXTB     r2,r2
000024  2a01              CMP      r2,#1
000026  d108              BNE      |L17.58|
;;;1346           {
;;;1347               if(MODULE_IP_EN_Pos_ENC(u32ModuleIdx) == 31U) //EADC1
000028  43c2              MVNS     r2,r0
00002a  06d3              LSLS     r3,r2,#27
;;;1348                   u32div = (uint32_t)&CLK->CLKDIV2;
00002c  4a0b              LDR      r2,|L17.92|
00002e  d003              BEQ      |L17.56|
;;;1349               else if(MODULE_IP_EN_Pos_ENC(u32ModuleIdx) == 29U) //I2S0
000030  f000031f          AND      r3,r0,#0x1f
000034  2b1d              CMP      r3,#0x1d
000036  d100              BNE      |L17.58|
                  |L17.56|
;;;1350                   u32div = (uint32_t)&CLK->CLKDIV2;
000038  4611              MOV      r1,r2
                  |L17.58|
;;;1351           }
;;;1352           /* Get clock divider number setting */
;;;1353           return ((M32(u32div) & (MODULE_CLKDIV_Msk(u32ModuleIdx) << MODULE_CLKDIV_Pos(u32ModuleIdx))) >> MODULE_CLKDIV_Pos(u32ModuleIdx));
00003a  6809              LDR      r1,[r1,#0]
00003c  f3c02287          UBFX     r2,r0,#10,#8
000040  f3c01044          UBFX     r0,r0,#5,#5
000044  4082              LSLS     r2,r2,r0
000046  4011              ANDS     r1,r1,r2
000048  fa21f000          LSR      r0,r1,r0
                  |L17.76|
;;;1354       }
;;;1355       else
;;;1356           return 0;
;;;1357   }
00004c  b004              ADD      sp,sp,#0x10
00004e  bd10              POP      {r4,pc}
                  |L17.80|
000050  2000              MOVS     r0,#0                 ;1356
000052  e7fb              B        |L17.76|
;;;1358   
                          ENDP

                  |L17.84|
                          DCD      ||.constdata||+0x10
                  |L17.88|
                          DCD      0x40000220
                  |L17.92|
                          DCD      0x40000228

                          AREA ||i.CLK_GetModuleClockSource||, CODE, READONLY, ALIGN=2

                  CLK_GetModuleClockSource PROC
;;;1286     */
;;;1287   uint32_t CLK_GetModuleClockSource(uint32_t u32ModuleIdx)
000000  b51f              PUSH     {r0-r4,lr}
;;;1288   {
;;;1289       uint32_t u32sel = 0;
;;;1290       uint32_t u32SelTbl[4] = {0x0, 0x4, 0x8, 0xC};
000002  4c1d              LDR      r4,|L18.120|
000004  cc1e              LDM      r4,{r1-r4}
000006  e88d001e          STM      sp,{r1-r4}
;;;1291   
;;;1292       /* Get clock source selection setting */
;;;1293       if(u32ModuleIdx == EPWM0_MODULE)
00000a  4a1c              LDR      r2,|L18.124|
;;;1294           return ((CLK->CLKSEL2 & CLK_CLKSEL2_EPWM0SEL_Msk) >> CLK_CLKSEL2_EPWM0SEL_Pos);
00000c  0691              LSLS     r1,r2,#26
00000e  4290              CMP      r0,r2                 ;1293
000010  d105              BNE      |L18.30|
000012  f8d10218          LDR      r0,[r1,#0x218]
000016  f0000001          AND      r0,r0,#1
                  |L18.26|
;;;1295       else if(u32ModuleIdx == EPWM1_MODULE)
;;;1296           return ((CLK->CLKSEL2 & CLK_CLKSEL2_EPWM1SEL_Msk) >> CLK_CLKSEL2_EPWM1SEL_Pos);
;;;1297       else if(u32ModuleIdx == BPWM0_MODULE)
;;;1298           return ((CLK->CLKSEL2 & CLK_CLKSEL2_BPWM0SEL_Msk) >> CLK_CLKSEL2_BPWM0SEL_Pos);
;;;1299       else if(u32ModuleIdx == BPWM1_MODULE)
;;;1300           return ((CLK->CLKSEL2 & CLK_CLKSEL2_BPWM1SEL_Msk) >> CLK_CLKSEL2_BPWM1SEL_Pos);
;;;1301       else if(MODULE_CLKSEL_Msk(u32ModuleIdx) != MODULE_NoMsk)
;;;1302       {
;;;1303           /* Get clock select control register address */
;;;1304           u32sel = (uint32_t)&CLK->CLKSEL0 + (u32SelTbl[MODULE_CLKSEL(u32ModuleIdx)]);
;;;1305           /* Get clock source selection setting */
;;;1306           return ((M32(u32sel) & (MODULE_CLKSEL_Msk(u32ModuleIdx) << MODULE_CLKSEL_Pos(u32ModuleIdx))) >> MODULE_CLKSEL_Pos(u32ModuleIdx));
;;;1307       }
;;;1308       else
;;;1309           return 0;
;;;1310   }
00001a  b004              ADD      sp,sp,#0x10
00001c  bd10              POP      {r4,pc}
                  |L18.30|
00001e  4a18              LDR      r2,|L18.128|
000020  4290              CMP      r0,r2                 ;1295
000022  d104              BNE      |L18.46|
000024  f8d10218          LDR      r0,[r1,#0x218]        ;1296
000028  f3c00040          UBFX     r0,r0,#1,#1           ;1296
00002c  e7f5              B        |L18.26|
                  |L18.46|
00002e  4a15              LDR      r2,|L18.132|
000030  4290              CMP      r0,r2                 ;1297
000032  d104              BNE      |L18.62|
000034  f8d10218          LDR      r0,[r1,#0x218]        ;1298
000038  f3c02000          UBFX     r0,r0,#8,#1           ;1298
00003c  e7ed              B        |L18.26|
                  |L18.62|
00003e  4a12              LDR      r2,|L18.136|
000040  4290              CMP      r0,r2                 ;1299
000042  d104              BNE      |L18.78|
000044  f8d10218          LDR      r0,[r1,#0x218]        ;1300
000048  f3c02040          UBFX     r0,r0,#9,#1           ;1300
00004c  e7e5              B        |L18.26|
                  |L18.78|
00004e  0e41              LSRS     r1,r0,#25             ;1301
000050  0749              LSLS     r1,r1,#29             ;1301
000052  d00e              BEQ      |L18.114|
000054  f3c07201          UBFX     r2,r0,#28,#2          ;1304
000058  f85d1022          LDR      r1,[sp,r2,LSL #2]     ;1304
00005c  4a0b              LDR      r2,|L18.140|
00005e  5889              LDR      r1,[r1,r2]            ;1306
000060  f3c06242          UBFX     r2,r0,#25,#3          ;1306
000064  f3c05004          UBFX     r0,r0,#20,#5          ;1306
000068  4082              LSLS     r2,r2,r0              ;1306
00006a  4011              ANDS     r1,r1,r2              ;1306
00006c  fa21f000          LSR      r0,r1,r0              ;1306
000070  e7d3              B        |L18.26|
                  |L18.114|
000072  2000              MOVS     r0,#0                 ;1309
000074  e7d1              B        |L18.26|
;;;1311   
                          ENDP

000076  0000              DCW      0x0000
                  |L18.120|
                          DCD      ||.constdata||
                  |L18.124|
                          DCD      0xa2000010
                  |L18.128|
                          DCD      0xa2100011
                  |L18.132|
                          DCD      0xa2800012
                  |L18.136|
                          DCD      0xa2900013
                  |L18.140|
                          DCD      0x40000210

                          AREA ||i.CLK_GetPCLK0Freq||, CODE, READONLY, ALIGN=2

                  CLK_GetPCLK0Freq PROC
;;;165      */
;;;166    uint32_t CLK_GetPCLK0Freq(void)
000000  b510              PUSH     {r4,lr}
;;;167    {
;;;168        uint32_t u32Freq;
;;;169        SystemCoreClockUpdate();
000002  f7fffffe          BL       SystemCoreClockUpdate
;;;170    
;;;171        if((CLK->PCLKDIV & CLK_PCLKDIV_APB0DIV_Msk) == CLK_PCLKDIV_APB0DIV_DIV1)
000006  f04f4180          MOV      r1,#0x40000000
00000a  f8d10234          LDR      r0,[r1,#0x234]
00000e  0742              LSLS     r2,r0,#29
;;;172        {
;;;173            u32Freq = SystemCoreClock;
000010  4813              LDR      r0,|L19.96|
000012  d017              BEQ      |L19.68|
;;;174        }
;;;175        else if((CLK->PCLKDIV & CLK_PCLKDIV_APB0DIV_Msk) == CLK_PCLKDIV_APB0DIV_DIV2)
000014  f8d12234          LDR      r2,[r1,#0x234]
000018  f0020207          AND      r2,r2,#7
00001c  2a01              CMP      r2,#1
00001e  d013              BEQ      |L19.72|
;;;176        {
;;;177            u32Freq = SystemCoreClock / 2UL;
;;;178        }
;;;179        else if((CLK->PCLKDIV & CLK_PCLKDIV_APB0DIV_Msk) == CLK_PCLKDIV_APB0DIV_DIV4)
000020  f8d12234          LDR      r2,[r1,#0x234]
000024  f0020207          AND      r2,r2,#7
000028  2a02              CMP      r2,#2
00002a  d010              BEQ      |L19.78|
;;;180        {
;;;181            u32Freq = SystemCoreClock / 4UL;
;;;182        }
;;;183        else if((CLK->PCLKDIV & CLK_PCLKDIV_APB0DIV_Msk) == CLK_PCLKDIV_APB0DIV_DIV8)
00002c  f8d12234          LDR      r2,[r1,#0x234]
000030  f0020207          AND      r2,r2,#7
000034  2a03              CMP      r2,#3
000036  d00d              BEQ      |L19.84|
;;;184        {
;;;185            u32Freq = SystemCoreClock / 8UL;
;;;186        }
;;;187        else if((CLK->PCLKDIV & CLK_PCLKDIV_APB0DIV_Msk) == CLK_PCLKDIV_APB0DIV_DIV16)
000038  f8d11234          LDR      r1,[r1,#0x234]
00003c  f0010107          AND      r1,r1,#7
000040  2904              CMP      r1,#4
000042  d00a              BEQ      |L19.90|
                  |L19.68|
000044  6800              LDR      r0,[r0,#0]            ;173  ; SystemCoreClock
;;;188        {
;;;189            u32Freq = SystemCoreClock / 16UL;
;;;190        }
;;;191        else
;;;192        {
;;;193            u32Freq = SystemCoreClock;
;;;194        }
;;;195    
;;;196        return u32Freq;
;;;197    }
000046  bd10              POP      {r4,pc}
                  |L19.72|
000048  6800              LDR      r0,[r0,#0]            ;177  ; SystemCoreClock
00004a  0840              LSRS     r0,r0,#1              ;177
00004c  bd10              POP      {r4,pc}
                  |L19.78|
00004e  6800              LDR      r0,[r0,#0]            ;181  ; SystemCoreClock
000050  0880              LSRS     r0,r0,#2              ;181
000052  bd10              POP      {r4,pc}
                  |L19.84|
000054  6800              LDR      r0,[r0,#0]            ;185  ; SystemCoreClock
000056  08c0              LSRS     r0,r0,#3              ;185
000058  bd10              POP      {r4,pc}
                  |L19.90|
00005a  6800              LDR      r0,[r0,#0]            ;189  ; SystemCoreClock
00005c  0900              LSRS     r0,r0,#4              ;189
00005e  bd10              POP      {r4,pc}
;;;198    
                          ENDP

                  |L19.96|
                          DCD      SystemCoreClock

                          AREA ||i.CLK_GetPCLK1Freq||, CODE, READONLY, ALIGN=2

                  CLK_GetPCLK1Freq PROC
;;;205      */
;;;206    uint32_t CLK_GetPCLK1Freq(void)
000000  b510              PUSH     {r4,lr}
;;;207    {
;;;208        uint32_t u32Freq;
;;;209        SystemCoreClockUpdate();
000002  f7fffffe          BL       SystemCoreClockUpdate
;;;210    
;;;211        if((CLK->PCLKDIV & CLK_PCLKDIV_APB1DIV_Msk) == CLK_PCLKDIV_APB1DIV_DIV1)
000006  f04f4180          MOV      r1,#0x40000000
00000a  f8d10234          LDR      r0,[r1,#0x234]
00000e  f0100f70          TST      r0,#0x70
;;;212        {
;;;213            u32Freq = SystemCoreClock;
000012  4814              LDR      r0,|L20.100|
000014  d017              BEQ      |L20.70|
;;;214        }
;;;215        else if((CLK->PCLKDIV & CLK_PCLKDIV_APB1DIV_Msk) == CLK_PCLKDIV_APB1DIV_DIV2)
000016  f8d12234          LDR      r2,[r1,#0x234]
00001a  f3c21202          UBFX     r2,r2,#4,#3
00001e  2a01              CMP      r2,#1
000020  d013              BEQ      |L20.74|
;;;216        {
;;;217            u32Freq = SystemCoreClock / 2UL;
;;;218        }
;;;219        else if((CLK->PCLKDIV & CLK_PCLKDIV_APB1DIV_Msk) == CLK_PCLKDIV_APB1DIV_DIV4)
000022  f8d12234          LDR      r2,[r1,#0x234]
000026  f3c21202          UBFX     r2,r2,#4,#3
00002a  2a02              CMP      r2,#2
00002c  d010              BEQ      |L20.80|
;;;220        {
;;;221            u32Freq = SystemCoreClock / 4UL;
;;;222        }
;;;223        else if((CLK->PCLKDIV & CLK_PCLKDIV_APB1DIV_Msk) == CLK_PCLKDIV_APB1DIV_DIV8)
00002e  f8d12234          LDR      r2,[r1,#0x234]
000032  f3c21202          UBFX     r2,r2,#4,#3
000036  2a03              CMP      r2,#3
000038  d00d              BEQ      |L20.86|
;;;224        {
;;;225            u32Freq = SystemCoreClock / 8UL;
;;;226        }
;;;227        else if((CLK->PCLKDIV & CLK_PCLKDIV_APB1DIV_Msk) == CLK_PCLKDIV_APB1DIV_DIV16)
00003a  f8d11234          LDR      r1,[r1,#0x234]
00003e  f3c11102          UBFX     r1,r1,#4,#3
000042  2904              CMP      r1,#4
000044  d00a              BEQ      |L20.92|
                  |L20.70|
000046  6800              LDR      r0,[r0,#0]            ;213  ; SystemCoreClock
;;;228        {
;;;229            u32Freq = SystemCoreClock / 16UL;
;;;230        }
;;;231        else
;;;232        {
;;;233            u32Freq = SystemCoreClock;
;;;234        }
;;;235    
;;;236        return u32Freq;
;;;237    }
000048  bd10              POP      {r4,pc}
                  |L20.74|
00004a  6800              LDR      r0,[r0,#0]            ;217  ; SystemCoreClock
00004c  0840              LSRS     r0,r0,#1              ;217
00004e  bd10              POP      {r4,pc}
                  |L20.80|
000050  6800              LDR      r0,[r0,#0]            ;221  ; SystemCoreClock
000052  0880              LSRS     r0,r0,#2              ;221
000054  bd10              POP      {r4,pc}
                  |L20.86|
000056  6800              LDR      r0,[r0,#0]            ;225  ; SystemCoreClock
000058  08c0              LSRS     r0,r0,#3              ;225
00005a  bd10              POP      {r4,pc}
                  |L20.92|
00005c  6800              LDR      r0,[r0,#0]            ;229  ; SystemCoreClock
00005e  0900              LSRS     r0,r0,#4              ;229
000060  bd10              POP      {r4,pc}
;;;238    
                          ENDP

000062  0000              DCW      0x0000
                  |L20.100|
                          DCD      SystemCoreClock

                          AREA ||i.CLK_GetPLLClockFreq||, CODE, READONLY, ALIGN=2

                  CLK_GetPLLClockFreq PROC
;;;1200     */
;;;1201   uint32_t CLK_GetPLLClockFreq(void)
000000  b508              PUSH     {r3,lr}
;;;1202   {
;;;1203       uint32_t u32PllFreq = 0UL, u32PllReg;
;;;1204       uint32_t u32FIN, u32NF, u32NR, u32NO;
;;;1205       uint8_t au8NoTbl[4] = {1U, 2U, 2U, 4U};
000002  a110              ADR      r1,|L21.68|
000004  2000              MOVS     r0,#0                 ;1203
000006  6809              LDR      r1,[r1,#0]
;;;1206   
;;;1207       u32PllReg = CLK->PLLCTL;
000008  9100              STR      r1,[sp,#0]
00000a  f04f4180          MOV      r1,#0x40000000
00000e  f8d11240          LDR      r1,[r1,#0x240]
;;;1208   
;;;1209       if(u32PllReg & (CLK_PLLCTL_PD_Msk | CLK_PLLCTL_OE_Msk))
000012  f4112fa0          TST      r1,#0x50000
000016  d113              BNE      |L21.64|
;;;1210       {
;;;1211           u32PllFreq = 0UL;           /* PLL is in power down mode or fix low */
;;;1212       }
;;;1213       else if((u32PllReg & CLK_PLLCTL_BP_Msk) == CLK_PLLCTL_BP_Msk)
;;;1214       {
;;;1215           if((u32PllReg & CLK_PLLCTL_PLLSRC_HIRC) == CLK_PLLCTL_PLLSRC_HIRC)
;;;1216           {
;;;1217               u32FIN = __HIRC;    /* PLL source clock from HIRC */
000018  480b              LDR      r0,|L21.72|
00001a  038a              LSLS     r2,r1,#14             ;1213
00001c  d410              BMI      |L21.64|
;;;1218           }
;;;1219           else
;;;1220           {
;;;1221               u32FIN = __HXT;     /* PLL source clock from HXT */
;;;1222           }
;;;1223   
;;;1224           u32PllFreq = u32FIN;
;;;1225       }
;;;1226       else
;;;1227       {
;;;1228           if((u32PllReg & CLK_PLLCTL_PLLSRC_HIRC) == CLK_PLLCTL_PLLSRC_HIRC)
;;;1229           {
;;;1230               u32FIN = __HIRC;    /* PLL source clock from HIRC */
;;;1231           }
;;;1232           else
;;;1233           {
;;;1234               u32FIN = __HXT;     /* PLL source clock from HXT */
;;;1235           }
;;;1236           /* PLL is output enabled in normal work mode */
;;;1237           u32NO = au8NoTbl[((u32PllReg & CLK_PLLCTL_OUTDIV_Msk) >> CLK_PLLCTL_OUTDIV_Pos)];
;;;1238           u32NF = ((u32PllReg & CLK_PLLCTL_FBDIV_Msk) >> CLK_PLLCTL_FBDIV_Pos) + 2UL;
00001e  f3c10008          UBFX     r0,r1,#0,#9
000022  f3c13281          UBFX     r2,r1,#14,#2          ;1237
;;;1239           u32NR = ((u32PllReg & CLK_PLLCTL_INDIV_Msk) >> CLK_PLLCTL_INDIV_Pos) + 1UL;
;;;1240   
;;;1241           /* u32FIN is shifted 2 bits to avoid overflow */
;;;1242           u32PllFreq = (((u32FIN >> 2) * u32NF) / (u32NR * u32NO) << 2) * 2UL;
000026  4b09              LDR      r3,|L21.76|
000028  1c80              ADDS     r0,r0,#2
00002a  f81d2002          LDRB     r2,[sp,r2]            ;1237
00002e  f3c12144          UBFX     r1,r1,#9,#5           ;1239
000032  4358              MULS     r0,r3,r0
000034  1c49              ADDS     r1,r1,#1
000036  fb11f102          SMULBB   r1,r1,r2
00003a  fbb0f0f1          UDIV     r0,r0,r1
00003e  00c0              LSLS     r0,r0,#3
                  |L21.64|
;;;1243       }
;;;1244   
;;;1245       return u32PllFreq;
;;;1246   }
000040  bd08              POP      {r3,pc}
;;;1247   
                          ENDP

000042  0000              DCW      0x0000
                  |L21.68|
000044  01020204          DCB      1,2,2,4
                  |L21.72|
                          DCD      0x00b71b00
                  |L21.76|
                          DCD      0x002dc6c0

                          AREA ||i.CLK_GetPMUWKSrc||, CODE, READONLY, ALIGN=1

                  CLK_GetPMUWKSrc PROC
;;;1158   
;;;1159   uint32_t CLK_GetPMUWKSrc(void)
000000  f04f4080          MOV      r0,#0x40000000
;;;1160   {
;;;1161       return (CLK->PMUSTS);
000004  f8d00294          LDR      r0,[r0,#0x294]
;;;1162   }
000008  4770              BX       lr
;;;1163   
                          ENDP


                          AREA ||i.CLK_Idle||, CODE, READONLY, ALIGN=2

                  CLK_Idle PROC
;;;103      */
;;;104    void CLK_Idle(void)
000000  4806              LDR      r0,|L23.28|
;;;105    {
;;;106        /* Set the processor uses sleep as its low power mode */
;;;107        SCB->SCR &= ~SCB_SCR_SLEEPDEEP_Msk;
000002  6801              LDR      r1,[r0,#0]
000004  f0210104          BIC      r1,r1,#4
000008  6001              STR      r1,[r0,#0]
;;;108    
;;;109        /* Set chip in idle mode because of WFI command */
;;;110        CLK->PWRCTL &= ~CLK_PWRCTL_PDEN_Msk;
00000a  0680              LSLS     r0,r0,#26
00000c  f8d01200          LDR      r1,[r0,#0x200]
000010  f0210180          BIC      r1,r1,#0x80
000014  f8c01200          STR      r1,[r0,#0x200]
;;;111    
;;;112        /* Chip enter idle mode after CPU run WFI instruction */
;;;113        __WFI();
000018  bf30              WFI      
;;;114    }
00001a  4770              BX       lr
;;;115    
                          ENDP

                  |L23.28|
                          DCD      0xe000ed10

                          AREA ||i.CLK_PowerDown||, CODE, READONLY, ALIGN=2

                  CLK_PowerDown PROC
;;;73       */
;;;74     void CLK_PowerDown(void)
000000  480a              LDR      r0,|L24.44|
;;;75     {
;;;76         uint32_t u32HIRCTRIMCTL;
;;;77     
;;;78         /* Set the processor uses deep sleep as its low power mode */
;;;79         SCB->SCR |= SCB_SCR_SLEEPDEEP_Msk;
000002  6801              LDR      r1,[r0,#0]
000004  f0410104          ORR      r1,r1,#4
000008  6001              STR      r1,[r0,#0]
;;;80     
;;;81         /* Set system Power-down enabled */
;;;82         CLK->PWRCTL |= (CLK_PWRCTL_PDEN_Msk);
00000a  0680              LSLS     r0,r0,#26
00000c  f8d01200          LDR      r1,[r0,#0x200]
000010  f0410180          ORR      r1,r1,#0x80
000014  f8c01200          STR      r1,[r0,#0x200]
;;;83     
;;;84         /* Store HIRC control register */
;;;85         u32HIRCTRIMCTL = SYS->IRCTCTL;
000018  f8501ff0          LDR      r1,[r0,#0xf0]!
;;;86     
;;;87         /* Disable HIRC auto trim */
;;;88         SYS->IRCTCTL &= (~SYS_IRCTCTL_FREQSEL_Msk);
00001c  6802              LDR      r2,[r0,#0]
00001e  f0220203          BIC      r2,r2,#3
000022  6002              STR      r2,[r0,#0]
;;;89     
;;;90         /* Chip enter Power-down mode after CPU run WFI instruction */
;;;91         __WFI();
000024  bf30              WFI      
;;;92     
;;;93         /* Restore HIRC control register */
;;;94         SYS->IRCTCTL = u32HIRCTRIMCTL;
000026  6001              STR      r1,[r0,#0]
;;;95     }
000028  4770              BX       lr
;;;96     
                          ENDP

00002a  0000              DCW      0x0000
                  |L24.44|
                          DCD      0xe000ed10

                          AREA ||i.CLK_SetCoreClock||, CODE, READONLY, ALIGN=2

                  CLK_SetCoreClock PROC
;;;272      */
;;;273    uint32_t CLK_SetCoreClock(uint32_t u32Hclk)
000000  b570              PUSH     {r4-r6,lr}
;;;274    {
;;;275        uint32_t u32HIRCSTB;
;;;276    
;;;277        /* Read HIRC clock source stable flag */
;;;278        u32HIRCSTB = CLK->STATUS & CLK_STATUS_HIRCSTB_Msk;
000002  f04f4480          MOV      r4,#0x40000000
000006  4605              MOV      r5,r0                 ;274
000008  f8d40250          LDR      r0,[r4,#0x250]
00000c  f0000610          AND      r6,r0,#0x10
;;;279    
;;;280        /* The range of u32Hclk is running up to 192 MHz */
;;;281        if(u32Hclk > FREQ_192MHZ)
000010  481b              LDR      r0,|L25.128|
000012  4285              CMP      r5,r0
000014  d900              BLS      |L25.24|
;;;282        {
;;;283            u32Hclk = FREQ_192MHZ;
000016  4605              MOV      r5,r0
                  |L25.24|
;;;284        }
;;;285    
;;;286        /* Switch HCLK clock source to HIRC clock for safe */
;;;287        CLK->PWRCTL |= CLK_PWRCTL_HIRCEN_Msk;
000018  f8d40200          LDR      r0,[r4,#0x200]
00001c  f0400004          ORR      r0,r0,#4
000020  f8c40200          STR      r0,[r4,#0x200]
;;;288        CLK_WaitClockReady(CLK_STATUS_HIRCSTB_Msk);
000024  2010              MOVS     r0,#0x10
000026  f5047400          ADD      r4,r4,#0x200
00002a  f7fffffe          BL       CLK_WaitClockReady
;;;289        CLK->CLKSEL0 |= CLK_CLKSEL0_HCLKSEL_Msk;
00002e  6920              LDR      r0,[r4,#0x10]
000030  f0400007          ORR      r0,r0,#7
000034  6120              STR      r0,[r4,#0x10]
;;;290        CLK->CLKDIV0 &= (~CLK_CLKDIV0_HCLKDIV_Msk);
000036  6a20              LDR      r0,[r4,#0x20]
000038  f020000f          BIC      r0,r0,#0xf
00003c  6220              STR      r0,[r4,#0x20]
;;;291    
;;;292        /* Configure PLL setting if HXT clock is enabled */
;;;293        if((CLK->PWRCTL & CLK_PWRCTL_HXTEN_Msk) == CLK_PWRCTL_HXTEN_Msk)
00003e  6820              LDR      r0,[r4,#0]
000040  f5a47400          SUB      r4,r4,#0x200
000044  07c0              LSLS     r0,r0,#31
;;;294        {
;;;295            u32Hclk = CLK_EnablePLL(CLK_PLLCTL_PLLSRC_HXT, u32Hclk);
;;;296        }
;;;297        /* Configure PLL setting if HXT clock is not enabled */
;;;298        else
;;;299        {
;;;300            u32Hclk = CLK_EnablePLL(CLK_PLLCTL_PLLSRC_HIRC, u32Hclk);
000046  4629              MOV      r1,r5
000048  d004              BEQ      |L25.84|
00004a  2000              MOVS     r0,#0                 ;295
00004c  f7fffffe          BL       CLK_EnablePLL
000050  4605              MOV      r5,r0                 ;295
000052  e008              B        |L25.102|
                  |L25.84|
000054  f44f2000          MOV      r0,#0x80000
000058  f7fffffe          BL       CLK_EnablePLL
00005c  4605              MOV      r5,r0
;;;301    
;;;302            /* Read HIRC clock source stable flag */
;;;303            u32HIRCSTB = CLK->STATUS & CLK_STATUS_HIRCSTB_Msk;
00005e  f8d40250          LDR      r0,[r4,#0x250]
000062  f0000610          AND      r6,r0,#0x10
                  |L25.102|
;;;304        }
;;;305    
;;;306        /* Select HCLK clock source to PLL,
;;;307           and update system core clock
;;;308        */
;;;309        CLK_SetHCLK(CLK_CLKSEL0_HCLKSEL_PLL, CLK_CLKDIV0_HCLK(1UL));
000066  2100              MOVS     r1,#0
000068  2002              MOVS     r0,#2
00006a  f7fffffe          BL       CLK_SetHCLK
;;;310    
;;;311        /* Disable HIRC if HIRC is disabled before setting core clock */
;;;312        if(u32HIRCSTB == 0UL)
00006e  b92e              CBNZ     r6,|L25.124|
;;;313        {
;;;314            CLK->PWRCTL &= ~CLK_PWRCTL_HIRCEN_Msk;
000070  f8d40200          LDR      r0,[r4,#0x200]
000074  f0200004          BIC      r0,r0,#4
000078  f8c40200          STR      r0,[r4,#0x200]
                  |L25.124|
;;;315        }
;;;316    
;;;317        /* Return actually HCLK frequency is PLL frequency divide 1 */
;;;318        return u32Hclk;
00007c  4628              MOV      r0,r5
;;;319    }
00007e  bd70              POP      {r4-r6,pc}
;;;320    
                          ENDP

                  |L25.128|
                          DCD      0x0b71b000

                          AREA ||i.CLK_SetHCLK||, CODE, READONLY, ALIGN=1

                  CLK_SetHCLK PROC
;;;334      */
;;;335    void CLK_SetHCLK(uint32_t u32ClkSrc, uint32_t u32ClkDiv)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;336    {
;;;337        uint32_t u32HIRCSTB;
;;;338    
;;;339        /* Read HIRC clock source stable flag */
;;;340        u32HIRCSTB = CLK->STATUS & CLK_STATUS_HIRCSTB_Msk;
000004  f04f4480          MOV      r4,#0x40000000
000008  4607              MOV      r7,r0                 ;336
00000a  f8d40250          LDR      r0,[r4,#0x250]
00000e  460e              MOV      r6,r1                 ;336
000010  f0000510          AND      r5,r0,#0x10
;;;341    
;;;342        /* Switch to HIRC for Safe. Avoid HCLK too high when applying new divider. */
;;;343        CLK->PWRCTL |= CLK_PWRCTL_HIRCEN_Msk;
000014  f8d40200          LDR      r0,[r4,#0x200]
000018  f0400004          ORR      r0,r0,#4
00001c  f8c40200          STR      r0,[r4,#0x200]
;;;344        CLK_WaitClockReady(CLK_STATUS_HIRCSTB_Msk);
000020  2010              MOVS     r0,#0x10
000022  f5047400          ADD      r4,r4,#0x200
000026  f7fffffe          BL       CLK_WaitClockReady
;;;345        CLK->CLKSEL0 = (CLK->CLKSEL0 & (~CLK_CLKSEL0_HCLKSEL_Msk)) | CLK_CLKSEL0_HCLKSEL_HIRC;
00002a  6920              LDR      r0,[r4,#0x10]
00002c  f0400007          ORR      r0,r0,#7
000030  6120              STR      r0,[r4,#0x10]
;;;346    
;;;347        /* Apply new Divider */
;;;348        CLK->CLKDIV0 = (CLK->CLKDIV0 & (~CLK_CLKDIV0_HCLKDIV_Msk)) | u32ClkDiv;
000032  6a20              LDR      r0,[r4,#0x20]
000034  f020000f          BIC      r0,r0,#0xf
000038  4330              ORRS     r0,r0,r6
00003a  6220              STR      r0,[r4,#0x20]
;;;349    
;;;350        /* Switch HCLK to new HCLK source */
;;;351        CLK->CLKSEL0 = (CLK->CLKSEL0 & (~CLK_CLKSEL0_HCLKSEL_Msk)) | u32ClkSrc;
00003c  6920              LDR      r0,[r4,#0x10]
00003e  f0200007          BIC      r0,r0,#7
000042  4338              ORRS     r0,r0,r7
000044  6120              STR      r0,[r4,#0x10]
000046  f5a47400          SUB      r4,r4,#0x200
;;;352    
;;;353        /* Update System Core Clock */
;;;354        SystemCoreClockUpdate();
00004a  f7fffffe          BL       SystemCoreClockUpdate
;;;355    
;;;356        /* Disable HIRC if HIRC is disabled before switching HCLK source */
;;;357        if(u32HIRCSTB == 0UL)
00004e  2d00              CMP      r5,#0
000050  d105              BNE      |L26.94|
;;;358        {
;;;359            CLK->PWRCTL &= ~CLK_PWRCTL_HIRCEN_Msk;
000052  f8d40200          LDR      r0,[r4,#0x200]
000056  f0200004          BIC      r0,r0,#4
00005a  f8c40200          STR      r0,[r4,#0x200]
                  |L26.94|
;;;360        }
;;;361    }
00005e  e8bd81f0          POP      {r4-r8,pc}
;;;362    
                          ENDP


                          AREA ||i.CLK_SetModuleClock||, CODE, READONLY, ALIGN=2

                  CLK_SetModuleClock PROC
;;;504      */
;;;505    void CLK_SetModuleClock(uint32_t u32ModuleIdx, uint32_t u32ClkSrc, uint32_t u32ClkDiv)
000000  b5f0              PUSH     {r4-r7,lr}
;;;506    {
;;;507        uint32_t u32sel = 0U, u32div = 0U;
;;;508    
;;;509        if(MODULE_CLKDIV_Msk(u32ModuleIdx) != MODULE_NoMsk)
000002  f4103f7f          TST      r0,#0x3fc00
000006  d02e              BEQ      |L27.102|
;;;510        {
;;;511            /* Get clock divider control register address */
;;;512            if ((SYS->CSERVER & SYS_CSERVER_VERSION_Msk) == 0x1) // M480LD
000008  f04f4380          MOV      r3,#0x40000000
00000c  f8d331f4          LDR      r3,[r3,#0x1f4]
;;;513            {
;;;514                if(MODULE_CLKDIV(u32ModuleIdx) == 2U && MODULE_IP_EN_Pos_ENC(u32ModuleIdx) == 31U) //EADC1
;;;515                {
;;;516                    u32div = (uint32_t)&CLK->CLKDIV2;
;;;517                }
;;;518                else if(MODULE_CLKDIV(u32ModuleIdx) == 2U && MODULE_IP_EN_Pos_ENC(u32ModuleIdx) == 29U) //I2S0
;;;519                {
;;;520                    u32div = (uint32_t)&CLK->CLKDIV2;
;;;521                }
;;;522                else if (MODULE_CLKDIV(u32ModuleIdx) == 2U)
;;;523                {
;;;524                    u32div = (uint32_t)&CLK->CLKDIV3;
000010  4e1e              LDR      r6,|L27.140|
000012  f0030cff          AND      r12,r3,#0xff          ;512
;;;525                }
;;;526                else if (MODULE_CLKDIV(u32ModuleIdx) == 3U)
;;;527                {
;;;528                    u32div = (uint32_t)&CLK->CLKDIV4;
;;;529                }
;;;530                else
;;;531                {
;;;532                    u32div = (uint32_t)&CLK->CLKDIV0 + ((MODULE_CLKDIV(u32ModuleIdx)) * 4U);
000016  4b1d              LDR      r3,|L27.140|
000018  1d37              ADDS     r7,r6,#4              ;528
00001a  3b0c              SUBS     r3,r3,#0xc
00001c  f3c04481          UBFX     r4,r0,#18,#2          ;514
000020  ea6f4590          MVN      r5,r0,LSR #18         ;526
000024  eb030384          ADD      r3,r3,r4,LSL #2
000028  f1bc0f01          CMP      r12,#1                ;512
00002c  d002              BEQ      |L27.52|
;;;533                }
;;;534            }
;;;535            else
;;;536            {
;;;537                /* Get clock divider control register address */
;;;538                if(MODULE_CLKDIV(u32ModuleIdx) == 2U)
00002e  2c02              CMP      r4,#2
000030  d00d              BEQ      |L27.78|
000032  e001              B        |L27.56|
                  |L27.52|
000034  2c02              CMP      r4,#2                 ;514
000036  d002              BEQ      |L27.62|
                  |L27.56|
;;;539                {
;;;540                    u32div = (uint32_t)&CLK->CLKDIV3;
;;;541                }
;;;542                else if (MODULE_CLKDIV(u32ModuleIdx) == 3U)
000038  07ac              LSLS     r4,r5,#30
00003a  d00a              BEQ      |L27.82|
00003c  e00a              B        |L27.84|
                  |L27.62|
00003e  43c3              MVNS     r3,r0                 ;514
000040  06dc              LSLS     r4,r3,#27             ;514
000042  4b13              LDR      r3,|L27.144|
000044  d006              BEQ      |L27.84|
000046  f000041f          AND      r4,r0,#0x1f           ;518
00004a  2c1d              CMP      r4,#0x1d              ;518
00004c  d002              BEQ      |L27.84|
                  |L27.78|
00004e  4633              MOV      r3,r6                 ;540
000050  e000              B        |L27.84|
                  |L27.82|
;;;543                {
;;;544                    u32div = (uint32_t)&CLK->CLKDIV4;
000052  463b              MOV      r3,r7
                  |L27.84|
;;;545                }
;;;546                else
;;;547                {
;;;548                    u32div = (uint32_t)&CLK->CLKDIV0 + ((MODULE_CLKDIV(u32ModuleIdx)) * 4U);
;;;549                }
;;;550            }
;;;551    
;;;552            /* Apply new divider */
;;;553            M32(u32div) = (M32(u32div) & (~(MODULE_CLKDIV_Msk(u32ModuleIdx) << MODULE_CLKDIV_Pos(u32ModuleIdx)))) | u32ClkDiv;
000054  681c              LDR      r4,[r3,#0]
000056  f3c02587          UBFX     r5,r0,#10,#8
00005a  f3c01644          UBFX     r6,r0,#5,#5
00005e  40b5              LSLS     r5,r5,r6
000060  43ac              BICS     r4,r4,r5
000062  4314              ORRS     r4,r4,r2
000064  601c              STR      r4,[r3,#0]
                  |L27.102|
;;;554        }
;;;555    
;;;556        if(MODULE_CLKSEL_Msk(u32ModuleIdx) != MODULE_NoMsk)
000066  0e42              LSRS     r2,r0,#25
000068  0752              LSLS     r2,r2,#29
00006a  d00e              BEQ      |L27.138|
;;;557        {
;;;558            /* Get clock select control register address */
;;;559            u32sel = (uint32_t)&CLK->CLKSEL0 + ((MODULE_CLKSEL(u32ModuleIdx)) * 4U);
00006c  4b08              LDR      r3,|L27.144|
00006e  f3c07201          UBFX     r2,r0,#28,#2
000072  3b18              SUBS     r3,r3,#0x18
000074  eb030282          ADD      r2,r3,r2,LSL #2
;;;560            /* Set new clock selection setting */
;;;561            M32(u32sel) = (M32(u32sel) & (~(MODULE_CLKSEL_Msk(u32ModuleIdx) << MODULE_CLKSEL_Pos(u32ModuleIdx)))) | u32ClkSrc;
000078  6813              LDR      r3,[r2,#0]
00007a  f3c06442          UBFX     r4,r0,#25,#3
00007e  f3c05004          UBFX     r0,r0,#20,#5
000082  4084              LSLS     r4,r4,r0
000084  43a3              BICS     r3,r3,r4
000086  430b              ORRS     r3,r3,r1
000088  6013              STR      r3,[r2,#0]
                  |L27.138|
;;;562        }
;;;563    }
00008a  bdf0              POP      {r4-r7,pc}
;;;564    
                          ENDP

                  |L27.140|
                          DCD      0x4000022c
                  |L27.144|
                          DCD      0x40000228

                          AREA ||i.CLK_SetPowerDownMode||, CODE, READONLY, ALIGN=1

                  CLK_SetPowerDownMode PROC
;;;1054   
;;;1055   void CLK_SetPowerDownMode(uint32_t u32PDMode)
000000  b530              PUSH     {r4,r5,lr}
;;;1056   {
;;;1057       if ((SYS->CSERVER & SYS_CSERVER_VERSION_Msk) == 0x1) // M480LD
000002  f04f4480          MOV      r4,#0x40000000
000006  4605              MOV      r5,r0                 ;1056
000008  f8d401f4          LDR      r0,[r4,#0x1f4]
00000c  b2c0              UXTB     r0,r0
00000e  2801              CMP      r0,#1
000010  d004              BEQ      |L28.28|
;;;1058       {
;;;1059           if(u32PDMode == CLK_PMUCTL_PDMSEL_SPD0)
;;;1060           {
;;;1061               u32PDMode = CLK_PMUCTL_PDMSEL_SPD0;
;;;1062               CLK->PMUCTL = (CLK->PMUCTL & ~(CLK_PMUCTL_SRETSEL_Msk)) | CLK_SPDSRETSEL_16K;
;;;1063           }
;;;1064           else if(u32PDMode == CLK_PMUCTL_PDMSEL_SPD1)
;;;1065           {
;;;1066               u32PDMode = CLK_PMUCTL_PDMSEL_SPD0;
;;;1067               CLK->PMUCTL = (CLK->PMUCTL & ~(CLK_PMUCTL_SRETSEL_Msk)) | CLK_SPDSRETSEL_NO;
;;;1068           }
;;;1069       }
;;;1070       else
;;;1071       {
;;;1072           /* Enable LIRC clock before entering to Standby Power-down Mode */
;;;1073           if((u32PDMode == CLK_PMUCTL_PDMSEL_SPD0) || (u32PDMode == CLK_PMUCTL_PDMSEL_SPD1))
000012  2d04              CMP      r5,#4
000014  d016              BEQ      |L28.68|
000016  2d05              CMP      r5,#5
000018  d014              BEQ      |L28.68|
00001a  e01c              B        |L28.86|
                  |L28.28|
00001c  2d04              CMP      r5,#4                 ;1059
00001e  d002              BEQ      |L28.38|
000020  2d05              CMP      r5,#5                 ;1064
000022  d007              BEQ      |L28.52|
000024  e017              B        |L28.86|
                  |L28.38|
000026  f8d40290          LDR      r0,[r4,#0x290]        ;1062
00002a  f0200070          BIC      r0,r0,#0x70           ;1062
00002e  f0400010          ORR      r0,r0,#0x10           ;1062
000032  e004              B        |L28.62|
                  |L28.52|
000034  f8d40290          LDR      r0,[r4,#0x290]        ;1067
000038  2504              MOVS     r5,#4                 ;1066
00003a  f0200070          BIC      r0,r0,#0x70           ;1067
                  |L28.62|
00003e  f8c40290          STR      r0,[r4,#0x290]        ;1067
000042  e008              B        |L28.86|
                  |L28.68|
;;;1074           {
;;;1075               /* Enable LIRC clock */
;;;1076               CLK->PWRCTL |= CLK_PWRCTL_LIRCEN_Msk;
000044  f8d40200          LDR      r0,[r4,#0x200]
000048  f0400008          ORR      r0,r0,#8
00004c  f8c40200          STR      r0,[r4,#0x200]
;;;1077   
;;;1078               /* Wait for LIRC clock stable */
;;;1079               CLK_WaitClockReady(CLK_STATUS_LIRCSTB_Msk);
000050  2008              MOVS     r0,#8
000052  f7fffffe          BL       CLK_WaitClockReady
                  |L28.86|
;;;1080           }
;;;1081       }
;;;1082   
;;;1083       CLK->PMUCTL = (CLK->PMUCTL & ~(CLK_PMUCTL_PDMSEL_Msk)) | u32PDMode;
000056  f8d40290          LDR      r0,[r4,#0x290]
00005a  f0200007          BIC      r0,r0,#7
00005e  4328              ORRS     r0,r0,r5
000060  f8c40290          STR      r0,[r4,#0x290]
;;;1084   }
000064  bd30              POP      {r4,r5,pc}
;;;1085   
                          ENDP


                          AREA ||i.CLK_SetSysTickClockSrc||, CODE, READONLY, ALIGN=1

                  CLK_SetSysTickClockSrc PROC
;;;576      */
;;;577    void CLK_SetSysTickClockSrc(uint32_t u32ClkSrc)
000000  f04f4180          MOV      r1,#0x40000000
;;;578    {
;;;579        CLK->CLKSEL0 = (CLK->CLKSEL0 & ~CLK_CLKSEL0_STCLKSEL_Msk) | u32ClkSrc;
000004  f8d12210          LDR      r2,[r1,#0x210]
000008  f0220238          BIC      r2,r2,#0x38
00000c  4302              ORRS     r2,r2,r0
00000e  f8c12210          STR      r2,[r1,#0x210]
;;;580    
;;;581    }
000012  4770              BX       lr
;;;582    
                          ENDP


                          AREA ||i.CLK_WaitClockReady||, CODE, READONLY, ALIGN=2

                  CLK_WaitClockReady PROC
;;;967      */
;;;968    uint32_t CLK_WaitClockReady(uint32_t u32ClkMask)
000000  b530              PUSH     {r4,r5,lr}
;;;969    {
000002  4603              MOV      r3,r0
;;;970        uint32_t u32TimeOutCnt = SystemCoreClock / 2;
000004  480b              LDR      r0,|L30.52|
;;;971        uint32_t u32Ret = 1U;
;;;972    
;;;973        g_CLK_i32ErrCode = 0;
000006  4a0c              LDR      r2,|L30.56|
000008  2400              MOVS     r4,#0
00000a  6800              LDR      r0,[r0,#0]            ;970  ; SystemCoreClock
;;;974        while((CLK->STATUS & u32ClkMask) != u32ClkMask)
00000c  6014              STR      r4,[r2,#0]  ; g_CLK_i32ErrCode
00000e  0841              LSRS     r1,r0,#1              ;970
000010  2001              MOVS     r0,#1                 ;971
000012  0784              LSLS     r4,r0,#30
000014  e001              B        |L30.26|
                  |L30.22|
000016  1e49              SUBS     r1,r1,#1              ;969
;;;975        {
;;;976            if(--u32TimeOutCnt == 0)
000018  d00a              BEQ      |L30.48|
                  |L30.26|
00001a  f8d45250          LDR      r5,[r4,#0x250]        ;974
00001e  ea330505          BICS     r5,r3,r5              ;974
000022  d1f8              BNE      |L30.22|
;;;977            {
;;;978                u32Ret = 0U;
;;;979                break;
;;;980            }
;;;981        }
;;;982    
;;;983        if(u32TimeOutCnt == 0)
000024  2900              CMP      r1,#0
000026  d102              BNE      |L30.46|
                  |L30.40|
;;;984            g_CLK_i32ErrCode = CLK_TIMEOUT_ERR;
000028  f04f31ff          MOV      r1,#0xffffffff
00002c  6011              STR      r1,[r2,#0]  ; g_CLK_i32ErrCode
                  |L30.46|
;;;985    
;;;986        return u32Ret;
;;;987    }
00002e  bd30              POP      {r4,r5,pc}
                  |L30.48|
000030  2000              MOVS     r0,#0                 ;978
000032  e7f9              B        |L30.40|
;;;988    
                          ENDP

                  |L30.52|
                          DCD      SystemCoreClock
                  |L30.56|
                          DCD      ||.data||

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                          DCD      0x00000000
                          DCD      0x00000004
                          DCD      0x00000008
                          DCD      0x0000000c
                          DCD      0x00000000
                          DCD      0x00000004
                          DCD      0x0000000c
                          DCD      0x00000010

                          AREA ||.data||, DATA, ALIGN=2

                  g_CLK_i32ErrCode
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\..\\Library\\StdDriver\\src\\clk.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___5_clk_c_9a445bc2____REV16|
#line 464 "..\\..\\..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___5_clk_c_9a445bc2____REV16| PROC
#line 465

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___5_clk_c_9a445bc2____REVSH|
#line 479
|__asm___5_clk_c_9a445bc2____REVSH| PROC
#line 480

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___5_clk_c_9a445bc2____RRX|
#line 666
|__asm___5_clk_c_9a445bc2____RRX| PROC
#line 667

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
