; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\obj\i2c.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\i2c.d --cpu=Cortex-M4.fp --apcs=interwork -O3 --diag_suppress=9931 -I..\..\..\..\Library\Device\Nuvoton\M480\Include -I..\..\..\..\Library\StdDriver\inc -I..\..\..\..\ThirdParty\emWin\Config -I..\..\..\..\ThirdParty\emWin\Include -I..\tslib -I..\..\..\..\Library\CMSIS\Include -I..\Thermostat -I..\Application\Source\Generated -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=523 --omf_browse=.\obj\i2c.crf ..\..\..\..\Library\StdDriver\src\i2c.c]
                          THUMB

                          AREA ||i.I2C_ClearTimeoutFlag||, CODE, READONLY, ALIGN=1

                  I2C_ClearTimeoutFlag PROC
;;;104      */
;;;105    void I2C_ClearTimeoutFlag(I2C_T *i2c)
000000  6941              LDR      r1,[r0,#0x14]
;;;106    {
;;;107        i2c->TOCTL |= I2C_TOCTL_TOIF_Msk;
000002  f0410101          ORR      r1,r1,#1
000006  6141              STR      r1,[r0,#0x14]
;;;108    }
000008  4770              BX       lr
;;;109    
                          ENDP


                          AREA ||i.I2C_Close||, CODE, READONLY, ALIGN=2

                  I2C_Close PROC
;;;71     
;;;72     void I2C_Close(I2C_T *i2c)
000000  4a13              LDR      r2,|L2.80|
;;;73     {
;;;74         /* Reset I2C Controller */
;;;75         if((uint32_t)i2c == I2C0_BASE)
;;;76         {
;;;77             SYS->IPRST1 |= SYS_IPRST1_I2C0RST_Msk;
000002  02d1              LSLS     r1,r2,#11
000004  4290              CMP      r0,r2                 ;75
000006  d107              BNE      |L2.24|
000008  68ca              LDR      r2,[r1,#0xc]
00000a  f4427280          ORR      r2,r2,#0x100
00000e  60ca              STR      r2,[r1,#0xc]
;;;78             SYS->IPRST1 &= ~SYS_IPRST1_I2C0RST_Msk;
000010  68ca              LDR      r2,[r1,#0xc]
000012  f4227280          BIC      r2,r2,#0x100
000016  e014              B        |L2.66|
                  |L2.24|
;;;79         }
;;;80         else if((uint32_t)i2c == I2C1_BASE)
000018  4a0e              LDR      r2,|L2.84|
00001a  4290              CMP      r0,r2
00001c  d107              BNE      |L2.46|
;;;81         {
;;;82             SYS->IPRST1 |= SYS_IPRST1_I2C1RST_Msk;
00001e  68ca              LDR      r2,[r1,#0xc]
000020  f4427200          ORR      r2,r2,#0x200
000024  60ca              STR      r2,[r1,#0xc]
;;;83             SYS->IPRST1 &= ~SYS_IPRST1_I2C1RST_Msk;
000026  68ca              LDR      r2,[r1,#0xc]
000028  f4227200          BIC      r2,r2,#0x200
00002c  e009              B        |L2.66|
                  |L2.46|
;;;84         }
;;;85         else if((uint32_t)i2c == I2C2_BASE)
00002e  4a0a              LDR      r2,|L2.88|
000030  4290              CMP      r0,r2
000032  d107              BNE      |L2.68|
;;;86         {
;;;87             SYS->IPRST1 |= SYS_IPRST1_I2C2RST_Msk;
000034  68ca              LDR      r2,[r1,#0xc]
000036  f4426280          ORR      r2,r2,#0x400
00003a  60ca              STR      r2,[r1,#0xc]
;;;88             SYS->IPRST1 &= ~SYS_IPRST1_I2C2RST_Msk;
00003c  68ca              LDR      r2,[r1,#0xc]
00003e  f4226280          BIC      r2,r2,#0x400
                  |L2.66|
000042  60ca              STR      r2,[r1,#0xc]
                  |L2.68|
;;;89         }
;;;90     
;;;91         /* Disable I2C */
;;;92         i2c->CTL0 &= ~I2C_CTL0_I2CEN_Msk;
000044  6801              LDR      r1,[r0,#0]
000046  f0210140          BIC      r1,r1,#0x40
00004a  6001              STR      r1,[r0,#0]
;;;93     }
00004c  4770              BX       lr
;;;94     
                          ENDP

00004e  0000              DCW      0x0000
                  |L2.80|
                          DCD      0x40080000
                  |L2.84|
                          DCD      0x40081000
                  |L2.88|
                          DCD      0x40082000

                          AREA ||i.I2C_DisableInt||, CODE, READONLY, ALIGN=1

                  I2C_DisableInt PROC
;;;160      */
;;;161    void I2C_DisableInt(I2C_T *i2c)
000000  6801              LDR      r1,[r0,#0]
;;;162    {
;;;163        i2c->CTL0 &= ~I2C_CTL0_INTEN_Msk;
000002  f0210180          BIC      r1,r1,#0x80
000006  6001              STR      r1,[r0,#0]
;;;164    }
000008  4770              BX       lr
;;;165    
                          ENDP


                          AREA ||i.I2C_DisableTimeout||, CODE, READONLY, ALIGN=1

                  I2C_DisableTimeout PROC
;;;406     */
;;;407    void I2C_DisableTimeout(I2C_T *i2c)
000000  6941              LDR      r1,[r0,#0x14]
;;;408    {
;;;409        i2c->TOCTL &= ~I2C_TOCTL_TOCEN_Msk;
000002  f0210104          BIC      r1,r1,#4
000006  6141              STR      r1,[r0,#0x14]
;;;410    }
000008  4770              BX       lr
;;;411    
                          ENDP


                          AREA ||i.I2C_DisableWakeup||, CODE, READONLY, ALIGN=1

                  I2C_DisableWakeup PROC
;;;436     */
;;;437    void I2C_DisableWakeup(I2C_T *i2c)
000000  6bc1              LDR      r1,[r0,#0x3c]
;;;438    {
;;;439        i2c->WKCTL &= ~I2C_WKCTL_WKEN_Msk;
000002  f0210101          BIC      r1,r1,#1
000006  63c1              STR      r1,[r0,#0x3c]
;;;440    }
000008  4770              BX       lr
;;;441    
                          ENDP


                          AREA ||i.I2C_EnableInt||, CODE, READONLY, ALIGN=1

                  I2C_EnableInt PROC
;;;175      */
;;;176    void I2C_EnableInt(I2C_T *i2c)
000000  6801              LDR      r1,[r0,#0]
;;;177    {
;;;178        i2c->CTL0 |= I2C_CTL0_INTEN_Msk;
000002  f0410180          ORR      r1,r1,#0x80
000006  6001              STR      r1,[r0,#0]
;;;179    }
000008  4770              BX       lr
;;;180    
                          ENDP


                          AREA ||i.I2C_EnableTimeout||, CODE, READONLY, ALIGN=1

                  I2C_EnableTimeout PROC
;;;382     */
;;;383    void I2C_EnableTimeout(I2C_T *i2c, uint8_t u8LongTimeout)
000000  2900              CMP      r1,#0
;;;384    {
;;;385        if(u8LongTimeout)
;;;386        {
;;;387            i2c->TOCTL |= I2C_TOCTL_TOCDIV4_Msk;
;;;388        }
;;;389        else
;;;390        {
;;;391            i2c->TOCTL &= ~I2C_TOCTL_TOCDIV4_Msk;
000002  6941              LDR      r1,[r0,#0x14]
000004  d002              BEQ      |L7.12|
000006  f0410102          ORR      r1,r1,#2              ;387
00000a  e001              B        |L7.16|
                  |L7.12|
00000c  f0210102          BIC      r1,r1,#2
                  |L7.16|
000010  6141              STR      r1,[r0,#0x14]
;;;392        }
;;;393    
;;;394        i2c->TOCTL |= I2C_TOCTL_TOCEN_Msk;
000012  6941              LDR      r1,[r0,#0x14]
000014  f0410104          ORR      r1,r1,#4
000018  6141              STR      r1,[r0,#0x14]
;;;395    }
00001a  4770              BX       lr
;;;396    
                          ENDP


                          AREA ||i.I2C_EnableWakeup||, CODE, READONLY, ALIGN=1

                  I2C_EnableWakeup PROC
;;;421     */
;;;422    void I2C_EnableWakeup(I2C_T *i2c)
000000  6bc1              LDR      r1,[r0,#0x3c]
;;;423    {
;;;424        i2c->WKCTL |= I2C_WKCTL_WKEN_Msk;
000002  f0410101          ORR      r1,r1,#1
000006  63c1              STR      r1,[r0,#0x3c]
;;;425    }
000008  4770              BX       lr
;;;426    
                          ENDP


                          AREA ||i.I2C_GetBusClockFreq||, CODE, READONLY, ALIGN=2

                  I2C_GetBusClockFreq PROC
;;;189     */
;;;190    uint32_t I2C_GetBusClockFreq(I2C_T *i2c)
000000  b510              PUSH     {r4,lr}
;;;191    {
;;;192        uint32_t u32Divider = i2c->CLKDIV;
000002  6904              LDR      r4,[r0,#0x10]
;;;193        uint32_t u32Pclk;
;;;194    
;;;195        if(i2c == I2C1)
000004  4906              LDR      r1,|L9.32|
000006  4288              CMP      r0,r1
000008  d102              BNE      |L9.16|
;;;196        {
;;;197            u32Pclk = CLK_GetPCLK1Freq();
00000a  f7fffffe          BL       CLK_GetPCLK1Freq
00000e  e001              B        |L9.20|
                  |L9.16|
;;;198        }
;;;199        else
;;;200        {
;;;201            u32Pclk = CLK_GetPCLK0Freq();
000010  f7fffffe          BL       CLK_GetPCLK0Freq
                  |L9.20|
000014  00a1              LSLS     r1,r4,#2
000016  1d09              ADDS     r1,r1,#4
;;;202        }
;;;203    
;;;204        return (u32Pclk / ((u32Divider + 1U) << 2U));
000018  fbb0f0f1          UDIV     r0,r0,r1
;;;205    }
00001c  bd10              POP      {r4,pc}
;;;206    
                          ENDP

00001e  0000              DCW      0x0000
                  |L9.32|
                          DCD      0x40081000

                          AREA ||i.I2C_GetData||, CODE, READONLY, ALIGN=1

                  I2C_GetData PROC
;;;284     */
;;;285    uint8_t I2C_GetData(I2C_T *i2c)
000000  6880              LDR      r0,[r0,#8]
;;;286    {
;;;287        return (uint8_t)(i2c->DAT);
000002  b2c0              UXTB     r0,r0
;;;288    }
000004  4770              BX       lr
;;;289    
                          ENDP


                          AREA ||i.I2C_GetIntFlag||, CODE, READONLY, ALIGN=1

                  I2C_GetIntFlag PROC
;;;245     */
;;;246    uint32_t I2C_GetIntFlag(I2C_T *i2c)
000000  6800              LDR      r0,[r0,#0]
;;;247    {
;;;248        uint32_t u32Value;
;;;249    
;;;250        if((i2c->CTL0 & I2C_CTL0_SI_Msk) == I2C_CTL0_SI_Msk)
000002  0700              LSLS     r0,r0,#28
000004  d501              BPL      |L11.10|
;;;251        {
;;;252            u32Value = 1U;
000006  2001              MOVS     r0,#1
;;;253        }
;;;254        else
;;;255        {
;;;256            u32Value = 0U;
;;;257        }
;;;258    
;;;259        return u32Value;
;;;260    }
000008  4770              BX       lr
                  |L11.10|
00000a  2000              MOVS     r0,#0                 ;256
00000c  4770              BX       lr
;;;261    
                          ENDP


                          AREA ||i.I2C_GetStatus||, CODE, READONLY, ALIGN=1

                  I2C_GetStatus PROC
;;;270     */
;;;271    uint32_t I2C_GetStatus(I2C_T *i2c)
000000  68c0              LDR      r0,[r0,#0xc]
;;;272    {
;;;273        return (i2c->STATUS0);
;;;274    }
000002  4770              BX       lr
;;;275    
                          ENDP


                          AREA ||i.I2C_Open||, CODE, READONLY, ALIGN=2

                  I2C_Open PROC
;;;37       */
;;;38     uint32_t I2C_Open(I2C_T *i2c, uint32_t u32BusClock)
000000  b570              PUSH     {r4-r6,lr}
;;;39     {
000002  4604              MOV      r4,r0
;;;40         uint32_t u32Div;
;;;41         uint32_t u32Pclk;
;;;42     
;;;43         if(i2c == I2C1)
000004  480e              LDR      r0,|L13.64|
000006  460d              MOV      r5,r1                 ;39
000008  4284              CMP      r4,r0
00000a  d102              BNE      |L13.18|
;;;44         {
;;;45             u32Pclk = CLK_GetPCLK1Freq();
00000c  f7fffffe          BL       CLK_GetPCLK1Freq
000010  e001              B        |L13.22|
                  |L13.18|
;;;46         }
;;;47         else
;;;48         {
;;;49             u32Pclk = CLK_GetPCLK0Freq();
000012  f7fffffe          BL       CLK_GetPCLK0Freq
                  |L13.22|
;;;50         }
;;;51     
;;;52         u32Div = (uint32_t)(((u32Pclk * 10U) / (u32BusClock * 4U) + 5U) / 10U - 1U); /* Compute proper divider for I2C clock */
000016  eb000180          ADD      r1,r0,r0,LSL #2
00001a  0049              LSLS     r1,r1,#1
00001c  00aa              LSLS     r2,r5,#2
00001e  fbb1f1f2          UDIV     r1,r1,r2
000022  220a              MOVS     r2,#0xa
000024  1d49              ADDS     r1,r1,#5
000026  fbb1f2f2          UDIV     r2,r1,r2
00002a  1e51              SUBS     r1,r2,#1
;;;53         i2c->CLKDIV = u32Div;
00002c  6121              STR      r1,[r4,#0x10]
;;;54     
;;;55         /* Enable I2C */
;;;56         i2c->CTL0 |= I2C_CTL0_I2CEN_Msk;
00002e  6821              LDR      r1,[r4,#0]
000030  f0410140          ORR      r1,r1,#0x40
000034  6021              STR      r1,[r4,#0]
000036  0091              LSLS     r1,r2,#2
;;;57     
;;;58         return (u32Pclk / ((u32Div + 1U) << 2U));
000038  fbb0f0f1          UDIV     r0,r0,r1
;;;59     }
00003c  bd70              POP      {r4-r6,pc}
;;;60     
                          ENDP

00003e  0000              DCW      0x0000
                  |L13.64|
                          DCD      0x40081000

                          AREA ||i.I2C_ReadByte||, CODE, READONLY, ALIGN=2

                  I2C_ReadByte PROC
;;;1128     */
;;;1129   uint8_t I2C_ReadByte(I2C_T *i2c, uint8_t u8SlaveAddr)
000000  b5f0              PUSH     {r4-r7,lr}
;;;1130   {
;;;1131       uint8_t u8Xfering = 1u, u8Err = 0u, rdata = 0u, u8Ctrl = 0u;
;;;1132   
;;;1133       g_I2C_i32ErrCode = 0;
000002  4e24              LDR      r6,|L14.148|
000004  2501              MOVS     r5,#1                 ;1131
000006  2300              MOVS     r3,#0                 ;1131
;;;1134   
;;;1135       I2C_START(i2c);                                                /* Send START */
000008  6033              STR      r3,[r6,#0]  ; g_I2C_i32ErrCode
00000a  6802              LDR      r2,[r0,#0]
00000c  461c              MOV      r4,r3                 ;1131
00000e  f0220208          BIC      r2,r2,#8
000012  f0420220          ORR      r2,r2,#0x20
000016  6002              STR      r2,[r0,#0]
;;;1136       while(u8Xfering && (u8Err == 0u))
;;;1137       {
;;;1138           uint32_t u32TimeOutCount = SystemCoreClock; // 1 second timeout
000018  4f1f              LDR      r7,|L14.152|
                  |L14.26|
;;;1139           I2C_WAIT_READY(i2c)
00001a  683a              LDR      r2,[r7,#0]  ; SystemCoreClock
00001c  e001              B        |L14.34|
                  |L14.30|
00001e  1e52              SUBS     r2,r2,#1
;;;1140           {
;;;1141               u32TimeOutCount--;
;;;1142               if(u32TimeOutCount == 0)
000020  d015              BEQ      |L14.78|
                  |L14.34|
000022  f8d0c000          LDR      r12,[r0,#0]           ;1139
000026  ea5f7c0c          LSLS     r12,r12,#28           ;1139
00002a  d5f8              BPL      |L14.30|
                  |L14.44|
;;;1143               {
;;;1144                   g_I2C_i32ErrCode = I2C_TIMEOUT_ERR;
;;;1145                   break;
;;;1146               }
;;;1147           }
;;;1148   
;;;1149           switch(I2C_GET_STATUS(i2c))
00002c  68c2              LDR      r2,[r0,#0xc]
00002e  2a08              CMP      r2,#8
000030  d011              BEQ      |L14.86|
000032  2a40              CMP      r2,#0x40
000034  d014              BEQ      |L14.96|
000036  2a48              CMP      r2,#0x48
000038  d014              BEQ      |L14.100|
00003a  2a58              CMP      r2,#0x58
00003c  d015              BEQ      |L14.106|
;;;1150           {
;;;1151           case 0x08u:
;;;1152               I2C_SET_DATA(i2c, (uint8_t)((u8SlaveAddr << 1u) | 0x01u));    /* Write SLA+R to Register I2CDAT */
;;;1153               u8Ctrl = I2C_CTL_SI;                             /* Clear SI */
;;;1154               break;
;;;1155           case 0x40u:                                             /* Slave Address ACK */
;;;1156               u8Ctrl = I2C_CTL_SI;                             /* Clear SI */
;;;1157               break;
;;;1158           case 0x48u:                                             /* Slave Address NACK */
;;;1159               u8Ctrl = I2C_CTL_STO_SI;                         /* Clear SI and send STOP */
;;;1160               u8Err = 1u;
;;;1161               break;
;;;1162           case 0x58u:
;;;1163               rdata = (unsigned char) I2C_GET_DATA(i2c);         /* Receive Data */
;;;1164               u8Ctrl = I2C_CTL_STO_SI;                         /* Clear SI and send STOP */
;;;1165               u8Xfering = 0u;
;;;1166               break;
;;;1167           case 0x38u:                                             /* Arbitration Lost */
;;;1168           default:                                               /* Unknow status */
;;;1169               I2C_SET_CONTROL_REG(i2c, I2C_CTL_STO_SI);        /* Clear SI and send STOP */
00003e  6802              LDR      r2,[r0,#0]
000040  f022023c          BIC      r2,r2,#0x3c
000044  f0420218          ORR      r2,r2,#0x18
000048  6002              STR      r2,[r0,#0]
;;;1170               u8Ctrl = I2C_CTL_SI;
00004a  2208              MOVS     r2,#8
;;;1171               u8Err = 1u;
;;;1172               break;
00004c  e00b              B        |L14.102|
                  |L14.78|
00004e  f04f32ff          MOV      r2,#0xffffffff        ;1144
000052  6032              STR      r2,[r6,#0]            ;1145  ; g_I2C_i32ErrCode
000054  e7ea              B        |L14.44|
                  |L14.86|
000056  2201              MOVS     r2,#1                 ;1152
000058  eb020241          ADD      r2,r2,r1,LSL #1       ;1152
00005c  b2d2              UXTB     r2,r2                 ;1152
00005e  6082              STR      r2,[r0,#8]            ;1152
                  |L14.96|
000060  2208              MOVS     r2,#8                 ;1156
000062  e006              B        |L14.114|
                  |L14.100|
000064  2218              MOVS     r2,#0x18              ;1159
                  |L14.102|
000066  2301              MOVS     r3,#1                 ;1160
000068  e003              B        |L14.114|
                  |L14.106|
00006a  6882              LDR      r2,[r0,#8]            ;1163
00006c  b2d4              UXTB     r4,r2                 ;1163
00006e  2218              MOVS     r2,#0x18              ;1164
000070  2500              MOVS     r5,#0                 ;1165
                  |L14.114|
;;;1173           }
;;;1174           I2C_SET_CONTROL_REG(i2c, u8Ctrl);                          /* Write controlbit to I2C_CTL register */
000072  f8d0c000          LDR      r12,[r0,#0]
000076  f02c0c3c          BIC      r12,r12,#0x3c
00007a  ea4c0c02          ORR      r12,r12,r2
00007e  f8c0c000          STR      r12,[r0,#0]
;;;1175       }
000082  b115              CBZ      r5,|L14.138|
000084  2b00              CMP      r3,#0                 ;1136
000086  d0c8              BEQ      |L14.26|
000088  e000              B        |L14.140|
                  |L14.138|
;;;1176       if(u8Err)
00008a  b103              CBZ      r3,|L14.142|
                  |L14.140|
;;;1177       {
;;;1178           rdata = 0u;                                                 /* If occurs error, return 0 */
00008c  2400              MOVS     r4,#0
                  |L14.142|
;;;1179       }
;;;1180       return rdata;                                                  /* Return read data */
00008e  4620              MOV      r0,r4
;;;1181   }
000090  bdf0              POP      {r4-r7,pc}
;;;1182   
                          ENDP

000092  0000              DCW      0x0000
                  |L14.148|
                          DCD      ||.data||
                  |L14.152|
                          DCD      SystemCoreClock

                          AREA ||i.I2C_ReadByteOneReg||, CODE, READONLY, ALIGN=2

                  I2C_ReadByteOneReg PROC
;;;1273     */
;;;1274   uint8_t I2C_ReadByteOneReg(I2C_T *i2c, uint8_t u8SlaveAddr, uint8_t u8DataAddr)
000000  e92d43f0          PUSH     {r4-r9,lr}
;;;1275   {
;;;1276       uint8_t u8Xfering = 1u, u8Err = 0u, rdata = 0u, u8Ctrl = 0u;
000004  2601              MOVS     r6,#1
;;;1277   
;;;1278       g_I2C_i32ErrCode = 0;
000006  4f2b              LDR      r7,|L15.180|
000008  2300              MOVS     r3,#0                 ;1276
00000a  4691              MOV      r9,r2                 ;1275
;;;1279   
;;;1280       I2C_START(i2c);                                                /* Send START */
00000c  603b              STR      r3,[r7,#0]  ; g_I2C_i32ErrCode
00000e  6804              LDR      r4,[r0,#0]
000010  461d              MOV      r5,r3                 ;1276
000012  461a              MOV      r2,r3                 ;1276
000014  f0240408          BIC      r4,r4,#8
000018  f0440420          ORR      r4,r4,#0x20
00001c  6004              STR      r4,[r0,#0]
;;;1281       while(u8Xfering && (u8Err == 0u))
;;;1282       {
;;;1283           uint32_t u32TimeOutCount = SystemCoreClock; // 1 second timeout
00001e  f8dfc098          LDR      r12,|L15.184|
                  |L15.34|
;;;1284           I2C_WAIT_READY(i2c)
000022  f8dc4000          LDR      r4,[r12,#0]  ; SystemCoreClock
000026  e001              B        |L15.44|
                  |L15.40|
000028  1e64              SUBS     r4,r4,#1
;;;1285           {
;;;1286               u32TimeOutCount--;
;;;1287               if(u32TimeOutCount == 0)
00002a  d009              BEQ      |L15.64|
                  |L15.44|
00002c  f8d08000          LDR      r8,[r0,#0]            ;1284
000030  ea5f7808          LSLS     r8,r8,#28             ;1284
000034  d5f8              BPL      |L15.40|
                  |L15.54|
;;;1288               {
;;;1289                   g_I2C_i32ErrCode = I2C_TIMEOUT_ERR;
;;;1290                   break;
;;;1291               }
;;;1292           }
;;;1293   
;;;1294           switch(I2C_GET_STATUS(i2c))
000036  68c4              LDR      r4,[r0,#0xc]
000038  f0140f07          TST      r4,#7
00003c  d004              BEQ      |L15.72|
00003e  e02c              B        |L15.154|
                  |L15.64|
000040  f04f34ff          MOV      r4,#0xffffffff        ;1289
000044  603c              STR      r4,[r7,#0]            ;1290  ; g_I2C_i32ErrCode
000046  e7f6              B        |L15.54|
                  |L15.72|
000048  10e4              ASRS     r4,r4,#3
00004a  2c0c              CMP      r4,#0xc
00004c  d225              BCS      |L15.154|
00004e  e8dff004          TBB      [pc,r4]
000052  2406              DCB      0x24,0x06
000054  10080b0e          DCB      0x10,0x08,0x0b,0x0e
000058  0b24150b          DCB      0x0b,0x24,0x15,0x0b
00005c  2417              DCB      0x24,0x17
;;;1295           {
;;;1296           case 0x08u:
;;;1297               I2C_SET_DATA(i2c, (uint8_t)(u8SlaveAddr << 1u | 0x00u));      /* Write SLA+W to Register I2CDAT */
00005e  004a              LSLS     r2,r1,#1
;;;1298               u8Ctrl = I2C_CTL_SI;                             /* Clear SI */
;;;1299               break;
000060  e00a              B        |L15.120|
;;;1300           case 0x18u:                                             /* Slave Address ACK */
;;;1301               I2C_SET_DATA(i2c, u8DataAddr);                     /* Write Lo byte address of register */
000062  f8c09008          STR      r9,[r0,#8]
;;;1302               break;
000066  e00f              B        |L15.136|
;;;1303           case 0x20u:                                             /* Slave Address NACK */
;;;1304           case 0x30u:                                             /* Master transmit data NACK */
;;;1305               u8Ctrl = I2C_CTL_STO_SI;                         /* Clear SI and send STOP */
000068  2218              MOVS     r2,#0x18
                  |L15.106|
;;;1306               u8Err = 1u;
00006a  2301              MOVS     r3,#1
00006c  e00c              B        |L15.136|
;;;1307               break;
;;;1308           case 0x28u:
;;;1309               u8Ctrl = I2C_CTL_STA_SI;                         /* Send repeat START */
00006e  2228              MOVS     r2,#0x28
;;;1310               break;
000070  e00a              B        |L15.136|
;;;1311           case 0x10u:
;;;1312               I2C_SET_DATA(i2c, (uint8_t)((u8SlaveAddr << 1u) | 0x01u));    /* Write SLA+R to Register I2CDAT */
000072  2201              MOVS     r2,#1
000074  eb020241          ADD      r2,r2,r1,LSL #1
                  |L15.120|
000078  b2d2              UXTB     r2,r2                 ;1297
00007a  6082              STR      r2,[r0,#8]            ;1297
;;;1313               u8Ctrl = I2C_CTL_SI;                               /* Clear SI */
;;;1314               break;
;;;1315           case 0x40u:                                             /* Slave Address ACK */
;;;1316               u8Ctrl = I2C_CTL_SI;                             /* Clear SI */
00007c  2208              MOVS     r2,#8
;;;1317               break;
00007e  e003              B        |L15.136|
;;;1318           case 0x48u:                                             /* Slave Address NACK */
;;;1319               u8Ctrl = I2C_CTL_STO_SI;                         /* Clear SI and send STOP */
;;;1320               u8Err = 1u;
;;;1321               break;
;;;1322           case 0x58u:
;;;1323               rdata = (uint8_t) I2C_GET_DATA(i2c);               /* Receive Data */
000080  6882              LDR      r2,[r0,#8]
000082  b2d5              UXTB     r5,r2
;;;1324               u8Ctrl = I2C_CTL_STO_SI;                         /* Clear SI and send STOP */
000084  2218              MOVS     r2,#0x18
;;;1325               u8Xfering = 0u;
000086  2600              MOVS     r6,#0
                  |L15.136|
;;;1326               break;
;;;1327           case 0x38u:                                             /* Arbitration Lost */
;;;1328           default:                                               /* Unknow status */
;;;1329               I2C_SET_CONTROL_REG(i2c, I2C_CTL_STO_SI);        /* Clear SI and send STOP */
;;;1330               u8Ctrl = I2C_CTL_SI;
;;;1331               u8Err = 1u;
;;;1332               break;
;;;1333           }
;;;1334           I2C_SET_CONTROL_REG(i2c, u8Ctrl);                          /* Write controlbit to I2C_CTL register */
000088  6804              LDR      r4,[r0,#0]
00008a  f024043c          BIC      r4,r4,#0x3c
00008e  4314              ORRS     r4,r4,r2
000090  6004              STR      r4,[r0,#0]
;;;1335       }
000092  b156              CBZ      r6,|L15.170|
000094  2b00              CMP      r3,#0                 ;1281
000096  d0c4              BEQ      |L15.34|
000098  e008              B        |L15.172|
                  |L15.154|
00009a  6802              LDR      r2,[r0,#0]            ;1329
00009c  f022023c          BIC      r2,r2,#0x3c           ;1329
0000a0  f0420218          ORR      r2,r2,#0x18           ;1329
0000a4  6002              STR      r2,[r0,#0]            ;1329
0000a6  2208              MOVS     r2,#8                 ;1330
0000a8  e7df              B        |L15.106|
                  |L15.170|
;;;1336       if(u8Err)
0000aa  b103              CBZ      r3,|L15.174|
                  |L15.172|
;;;1337       {
;;;1338           rdata = 0u;                                                 /* If occurs error, return 0 */
0000ac  2500              MOVS     r5,#0
                  |L15.174|
;;;1339       }
;;;1340       return rdata;                                                  /* Return read data */
0000ae  4628              MOV      r0,r5
;;;1341   }
0000b0  e8bd83f0          POP      {r4-r9,pc}
;;;1342   
                          ENDP

                  |L15.180|
                          DCD      ||.data||
                  |L15.184|
                          DCD      SystemCoreClock

                          AREA ||i.I2C_ReadByteTwoRegs||, CODE, READONLY, ALIGN=2

                  I2C_ReadByteTwoRegs PROC
;;;1447     */
;;;1448   uint8_t I2C_ReadByteTwoRegs(I2C_T *i2c, uint8_t u8SlaveAddr, uint16_t u16DataAddr)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1449   {
;;;1450       uint8_t u8Xfering = 1u, u8Err = 0u, rdata = 0u, u8Addr = 1u, u8Ctrl = 0u;
000004  2601              MOVS     r6,#1
000006  4692              MOV      r10,r2                ;1449
;;;1451   
;;;1452       g_I2C_i32ErrCode = 0;
000008  4f2f              LDR      r7,|L16.200|
00000a  2200              MOVS     r2,#0                 ;1450
00000c  4689              MOV      r9,r1                 ;1449
;;;1453   
;;;1454       I2C_START(i2c);                                                         /* Send START */
00000e  603a              STR      r2,[r7,#0]  ; g_I2C_i32ErrCode
000010  6803              LDR      r3,[r0,#0]
000012  4614              MOV      r4,r2                 ;1450
000014  4635              MOV      r5,r6                 ;1450
000016  4611              MOV      r1,r2                 ;1450
000018  f0230308          BIC      r3,r3,#8
00001c  f0430320          ORR      r3,r3,#0x20
000020  6003              STR      r3,[r0,#0]
;;;1455       while(u8Xfering && (u8Err == 0u))
;;;1456       {
;;;1457           uint32_t u32TimeOutCount = SystemCoreClock; // 1 second timeout
000022  f8dfc0a8          LDR      r12,|L16.204|
                  |L16.38|
;;;1458           I2C_WAIT_READY(i2c)
000026  f8dc3000          LDR      r3,[r12,#0]  ; SystemCoreClock
00002a  e001              B        |L16.48|
                  |L16.44|
00002c  1e5b              SUBS     r3,r3,#1
;;;1459           {
;;;1460               u32TimeOutCount--;
;;;1461               if(u32TimeOutCount == 0)
00002e  d009              BEQ      |L16.68|
                  |L16.48|
000030  f8d08000          LDR      r8,[r0,#0]            ;1458
000034  ea5f7808          LSLS     r8,r8,#28             ;1458
000038  d5f8              BPL      |L16.44|
                  |L16.58|
;;;1462               {
;;;1463                   g_I2C_i32ErrCode = I2C_TIMEOUT_ERR;
;;;1464                   break;
;;;1465               }
;;;1466           }
;;;1467   
;;;1468           switch(I2C_GET_STATUS(i2c))
00003a  68c3              LDR      r3,[r0,#0xc]
00003c  f0130f07          TST      r3,#7
000040  d004              BEQ      |L16.76|
000042  e034              B        |L16.174|
                  |L16.68|
000044  f04f33ff          MOV      r3,#0xffffffff        ;1463
000048  603b              STR      r3,[r7,#0]            ;1464  ; g_I2C_i32ErrCode
00004a  e7f6              B        |L16.58|
                  |L16.76|
00004c  10db              ASRS     r3,r3,#3
00004e  2b0c              CMP      r3,#0xc
000050  d22d              BCS      |L16.174|
000052  e8dff003          TBB      [pc,r3]
000056  2c06              DCB      0x2c,0x06
000058  18090d10          DCB      0x18,0x09,0x0d,0x10
00005c  0d2c1d0d          DCB      0x0d,0x2c,0x1d,0x0d
000060  2c1f              DCB      0x2c,0x1f
;;;1469           {
;;;1470           case 0x08u:
;;;1471               I2C_SET_DATA(i2c, (uint8_t)(u8SlaveAddr << 1u | 0x00u));               /* Write SLA+W to Register I2CDAT */
000062  ea4f0149          LSL      r1,r9,#1
;;;1472               u8Ctrl = I2C_CTL_SI;                                      /* Clear SI */
;;;1473               break;
000066  e011              B        |L16.140|
;;;1474           case 0x18u:                                                      /* Slave Address ACK */
;;;1475               I2C_SET_DATA(i2c, (uint8_t)((u16DataAddr & 0xFF00u) >> 8u));    /* Write Hi byte address of register */
000068  ea4f231a          LSR      r3,r10,#8
00006c  6083              STR      r3,[r0,#8]
;;;1476               break;
00006e  e015              B        |L16.156|
;;;1477           case 0x20u:                                                      /* Slave Address NACK */
;;;1478           case 0x30u:                                                      /* Master transmit data NACK */
;;;1479               u8Ctrl = I2C_CTL_STO_SI;                                  /* Clear SI and send STOP */
000070  2118              MOVS     r1,#0x18
                  |L16.114|
;;;1480               u8Err = 1u;
000072  2201              MOVS     r2,#1
000074  e012              B        |L16.156|
;;;1481               break;
;;;1482           case 0x28u:
;;;1483               if(u8Addr)
000076  b125              CBZ      r5,|L16.130|
;;;1484               {
;;;1485                   I2C_SET_DATA(i2c, (uint8_t)(u16DataAddr & 0xFFu));       /* Write Lo byte address of register */
000078  f00a03ff          AND      r3,r10,#0xff
00007c  6083              STR      r3,[r0,#8]
;;;1486                   u8Addr = 0u;
00007e  2500              MOVS     r5,#0
000080  e00c              B        |L16.156|
                  |L16.130|
;;;1487               }
;;;1488               else
;;;1489               {
;;;1490                   u8Ctrl = I2C_CTL_STA_SI;                              /* Clear SI and send repeat START */
000082  2128              MOVS     r1,#0x28
000084  e00a              B        |L16.156|
;;;1491               }
;;;1492               break;
;;;1493           case 0x10u:
;;;1494               I2C_SET_DATA(i2c, (uint8_t)((u8SlaveAddr << 1u) | 0x01u));             /* Write SLA+R to Register I2CDAT */
000086  2301              MOVS     r3,#1
000088  eb030149          ADD      r1,r3,r9,LSL #1
                  |L16.140|
00008c  b2c9              UXTB     r1,r1                 ;1471
00008e  6081              STR      r1,[r0,#8]            ;1471
;;;1495               u8Ctrl = I2C_CTL_SI;                                      /* Clear SI */
;;;1496               break;
;;;1497           case 0x40u:                                                      /* Slave Address ACK */
;;;1498               u8Ctrl = I2C_CTL_SI;                                      /* Clear SI */
000090  2108              MOVS     r1,#8
;;;1499               break;
000092  e003              B        |L16.156|
;;;1500           case 0x48u:                                                      /* Slave Address NACK */
;;;1501               u8Ctrl = I2C_CTL_STO_SI;                                  /* Clear SI and send STOP */
;;;1502               u8Err = 1u;
;;;1503               break;
;;;1504           case 0x58u:
;;;1505               rdata = (unsigned char) I2C_GET_DATA(i2c);                  /* Receive Data */
000094  6881              LDR      r1,[r0,#8]
000096  b2cc              UXTB     r4,r1
;;;1506               u8Ctrl = I2C_CTL_STO_SI;                                  /* Clear SI and send STOP */
000098  2118              MOVS     r1,#0x18
;;;1507               u8Xfering = 0u;
00009a  2600              MOVS     r6,#0
                  |L16.156|
;;;1508               break;
;;;1509           case 0x38u:                                                      /* Arbitration Lost */
;;;1510           default:                                                        /* Unknow status */
;;;1511               I2C_SET_CONTROL_REG(i2c, I2C_CTL_STO_SI);                 /* Clear SI and send STOP */
;;;1512               u8Ctrl = I2C_CTL_SI;
;;;1513               u8Err = 1u;
;;;1514               break;
;;;1515           }
;;;1516           I2C_SET_CONTROL_REG(i2c, u8Ctrl);                                   /* Write controlbit to I2C_CTL register */
00009c  6803              LDR      r3,[r0,#0]
00009e  f023033c          BIC      r3,r3,#0x3c
0000a2  430b              ORRS     r3,r3,r1
0000a4  6003              STR      r3,[r0,#0]
;;;1517       }
0000a6  b156              CBZ      r6,|L16.190|
0000a8  2a00              CMP      r2,#0                 ;1455
0000aa  d0bc              BEQ      |L16.38|
0000ac  e008              B        |L16.192|
                  |L16.174|
0000ae  6801              LDR      r1,[r0,#0]            ;1511
0000b0  f021013c          BIC      r1,r1,#0x3c           ;1511
0000b4  f0410118          ORR      r1,r1,#0x18           ;1511
0000b8  6001              STR      r1,[r0,#0]            ;1511
0000ba  2108              MOVS     r1,#8                 ;1512
0000bc  e7d9              B        |L16.114|
                  |L16.190|
;;;1518       if(u8Err)
0000be  b102              CBZ      r2,|L16.194|
                  |L16.192|
;;;1519       {
;;;1520           rdata = 0u;                                                          /* If occurs error, return 0 */
0000c0  2400              MOVS     r4,#0
                  |L16.194|
;;;1521       }
;;;1522       return rdata;                                                           /* Return read data */
0000c2  4620              MOV      r0,r4
;;;1523   }
0000c4  e8bd87f0          POP      {r4-r10,pc}
;;;1524   
                          ENDP

                  |L16.200|
                          DCD      ||.data||
                  |L16.204|
                          DCD      SystemCoreClock

                          AREA ||i.I2C_ReadMultiBytes||, CODE, READONLY, ALIGN=2

                  I2C_ReadMultiBytes PROC
;;;1197     */
;;;1198   uint32_t I2C_ReadMultiBytes(I2C_T *i2c, uint8_t u8SlaveAddr, uint8_t rdata[], uint32_t u32rLen)
000000  e92d43f0          PUSH     {r4-r9,lr}
;;;1199   {
;;;1200       uint8_t u8Xfering = 1u, u8Err = 0u, u8Ctrl = 0u;
;;;1201       uint32_t u32rxLen = 0u;
;;;1202   
;;;1203       g_I2C_i32ErrCode = 0;
000004  4f2b              LDR      r7,|L17.180|
000006  2601              MOVS     r6,#1                 ;1200
000008  2500              MOVS     r5,#0                 ;1200
;;;1204   
;;;1205       I2C_START(i2c);                                                /* Send START */
00000a  603d              STR      r5,[r7,#0]  ; g_I2C_i32ErrCode
00000c  4699              MOV      r9,r3                 ;1199
00000e  6804              LDR      r4,[r0,#0]
000010  462b              MOV      r3,r5                 ;1201
000012  f0240408          BIC      r4,r4,#8
000016  f0440420          ORR      r4,r4,#0x20
00001a  6004              STR      r4,[r0,#0]
;;;1206       while(u8Xfering && (u8Err == 0u))
;;;1207       {
;;;1208           uint32_t u32TimeOutCount = SystemCoreClock; // 1 second timeout
00001c  f8dfc098          LDR      r12,|L17.184|
                  |L17.32|
;;;1209           I2C_WAIT_READY(i2c)
000020  f8dc4000          LDR      r4,[r12,#0]  ; SystemCoreClock
000024  e001              B        |L17.42|
                  |L17.38|
000026  1e64              SUBS     r4,r4,#1
;;;1210           {
;;;1211               u32TimeOutCount--;
;;;1212               if(u32TimeOutCount == 0)
000028  d00d              BEQ      |L17.70|
                  |L17.42|
00002a  f8d08000          LDR      r8,[r0,#0]            ;1209
00002e  ea5f7808          LSLS     r8,r8,#28             ;1209
000032  d5f8              BPL      |L17.38|
                  |L17.52|
;;;1213               {
;;;1214                   g_I2C_i32ErrCode = I2C_TIMEOUT_ERR;
;;;1215                   break;
;;;1216               }
;;;1217           }
;;;1218   
;;;1219           switch(I2C_GET_STATUS(i2c))
000034  68c4              LDR      r4,[r0,#0xc]
000036  2c48              CMP      r4,#0x48
000038  d01b              BEQ      |L17.114|
00003a  dc08              BGT      |L17.78|
00003c  2c08              CMP      r4,#8
00003e  d012              BEQ      |L17.102|
000040  2c40              CMP      r4,#0x40
000042  d108              BNE      |L17.86|
000044  e01f              B        |L17.134|
                  |L17.70|
000046  f04f34ff          MOV      r4,#0xffffffff        ;1214
00004a  603c              STR      r4,[r7,#0]            ;1215  ; g_I2C_i32ErrCode
00004c  e7f2              B        |L17.52|
                  |L17.78|
00004e  2c50              CMP      r4,#0x50
000050  d012              BEQ      |L17.120|
000052  2c58              CMP      r4,#0x58
000054  d01b              BEQ      |L17.142|
                  |L17.86|
;;;1220           {
;;;1221           case 0x08u:
;;;1222               I2C_SET_DATA(i2c, (uint8_t)((u8SlaveAddr << 1u) | 0x01u));    /* Write SLA+R to Register I2CDAT */
;;;1223               u8Ctrl = I2C_CTL_SI;                             /* Clear SI */
;;;1224               break;
;;;1225           case 0x40u:                                             /* Slave Address ACK */
;;;1226               u8Ctrl = I2C_CTL_SI_AA;                          /* Clear SI and set ACK */
;;;1227               break;
;;;1228           case 0x48u:                                             /* Slave Address NACK */
;;;1229               u8Ctrl = I2C_CTL_STO_SI;                         /* Clear SI and send STOP */
;;;1230               u8Err = 1u;
;;;1231               break;
;;;1232           case 0x50u:
;;;1233               rdata[u32rxLen++] = (unsigned char) I2C_GET_DATA(i2c);    /* Receive Data */
;;;1234               if(u32rxLen < (u32rLen - 1u))
;;;1235               {
;;;1236                   u8Ctrl = I2C_CTL_SI_AA;                             /* Clear SI and set ACK */
;;;1237               }
;;;1238               else
;;;1239               {
;;;1240                   u8Ctrl = I2C_CTL_SI;                                /* Clear SI */
;;;1241               }
;;;1242               break;
;;;1243           case 0x58u:
;;;1244               rdata[u32rxLen++] = (unsigned char) I2C_GET_DATA(i2c);    /* Receive Data */
;;;1245               u8Ctrl = I2C_CTL_STO_SI;                                /* Clear SI and send STOP */
;;;1246               u8Xfering = 0u;
;;;1247               break;
;;;1248           case 0x38u:                                                    /* Arbitration Lost */
;;;1249           default:                                                      /* Unknow status */
;;;1250               I2C_SET_CONTROL_REG(i2c, I2C_CTL_STO_SI);               /* Clear SI and send STOP */
000056  6804              LDR      r4,[r0,#0]
000058  f024043c          BIC      r4,r4,#0x3c
00005c  f0440418          ORR      r4,r4,#0x18
000060  6004              STR      r4,[r0,#0]
;;;1251               u8Ctrl = I2C_CTL_SI;
000062  2408              MOVS     r4,#8
;;;1252               u8Err = 1u;
;;;1253               break;
000064  e006              B        |L17.116|
                  |L17.102|
000066  2401              MOVS     r4,#1                 ;1222
000068  eb040441          ADD      r4,r4,r1,LSL #1       ;1222
00006c  b2e4              UXTB     r4,r4                 ;1222
00006e  6084              STR      r4,[r0,#8]            ;1222
000070  e00b              B        |L17.138|
                  |L17.114|
000072  2418              MOVS     r4,#0x18              ;1229
                  |L17.116|
000074  2501              MOVS     r5,#1                 ;1230
000076  e00f              B        |L17.152|
                  |L17.120|
000078  6884              LDR      r4,[r0,#8]            ;1233
00007a  54d4              STRB     r4,[r2,r3]            ;1233
00007c  f1a90401          SUB      r4,r9,#1              ;1234
000080  1c5b              ADDS     r3,r3,#1              ;1234
000082  42a3              CMP      r3,r4                 ;1234
000084  d201              BCS      |L17.138|
                  |L17.134|
000086  240c              MOVS     r4,#0xc               ;1236
000088  e006              B        |L17.152|
                  |L17.138|
00008a  2408              MOVS     r4,#8                 ;1240
00008c  e004              B        |L17.152|
                  |L17.142|
00008e  6884              LDR      r4,[r0,#8]            ;1244
000090  54d4              STRB     r4,[r2,r3]            ;1244
000092  2418              MOVS     r4,#0x18              ;1245
000094  2600              MOVS     r6,#0                 ;1246
000096  1c5b              ADDS     r3,r3,#1              ;1246
                  |L17.152|
;;;1254           }
;;;1255           I2C_SET_CONTROL_REG(i2c, u8Ctrl);                                 /* Write controlbit to I2C_CTL register */
000098  f8d08000          LDR      r8,[r0,#0]
00009c  f028083c          BIC      r8,r8,#0x3c
0000a0  ea480804          ORR      r8,r8,r4
0000a4  f8c08000          STR      r8,[r0,#0]
;;;1256       }
0000a8  b10e              CBZ      r6,|L17.174|
0000aa  2d00              CMP      r5,#0                 ;1206
0000ac  d0b8              BEQ      |L17.32|
                  |L17.174|
;;;1257       return u32rxLen;                                                      /* Return bytes length that have been received */
0000ae  4618              MOV      r0,r3
;;;1258   }
0000b0  e8bd83f0          POP      {r4-r9,pc}
;;;1259   
                          ENDP

                  |L17.180|
                          DCD      ||.data||
                  |L17.184|
                          DCD      SystemCoreClock

                          AREA ||i.I2C_ReadMultiBytesOneReg||, CODE, READONLY, ALIGN=2

                  I2C_ReadMultiBytesOneReg PROC
;;;1357     */
;;;1358   uint32_t I2C_ReadMultiBytesOneReg(I2C_T *i2c, uint8_t u8SlaveAddr, uint8_t u8DataAddr, uint8_t rdata[], uint32_t u32rLen)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;1359   {
;;;1360       uint8_t u8Xfering = 1u, u8Err = 0u, u8Ctrl = 0u;
000004  2601              MOVS     r6,#1
;;;1361       uint32_t u32rxLen = 0u;
;;;1362   
;;;1363       g_I2C_i32ErrCode = 0;
000006  4f33              LDR      r7,|L18.212|
000008  2400              MOVS     r4,#0                 ;1360
00000a  f8ddb024          LDR      r11,[sp,#0x24]
;;;1364   
;;;1365       I2C_START(i2c);                                                /* Send START */
00000e  603c              STR      r4,[r7,#0]  ; g_I2C_i32ErrCode
000010  4692              MOV      r10,r2                ;1359
000012  4689              MOV      r9,r1                 ;1359
000014  6805              LDR      r5,[r0,#0]
000016  4621              MOV      r1,r4                 ;1360
000018  4622              MOV      r2,r4                 ;1361
00001a  f0250508          BIC      r5,r5,#8
00001e  f0450520          ORR      r5,r5,#0x20
000022  6005              STR      r5,[r0,#0]
;;;1366       while(u8Xfering && (u8Err == 0u))
;;;1367       {
;;;1368           uint32_t u32TimeOutCount = SystemCoreClock; // 1 second timeout
000024  f8dfc0b0          LDR      r12,|L18.216|
                  |L18.40|
;;;1369           I2C_WAIT_READY(i2c)
000028  f8dc5000          LDR      r5,[r12,#0]  ; SystemCoreClock
00002c  e001              B        |L18.50|
                  |L18.46|
00002e  1e6d              SUBS     r5,r5,#1
;;;1370           {
;;;1371               u32TimeOutCount--;
;;;1372               if(u32TimeOutCount == 0)
000030  d009              BEQ      |L18.70|
                  |L18.50|
000032  f8d08000          LDR      r8,[r0,#0]            ;1369
000036  ea5f7808          LSLS     r8,r8,#28             ;1369
00003a  d5f8              BPL      |L18.46|
                  |L18.60|
;;;1373               {
;;;1374                   g_I2C_i32ErrCode = I2C_TIMEOUT_ERR;
;;;1375                   break;
;;;1376               }
;;;1377           }
;;;1378   
;;;1379           switch(I2C_GET_STATUS(i2c))
00003c  68c5              LDR      r5,[r0,#0xc]
00003e  f0150f07          TST      r5,#7
000042  d004              BEQ      |L18.78|
000044  e03e              B        |L18.196|
                  |L18.70|
000046  f04f35ff          MOV      r5,#0xffffffff        ;1374
00004a  603d              STR      r5,[r7,#0]            ;1375  ; g_I2C_i32ErrCode
00004c  e7f6              B        |L18.60|
                  |L18.78|
00004e  10ed              ASRS     r5,r5,#3
000050  2d0c              CMP      r5,#0xc
000052  d237              BCS      |L18.196|
000054  e8dff005          TBB      [pc,r5]
000058  36061109          DCB      0x36,0x06,0x11,0x09
00005c  0c0f0c36          DCB      0x0c,0x0f,0x0c,0x36
000060  1e0c172c          DCB      0x1e,0x0c,0x17,0x2c
;;;1380           {
;;;1381           case 0x08u:
;;;1382               I2C_SET_DATA(i2c, (uint8_t)(u8SlaveAddr << 1u | 0x00u));      /* Write SLA+W to Register I2CDAT */
000064  ea4f0149          LSL      r1,r9,#1
;;;1383               u8Ctrl = I2C_CTL_SI;                             /* Clear SI */
;;;1384               break;
000068  e00a              B        |L18.128|
;;;1385           case 0x18u:                                             /* Slave Address ACK */
;;;1386               I2C_SET_DATA(i2c, u8DataAddr);                     /* Write Lo byte address of register */
00006a  f8c0a008          STR      r10,[r0,#8]
;;;1387               break;
00006e  e014              B        |L18.154|
;;;1388           case 0x20u:                                             /* Slave Address NACK */
;;;1389           case 0x30u:                                             /* Master transmit data NACK */
;;;1390               u8Ctrl = I2C_CTL_STO_SI;                         /* Clear SI and send STOP */
000070  2118              MOVS     r1,#0x18
                  |L18.114|
;;;1391               u8Err = 1u;
000072  2401              MOVS     r4,#1
000074  e011              B        |L18.154|
;;;1392               break;
;;;1393           case 0x28u:
;;;1394               u8Ctrl = I2C_CTL_STA_SI;                         /* Send repeat START */
000076  2128              MOVS     r1,#0x28
;;;1395               break;
000078  e00f              B        |L18.154|
;;;1396           case 0x10u:
;;;1397               I2C_SET_DATA(i2c, (uint8_t)((u8SlaveAddr << 1u) | 0x01u));    /* Write SLA+R to Register I2CDAT */
00007a  2501              MOVS     r5,#1
00007c  eb050149          ADD      r1,r5,r9,LSL #1
                  |L18.128|
000080  b2c9              UXTB     r1,r1
000082  6081              STR      r1,[r0,#8]
000084  e008              B        |L18.152|
;;;1398               u8Ctrl = I2C_CTL_SI;                             /* Clear SI */
;;;1399               break;
;;;1400           case 0x40u:                                             /* Slave Address ACK */
;;;1401               u8Ctrl = I2C_CTL_SI_AA;                          /* Clear SI and set ACK */
;;;1402               break;
;;;1403           case 0x48u:                                             /* Slave Address NACK */
;;;1404               u8Ctrl = I2C_CTL_STO_SI;                         /* Clear SI and send STOP */
;;;1405               u8Err = 1u;
;;;1406               break;
;;;1407           case 0x50u:
;;;1408               rdata[u32rxLen++] = (uint8_t) I2C_GET_DATA(i2c);   /* Receive Data */
000086  6881              LDR      r1,[r0,#8]
000088  5499              STRB     r1,[r3,r2]
;;;1409               if(u32rxLen < (u32rLen - 1u))
00008a  f1ab0101          SUB      r1,r11,#1
00008e  1c52              ADDS     r2,r2,#1
000090  428a              CMP      r2,r1
000092  d201              BCS      |L18.152|
;;;1410               {
;;;1411                   u8Ctrl = I2C_CTL_SI_AA;                      /* Clear SI and set ACK */
000094  210c              MOVS     r1,#0xc
000096  e000              B        |L18.154|
                  |L18.152|
;;;1412               }
;;;1413               else
;;;1414               {
;;;1415                   u8Ctrl = I2C_CTL_SI;                         /* Clear SI */
000098  2108              MOVS     r1,#8
                  |L18.154|
;;;1416               }
;;;1417               break;
;;;1418           case 0x58u:
;;;1419               rdata[u32rxLen++] = (uint8_t) I2C_GET_DATA(i2c);   /* Receive Data */
;;;1420               u8Ctrl = I2C_CTL_STO_SI;                         /* Clear SI and send STOP */
;;;1421               u8Xfering = 0u;
;;;1422               break;
;;;1423           case 0x38u:                                             /* Arbitration Lost */
;;;1424           default:                                               /* Unknow status */
;;;1425               I2C_SET_CONTROL_REG(i2c, I2C_CTL_STO_SI);        /* Clear SI and send STOP */
;;;1426               u8Ctrl = I2C_CTL_SI;
;;;1427               u8Err = 1u;
;;;1428               break;
;;;1429           }
;;;1430           I2C_SET_CONTROL_REG(i2c, u8Ctrl);                          /* Write controlbit to I2C_CTL register */
00009a  6805              LDR      r5,[r0,#0]
00009c  f025053c          BIC      r5,r5,#0x3c
0000a0  430d              ORRS     r5,r5,r1
0000a2  6005              STR      r5,[r0,#0]
;;;1431       }
0000a4  b10e              CBZ      r6,|L18.170|
0000a6  2c00              CMP      r4,#0                 ;1366
0000a8  d0be              BEQ      |L18.40|
                  |L18.170|
;;;1432       return u32rxLen;                                               /* Return bytes length that have been received */
0000aa  4610              MOV      r0,r2
;;;1433   }
0000ac  e8bd8ff0          POP      {r4-r11,pc}
0000b0  6881              LDR      r1,[r0,#8]            ;1419
0000b2  5499              STRB     r1,[r3,r2]            ;1419
0000b4  6805              LDR      r5,[r0,#0]            ;1430
0000b6  f025053c          BIC      r5,r5,#0x3c           ;1430
0000ba  f0450518          ORR      r5,r5,#0x18           ;1430
0000be  6005              STR      r5,[r0,#0]            ;1430
0000c0  1c52              ADDS     r2,r2,#1              ;1430
0000c2  e7f2              B        |L18.170|
                  |L18.196|
0000c4  6801              LDR      r1,[r0,#0]            ;1425
0000c6  f021013c          BIC      r1,r1,#0x3c           ;1425
0000ca  f0410118          ORR      r1,r1,#0x18           ;1425
0000ce  6001              STR      r1,[r0,#0]            ;1425
0000d0  2108              MOVS     r1,#8                 ;1426
0000d2  e7ce              B        |L18.114|
;;;1434   
                          ENDP

                  |L18.212|
                          DCD      ||.data||
                  |L18.216|
                          DCD      SystemCoreClock

                          AREA ||i.I2C_ReadMultiBytesTwoRegs||, CODE, READONLY, ALIGN=2

                  I2C_ReadMultiBytesTwoRegs PROC
;;;1539     */
;;;1540   uint32_t I2C_ReadMultiBytesTwoRegs(I2C_T *i2c, uint8_t u8SlaveAddr, uint16_t u16DataAddr, uint8_t rdata[], uint32_t u32rLen)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;1541   {
;;;1542       uint8_t u8Xfering = 1u, u8Err = 0u, u8Addr = 1u, u8Ctrl = 0u;
000004  2601              MOVS     r6,#1
000006  4699              MOV      r9,r3                 ;1541
;;;1543       uint32_t u32rxLen = 0u;
;;;1544   
;;;1545       g_I2C_i32ErrCode = 0;
000008  4f38              LDR      r7,|L19.236|
00000a  2300              MOVS     r3,#0                 ;1542
00000c  f8dde024          LDR      lr,[sp,#0x24]
;;;1546   
;;;1547       I2C_START(i2c);                                                         /* Send START */
000010  603b              STR      r3,[r7,#0]  ; g_I2C_i32ErrCode
000012  4693              MOV      r11,r2                ;1541
000014  468a              MOV      r10,r1                ;1541
000016  6804              LDR      r4,[r0,#0]
000018  4635              MOV      r5,r6                 ;1542
00001a  4619              MOV      r1,r3                 ;1542
00001c  461a              MOV      r2,r3                 ;1543
00001e  f0240408          BIC      r4,r4,#8
000022  f0440420          ORR      r4,r4,#0x20
000026  6004              STR      r4,[r0,#0]
;;;1548       while(u8Xfering && (u8Err == 0u))
;;;1549       {
;;;1550           uint32_t u32TimeOutCount = SystemCoreClock; // 1 second timeout
000028  f8dfc0c4          LDR      r12,|L19.240|
                  |L19.44|
;;;1551           I2C_WAIT_READY(i2c)
00002c  f8dc4000          LDR      r4,[r12,#0]  ; SystemCoreClock
000030  e001              B        |L19.54|
                  |L19.50|
000032  1e64              SUBS     r4,r4,#1
;;;1552           {
;;;1553               u32TimeOutCount--;
;;;1554               if(u32TimeOutCount == 0)
000034  d009              BEQ      |L19.74|
                  |L19.54|
000036  f8d08000          LDR      r8,[r0,#0]            ;1551
00003a  ea5f7808          LSLS     r8,r8,#28             ;1551
00003e  d5f8              BPL      |L19.50|
                  |L19.64|
;;;1555               {
;;;1556                   g_I2C_i32ErrCode = I2C_TIMEOUT_ERR;
;;;1557                   break;
;;;1558               }
;;;1559           }
;;;1560   
;;;1561           switch(I2C_GET_STATUS(i2c))
000040  68c4              LDR      r4,[r0,#0xc]
000042  f0140f07          TST      r4,#7
000046  d004              BEQ      |L19.82|
000048  e047              B        |L19.218|
                  |L19.74|
00004a  f04f34ff          MOV      r4,#0xffffffff        ;1556
00004e  603c              STR      r4,[r7,#0]            ;1557  ; g_I2C_i32ErrCode
000050  e7f6              B        |L19.64|
                  |L19.82|
000052  10e4              ASRS     r4,r4,#3
000054  2c0c              CMP      r4,#0xc
000056  d240              BCS      |L19.218|
000058  e8dff004          TBB      [pc,r4]
00005c  3f061809          DCB      0x3f,0x06,0x18,0x09
000060  0d100d3f          DCB      0x0d,0x10,0x0d,0x3f
000064  260d1e34          DCB      0x26,0x0d,0x1e,0x34
;;;1562           {
;;;1563           case 0x08u:
;;;1564               I2C_SET_DATA(i2c, (uint8_t)(u8SlaveAddr << 1u | 0x00u));               /* Write SLA+W to Register I2CDAT */
000068  ea4f014a          LSL      r1,r10,#1
;;;1565               u8Ctrl = I2C_CTL_SI;                                      /* Clear SI */
;;;1566               break;
00006c  e011              B        |L19.146|
;;;1567           case 0x18u:                                                      /* Slave Address ACK */
;;;1568               I2C_SET_DATA(i2c, (uint8_t)((u16DataAddr & 0xFF00u) >> 8u));    /* Write Hi byte address of register */
00006e  ea4f241b          LSR      r4,r11,#8
000072  6084              STR      r4,[r0,#8]
;;;1569               break;
000074  e01b              B        |L19.174|
;;;1570           case 0x20u:                                                      /* Slave Address NACK */
;;;1571           case 0x30u:                                                      /* Master transmit data NACK */
;;;1572               u8Ctrl = I2C_CTL_STO_SI;                                  /* Clear SI and send STOP */
000076  2118              MOVS     r1,#0x18
                  |L19.120|
;;;1573               u8Err = 1u;
000078  2301              MOVS     r3,#1
00007a  e018              B        |L19.174|
;;;1574               break;
;;;1575           case 0x28u:
;;;1576               if(u8Addr)
00007c  b125              CBZ      r5,|L19.136|
;;;1577               {
;;;1578                   I2C_SET_DATA(i2c, (uint8_t)(u16DataAddr & 0xFFu));       /* Write Lo byte address of register */
00007e  f00b04ff          AND      r4,r11,#0xff
000082  6084              STR      r4,[r0,#8]
;;;1579                   u8Addr = 0u;
000084  2500              MOVS     r5,#0
000086  e012              B        |L19.174|
                  |L19.136|
;;;1580               }
;;;1581               else
;;;1582               {
;;;1583                   u8Ctrl = I2C_CTL_STA_SI;                              /* Clear SI and send repeat START */
000088  2128              MOVS     r1,#0x28
00008a  e010              B        |L19.174|
;;;1584               }
;;;1585               break;
;;;1586           case 0x10u:
;;;1587               I2C_SET_DATA(i2c, (uint8_t)((u8SlaveAddr << 1u) | 0x01u));             /* Write SLA+R to Register I2CDAT */
00008c  2401              MOVS     r4,#1
00008e  eb04014a          ADD      r1,r4,r10,LSL #1
                  |L19.146|
000092  b2c9              UXTB     r1,r1
000094  6081              STR      r1,[r0,#8]
000096  e009              B        |L19.172|
;;;1588               u8Ctrl = I2C_CTL_SI;                                      /* Clear SI */
;;;1589               break;
;;;1590           case 0x40u:                                                      /* Slave Address ACK */
;;;1591               u8Ctrl = I2C_CTL_SI_AA;                                   /* Clear SI and set ACK */
;;;1592               break;
;;;1593           case 0x48u:                                                      /* Slave Address NACK */
;;;1594               u8Ctrl = I2C_CTL_STO_SI;                                  /* Clear SI and send STOP */
;;;1595               u8Err = 1u;
;;;1596               break;
;;;1597           case 0x50u:
;;;1598               rdata[u32rxLen++] = (unsigned char) I2C_GET_DATA(i2c);      /* Receive Data */
000098  6881              LDR      r1,[r0,#8]
00009a  f8091002          STRB     r1,[r9,r2]
;;;1599               if(u32rxLen < (u32rLen - 1u))
00009e  f1ae0101          SUB      r1,lr,#1
0000a2  1c52              ADDS     r2,r2,#1
0000a4  428a              CMP      r2,r1
0000a6  d201              BCS      |L19.172|
;;;1600               {
;;;1601                   u8Ctrl = I2C_CTL_SI_AA;                               /* Clear SI and set ACK */
0000a8  210c              MOVS     r1,#0xc
0000aa  e000              B        |L19.174|
                  |L19.172|
;;;1602               }
;;;1603               else
;;;1604               {
;;;1605                   u8Ctrl = I2C_CTL_SI;                                  /* Clear SI */
0000ac  2108              MOVS     r1,#8
                  |L19.174|
;;;1606               }
;;;1607               break;
;;;1608           case 0x58u:
;;;1609               rdata[u32rxLen++] = (unsigned char) I2C_GET_DATA(i2c);      /* Receive Data */
;;;1610               u8Ctrl = I2C_CTL_STO_SI;                                  /* Clear SI and send STOP */
;;;1611               u8Xfering = 0u;
;;;1612               break;
;;;1613           case 0x38u:                                                      /* Arbitration Lost */
;;;1614           default:                                                        /* Unknow status */
;;;1615               I2C_SET_CONTROL_REG(i2c, I2C_CTL_STO_SI);                 /* Clear SI and send STOP */
;;;1616               u8Ctrl = I2C_CTL_SI;
;;;1617               u8Err = 1u;
;;;1618               break;
;;;1619           }
;;;1620           I2C_SET_CONTROL_REG(i2c, u8Ctrl);                                   /* Write controlbit to I2C_CTL register */
0000ae  6804              LDR      r4,[r0,#0]
0000b0  f024043c          BIC      r4,r4,#0x3c
0000b4  430c              ORRS     r4,r4,r1
0000b6  6004              STR      r4,[r0,#0]
;;;1621       }
0000b8  b10e              CBZ      r6,|L19.190|
0000ba  2b00              CMP      r3,#0                 ;1548
0000bc  d0b6              BEQ      |L19.44|
                  |L19.190|
;;;1622       return u32rxLen;                                                        /* Return bytes length that have been received */
0000be  4610              MOV      r0,r2
;;;1623   }
0000c0  e8bd8ff0          POP      {r4-r11,pc}
0000c4  6881              LDR      r1,[r0,#8]            ;1609
0000c6  f8091002          STRB     r1,[r9,r2]            ;1609
0000ca  6804              LDR      r4,[r0,#0]            ;1620
0000cc  f024043c          BIC      r4,r4,#0x3c           ;1620
0000d0  f0440418          ORR      r4,r4,#0x18           ;1620
0000d4  6004              STR      r4,[r0,#0]            ;1620
0000d6  1c52              ADDS     r2,r2,#1              ;1620
0000d8  e7f1              B        |L19.190|
                  |L19.218|
0000da  6801              LDR      r1,[r0,#0]            ;1615
0000dc  f021013c          BIC      r1,r1,#0x3c           ;1615
0000e0  f0410118          ORR      r1,r1,#0x18           ;1615
0000e4  6001              STR      r1,[r0,#0]            ;1615
0000e6  2108              MOVS     r1,#8                 ;1616
0000e8  e7c6              B        |L19.120|
;;;1624   
                          ENDP

0000ea  0000              DCW      0x0000
                  |L19.236|
                          DCD      ||.data||
                  |L19.240|
                          DCD      SystemCoreClock

                          AREA ||i.I2C_SMBusClearInterruptFlag||, CODE, READONLY, ALIGN=1

                  I2C_SMBusClearInterruptFlag PROC
;;;467     */
;;;468    void I2C_SMBusClearInterruptFlag(I2C_T *i2c, uint8_t u8SMBusIntFlag)
000000  6581              STR      r1,[r0,#0x58]
;;;469    {
;;;470        i2c->BUSSTS = u8SMBusIntFlag;
;;;471    }
000002  4770              BX       lr
;;;472    
                          ENDP


                          AREA ||i.I2C_SMBusClockLoTimeout||, CODE, READONLY, ALIGN=1

                  I2C_SMBusClockLoTimeout PROC
;;;652    
;;;653    void I2C_SMBusClockLoTimeout(I2C_T *i2c, uint32_t ms, uint32_t u32Pclk)
000000  6d03              LDR      r3,[r0,#0x50]
;;;654    {
;;;655        uint32_t u32Div, u32Pclk_kHz;
;;;656    
;;;657        i2c->BUSCTL &= ~I2C_BUSCTL_TIDLE_Msk;
000002  f4237300          BIC      r3,r3,#0x200
000006  6503              STR      r3,[r0,#0x50]
;;;658    
;;;659        /* DIV4 disabled */
;;;660        i2c->TOCTL &= ~I2C_TOCTL_TOCEN_Msk;
000008  6943              LDR      r3,[r0,#0x14]
00000a  f0230304          BIC      r3,r3,#4
00000e  6143              STR      r3,[r0,#0x14]
;;;661        u32Pclk_kHz = u32Pclk / 1000U;
000010  f44f737a          MOV      r3,#0x3e8
000014  fbb2f2f3          UDIV     r2,r2,r3
;;;662        u32Div = ((ms * u32Pclk_kHz) / (16U * 1024U)) - 1U;
000018  4351              MULS     r1,r2,r1
00001a  f04f33ff          MOV      r3,#0xffffffff
00001e  eb033291          ADD      r2,r3,r1,LSR #14
;;;663        if(u32Div <= 0xFFU)
000022  2aff              CMP      r2,#0xff
000024  d801              BHI      |L21.42|
;;;664        {
;;;665            i2c->CLKTOUT = u32Div;
000026  6682              STR      r2,[r0,#0x68]
;;;666        }
;;;667        else
;;;668        {
;;;669            /* DIV4 enabled */
;;;670            i2c->TOCTL |= I2C_TOCTL_TOCEN_Msk;
;;;671            i2c->CLKTOUT = (((ms * u32Pclk_kHz) / (16U * 1024U * 4U)) - 1U) & 0xFFU; /* The max value is 255 */
;;;672        }
;;;673    }
000028  4770              BX       lr
                  |L21.42|
00002a  6942              LDR      r2,[r0,#0x14]         ;670
00002c  f0420204          ORR      r2,r2,#4              ;670
000030  6142              STR      r2,[r0,#0x14]         ;670
000032  eb034111          ADD      r1,r3,r1,LSR #16      ;671
000036  b2c9              UXTB     r1,r1                 ;671
000038  6681              STR      r1,[r0,#0x68]         ;671
00003a  4770              BX       lr
;;;674    
                          ENDP


                          AREA ||i.I2C_SMBusClose||, CODE, READONLY, ALIGN=1

                  I2C_SMBusClose PROC
;;;525     */
;;;526    void I2C_SMBusClose(I2C_T *i2c)
000000  2100              MOVS     r1,#0
;;;527    {
;;;528    
;;;529        i2c->BUSCTL = 0x00U;
000002  6501              STR      r1,[r0,#0x50]
;;;530    }
000004  4770              BX       lr
;;;531    
                          ENDP


                          AREA ||i.I2C_SMBusGetPECValue||, CODE, READONLY, ALIGN=1

                  I2C_SMBusGetPECValue PROC
;;;566     */
;;;567    uint8_t I2C_SMBusGetPECValue(I2C_T *i2c)
000000  6e00              LDR      r0,[r0,#0x60]
;;;568    {
;;;569        return (uint8_t)i2c->PKTCRC;
000002  b2c0              UXTB     r0,r0
;;;570    }
000004  4770              BX       lr
;;;571    
                          ENDP


                          AREA ||i.I2C_SMBusGetStatus||, CODE, READONLY, ALIGN=1

                  I2C_SMBusGetStatus PROC
;;;451     */
;;;452    uint32_t I2C_SMBusGetStatus(I2C_T *i2c)
000000  6d80              LDR      r0,[r0,#0x58]
;;;453    {
;;;454        return (i2c->BUSSTS);
;;;455    }
000002  4770              BX       lr
;;;456    
                          ENDP


                          AREA ||i.I2C_SMBusIdleTimeout||, CODE, READONLY, ALIGN=1

                  I2C_SMBusIdleTimeout PROC
;;;584    
;;;585    void I2C_SMBusIdleTimeout(I2C_T *i2c, uint32_t us, uint32_t u32Hclk)
000000  6d03              LDR      r3,[r0,#0x50]
;;;586    {
;;;587        uint32_t  u32Div, u32Hclk_kHz;
;;;588    
;;;589        i2c->BUSCTL |= I2C_BUSCTL_TIDLE_Msk;
000002  f4437300          ORR      r3,r3,#0x200
000006  6503              STR      r3,[r0,#0x50]
;;;590        u32Hclk_kHz = u32Hclk / 1000U;
000008  f44f737a          MOV      r3,#0x3e8
00000c  fbb2f2f3          UDIV     r2,r2,r3
;;;591        u32Div = (((us * u32Hclk_kHz) / 1000U) >> 2U) - 1U;
000010  4351              MULS     r1,r2,r1
000012  fbb1f1f3          UDIV     r1,r1,r3
000016  f04f32ff          MOV      r2,#0xffffffff
00001a  eb020191          ADD      r1,r2,r1,LSR #2
;;;592        if(u32Div > 255U)
00001e  29ff              CMP      r1,#0xff
000020  d900              BLS      |L25.36|
;;;593        {
;;;594            i2c->BUSTOUT = 0xFFU;
000022  21ff              MOVS     r1,#0xff
                  |L25.36|
;;;595        }
;;;596        else
;;;597        {
;;;598            i2c->BUSTOUT = u32Div;
000024  6641              STR      r1,[r0,#0x64]
;;;599        }
;;;600    
;;;601    }
000026  4770              BX       lr
;;;602    
                          ENDP


                          AREA ||i.I2C_SMBusOpen||, CODE, READONLY, ALIGN=1

                  I2C_SMBusOpen PROC
;;;499     */
;;;500    void I2C_SMBusOpen(I2C_T *i2c, uint8_t u8HostDevice)
000000  6d02              LDR      r2,[r0,#0x50]
;;;501    {
;;;502        /* Clear  BMHEN, BMDEN of BUSCTL Register */
;;;503        i2c->BUSCTL &=  ~(I2C_BUSCTL_BMHEN_Msk | I2C_BUSCTL_BMDEN_Msk);
000002  f022020c          BIC      r2,r2,#0xc
000006  6502              STR      r2,[r0,#0x50]
;;;504    
;;;505        /* Set SMBus Host/Device Mode, and enable Bus Management*/
;;;506        if(u8HostDevice == (uint8_t)I2C_SMBH_ENABLE)
000008  2901              CMP      r1,#1
;;;507        {
;;;508            i2c->BUSCTL |= (I2C_BUSCTL_BMHEN_Msk | I2C_BUSCTL_BUSEN_Msk);
;;;509        }
;;;510        else
;;;511        {
;;;512            i2c->BUSCTL |= (I2C_BUSCTL_BMDEN_Msk | I2C_BUSCTL_BUSEN_Msk);
00000a  6d01              LDR      r1,[r0,#0x50]
00000c  d003              BEQ      |L26.22|
00000e  f0410184          ORR      r1,r1,#0x84
                  |L26.18|
000012  6501              STR      r1,[r0,#0x50]         ;508
;;;513        }
;;;514    }
000014  4770              BX       lr
                  |L26.22|
000016  f0410188          ORR      r1,r1,#0x88           ;508
00001a  e7fa              B        |L26.18|
;;;515    
                          ENDP


                          AREA ||i.I2C_SMBusPECTxEnable||, CODE, READONLY, ALIGN=1

                  I2C_SMBusPECTxEnable PROC
;;;542     */
;;;543    void I2C_SMBusPECTxEnable(I2C_T *i2c, uint8_t u8PECTxEn)
000000  6d02              LDR      r2,[r0,#0x50]
;;;544    {
;;;545        i2c->BUSCTL &= ~I2C_BUSCTL_PECTXEN_Msk;
000002  f4227280          BIC      r2,r2,#0x100
000006  6502              STR      r2,[r0,#0x50]
;;;546    
;;;547        if(u8PECTxEn)
000008  2900              CMP      r1,#0
;;;548        {
;;;549            i2c->BUSCTL |= (I2C_BUSCTL_PECEN_Msk | I2C_BUSCTL_PECTXEN_Msk);
;;;550        }
;;;551        else
;;;552        {
;;;553            i2c->BUSCTL |= I2C_BUSCTL_PECEN_Msk;
00000a  6d01              LDR      r1,[r0,#0x50]
00000c  d002              BEQ      |L27.20|
00000e  f4417181          ORR      r1,r1,#0x102          ;549
000012  e001              B        |L27.24|
                  |L27.20|
000014  f0410102          ORR      r1,r1,#2
                  |L27.24|
000018  6501              STR      r1,[r0,#0x50]         ;549
;;;554        }
;;;555    }
00001a  4770              BX       lr
;;;556    
                          ENDP


                          AREA ||i.I2C_SMBusSetPacketByteCount||, CODE, READONLY, ALIGN=1

                  I2C_SMBusSetPacketByteCount PROC
;;;483     */
;;;484    void I2C_SMBusSetPacketByteCount(I2C_T *i2c, uint32_t u32PktSize)
000000  65c1              STR      r1,[r0,#0x5c]
;;;485    {
;;;486        i2c->PKTSIZE = u32PktSize;
;;;487    }
000002  4770              BX       lr
;;;488    
                          ENDP


                          AREA ||i.I2C_SMBusTimeout||, CODE, READONLY, ALIGN=1

                  I2C_SMBusTimeout PROC
;;;616    
;;;617    void I2C_SMBusTimeout(I2C_T *i2c, uint32_t ms, uint32_t u32Pclk)
000000  6d03              LDR      r3,[r0,#0x50]
;;;618    {
;;;619        uint32_t u32Div, u32Pclk_kHz;
;;;620    
;;;621        i2c->BUSCTL &= ~I2C_BUSCTL_TIDLE_Msk;
000002  f4237300          BIC      r3,r3,#0x200
000006  6503              STR      r3,[r0,#0x50]
;;;622    
;;;623        /* DIV4 disabled */
;;;624        i2c->TOCTL &= ~I2C_TOCTL_TOCEN_Msk;
000008  6943              LDR      r3,[r0,#0x14]
00000a  f0230304          BIC      r3,r3,#4
00000e  6143              STR      r3,[r0,#0x14]
;;;625        u32Pclk_kHz = u32Pclk / 1000U;
000010  f44f737a          MOV      r3,#0x3e8
000014  fbb2f2f3          UDIV     r2,r2,r3
;;;626        u32Div = ((ms * u32Pclk_kHz) / (16U * 1024U)) - 1U;
000018  4351              MULS     r1,r2,r1
00001a  f04f33ff          MOV      r3,#0xffffffff
00001e  eb033291          ADD      r2,r3,r1,LSR #14
;;;627        if(u32Div <= 0xFFU)
000022  2aff              CMP      r2,#0xff
000024  d801              BHI      |L29.42|
;;;628        {
;;;629            i2c->BUSTOUT = u32Div;
000026  6642              STR      r2,[r0,#0x64]
;;;630        }
;;;631        else
;;;632        {
;;;633            /* DIV4 enabled */
;;;634            i2c->TOCTL |= I2C_TOCTL_TOCEN_Msk;
;;;635            i2c->BUSTOUT = (((ms * u32Pclk_kHz) / (16U * 1024U * 4U)) - 1U) & 0xFFU; /* The max value is 255 */
;;;636        }
;;;637    }
000028  4770              BX       lr
                  |L29.42|
00002a  6942              LDR      r2,[r0,#0x14]         ;634
00002c  f0420204          ORR      r2,r2,#4              ;634
000030  6142              STR      r2,[r0,#0x14]         ;634
000032  eb034111          ADD      r1,r3,r1,LSR #16      ;635
000036  b2c9              UXTB     r1,r1                 ;635
000038  6641              STR      r1,[r0,#0x64]         ;635
00003a  4770              BX       lr
;;;638    
                          ENDP


                          AREA ||i.I2C_SetBusClockFreq||, CODE, READONLY, ALIGN=2

                  I2C_SetBusClockFreq PROC
;;;216     */
;;;217    uint32_t I2C_SetBusClockFreq(I2C_T *i2c, uint32_t u32BusClock)
000000  b570              PUSH     {r4-r6,lr}
;;;218    {
000002  4604              MOV      r4,r0
;;;219        uint32_t u32Div;
;;;220        uint32_t u32Pclk;
;;;221    
;;;222        if(i2c == I2C1)
000004  480c              LDR      r0,|L30.56|
000006  460d              MOV      r5,r1                 ;218
000008  4284              CMP      r4,r0
00000a  d102              BNE      |L30.18|
;;;223        {
;;;224            u32Pclk = CLK_GetPCLK1Freq();
00000c  f7fffffe          BL       CLK_GetPCLK1Freq
000010  e001              B        |L30.22|
                  |L30.18|
;;;225        }
;;;226        else
;;;227        {
;;;228            u32Pclk = CLK_GetPCLK0Freq();
000012  f7fffffe          BL       CLK_GetPCLK0Freq
                  |L30.22|
;;;229        }
;;;230    
;;;231        u32Div = (uint32_t)(((u32Pclk * 10U) / (u32BusClock * 4U) + 5U) / 10U - 1U); /* Compute proper divider for I2C clock */
000016  eb000180          ADD      r1,r0,r0,LSL #2
00001a  0049              LSLS     r1,r1,#1
00001c  00aa              LSLS     r2,r5,#2
00001e  fbb1f1f2          UDIV     r1,r1,r2
000022  220a              MOVS     r2,#0xa
000024  1d49              ADDS     r1,r1,#5
000026  fbb1f2f2          UDIV     r2,r1,r2
00002a  1e51              SUBS     r1,r2,#1
;;;232        i2c->CLKDIV = u32Div;
00002c  6121              STR      r1,[r4,#0x10]
00002e  0091              LSLS     r1,r2,#2
;;;233    
;;;234        return (u32Pclk / ((u32Div + 1U) << 2U));
000030  fbb0f0f1          UDIV     r0,r0,r1
;;;235    }
000034  bd70              POP      {r4-r6,pc}
;;;236    
                          ENDP

000036  0000              DCW      0x0000
                  |L30.56|
                          DCD      0x40081000

                          AREA ||i.I2C_SetData||, CODE, READONLY, ALIGN=1

                  I2C_SetData PROC
;;;299     */
;;;300    void I2C_SetData(I2C_T *i2c, uint8_t u8Data)
000000  6081              STR      r1,[r0,#8]
;;;301    {
;;;302        i2c->DAT = u8Data;
;;;303    }
000002  4770              BX       lr
;;;304    
                          ENDP


                          AREA ||i.I2C_SetSlaveAddr||, CODE, READONLY, ALIGN=1

                  I2C_SetSlaveAddr PROC
;;;318     */
;;;319    void I2C_SetSlaveAddr(I2C_T *i2c, uint8_t u8SlaveNo, uint8_t u8SlaveAddr, uint8_t u8GCMode)
000000  ea430242          ORR      r2,r3,r2,LSL #1
;;;320    {
;;;321        switch(u8SlaveNo)
000004  2901              CMP      r1,#1
000006  d005              BEQ      |L32.20|
000008  2902              CMP      r1,#2
00000a  d005              BEQ      |L32.24|
00000c  2903              CMP      r1,#3
00000e  d005              BEQ      |L32.28|
;;;322        {
;;;323        case 1:
;;;324            i2c->ADDR1  = ((uint32_t)u8SlaveAddr << 1U) | u8GCMode;
;;;325            break;
;;;326        case 2:
;;;327            i2c->ADDR2  = ((uint32_t)u8SlaveAddr << 1U) | u8GCMode;
;;;328            break;
;;;329        case 3:
;;;330            i2c->ADDR3  = ((uint32_t)u8SlaveAddr << 1U) | u8GCMode;
;;;331            break;
;;;332        case 0:
;;;333        default:
;;;334            i2c->ADDR0  = ((uint32_t)u8SlaveAddr << 1U) | u8GCMode;
000010  6042              STR      r2,[r0,#4]
;;;335            break;
;;;336        }
;;;337    }
000012  4770              BX       lr
                  |L32.20|
000014  6182              STR      r2,[r0,#0x18]         ;324
000016  4770              BX       lr
                  |L32.24|
000018  61c2              STR      r2,[r0,#0x1c]         ;327
00001a  4770              BX       lr
                  |L32.28|
00001c  6202              STR      r2,[r0,#0x20]         ;330
00001e  4770              BX       lr
;;;338    
                          ENDP


                          AREA ||i.I2C_SetSlaveAddrMask||, CODE, READONLY, ALIGN=1

                  I2C_SetSlaveAddrMask PROC
;;;350     */
;;;351    void I2C_SetSlaveAddrMask(I2C_T *i2c, uint8_t u8SlaveNo, uint8_t u8SlaveAddrMask)
000000  0052              LSLS     r2,r2,#1
;;;352    {
;;;353        switch(u8SlaveNo)
000002  2901              CMP      r1,#1
000004  d005              BEQ      |L33.18|
000006  2902              CMP      r1,#2
000008  d005              BEQ      |L33.22|
00000a  2903              CMP      r1,#3
00000c  d005              BEQ      |L33.26|
;;;354        {
;;;355        case 1:
;;;356            i2c->ADDRMSK1  = (uint32_t)u8SlaveAddrMask << 1U;
;;;357            break;
;;;358        case 2:
;;;359            i2c->ADDRMSK2  = (uint32_t)u8SlaveAddrMask << 1U;
;;;360            break;
;;;361        case 3:
;;;362            i2c->ADDRMSK3  = (uint32_t)u8SlaveAddrMask << 1U;
;;;363            break;
;;;364        case 0:
;;;365        default:
;;;366            i2c->ADDRMSK0  = (uint32_t)u8SlaveAddrMask << 1U;
00000e  6242              STR      r2,[r0,#0x24]
;;;367            break;
;;;368        }
;;;369    }
000010  4770              BX       lr
                  |L33.18|
000012  6282              STR      r2,[r0,#0x28]         ;356
000014  4770              BX       lr
                  |L33.22|
000016  62c2              STR      r2,[r0,#0x2c]         ;359
000018  4770              BX       lr
                  |L33.26|
00001a  6302              STR      r2,[r0,#0x30]         ;362
00001c  4770              BX       lr
;;;370    
                          ENDP


                          AREA ||i.I2C_Trigger||, CODE, READONLY, ALIGN=1

                  I2C_Trigger PROC
;;;123      */
;;;124    void I2C_Trigger(I2C_T *i2c, uint8_t u8Start, uint8_t u8Stop, uint8_t u8Si, uint8_t u8Ack)
000000  b530              PUSH     {r4,r5,lr}
;;;125    {
;;;126        uint32_t u32Reg = 0U;
000002  2400              MOVS     r4,#0
000004  9d03              LDR      r5,[sp,#0xc]          ;125
000006  b101              CBZ      r1,|L34.10|
;;;127    
;;;128        if(u8Start)
;;;129        {
;;;130            u32Reg |= I2C_CTL_STA;
000008  2420              MOVS     r4,#0x20
                  |L34.10|
;;;131        }
;;;132    
;;;133        if(u8Stop)
00000a  b10a              CBZ      r2,|L34.16|
;;;134        {
;;;135            u32Reg |= I2C_CTL_STO;
00000c  f0440410          ORR      r4,r4,#0x10
                  |L34.16|
;;;136        }
;;;137    
;;;138        if(u8Si)
000010  b10b              CBZ      r3,|L34.22|
;;;139        {
;;;140            u32Reg |= I2C_CTL_SI;
000012  f0440408          ORR      r4,r4,#8
                  |L34.22|
;;;141        }
;;;142    
;;;143        if(u8Ack)
000016  b10d              CBZ      r5,|L34.28|
;;;144        {
;;;145            u32Reg |= I2C_CTL_AA;
000018  f0440404          ORR      r4,r4,#4
                  |L34.28|
;;;146        }
;;;147    
;;;148        i2c->CTL0 = (i2c->CTL0 & ~0x3CU) | u32Reg;
00001c  6801              LDR      r1,[r0,#0]
00001e  f021013c          BIC      r1,r1,#0x3c
000022  4321              ORRS     r1,r1,r4
000024  6001              STR      r1,[r0,#0]
;;;149    }
000026  bd30              POP      {r4,r5,pc}
;;;150    
                          ENDP


                          AREA ||i.I2C_WriteByte||, CODE, READONLY, ALIGN=2

                  I2C_WriteByte PROC
;;;689    
;;;690    uint8_t I2C_WriteByte(I2C_T *i2c, uint8_t u8SlaveAddr, uint8_t data)
000000  b5f0              PUSH     {r4-r7,lr}
;;;691    {
;;;692        uint8_t u8Xfering = 1u, u8Err = 0u, u8Ctrl = 0u;
;;;693    
;;;694        g_I2C_i32ErrCode = 0;
000002  4f24              LDR      r7,|L35.148|
000004  2501              MOVS     r5,#1                 ;692
000006  2300              MOVS     r3,#0                 ;692
;;;695    
;;;696        I2C_START(i2c);
000008  603b              STR      r3,[r7,#0]  ; g_I2C_i32ErrCode
00000a  6806              LDR      r6,[r0,#0]
00000c  461c              MOV      r4,r3                 ;692
00000e  f0260608          BIC      r6,r6,#8
000012  f0460620          ORR      r6,r6,#0x20
000016  6006              STR      r6,[r0,#0]
;;;697        while(u8Xfering && (u8Err == 0u))
;;;698        {
;;;699            uint32_t u32TimeOutCount = SystemCoreClock; // 1 second timeout
000018  f8dfc07c          LDR      r12,|L35.152|
                  |L35.28|
;;;700            I2C_WAIT_READY(i2c)
00001c  f8dc6000          LDR      r6,[r12,#0]  ; SystemCoreClock
000020  e001              B        |L35.38|
                  |L35.34|
000022  1e76              SUBS     r6,r6,#1
;;;701            {
;;;702                u32TimeOutCount--;
;;;703                if(u32TimeOutCount == 0)
000024  d00d              BEQ      |L35.66|
                  |L35.38|
000026  f8d0e000          LDR      lr,[r0,#0]            ;700
00002a  ea5f7e0e          LSLS     lr,lr,#28             ;700
00002e  d5f8              BPL      |L35.34|
                  |L35.48|
;;;704                {
;;;705                    g_I2C_i32ErrCode = I2C_TIMEOUT_ERR;
;;;706                    u8Err = 1u;
;;;707                    break;
;;;708                }
;;;709            }
;;;710    
;;;711            switch(I2C_GET_STATUS(i2c))
000030  68c6              LDR      r6,[r0,#0xc]
000032  2e20              CMP      r6,#0x20
000034  d01d              BEQ      |L35.114|
000036  dc09              BGT      |L35.76|
000038  2e08              CMP      r6,#8
00003a  d013              BEQ      |L35.100|
00003c  2e18              CMP      r6,#0x18
00003e  d109              BNE      |L35.84|
000040  e015              B        |L35.110|
                  |L35.66|
000042  f04f33ff          MOV      r3,#0xffffffff        ;705
000046  603b              STR      r3,[r7,#0]            ;706  ; g_I2C_i32ErrCode
000048  2301              MOVS     r3,#1                 ;706
00004a  e7f1              B        |L35.48|
                  |L35.76|
00004c  2e28              CMP      r6,#0x28
00004e  d013              BEQ      |L35.120|
000050  2e30              CMP      r6,#0x30
000052  d00e              BEQ      |L35.114|
                  |L35.84|
;;;712            {
;;;713            case 0x08u:
;;;714                I2C_SET_DATA(i2c, (uint8_t)(u8SlaveAddr << 1u | 0x00u));    /* Write SLA+W to Register I2CDAT */
;;;715                u8Ctrl = I2C_CTL_SI;                              /* Clear SI */
;;;716                break;
;;;717            case 0x18u:                                           /* Slave Address ACK */
;;;718                I2C_SET_DATA(i2c, data);                          /* Write data to I2CDAT */
;;;719                break;
;;;720            case 0x20u:                                           /* Slave Address NACK */
;;;721            case 0x30u:                                           /* Master transmit data NACK */
;;;722                u8Ctrl = I2C_CTL_STO_SI;                          /* Clear SI and send STOP */
;;;723                u8Err = 1u;
;;;724                break;
;;;725            case 0x28u:
;;;726                u8Ctrl = I2C_CTL_STO_SI;                          /* Clear SI and send STOP */
;;;727                u8Xfering = 0u;
;;;728                break;
;;;729            case 0x38u:                                           /* Arbitration Lost */
;;;730            default:                                              /* Unknow status */
;;;731                I2C_SET_CONTROL_REG(i2c, I2C_CTL_STO_SI);      /* Clear SI and send STOP */
000054  6803              LDR      r3,[r0,#0]
000056  f023033c          BIC      r3,r3,#0x3c
00005a  f0430318          ORR      r3,r3,#0x18
00005e  6003              STR      r3,[r0,#0]
;;;732                u8Ctrl = I2C_CTL_SI;
000060  2408              MOVS     r4,#8
;;;733                u8Err = 1u;
;;;734                break;
000062  e007              B        |L35.116|
                  |L35.100|
000064  064c              LSLS     r4,r1,#25             ;714
000066  0e24              LSRS     r4,r4,#24             ;714
000068  6084              STR      r4,[r0,#8]            ;714
00006a  2408              MOVS     r4,#8                 ;715
00006c  e006              B        |L35.124|
                  |L35.110|
00006e  6082              STR      r2,[r0,#8]            ;718
000070  e004              B        |L35.124|
                  |L35.114|
000072  2418              MOVS     r4,#0x18              ;722
                  |L35.116|
000074  2301              MOVS     r3,#1                 ;723
000076  e001              B        |L35.124|
                  |L35.120|
000078  2418              MOVS     r4,#0x18              ;726
00007a  2500              MOVS     r5,#0                 ;727
                  |L35.124|
;;;735            }
;;;736            I2C_SET_CONTROL_REG(i2c, u8Ctrl);                        /* Write controlbit to I2C_CTL register */
00007c  6806              LDR      r6,[r0,#0]
00007e  f026063c          BIC      r6,r6,#0x3c
000082  4326              ORRS     r6,r6,r4
000084  6006              STR      r6,[r0,#0]
;;;737        }
000086  b10d              CBZ      r5,|L35.140|
000088  2b00              CMP      r3,#0                 ;697
00008a  d0c7              BEQ      |L35.28|
                  |L35.140|
;;;738        return (u8Err | u8Xfering);                                  /* return (Success)/(Fail) status */
00008c  ea430005          ORR      r0,r3,r5
;;;739    }
000090  bdf0              POP      {r4-r7,pc}
;;;740    
                          ENDP

000092  0000              DCW      0x0000
                  |L35.148|
                          DCD      ||.data||
                  |L35.152|
                          DCD      SystemCoreClock

                          AREA ||i.I2C_WriteByteOneReg||, CODE, READONLY, ALIGN=2

                  I2C_WriteByteOneReg PROC
;;;825    
;;;826    uint8_t I2C_WriteByteOneReg(I2C_T *i2c, uint8_t u8SlaveAddr, uint8_t u8DataAddr, uint8_t data)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;827    {
000004  4691              MOV      r9,r2
;;;828        uint8_t u8Xfering = 1u, u8Err = 0u, u8Ctrl = 0u;
000006  2401              MOVS     r4,#1
;;;829        uint32_t u32txLen = 0u;
;;;830    
;;;831        g_I2C_i32ErrCode = 0;
000008  4f27              LDR      r7,|L36.168|
00000a  2200              MOVS     r2,#0                 ;828
00000c  469a              MOV      r10,r3                ;827
;;;832    
;;;833        I2C_START(i2c);                                              /* Send START */
00000e  603a              STR      r2,[r7,#0]  ; g_I2C_i32ErrCode
000010  6805              LDR      r5,[r0,#0]
000012  4613              MOV      r3,r2                 ;828
000014  4616              MOV      r6,r2                 ;829
000016  f0250508          BIC      r5,r5,#8
00001a  f0450520          ORR      r5,r5,#0x20
00001e  6005              STR      r5,[r0,#0]
;;;834        while(u8Xfering && (u8Err == 0u))
;;;835        {
;;;836            uint32_t u32TimeOutCount = SystemCoreClock; // 1 second timeout
000020  f8dfc088          LDR      r12,|L36.172|
                  |L36.36|
;;;837            I2C_WAIT_READY(i2c)
000024  f8dc5000          LDR      r5,[r12,#0]  ; SystemCoreClock
000028  e001              B        |L36.46|
                  |L36.42|
00002a  1e6d              SUBS     r5,r5,#1
;;;838            {
;;;839                u32TimeOutCount--;
;;;840                if(u32TimeOutCount == 0)
00002c  d00d              BEQ      |L36.74|
                  |L36.46|
00002e  f8d08000          LDR      r8,[r0,#0]            ;837
000032  ea5f7808          LSLS     r8,r8,#28             ;837
000036  d5f8              BPL      |L36.42|
                  |L36.56|
;;;841                {
;;;842                    g_I2C_i32ErrCode = I2C_TIMEOUT_ERR;
;;;843                    break;
;;;844                }
;;;845            }
;;;846    
;;;847            switch(I2C_GET_STATUS(i2c))
000038  68c5              LDR      r5,[r0,#0xc]
00003a  2d20              CMP      r5,#0x20
00003c  d01d              BEQ      |L36.122|
00003e  dc08              BGT      |L36.82|
000040  2d08              CMP      r5,#8
000042  d012              BEQ      |L36.106|
000044  2d18              CMP      r5,#0x18
000046  d108              BNE      |L36.90|
000048  e014              B        |L36.116|
                  |L36.74|
00004a  f04f35ff          MOV      r5,#0xffffffff        ;842
00004e  603d              STR      r5,[r7,#0]            ;843  ; g_I2C_i32ErrCode
000050  e7f2              B        |L36.56|
                  |L36.82|
000052  2d28              CMP      r5,#0x28
000054  d014              BEQ      |L36.128|
000056  2d30              CMP      r5,#0x30
000058  d00f              BEQ      |L36.122|
                  |L36.90|
;;;848            {
;;;849            case 0x08u:
;;;850                I2C_SET_DATA(i2c, (uint8_t)(u8SlaveAddr << 1u | 0x00u));    /* Send Slave address with write bit */
;;;851                u8Ctrl = I2C_CTL_SI;                           /* Clear SI */
;;;852                break;
;;;853            case 0x18u:                                           /* Slave Address ACK */
;;;854                I2C_SET_DATA(i2c, u8DataAddr);                   /* Write Lo byte address of register */
;;;855                break;
;;;856            case 0x20u:                                           /* Slave Address NACK */
;;;857            case 0x30u:                                           /* Master transmit data NACK */
;;;858                u8Ctrl = I2C_CTL_STO_SI;                       /* Clear SI and send STOP */
;;;859                u8Err = 1u;
;;;860                break;
;;;861            case 0x28u:
;;;862                if(u32txLen < 1u)
;;;863                {
;;;864                    I2C_SET_DATA(i2c, data);
;;;865                    u32txLen++;
;;;866                }
;;;867                else
;;;868                {
;;;869                    u8Ctrl = I2C_CTL_STO_SI;                   /* Clear SI and send STOP */
;;;870                    u8Xfering = 0u;
;;;871                }
;;;872                break;
;;;873            case 0x38u:                                           /* Arbitration Lost */
;;;874            default:                                             /* Unknow status */
;;;875                I2C_SET_CONTROL_REG(i2c, I2C_CTL_STO_SI);      /* Clear SI and send STOP */
00005a  6802              LDR      r2,[r0,#0]
00005c  f022023c          BIC      r2,r2,#0x3c
000060  f0420218          ORR      r2,r2,#0x18
000064  6002              STR      r2,[r0,#0]
;;;876                u8Ctrl = I2C_CTL_SI;
000066  2308              MOVS     r3,#8
;;;877                u8Err = 1u;
;;;878                break;
000068  e008              B        |L36.124|
                  |L36.106|
00006a  064b              LSLS     r3,r1,#25             ;850
00006c  0e1b              LSRS     r3,r3,#24             ;850
00006e  6083              STR      r3,[r0,#8]            ;850
000070  2308              MOVS     r3,#8                 ;851
000072  e00c              B        |L36.142|
                  |L36.116|
000074  f8c09008          STR      r9,[r0,#8]            ;854
000078  e009              B        |L36.142|
                  |L36.122|
00007a  2318              MOVS     r3,#0x18              ;858
                  |L36.124|
00007c  2201              MOVS     r2,#1                 ;859
00007e  e006              B        |L36.142|
                  |L36.128|
000080  b116              CBZ      r6,|L36.136|
000082  2318              MOVS     r3,#0x18              ;869
000084  2400              MOVS     r4,#0                 ;870
000086  e002              B        |L36.142|
                  |L36.136|
000088  f8c0a008          STR      r10,[r0,#8]           ;864
00008c  2601              MOVS     r6,#1                 ;865
                  |L36.142|
;;;879            }
;;;880            I2C_SET_CONTROL_REG(i2c, u8Ctrl);                        /* Write controlbit to I2C_CTL register */
00008e  6805              LDR      r5,[r0,#0]
000090  f025053c          BIC      r5,r5,#0x3c
000094  431d              ORRS     r5,r5,r3
000096  6005              STR      r5,[r0,#0]
;;;881        }
000098  b10c              CBZ      r4,|L36.158|
00009a  2a00              CMP      r2,#0                 ;834
00009c  d0c2              BEQ      |L36.36|
                  |L36.158|
;;;882        return (u8Err | u8Xfering);                                  /* return (Success)/(Fail) status */
00009e  ea420004          ORR      r0,r2,r4
;;;883    }
0000a2  e8bd87f0          POP      {r4-r10,pc}
;;;884    
                          ENDP

0000a6  0000              DCW      0x0000
                  |L36.168|
                          DCD      ||.data||
                  |L36.172|
                          DCD      SystemCoreClock

                          AREA ||i.I2C_WriteByteTwoRegs||, CODE, READONLY, ALIGN=2

                  I2C_WriteByteTwoRegs PROC
;;;974    
;;;975    uint8_t I2C_WriteByteTwoRegs(I2C_T *i2c, uint8_t u8SlaveAddr, uint16_t u16DataAddr, uint8_t data)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;976    {
000004  469b              MOV      r11,r3
;;;977        uint8_t u8Xfering = 1u, u8Err = 0u, u8Addr = 1u, u8Ctrl = 0u;
000006  2301              MOVS     r3,#1
000008  468a              MOV      r10,r1                ;976
;;;978        uint32_t u32txLen = 0u;
;;;979    
;;;980        g_I2C_i32ErrCode = 0;
00000a  4f2c              LDR      r7,|L37.188|
00000c  2100              MOVS     r1,#0                 ;977
00000e  4691              MOV      r9,r2                 ;976
;;;981    
;;;982        I2C_START(i2c);                                                         /* Send START */
000010  6039              STR      r1,[r7,#0]  ; g_I2C_i32ErrCode
000012  6804              LDR      r4,[r0,#0]
000014  461e              MOV      r6,r3                 ;977
000016  460a              MOV      r2,r1                 ;977
000018  460d              MOV      r5,r1                 ;978
00001a  f0240408          BIC      r4,r4,#8
00001e  f0440420          ORR      r4,r4,#0x20
000022  6004              STR      r4,[r0,#0]
;;;983        while(u8Xfering && (u8Err == 0u))
;;;984        {
;;;985            uint32_t u32TimeOutCount = SystemCoreClock; // 1 second timeout
000024  f8dfc098          LDR      r12,|L37.192|
                  |L37.40|
;;;986            I2C_WAIT_READY(i2c)
000028  f8dc4000          LDR      r4,[r12,#0]  ; SystemCoreClock
00002c  e001              B        |L37.50|
                  |L37.46|
00002e  1e64              SUBS     r4,r4,#1
;;;987            {
;;;988                u32TimeOutCount--;
;;;989                if(u32TimeOutCount == 0)
000030  d00d              BEQ      |L37.78|
                  |L37.50|
000032  f8d08000          LDR      r8,[r0,#0]            ;986
000036  ea5f7808          LSLS     r8,r8,#28             ;986
00003a  d5f8              BPL      |L37.46|
                  |L37.60|
;;;990                {
;;;991                    g_I2C_i32ErrCode = I2C_TIMEOUT_ERR;
;;;992                    break;
;;;993                }
;;;994            }
;;;995    
;;;996            switch(I2C_GET_STATUS(i2c))
00003c  68c4              LDR      r4,[r0,#0xc]
00003e  2c20              CMP      r4,#0x20
000040  d01f              BEQ      |L37.130|
000042  dc08              BGT      |L37.86|
000044  2c08              CMP      r4,#8
000046  d012              BEQ      |L37.110|
000048  2c18              CMP      r4,#0x18
00004a  d108              BNE      |L37.94|
00004c  e015              B        |L37.122|
                  |L37.78|
00004e  f04f34ff          MOV      r4,#0xffffffff        ;991
000052  603c              STR      r4,[r7,#0]            ;992  ; g_I2C_i32ErrCode
000054  e7f2              B        |L37.60|
                  |L37.86|
000056  2c28              CMP      r4,#0x28
000058  d016              BEQ      |L37.136|
00005a  2c30              CMP      r4,#0x30
00005c  d011              BEQ      |L37.130|
                  |L37.94|
;;;997            {
;;;998            case 0x08u:
;;;999                I2C_SET_DATA(i2c, (uint8_t)(u8SlaveAddr << 1u | 0x00u));               /* Write SLA+W to Register I2CDAT */
;;;1000               u8Ctrl = I2C_CTL_SI;                                      /* Clear SI */
;;;1001               break;
;;;1002           case 0x18u:                                                      /* Slave Address ACK */
;;;1003               I2C_SET_DATA(i2c, (uint8_t)((u16DataAddr & 0xFF00u) >> 8u));    /* Write Hi byte address of register */
;;;1004               break;
;;;1005           case 0x20u:                                                      /* Slave Address NACK */
;;;1006           case 0x30u:                                                      /* Master transmit data NACK */
;;;1007               u8Ctrl = I2C_CTL_STO_SI;                                  /* Clear SI and send STOP */
;;;1008               u8Err = 1u;
;;;1009               break;
;;;1010           case 0x28u:
;;;1011               if(u8Addr)
;;;1012               {
;;;1013                   I2C_SET_DATA(i2c, (uint8_t)(u16DataAddr & 0xFFu));       /* Write Lo byte address of register */
;;;1014                   u8Addr = 0u;
;;;1015               }
;;;1016               else if((u32txLen < 1u) && (u8Addr == 0u))
;;;1017               {
;;;1018                   I2C_SET_DATA(i2c, data);
;;;1019                   u32txLen++;
;;;1020               }
;;;1021               else
;;;1022               {
;;;1023                   u8Ctrl = I2C_CTL_STO_SI;                              /* Clear SI and send STOP */
;;;1024                   u8Xfering = 0u;
;;;1025               }
;;;1026               break;
;;;1027           case 0x38u:                                                      /* Arbitration Lost */
;;;1028           default:                                                        /* Unknow status */
;;;1029               I2C_SET_CONTROL_REG(i2c, I2C_CTL_STO_SI);                   /* Clear SI and send STOP */
00005e  6801              LDR      r1,[r0,#0]
000060  f021013c          BIC      r1,r1,#0x3c
000064  f0410118          ORR      r1,r1,#0x18
000068  6001              STR      r1,[r0,#0]
;;;1030               u8Ctrl = I2C_CTL_SI;
00006a  2208              MOVS     r2,#8
;;;1031               u8Err = 1u;
;;;1032               break;
00006c  e00a              B        |L37.132|
                  |L37.110|
00006e  ea4f624a          LSL      r2,r10,#25            ;999
000072  0e12              LSRS     r2,r2,#24             ;999
000074  6082              STR      r2,[r0,#8]            ;999
000076  2208              MOVS     r2,#8                 ;1000
000078  e013              B        |L37.162|
                  |L37.122|
00007a  ea4f2419          LSR      r4,r9,#8              ;1003
00007e  6084              STR      r4,[r0,#8]            ;1003
000080  e00f              B        |L37.162|
                  |L37.130|
000082  2218              MOVS     r2,#0x18              ;1007
                  |L37.132|
000084  2101              MOVS     r1,#1                 ;1008
000086  e00c              B        |L37.162|
                  |L37.136|
000088  b126              CBZ      r6,|L37.148|
00008a  f00904ff          AND      r4,r9,#0xff           ;1013
00008e  6084              STR      r4,[r0,#8]            ;1013
000090  2600              MOVS     r6,#0                 ;1014
000092  e006              B        |L37.162|
                  |L37.148|
000094  b115              CBZ      r5,|L37.156|
000096  2218              MOVS     r2,#0x18              ;1023
000098  2300              MOVS     r3,#0                 ;1024
00009a  e002              B        |L37.162|
                  |L37.156|
00009c  f8c0b008          STR      r11,[r0,#8]           ;1018
0000a0  2501              MOVS     r5,#1                 ;1019
                  |L37.162|
;;;1033           }
;;;1034           I2C_SET_CONTROL_REG(i2c, u8Ctrl);                                   /* Write controlbit to I2C_CTL register */
0000a2  6804              LDR      r4,[r0,#0]
0000a4  f024043c          BIC      r4,r4,#0x3c
0000a8  4314              ORRS     r4,r4,r2
0000aa  6004              STR      r4,[r0,#0]
;;;1035       }
0000ac  b10b              CBZ      r3,|L37.178|
0000ae  2900              CMP      r1,#0                 ;983
0000b0  d0ba              BEQ      |L37.40|
                  |L37.178|
;;;1036       return (u8Err | u8Xfering);                                             /* return (Success)/(Fail) status */
0000b2  ea410003          ORR      r0,r1,r3
;;;1037   }
0000b6  e8bd8ff0          POP      {r4-r11,pc}
;;;1038   
                          ENDP

0000ba  0000              DCW      0x0000
                  |L37.188|
                          DCD      ||.data||
                  |L37.192|
                          DCD      SystemCoreClock

                          AREA ||i.I2C_WriteMultiBytes||, CODE, READONLY, ALIGN=2

                  I2C_WriteMultiBytes PROC
;;;754    
;;;755    uint32_t I2C_WriteMultiBytes(I2C_T *i2c, uint8_t u8SlaveAddr, uint8_t data[], uint32_t u32wLen)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;756    {
;;;757        uint8_t u8Xfering = 1u, u8Err = 0u, u8Ctrl = 0u;
000004  2601              MOVS     r6,#1
;;;758        uint32_t u32txLen = 0u;
;;;759    
;;;760        g_I2C_i32ErrCode = 0;
000006  4f27              LDR      r7,|L38.164|
000008  2500              MOVS     r5,#0                 ;757
00000a  4692              MOV      r10,r2                ;756
;;;761    
;;;762        I2C_START(i2c);                                              /* Send START */
00000c  603d              STR      r5,[r7,#0]  ; g_I2C_i32ErrCode
00000e  4689              MOV      r9,r1                 ;756
000010  6804              LDR      r4,[r0,#0]
000012  4629              MOV      r1,r5                 ;757
000014  462a              MOV      r2,r5                 ;758
000016  f0240408          BIC      r4,r4,#8
00001a  f0440420          ORR      r4,r4,#0x20
00001e  6004              STR      r4,[r0,#0]
;;;763        while(u8Xfering && (u8Err == 0u))
;;;764        {
;;;765            uint32_t u32TimeOutCount = SystemCoreClock; // 1 second timeout
000020  f8dfc084          LDR      r12,|L38.168|
                  |L38.36|
;;;766            I2C_WAIT_READY(i2c)
000024  f8dc4000          LDR      r4,[r12,#0]  ; SystemCoreClock
000028  e001              B        |L38.46|
                  |L38.42|
00002a  1e64              SUBS     r4,r4,#1
;;;767            {
;;;768                u32TimeOutCount--;
;;;769                if(u32TimeOutCount == 0)
00002c  d00d              BEQ      |L38.74|
                  |L38.46|
00002e  f8d08000          LDR      r8,[r0,#0]            ;766
000032  ea5f7808          LSLS     r8,r8,#28             ;766
000036  d5f8              BPL      |L38.42|
                  |L38.56|
;;;770                {
;;;771                    g_I2C_i32ErrCode = I2C_TIMEOUT_ERR;
;;;772                    break;
;;;773                }
;;;774            }
;;;775    
;;;776            switch(I2C_GET_STATUS(i2c))
000038  68c4              LDR      r4,[r0,#0xc]
00003a  2c20              CMP      r4,#0x20
00003c  d025              BEQ      |L38.138|
00003e  dc08              BGT      |L38.82|
000040  2c08              CMP      r4,#8
000042  d012              BEQ      |L38.106|
000044  2c18              CMP      r4,#0x18
000046  d108              BNE      |L38.90|
000048  e015              B        |L38.118|
                  |L38.74|
00004a  f04f34ff          MOV      r4,#0xffffffff        ;771
00004e  603c              STR      r4,[r7,#0]            ;772  ; g_I2C_i32ErrCode
000050  e7f2              B        |L38.56|
                  |L38.82|
000052  2c28              CMP      r4,#0x28
000054  d00f              BEQ      |L38.118|
000056  2c30              CMP      r4,#0x30
000058  d017              BEQ      |L38.138|
                  |L38.90|
;;;777            {
;;;778            case 0x08u:
;;;779                I2C_SET_DATA(i2c, (uint8_t)(u8SlaveAddr << 1u | 0x00u));    /* Write SLA+W to Register I2CDAT */
;;;780                u8Ctrl = I2C_CTL_SI;                           /* Clear SI */
;;;781                break;
;;;782            case 0x18u:                                           /* Slave Address ACK */
;;;783            case 0x28u:
;;;784                if(u32txLen < u32wLen)
;;;785                {
;;;786                    I2C_SET_DATA(i2c, data[u32txLen++]);                /* Write Data to I2CDAT */
;;;787                }
;;;788                else
;;;789                {
;;;790                    u8Ctrl = I2C_CTL_STO_SI;                   /* Clear SI and send STOP */
;;;791                    u8Xfering = 0u;
;;;792                }
;;;793                break;
;;;794            case 0x20u:                                           /* Slave Address NACK */
;;;795            case 0x30u:                                           /* Master transmit data NACK */
;;;796                u8Ctrl = I2C_CTL_STO_SI;                       /* Clear SI and send STOP */
;;;797                u8Err = 1u;
;;;798                break;
;;;799            case 0x38u:                                           /* Arbitration Lost */
;;;800            default:                                             /* Unknow status */
;;;801                I2C_SET_CONTROL_REG(i2c, I2C_CTL_STO_SI);      /* Clear SI and send STOP */
00005a  6801              LDR      r1,[r0,#0]
00005c  f021013c          BIC      r1,r1,#0x3c
000060  f0410118          ORR      r1,r1,#0x18
000064  6001              STR      r1,[r0,#0]
;;;802                u8Ctrl = I2C_CTL_SI;
000066  2108              MOVS     r1,#8
;;;803                u8Err = 1u;
;;;804                break;
000068  e010              B        |L38.140|
                  |L38.106|
00006a  ea4f6149          LSL      r1,r9,#25             ;779
00006e  0e09              LSRS     r1,r1,#24             ;779
000070  6081              STR      r1,[r0,#8]            ;779
000072  2108              MOVS     r1,#8                 ;780
000074  e00b              B        |L38.142|
                  |L38.118|
000076  429a              CMP      r2,r3                 ;784
000078  d204              BCS      |L38.132|
00007a  f81a4002          LDRB     r4,[r10,r2]           ;786
00007e  6084              STR      r4,[r0,#8]            ;786
000080  1c52              ADDS     r2,r2,#1              ;786
000082  e004              B        |L38.142|
                  |L38.132|
000084  2118              MOVS     r1,#0x18              ;790
000086  2600              MOVS     r6,#0                 ;791
000088  e001              B        |L38.142|
                  |L38.138|
00008a  2118              MOVS     r1,#0x18              ;796
                  |L38.140|
00008c  2501              MOVS     r5,#1                 ;797
                  |L38.142|
;;;805            }
;;;806            I2C_SET_CONTROL_REG(i2c, u8Ctrl);                        /* Write controlbit to I2C_CTL register */
00008e  6804              LDR      r4,[r0,#0]
000090  f024043c          BIC      r4,r4,#0x3c
000094  430c              ORRS     r4,r4,r1
000096  6004              STR      r4,[r0,#0]
;;;807        }
000098  b10e              CBZ      r6,|L38.158|
00009a  2d00              CMP      r5,#0                 ;763
00009c  d0c2              BEQ      |L38.36|
                  |L38.158|
;;;808        return u32txLen;                                             /* Return bytes length that have been transmitted */
00009e  4610              MOV      r0,r2
;;;809    }
0000a0  e8bd87f0          POP      {r4-r10,pc}
;;;810    
                          ENDP

                  |L38.164|
                          DCD      ||.data||
                  |L38.168|
                          DCD      SystemCoreClock

                          AREA ||i.I2C_WriteMultiBytesOneReg||, CODE, READONLY, ALIGN=2

                  I2C_WriteMultiBytesOneReg PROC
;;;900    
;;;901    uint32_t I2C_WriteMultiBytesOneReg(I2C_T *i2c, uint8_t u8SlaveAddr, uint8_t u8DataAddr, uint8_t data[], uint32_t u32wLen)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;902    {
;;;903        uint8_t u8Xfering = 1u, u8Err = 0u, u8Ctrl = 0u;
000004  2601              MOVS     r6,#1
;;;904        uint32_t u32txLen = 0u;
;;;905    
;;;906        g_I2C_i32ErrCode = 0;
000006  4f29              LDR      r7,|L39.172|
000008  2500              MOVS     r5,#0                 ;903
00000a  f8dd9024          LDR      r9,[sp,#0x24]
;;;907    
;;;908        I2C_START(i2c);                                              /* Send START */
00000e  603d              STR      r5,[r7,#0]  ; g_I2C_i32ErrCode
000010  469b              MOV      r11,r3                ;902
000012  4692              MOV      r10,r2                ;902
000014  6804              LDR      r4,[r0,#0]
000016  462a              MOV      r2,r5                 ;903
000018  462b              MOV      r3,r5                 ;904
00001a  f0240408          BIC      r4,r4,#8
00001e  f0440420          ORR      r4,r4,#0x20
000022  6004              STR      r4,[r0,#0]
;;;909        while(u8Xfering && (u8Err == 0u))
;;;910        {
;;;911            uint32_t u32TimeOutCount = SystemCoreClock; // 1 second timeout
000024  f8dfc088          LDR      r12,|L39.176|
                  |L39.40|
;;;912            I2C_WAIT_READY(i2c)
000028  f8dc4000          LDR      r4,[r12,#0]  ; SystemCoreClock
00002c  e001              B        |L39.50|
                  |L39.46|
00002e  1e64              SUBS     r4,r4,#1
;;;913            {
;;;914                u32TimeOutCount--;
;;;915                if(u32TimeOutCount == 0)
000030  d00d              BEQ      |L39.78|
                  |L39.50|
000032  f8d08000          LDR      r8,[r0,#0]            ;912
000036  ea5f7808          LSLS     r8,r8,#28             ;912
00003a  d5f8              BPL      |L39.46|
                  |L39.60|
;;;916                {
;;;917                    g_I2C_i32ErrCode = I2C_TIMEOUT_ERR;
;;;918                    break;
;;;919                }
;;;920            }
;;;921    
;;;922            switch(I2C_GET_STATUS(i2c))
00003c  68c4              LDR      r4,[r0,#0xc]
00003e  2c20              CMP      r4,#0x20
000040  d01d              BEQ      |L39.126|
000042  dc08              BGT      |L39.86|
000044  2c08              CMP      r4,#8
000046  d012              BEQ      |L39.110|
000048  2c18              CMP      r4,#0x18
00004a  d108              BNE      |L39.94|
00004c  e014              B        |L39.120|
                  |L39.78|
00004e  f04f34ff          MOV      r4,#0xffffffff        ;917
000052  603c              STR      r4,[r7,#0]            ;918  ; g_I2C_i32ErrCode
000054  e7f2              B        |L39.60|
                  |L39.86|
000056  2c28              CMP      r4,#0x28
000058  d014              BEQ      |L39.132|
00005a  2c30              CMP      r4,#0x30
00005c  d00f              BEQ      |L39.126|
                  |L39.94|
;;;923            {
;;;924            case 0x08u:
;;;925                I2C_SET_DATA(i2c, (uint8_t)(u8SlaveAddr << 1u | 0x00u));    /* Write SLA+W to Register I2CDAT */
;;;926                u8Ctrl = I2C_CTL_SI;
;;;927                break;
;;;928            case 0x18u:                                           /* Slave Address ACK */
;;;929                I2C_SET_DATA(i2c, u8DataAddr);                   /* Write Lo byte address of register */
;;;930                break;
;;;931            case 0x20u:                                           /* Slave Address NACK */
;;;932            case 0x30u:                                           /* Master transmit data NACK */
;;;933                u8Ctrl = I2C_CTL_STO_SI;                       /* Clear SI and send STOP */
;;;934                u8Err = 1u;
;;;935                break;
;;;936            case 0x28u:
;;;937                if(u32txLen < u32wLen)
;;;938                {
;;;939                    I2C_SET_DATA(i2c, data[u32txLen++]);
;;;940                }
;;;941                else
;;;942                {
;;;943                    u8Ctrl = I2C_CTL_STO_SI;                   /* Clear SI and send STOP */
;;;944                    u8Xfering = 0u;
;;;945                }
;;;946                break;
;;;947            case 0x38u:                                           /* Arbitration Lost */
;;;948            default:                                             /* Unknow status */
;;;949                I2C_SET_CONTROL_REG(i2c, I2C_CTL_STO_SI);        /* Clear SI and send STOP */
00005e  6802              LDR      r2,[r0,#0]
000060  f022023c          BIC      r2,r2,#0x3c
000064  f0420218          ORR      r2,r2,#0x18
000068  6002              STR      r2,[r0,#0]
;;;950                u8Ctrl = I2C_CTL_SI;
00006a  2208              MOVS     r2,#8
;;;951                u8Err = 1u;
;;;952                break;
00006c  e008              B        |L39.128|
                  |L39.110|
00006e  064a              LSLS     r2,r1,#25             ;925
000070  0e12              LSRS     r2,r2,#24             ;925
000072  6082              STR      r2,[r0,#8]            ;925
000074  2208              MOVS     r2,#8                 ;926
000076  e00e              B        |L39.150|
                  |L39.120|
000078  f8c0a008          STR      r10,[r0,#8]           ;929
00007c  e00b              B        |L39.150|
                  |L39.126|
00007e  2218              MOVS     r2,#0x18              ;933
                  |L39.128|
000080  2501              MOVS     r5,#1                 ;934
000082  e008              B        |L39.150|
                  |L39.132|
000084  454b              CMP      r3,r9                 ;937
000086  d204              BCS      |L39.146|
000088  f81b4003          LDRB     r4,[r11,r3]           ;939
00008c  6084              STR      r4,[r0,#8]            ;939
00008e  1c5b              ADDS     r3,r3,#1              ;939
000090  e001              B        |L39.150|
                  |L39.146|
000092  2218              MOVS     r2,#0x18              ;943
000094  2600              MOVS     r6,#0                 ;944
                  |L39.150|
;;;953            }
;;;954            I2C_SET_CONTROL_REG(i2c, u8Ctrl);                        /* Write controlbit to I2C_CTL register */
000096  6804              LDR      r4,[r0,#0]
000098  f024043c          BIC      r4,r4,#0x3c
00009c  4314              ORRS     r4,r4,r2
00009e  6004              STR      r4,[r0,#0]
;;;955        }
0000a0  b10e              CBZ      r6,|L39.166|
0000a2  2d00              CMP      r5,#0                 ;909
0000a4  d0c0              BEQ      |L39.40|
                  |L39.166|
;;;956    
;;;957        return u32txLen;                                             /* Return bytes length that have been transmitted */
0000a6  4618              MOV      r0,r3
;;;958    }
0000a8  e8bd8ff0          POP      {r4-r11,pc}
;;;959    
                          ENDP

                  |L39.172|
                          DCD      ||.data||
                  |L39.176|
                          DCD      SystemCoreClock

                          AREA ||i.I2C_WriteMultiBytesTwoRegs||, CODE, READONLY, ALIGN=2

                  I2C_WriteMultiBytesTwoRegs PROC
;;;1054   
;;;1055   uint32_t I2C_WriteMultiBytesTwoRegs(I2C_T *i2c, uint8_t u8SlaveAddr, uint16_t u16DataAddr, uint8_t data[], uint32_t u32wLen)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;1056   {
;;;1057       uint8_t u8Xfering = 1u, u8Err = 0u, u8Addr = 1u, u8Ctrl = 0u;
000004  2501              MOVS     r5,#1
;;;1058       uint32_t u32txLen = 0u;
;;;1059   
;;;1060       g_I2C_i32ErrCode = 0;
000006  4f2e              LDR      r7,|L40.192|
000008  2400              MOVS     r4,#0                 ;1057
00000a  f8ddb024          LDR      r11,[sp,#0x24]
00000e  469e              MOV      lr,r3                 ;1056
;;;1061   
;;;1062       I2C_START(i2c);                                                         /* Send START */
000010  603c              STR      r4,[r7,#0]  ; g_I2C_i32ErrCode
000012  4691              MOV      r9,r2                 ;1056
000014  468a              MOV      r10,r1                ;1056
000016  6803              LDR      r3,[r0,#0]
000018  462e              MOV      r6,r5                 ;1057
00001a  4621              MOV      r1,r4                 ;1057
00001c  4622              MOV      r2,r4                 ;1058
00001e  f0230308          BIC      r3,r3,#8
000022  f0430320          ORR      r3,r3,#0x20
000026  6003              STR      r3,[r0,#0]
;;;1063       while(u8Xfering && (u8Err == 0u))
;;;1064       {
;;;1065           uint32_t u32TimeOutCount = SystemCoreClock; // 1 second timeout
000028  f8dfc098          LDR      r12,|L40.196|
                  |L40.44|
;;;1066           I2C_WAIT_READY(i2c)
00002c  f8dc3000          LDR      r3,[r12,#0]  ; SystemCoreClock
000030  e001              B        |L40.54|
                  |L40.50|
000032  1e5b              SUBS     r3,r3,#1
;;;1067           {
;;;1068               u32TimeOutCount--;
;;;1069               if(u32TimeOutCount == 0)
000034  d00d              BEQ      |L40.82|
                  |L40.54|
000036  f8d08000          LDR      r8,[r0,#0]            ;1066
00003a  ea5f7808          LSLS     r8,r8,#28             ;1066
00003e  d5f8              BPL      |L40.50|
                  |L40.64|
;;;1070               {
;;;1071                   g_I2C_i32ErrCode = I2C_TIMEOUT_ERR;
;;;1072                   break;
;;;1073               }
;;;1074           }
;;;1075   
;;;1076           switch(I2C_GET_STATUS(i2c))
000040  68c3              LDR      r3,[r0,#0xc]
000042  2b20              CMP      r3,#0x20
000044  d01f              BEQ      |L40.134|
000046  dc08              BGT      |L40.90|
000048  2b08              CMP      r3,#8
00004a  d012              BEQ      |L40.114|
00004c  2b18              CMP      r3,#0x18
00004e  d108              BNE      |L40.98|
000050  e015              B        |L40.126|
                  |L40.82|
000052  f04f33ff          MOV      r3,#0xffffffff        ;1071
000056  603b              STR      r3,[r7,#0]            ;1072  ; g_I2C_i32ErrCode
000058  e7f2              B        |L40.64|
                  |L40.90|
00005a  2b28              CMP      r3,#0x28
00005c  d016              BEQ      |L40.140|
00005e  2b30              CMP      r3,#0x30
000060  d011              BEQ      |L40.134|
                  |L40.98|
;;;1077           {
;;;1078           case 0x08u:
;;;1079               I2C_SET_DATA(i2c, (uint8_t)(u8SlaveAddr << 1u | 0x00u));               /* Write SLA+W to Register I2CDAT */
;;;1080               u8Ctrl = I2C_CTL_SI;                                      /* Clear SI */
;;;1081               break;
;;;1082           case 0x18u:                                                      /* Slave Address ACK */
;;;1083               I2C_SET_DATA(i2c, (uint8_t)((u16DataAddr & 0xFF00u) >> 8u));    /* Write Hi byte address of register */
;;;1084               break;
;;;1085           case 0x20u:                                                      /* Slave Address NACK */
;;;1086           case 0x30u:                                                      /* Master transmit data NACK */
;;;1087               u8Ctrl = I2C_CTL_STO_SI;                                  /* Clear SI and send STOP */
;;;1088               u8Err = 1u;
;;;1089               break;
;;;1090           case 0x28u:
;;;1091               if(u8Addr)
;;;1092               {
;;;1093                   I2C_SET_DATA(i2c, (uint8_t)(u16DataAddr & 0xFFu));       /* Write Lo byte address of register */
;;;1094                   u8Addr = 0u;
;;;1095               }
;;;1096               else if((u32txLen < u32wLen) && (u8Addr == 0u))
;;;1097               {
;;;1098                   I2C_SET_DATA(i2c, data[u32txLen++]);                           /* Write data to Register I2CDAT*/
;;;1099               }
;;;1100               else
;;;1101               {
;;;1102                   u8Ctrl = I2C_CTL_STO_SI;                              /* Clear SI and send STOP */
;;;1103                   u8Xfering = 0u;
;;;1104               }
;;;1105               break;
;;;1106           case 0x38u:                                                      /* Arbitration Lost */
;;;1107           default:                                                        /* Unknow status */
;;;1108               I2C_SET_CONTROL_REG(i2c, I2C_CTL_STO_SI);                   /* Clear SI and send STOP */
000062  6801              LDR      r1,[r0,#0]
000064  f021013c          BIC      r1,r1,#0x3c
000068  f0410118          ORR      r1,r1,#0x18
00006c  6001              STR      r1,[r0,#0]
;;;1109               u8Ctrl = I2C_CTL_SI;
00006e  2108              MOVS     r1,#8
;;;1110               u8Err = 1u;
;;;1111               break;
000070  e00a              B        |L40.136|
                  |L40.114|
000072  ea4f614a          LSL      r1,r10,#25            ;1079
000076  0e09              LSRS     r1,r1,#24             ;1079
000078  6081              STR      r1,[r0,#8]            ;1079
00007a  2108              MOVS     r1,#8                 ;1080
00007c  e015              B        |L40.170|
                  |L40.126|
00007e  ea4f2319          LSR      r3,r9,#8              ;1083
000082  6083              STR      r3,[r0,#8]            ;1083
000084  e011              B        |L40.170|
                  |L40.134|
000086  2118              MOVS     r1,#0x18              ;1087
                  |L40.136|
000088  2401              MOVS     r4,#1                 ;1088
00008a  e00e              B        |L40.170|
                  |L40.140|
00008c  b126              CBZ      r6,|L40.152|
00008e  f00903ff          AND      r3,r9,#0xff           ;1093
000092  6083              STR      r3,[r0,#8]            ;1093
000094  2600              MOVS     r6,#0                 ;1094
000096  e008              B        |L40.170|
                  |L40.152|
000098  455a              CMP      r2,r11                ;1096
00009a  d204              BCS      |L40.166|
00009c  f81e3002          LDRB     r3,[lr,r2]            ;1098
0000a0  6083              STR      r3,[r0,#8]            ;1098
0000a2  1c52              ADDS     r2,r2,#1              ;1098
0000a4  e001              B        |L40.170|
                  |L40.166|
0000a6  2118              MOVS     r1,#0x18              ;1102
0000a8  2500              MOVS     r5,#0                 ;1103
                  |L40.170|
;;;1112           }
;;;1113           I2C_SET_CONTROL_REG(i2c, u8Ctrl);                                   /* Write controlbit to I2C_CTL register */
0000aa  6803              LDR      r3,[r0,#0]
0000ac  f023033c          BIC      r3,r3,#0x3c
0000b0  430b              ORRS     r3,r3,r1
0000b2  6003              STR      r3,[r0,#0]
;;;1114       }
0000b4  b10d              CBZ      r5,|L40.186|
0000b6  2c00              CMP      r4,#0                 ;1063
0000b8  d0b8              BEQ      |L40.44|
                  |L40.186|
;;;1115       return u32txLen;                                                        /* Return bytes length that have been transmitted */
0000ba  4610              MOV      r0,r2
;;;1116   }
0000bc  e8bd8ff0          POP      {r4-r11,pc}
;;;1117   
                          ENDP

                  |L40.192|
                          DCD      ||.data||
                  |L40.196|
                          DCD      SystemCoreClock

                          AREA ||.data||, DATA, ALIGN=2

                  g_I2C_i32ErrCode
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\..\\Library\\StdDriver\\src\\i2c.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___5_i2c_c_0e6d8793____REV16|
#line 464 "..\\..\\..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___5_i2c_c_0e6d8793____REV16| PROC
#line 465

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___5_i2c_c_0e6d8793____REVSH|
#line 479
|__asm___5_i2c_c_0e6d8793____REVSH| PROC
#line 480

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___5_i2c_c_0e6d8793____RRX|
#line 666
|__asm___5_i2c_c_0e6d8793____RRX| PROC
#line 667

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
