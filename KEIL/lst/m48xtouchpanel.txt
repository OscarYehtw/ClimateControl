; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\obj\m48xtouchpanel.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\m48xtouchpanel.d --cpu=Cortex-M4.fp --apcs=interwork -O3 --diag_suppress=9931 -I..\..\..\..\Library\Device\Nuvoton\M480\Include -I..\..\..\..\Library\StdDriver\inc -I..\..\..\..\ThirdParty\emWin\Config -I..\..\..\..\ThirdParty\emWin\Include -I..\tslib -I..\..\..\..\Library\CMSIS\Include -I..\Thermostat -I..\Application\Source\Generated -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=523 --omf_browse=.\obj\m48xtouchpanel.crf ..\tslib\M48XTouchPanel.c]
                          THUMB

                          AREA ||i.Check_TouchPanel||, CODE, READONLY, ALIGN=1

                  Check_TouchPanel PROC
;;;155    
;;;156    int Check_TouchPanel(void)
000000  2000              MOVS     r0,#0
;;;157    {
;;;158        return 0;   //Pen up;
;;;159    }
000002  4770              BX       lr
;;;160    
                          ENDP


                          AREA ||i.EADC01_IRQHandler||, CODE, READONLY, ALIGN=2

                  EADC01_IRQHandler PROC
;;;32     /*-----------------------------------------------*/
;;;33     void EADC01_IRQHandler(void)
000000  4903              LDR      r1,|L2.16|
;;;34     {
;;;35         /* Clear the A/D ADINT1 interrupt flag */
;;;36         EADC_CLR_INT_FLAG(EADC, EADC_STATUS2_ADIF1_Msk);
000002  2002              MOVS     r0,#2
000004  f8c100f8          STR      r0,[r1,#0xf8]
;;;37     
;;;38         g_u32AdcIntFlag_TP = 1;
000008  4902              LDR      r1,|L2.20|
00000a  2001              MOVS     r0,#1
00000c  6008              STR      r0,[r1,#0]  ; g_u32AdcIntFlag_TP
;;;39     
;;;40     }
00000e  4770              BX       lr
;;;41     
                          ENDP

                  |L2.16|
                          DCD      0x40043000
                  |L2.20|
                          DCD      ||.data||

                          AREA ||i.Get_TP_X||, CODE, READONLY, ALIGN=2

                  Get_TP_X PROC
;;;45     /*-----------------------------------------------*/
;;;46     uint16_t Get_TP_X(void)
000000  b570              PUSH     {r4-r6,lr}
;;;47     {
;;;48         uint16_t    x_adc_in;
;;;49     
;;;50         /*=== Get X from ADC input ===*/
;;;51         GPIO_SetMode(PB, BIT9, GPIO_MODE_OUTPUT);   // XR
000002  2201              MOVS     r2,#1
000004  0251              LSLS     r1,r2,#9
000006  4821              LDR      r0,|L3.140|
000008  f7fffffe          BL       GPIO_SetMode
;;;52         GPIO_SetMode(PH, BIT5, GPIO_MODE_INPUT);    // YD
00000c  4c20              LDR      r4,|L3.144|
00000e  2200              MOVS     r2,#0
000010  2120              MOVS     r1,#0x20
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       GPIO_SetMode
;;;53         GPIO_SetMode(PH, BIT4, GPIO_MODE_OUTPUT);   // XL
000018  2201              MOVS     r2,#1
00001a  2110              MOVS     r1,#0x10
00001c  4620              MOV      r0,r4
00001e  f7fffffe          BL       GPIO_SetMode
;;;54         PB9 = 1;
000022  491c              LDR      r1,|L3.148|
000024  2001              MOVS     r0,#1
000026  6008              STR      r0,[r1,#0]
;;;55         PH4 = 0;
000028  481b              LDR      r0,|L3.152|
00002a  2500              MOVS     r5,#0
00002c  6005              STR      r5,[r0,#0]
;;;56     
;;;57         /* Configure the GPB8 ADC analog input pins.  */
;;;58         SYS->GPB_MFPH &= ~(SYS_GPB_MFPH_PB8MFP_Msk | SYS_GPB_MFPH_PB9MFP_Msk);
00002e  0680              LSLS     r0,r0,#26
000030  6bc1              LDR      r1,[r0,#0x3c]
000032  f02101ff          BIC      r1,r1,#0xff
000036  63c1              STR      r1,[r0,#0x3c]
;;;59         SYS->GPB_MFPH |= SYS_GPB_MFPH_PB8MFP_EADC0_CH8;
000038  6bc1              LDR      r1,[r0,#0x3c]
00003a  f0410101          ORR      r1,r1,#1
00003e  63c1              STR      r1,[r0,#0x3c]
;;;60     
;;;61         /* Disable the GPB8 digital input path to avoid the leakage current. */
;;;62         GPIO_DISABLE_DIGITAL_PATH(PB, BIT8);
000040  f04f2040          MOV      r0,#0x40004000
000044  6c41              LDR      r1,[r0,#0x44]
000046  f0417180          ORR      r1,r1,#0x1000000
00004a  6441              STR      r1,[r0,#0x44]
;;;63     
;;;64         /* Configure the sample module 1 for analog input channel 8 and software trigger source.*/
;;;65         EADC_ConfigSampleModule(EADC, 1, EADC_SOFTWARE_TRIGGER, 8); // YU
00004c  4c13              LDR      r4,|L3.156|
00004e  2308              MOVS     r3,#8
000050  462a              MOV      r2,r5
000052  2101              MOVS     r1,#1
000054  4620              MOV      r0,r4
000056  f7fffffe          BL       EADC_ConfigSampleModule
;;;66     
;;;67         /* Clear the A/D ADINT1 interrupt flag for safe */
;;;68         EADC_CLR_INT_FLAG(EADC, EADC_STATUS2_ADIF1_Msk);
00005a  2602              MOVS     r6,#2
00005c  f8c460f8          STR      r6,[r4,#0xf8]
;;;69     
;;;70         /* Enable the sample module 1 interrupt.  */
;;;71         EADC_ENABLE_INT(EADC, BIT1);    //Enable sample module A/D ADINT1 interrupt.
000060  6d20              LDR      r0,[r4,#0x50]
000062  f0400008          ORR      r0,r0,#8
000066  6520              STR      r0,[r4,#0x50]
;;;72         EADC_ENABLE_SAMPLE_MODULE_INT(EADC, 1, BIT1);    //Enable sample module 1 interrupt.
000068  f8d400d4          LDR      r0,[r4,#0xd4]
00006c  f0400002          ORR      r0,r0,#2
000070  f8c400d4          STR      r0,[r4,#0xd4]
;;;73         NVIC_EnableIRQ(EADC01_IRQn);
000074  202b              MOVS     r0,#0x2b
000076  f7fffffe          BL       __NVIC_EnableIRQ
;;;74     
;;;75         /* Reset the ADC interrupt indicator and trigger sample module 1 to start A/D conversion */
;;;76         g_u32AdcIntFlag_TP = 0;
00007a  4809              LDR      r0,|L3.160|
00007c  6005              STR      r5,[r0,#0]  ; g_u32AdcIntFlag_TP
;;;77         EADC_START_CONV(EADC, BIT1);
00007e  6566              STR      r6,[r4,#0x54]
                  |L3.128|
;;;78     
;;;79         /* Wait ADC interrupt (g_u32AdcIntFlag_TP will be set at IRQ_Handler function) */
;;;80         while(g_u32AdcIntFlag_TP == 0);
000080  6801              LDR      r1,[r0,#0]  ; g_u32AdcIntFlag_TP
000082  2900              CMP      r1,#0
000084  d0fc              BEQ      |L3.128|
;;;81         x_adc_in = EADC_GET_CONV_DATA(EADC, 1);
000086  6860              LDR      r0,[r4,#4]
000088  b280              UXTH     r0,r0
;;;82         return x_adc_in;
;;;83     
;;;84     }
00008a  bd70              POP      {r4-r6,pc}
;;;85     
                          ENDP

                  |L3.140|
                          DCD      0x40004040
                  |L3.144|
                          DCD      0x400041c0
                  |L3.148|
                          DCD      0x40004864
                  |L3.152|
                          DCD      0x400049d0
                  |L3.156|
                          DCD      0x40043000
                  |L3.160|
                          DCD      ||.data||

                          AREA ||i.Get_TP_Y||, CODE, READONLY, ALIGN=2

                  Get_TP_Y PROC
;;;90     /*-----------------------------------------------*/
;;;91     uint16_t Get_TP_Y(void)
000000  b570              PUSH     {r4-r6,lr}
;;;92     {
;;;93         uint16_t    y_adc_in;
;;;94     
;;;95         /*=== Get Y from ADC input ===*/
;;;96         GPIO_SetMode(PB, BIT8, GPIO_MODE_OUTPUT);   // YU
000002  2201              MOVS     r2,#1
000004  0211              LSLS     r1,r2,#8
000006  4822              LDR      r0,|L4.144|
000008  f7fffffe          BL       GPIO_SetMode
;;;97         GPIO_SetMode(PH, BIT5, GPIO_MODE_OUTPUT);   // YD
00000c  4c21              LDR      r4,|L4.148|
00000e  2201              MOVS     r2,#1
000010  2120              MOVS     r1,#0x20
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       GPIO_SetMode
;;;98         GPIO_SetMode(PH, BIT4, GPIO_MODE_INPUT);    // XL
000018  2200              MOVS     r2,#0
00001a  2110              MOVS     r1,#0x10
00001c  4620              MOV      r0,r4
00001e  f7fffffe          BL       GPIO_SetMode
;;;99         PB8 = 1;
000022  491d              LDR      r1,|L4.152|
000024  2001              MOVS     r0,#1
000026  6008              STR      r0,[r1,#0]
;;;100        PH5 = 0;
000028  481c              LDR      r0,|L4.156|
00002a  2500              MOVS     r5,#0
00002c  6005              STR      r5,[r0,#0]
;;;101    
;;;102        /* Configure the GPB9 ADC analog input pins.  */
;;;103        SYS->GPB_MFPH &= ~(SYS_GPB_MFPH_PB8MFP_Msk | SYS_GPB_MFPH_PB9MFP_Msk);
00002e  0700              LSLS     r0,r0,#28
000030  6bc1              LDR      r1,[r0,#0x3c]
000032  f02101ff          BIC      r1,r1,#0xff
000036  63c1              STR      r1,[r0,#0x3c]
;;;104        SYS->GPB_MFPH |= SYS_GPB_MFPH_PB9MFP_EADC0_CH9;
000038  6bc1              LDR      r1,[r0,#0x3c]
00003a  f0410110          ORR      r1,r1,#0x10
00003e  63c1              STR      r1,[r0,#0x3c]
;;;105    
;;;106        /* Disable the GPB9 digital input path to avoid the leakage current. */
;;;107        GPIO_DISABLE_DIGITAL_PATH(PB, BIT9);
000040  f04f2040          MOV      r0,#0x40004000
000044  6c41              LDR      r1,[r0,#0x44]
000046  f0417100          ORR      r1,r1,#0x2000000
00004a  6441              STR      r1,[r0,#0x44]
;;;108    
;;;109        /* Configure the sample module 2 for analog input channel 9 and software trigger source.*/
;;;110        EADC_ConfigSampleModule(EADC, 2, EADC_SOFTWARE_TRIGGER, 9); // XR
00004c  4c14              LDR      r4,|L4.160|
00004e  2309              MOVS     r3,#9
000050  462a              MOV      r2,r5
000052  2102              MOVS     r1,#2
000054  4620              MOV      r0,r4
000056  f7fffffe          BL       EADC_ConfigSampleModule
;;;111    
;;;112        /* Clear the A/D ADINT1 interrupt flag for safe */
;;;113        EADC_CLR_INT_FLAG(EADC, EADC_STATUS2_ADIF1_Msk);
00005a  2002              MOVS     r0,#2
00005c  f8c400f8          STR      r0,[r4,#0xf8]
;;;114    
;;;115        /* Enable the sample module 2 interrupt.  */
;;;116        EADC_ENABLE_INT(EADC, BIT2);    //Enable sample module A/D ADINT1 interrupt.
000060  6d20              LDR      r0,[r4,#0x50]
000062  f0400010          ORR      r0,r0,#0x10
000066  6520              STR      r0,[r4,#0x50]
;;;117        EADC_ENABLE_SAMPLE_MODULE_INT(EADC, 1, BIT2);    //Enable sample module 2 interrupt.
000068  f8d400d4          LDR      r0,[r4,#0xd4]
00006c  f0400004          ORR      r0,r0,#4
000070  f8c400d4          STR      r0,[r4,#0xd4]
;;;118        NVIC_EnableIRQ(EADC01_IRQn);
000074  202b              MOVS     r0,#0x2b
000076  f7fffffe          BL       __NVIC_EnableIRQ
;;;119    
;;;120        /* Reset the ADC interrupt indicator and trigger sample module 2 to start A/D conversion */
;;;121        g_u32AdcIntFlag_TP = 0;
00007a  480a              LDR      r0,|L4.164|
00007c  6005              STR      r5,[r0,#0]  ; g_u32AdcIntFlag_TP
;;;122        EADC_START_CONV(EADC, BIT2);
00007e  2104              MOVS     r1,#4
000080  6561              STR      r1,[r4,#0x54]
                  |L4.130|
;;;123    
;;;124        /* Wait ADC interrupt (g_u32AdcIntFlag_TP will be set at IRQ_Handler function) */
;;;125        while(g_u32AdcIntFlag_TP == 0);
000082  6801              LDR      r1,[r0,#0]  ; g_u32AdcIntFlag_TP
000084  2900              CMP      r1,#0
000086  d0fc              BEQ      |L4.130|
;;;126        y_adc_in = EADC_GET_CONV_DATA(EADC, 2);
000088  68a0              LDR      r0,[r4,#8]
00008a  b280              UXTH     r0,r0
;;;127        return y_adc_in;
;;;128    
;;;129    }
00008c  bd70              POP      {r4-r6,pc}
;;;130    
                          ENDP

00008e  0000              DCW      0x0000
                  |L4.144|
                          DCD      0x40004040
                  |L4.148|
                          DCD      0x400041c0
                  |L4.152|
                          DCD      0x40004860
                  |L4.156|
                          DCD      0x400049d4
                  |L4.160|
                          DCD      0x40043000
                  |L4.164|
                          DCD      ||.data||

                          AREA ||i.Init_TouchPanel||, CODE, READONLY, ALIGN=2

                  Init_TouchPanel PROC
;;;11     
;;;12     int Init_TouchPanel(void)
000000  b510              PUSH     {r4,lr}
;;;13     {
;;;14         /* Enable peripheral clock */
;;;15         CLK_EnableModuleClock(EADC_MODULE);
000002  4c08              LDR      r4,|L5.36|
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       CLK_EnableModuleClock
;;;16     
;;;17         /* Peripheral clock source */
;;;18         CLK_SetModuleClock(EADC_MODULE, 0, CLK_CLKDIV0_EADC(8));
00000a  f44f22e0          MOV      r2,#0x70000
00000e  2100              MOVS     r1,#0
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       CLK_SetModuleClock
;;;19     
;;;20         /* Init ADC for TP */
;;;21         /* Set input mode as single-end and enable the A/D converter */
;;;22         EADC_Open(EADC, EADC_CTL_DIFFEN_SINGLE_END);
000016  2100              MOVS     r1,#0
000018  4803              LDR      r0,|L5.40|
00001a  f7fffffe          BL       EADC_Open
;;;23     
;;;24         return 1;
00001e  2001              MOVS     r0,#1
;;;25     }
000020  bd10              POP      {r4,pc}
;;;26     
                          ENDP

000022  0000              DCW      0x0000
                  |L5.36|
                          DCD      0x4003fe1c
                  |L5.40|
                          DCD      0x40043000

                          AREA ||i.Read_TouchPanel||, CODE, READONLY, ALIGN=1

                  Read_TouchPanel PROC
;;;130    
;;;131    int Read_TouchPanel(int *x, int *y)
000000  b570              PUSH     {r4-r6,lr}
;;;132    {
000002  460d              MOV      r5,r1
000004  4604              MOV      r4,r0
;;;133    //    int a, b;
;;;134        *x = Get_TP_X();
000006  f7fffffe          BL       Get_TP_X
;;;135        *y = Get_TP_Y();
00000a  6020              STR      r0,[r4,#0]
00000c  f7fffffe          BL       Get_TP_Y
;;;136    //    a = *x;
;;;137    //    b = *y;
;;;138        
;;;139        if ( (*x >= 0xF00) || (*y >= 0xF00) )
000010  6028              STR      r0,[r5,#0]
000012  6822              LDR      r2,[r4,#0]
000014  f44f6170          MOV      r1,#0xf00
000018  428a              CMP      r2,r1
00001a  da01              BGE      |L6.32|
00001c  4288              CMP      r0,r1
00001e  db01              BLT      |L6.36|
                  |L6.32|
;;;140        {
;;;141    //        printf("000 x[%04X] y[%04X]\r\n", a, b);
;;;142            return 0;
000020  2000              MOVS     r0,#0
;;;143        }
;;;144        else
;;;145        {
;;;146    //        printf("111 x[%04X] y[%04X]\r\n", a, b);
;;;147            return 1;
;;;148        }
;;;149    }
000022  bd70              POP      {r4-r6,pc}
                  |L6.36|
000024  2001              MOVS     r0,#1                 ;147
000026  bd70              POP      {r4-r6,pc}
;;;150    
                          ENDP


                          AREA ||i.Uninit_TouchPanel||, CODE, READONLY, ALIGN=1

                  Uninit_TouchPanel PROC
;;;150    
;;;151    int Uninit_TouchPanel(void)
000000  2001              MOVS     r0,#1
;;;152    {
;;;153        return 1;
;;;154    }
000002  4770              BX       lr
;;;155    
                          ENDP


                          AREA ||i.__NVIC_EnableIRQ||, CODE, READONLY, ALIGN=1

                  __NVIC_EnableIRQ PROC
;;;1671    */
;;;1672   __STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
000000  2800              CMP      r0,#0
;;;1673   {
000002  db09              BLT      |L8.24|
;;;1674     if ((int32_t)(IRQn) >= 0)
;;;1675     {
;;;1676       NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
000004  f000021f          AND      r2,r0,#0x1f
000008  2101              MOVS     r1,#1
00000a  4091              LSLS     r1,r1,r2
00000c  0940              LSRS     r0,r0,#5
00000e  0080              LSLS     r0,r0,#2
000010  f10020e0          ADD      r0,r0,#0xe000e000
000014  f8c01100          STR      r1,[r0,#0x100]
                  |L8.24|
;;;1677     }
;;;1678   }
000018  4770              BX       lr
;;;1679   
                          ENDP


                          AREA ||.data||, DATA, ALIGN=2

                  g_u32AdcIntFlag_TP
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\tslib\\M48XTouchPanel.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___16_M48XTouchPanel_c_4552d169____REV16|
#line 464 "..\\..\\..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___16_M48XTouchPanel_c_4552d169____REV16| PROC
#line 465

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___16_M48XTouchPanel_c_4552d169____REVSH|
#line 479
|__asm___16_M48XTouchPanel_c_4552d169____REVSH| PROC
#line 480

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___16_M48XTouchPanel_c_4552d169____RRX|
#line 666
|__asm___16_M48XTouchPanel_c_4552d169____RRX| PROC
#line 667

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
