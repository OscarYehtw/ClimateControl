; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\obj\platform.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\platform.d --cpu=Cortex-M4.fp --apcs=interwork -O3 --diag_suppress=9931 -I..\..\..\..\Library\Device\Nuvoton\M480\Include -I..\..\..\..\Library\StdDriver\inc -I..\..\..\..\ThirdParty\emWin\Config -I..\..\..\..\ThirdParty\emWin\Include -I..\tslib -I..\..\..\..\Library\CMSIS\Include -I..\Thermostat -I..\Application\Source\Generated -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=523 --omf_browse=.\obj\platform.crf ..\Thermostat\platform.c]
                          THUMB

                          AREA ||i.EINT0_IRQHandler||, CODE, READONLY, ALIGN=1

                  EINT0_IRQHandler PROC
;;;503    /*---------------------------------------------------------------------------------------------------------*/
;;;504    void EINT0_IRQHandler(void){
000000  4770              BX       lr
;;;505    
;;;506      return;
;;;507    }
;;;508    
                          ENDP


                          AREA ||i.EepromReadByte||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                  EepromReadByte PROC
;;;379    /*---------------------------------------------------------------------------------------------------------*/
;;;380    void EepromReadByte(uint32_t u32Status)
000000  b430              PUSH     {r4,r5}
;;;381    {
;;;382        //printf("I2C2 - u32Status: 0x%x\n", u32Status);
;;;383        if (u32Status == 0x08)                      /* START has been transmitted and prepare SLA+W */
;;;384        {
;;;385            //printf("I2C2 - W - Slave Addr: 0x%x\n", g_u8DeviceAddr);
;;;386            I2C_SET_DATA(I2C2, (g_u8DeviceAddr << 1)); /* Write SLA+W to Register I2CDAT */
000002  4b23              LDR      r3,|L2.144|
000004  4a21              LDR      r2,|L2.140|
000006  2808              CMP      r0,#8                 ;383
000008  7859              LDRB     r1,[r3,#1]
00000a  d012              BEQ      |L2.50|
;;;387            I2C_SET_CONTROL_REG(I2C2, I2C_CTL_SI);
;;;388        }
;;;389        else if (u32Status == 0x18)                 /* SLA+W has been transmitted and ACK has been received */
;;;390        {
;;;391            //printf("I2C2 - TxData[%d]: 0x%x\n", g_u8DataLen, g_au8TxData[g_u8DataLen]);
;;;392            I2C_SET_DATA(I2C2, g_au8TxData[g_u8DataLen++]);
00000c  1d1c              ADDS     r4,r3,#4
00000e  2818              CMP      r0,#0x18              ;389
000010  d022              BEQ      |L2.88|
;;;393            I2C_SET_CONTROL_REG(I2C2, I2C_CTL_SI);
;;;394        }
;;;395        else if (u32Status == 0x20)                 /* SLA+W has been transmitted and NACK has been received */
000012  2820              CMP      r0,#0x20
000014  d017              BEQ      |L2.70|
;;;396        {
;;;397            I2C_SET_CONTROL_REG(I2C2, I2C_CTL_STO | I2C_CTL_SI);
;;;398        }
;;;399        else if (u32Status == 0x28)                 /* DATA has been transmitted and ACK has been received */
000016  2828              CMP      r0,#0x28
000018  d01b              BEQ      |L2.82|
;;;400        {
;;;401            if (g_u8DataLen < 2)
;;;402            {
;;;403                I2C_SET_DATA(I2C2, g_au8TxData[g_u8DataLen++]);
;;;404                I2C_SET_CONTROL_REG(I2C2, I2C_CTL_SI);
;;;405            }
;;;406            else
;;;407            {
;;;408                I2C_SET_CONTROL_REG(I2C2, I2C_CTL_STA | I2C_CTL_SI);
;;;409            }
;;;410        }
;;;411        else if (u32Status == 0x10)                 /* Repeat START has been transmitted and prepare SLA+R */
;;;412        {
;;;413            //printf("I2C2 - R - Slave Addr: 0x%x\n", g_u8DeviceAddr);
;;;414            I2C_SET_DATA(I2C2, (g_u8DeviceAddr << 1) | 0x01);  /* Write SLA+R to Register I2CDAT */
00001a  2401              MOVS     r4,#1
00001c  2810              CMP      r0,#0x10              ;411
00001e  d027              BEQ      |L2.112|
;;;415            I2C_SET_CONTROL_REG(I2C2, I2C_CTL_SI);
;;;416        }
;;;417        else if (u32Status == 0x40)                 /* SLA+R has been transmitted and ACK has been received */
000020  2840              CMP      r0,#0x40
000022  d008              BEQ      |L2.54|
;;;418        {
;;;419            I2C_SET_CONTROL_REG(I2C2, I2C_CTL_SI);
;;;420        }
;;;421        else if (u32Status == 0x58)                 /* DATA has been received and NACK has been returned */
000024  2858              CMP      r0,#0x58
000026  d026              BEQ      |L2.118|
;;;422        {
;;;423            g_u8RxData = I2C_GET_DATA(I2C2);
;;;424            I2C_SET_CONTROL_REG(I2C2, I2C_CTL_STO | I2C_CTL_SI);
;;;425            g_u8EndFlag = 1;
;;;426            //printf("I2C2 - R - RxData: 0x%x\n", g_u8RxData);
;;;427        }
;;;428        else
;;;429        {
;;;430            /* TO DO */
;;;431            printf("Status 0x%x is NOT processed\n", u32Status);
000028  4601              MOV      r1,r0
00002a  bc30              POP      {r4,r5}
00002c  a019              ADR      r0,|L2.148|
00002e  f7ffbffe          B.W      __2printf
                  |L2.50|
000032  0048              LSLS     r0,r1,#1              ;386
                  |L2.52|
000034  6090              STR      r0,[r2,#8]            ;386
                  |L2.54|
000036  6810              LDR      r0,[r2,#0]            ;419
000038  f020003c          BIC      r0,r0,#0x3c           ;419
00003c  f0400008          ORR      r0,r0,#8              ;419
                  |L2.64|
000040  6010              STR      r0,[r2,#0]            ;387
                  |L2.66|
;;;432        }
;;;433    }
000042  bc30              POP      {r4,r5}
000044  4770              BX       lr
                  |L2.70|
000046  6810              LDR      r0,[r2,#0]            ;397
000048  f020003c          BIC      r0,r0,#0x3c           ;397
00004c  f0400018          ORR      r0,r0,#0x18           ;397
000050  e7f6              B        |L2.64|
                  |L2.82|
000052  78d8              LDRB     r0,[r3,#3]            ;401  ; g_u8DataLen
000054  2802              CMP      r0,#2                 ;401
000056  d205              BCS      |L2.100|
                  |L2.88|
000058  78d8              LDRB     r0,[r3,#3]            ;403  ; g_u8DataLen
00005a  1821              ADDS     r1,r4,r0              ;403
00005c  1c40              ADDS     r0,r0,#1              ;403
00005e  70d8              STRB     r0,[r3,#3]            ;403
000060  7808              LDRB     r0,[r1,#0]            ;403
000062  e7e7              B        |L2.52|
                  |L2.100|
000064  6810              LDR      r0,[r2,#0]            ;408
000066  f020003c          BIC      r0,r0,#0x3c           ;408
00006a  f0400028          ORR      r0,r0,#0x28           ;408
00006e  e7e7              B        |L2.64|
                  |L2.112|
000070  eb040041          ADD      r0,r4,r1,LSL #1       ;414
000074  e7de              B        |L2.52|
                  |L2.118|
000076  6890              LDR      r0,[r2,#8]            ;423
000078  7098              STRB     r0,[r3,#2]            ;423
00007a  6810              LDR      r0,[r2,#0]            ;424
00007c  f020003c          BIC      r0,r0,#0x3c           ;424
000080  f0400018          ORR      r0,r0,#0x18           ;424
000084  6010              STR      r0,[r2,#0]            ;424
000086  701c              STRB     r4,[r3,#0]            ;425
000088  e7db              B        |L2.66|
;;;434    
                          ENDP

00008a  0000              DCW      0x0000
                  |L2.140|
                          DCD      0x40082000
                  |L2.144|
                          DCD      ||.data||
                  |L2.148|
000094  53746174          DCB      "Status 0x%x is NOT processed\n",0
000098  75732030
00009c  78257820
0000a0  6973204e
0000a4  4f542070
0000a8  726f6365
0000ac  73736564
0000b0  0a00    
0000b2  00                DCB      0
0000b3  00                DCB      0

                          AREA ||i.EepromWriteByte||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                  EepromWriteByte PROC
;;;437    /*---------------------------------------------------------------------------------------------------------*/
;;;438    void EepromWriteByte(uint32_t u32Status)
000000  4a18              LDR      r2,|L3.100|
;;;439    {
;;;440        if (u32Status == 0x08)                      /* START has been transmitted */
;;;441        {
;;;442            I2C_SET_DATA(I2C2, g_u8DeviceAddr << 1);  /* Write SLA+W to Register I2CDAT */
000002  4b19              LDR      r3,|L3.104|
000004  2808              CMP      r0,#8                 ;440
000006  d00a              BEQ      |L3.30|
;;;443            I2C_SET_CONTROL_REG(I2C2, I2C_CTL_SI);
;;;444        }
;;;445        else if (u32Status == 0x18)                 /* SLA+W has been transmitted and ACK has been received */
;;;446        {
;;;447            I2C_SET_DATA(I2C2, g_au8TxData[g_u8DataLen++]);
000008  1d19              ADDS     r1,r3,#4
00000a  2818              CMP      r0,#0x18              ;445
00000c  d01a              BEQ      |L3.68|
;;;448            I2C_SET_CONTROL_REG(I2C2, I2C_CTL_SI);
;;;449        }
;;;450        else if (u32Status == 0x20)                 /* SLA+W has been transmitted and NACK has been received */
00000e  2820              CMP      r0,#0x20
000010  d00f              BEQ      |L3.50|
;;;451        {
;;;452            I2C_SET_CONTROL_REG(I2C2, I2C_CTL_STA | I2C_CTL_STO | I2C_CTL_SI);
;;;453        }
;;;454        else if (u32Status == 0x28)                 /* DATA has been transmitted and ACK has been received */
000012  2828              CMP      r0,#0x28
000014  d013              BEQ      |L3.62|
;;;455        {
;;;456            if (g_u8DataLen != 3)
;;;457            {
;;;458                I2C_SET_DATA(I2C2, g_au8TxData[g_u8DataLen++]);
;;;459                I2C_SET_CONTROL_REG(I2C2, I2C_CTL_SI);
;;;460            }
;;;461            else
;;;462            {
;;;463                I2C_SET_CONTROL_REG(I2C2, I2C_CTL_STO | I2C_CTL_SI);
;;;464                g_u8EndFlag = 1;
;;;465            }
;;;466        }
;;;467        else
;;;468        {
;;;469            /* TO DO */
;;;470            printf("Status 0x%x is NOT processed\n", u32Status);
000016  4601              MOV      r1,r0
000018  a014              ADR      r0,|L3.108|
00001a  f7ffbffe          B.W      __2printf
                  |L3.30|
00001e  7858              LDRB     r0,[r3,#1]            ;442  ; g_u8DeviceAddr
000020  0040              LSLS     r0,r0,#1              ;442
                  |L3.34|
000022  6090              STR      r0,[r2,#8]            ;442
000024  6810              LDR      r0,[r2,#0]            ;443
000026  f020003c          BIC      r0,r0,#0x3c           ;443
00002a  f0400008          ORR      r0,r0,#8              ;443
                  |L3.46|
00002e  6010              STR      r0,[r2,#0]            ;443
;;;471        }
;;;472    }
000030  4770              BX       lr
                  |L3.50|
000032  6810              LDR      r0,[r2,#0]            ;452
000034  f020003c          BIC      r0,r0,#0x3c           ;452
000038  f0400038          ORR      r0,r0,#0x38           ;452
00003c  e7f7              B        |L3.46|
                  |L3.62|
00003e  78d8              LDRB     r0,[r3,#3]            ;456  ; g_u8DataLen
000040  2803              CMP      r0,#3                 ;456
000042  d005              BEQ      |L3.80|
                  |L3.68|
000044  78d8              LDRB     r0,[r3,#3]            ;458  ; g_u8DataLen
000046  4401              ADD      r1,r1,r0              ;458
000048  1c40              ADDS     r0,r0,#1              ;458
00004a  70d8              STRB     r0,[r3,#3]            ;458
00004c  7808              LDRB     r0,[r1,#0]            ;458
00004e  e7e8              B        |L3.34|
                  |L3.80|
000050  6810              LDR      r0,[r2,#0]            ;463
000052  f020003c          BIC      r0,r0,#0x3c           ;463
000056  f0400018          ORR      r0,r0,#0x18           ;463
00005a  6010              STR      r0,[r2,#0]            ;463
00005c  2001              MOVS     r0,#1                 ;464
00005e  7018              STRB     r0,[r3,#0]            ;464
000060  4770              BX       lr
;;;473    
                          ENDP

000062  0000              DCW      0x0000
                  |L3.100|
                          DCD      0x40082000
                  |L3.104|
                          DCD      ||.data||
                  |L3.108|
00006c  53746174          DCB      "Status 0x%x is NOT processed\n",0
000070  75732030
000074  78257820
000078  6973204e
00007c  4f542070
000080  726f6365
000084  73736564
000088  0a00    
00008a  00                DCB      0
00008b  00                DCB      0

                          AREA ||i.GPE_IRQHandler||, CODE, READONLY, ALIGN=1

                  GPE_IRQHandler PROC
;;;511    /*---------------------------------------------------------------------------------------------------------*/
;;;512    void GPE_IRQHandler (void) {
000000  4770              BX       lr
;;;513    	
;;;514      return;
;;;515    }
;;;516    
                          ENDP


                          AREA ||i.Gpio_Initialize||, CODE, READONLY, ALIGN=2

                  Gpio_Initialize PROC
;;;612     *----------------------------------------------------------------------------*/
;;;613    void Gpio_Initialize (void) {
000000  b570              PUSH     {r4-r6,lr}
;;;614    
;;;615      /*---------------------------------------------------------------------------------------------------------*/
;;;616      /* Init I/O Multi-function                                                                                 */
;;;617      /*---------------------------------------------------------------------------------------------------------*/
;;;618    
;;;619      /*=== UART mult-function pins ===*/
;;;620      /* Set PB.12 and PB.13 multi-function pins for UART0 RXD, TXD */
;;;621      SYS->GPB_MFPH &= ~(SYS_GPB_MFPH_PB12MFP_Msk | SYS_GPB_MFPH_PB13MFP_Msk);
000002  f04f4080          MOV      r0,#0x40000000
000006  6bc1              LDR      r1,[r0,#0x3c]
000008  f421017f          BIC      r1,r1,#0xff0000
00000c  63c1              STR      r1,[r0,#0x3c]
;;;622      SYS->GPB_MFPH |= (SYS_GPB_MFPH_PB12MFP_UART0_RXD | SYS_GPB_MFPH_PB13MFP_UART0_TXD);
00000e  6bc1              LDR      r1,[r0,#0x3c]
000010  f44101cc          ORR      r1,r1,#0x660000
000014  63c1              STR      r1,[r0,#0x3c]
;;;623    
;;;624      /* Set PB.0 and PB.1 multi-function pins for I2C1 SCL/SDA */
;;;625      SYS->GPB_MFPL &= ~(SYS_GPB_MFPL_PB0MFP_Msk | SYS_GPB_MFPL_PB1MFP_Msk);
000016  6b81              LDR      r1,[r0,#0x38]
000018  f02101ff          BIC      r1,r1,#0xff
00001c  6381              STR      r1,[r0,#0x38]
;;;626      SYS->GPB_MFPL |= (SYS_GPB_MFPL_PB0MFP_I2C1_SDA | SYS_GPB_MFPL_PB1MFP_I2C1_SCL);
00001e  6b81              LDR      r1,[r0,#0x38]
000020  f0410199          ORR      r1,r1,#0x99
000024  6381              STR      r1,[r0,#0x38]
;;;627    
;;;628      /* Set I2C2 multi-function pins */
;;;629      SYS->GPD_MFPL = (SYS->GPD_MFPL & ~(SYS_GPD_MFPL_PD0MFP_Msk | SYS_GPD_MFPL_PD1MFP_Msk)) |
000026  6c81              LDR      r1,[r0,#0x48]
000028  f02101ff          BIC      r1,r1,#0xff
00002c  f0410166          ORR      r1,r1,#0x66
000030  6481              STR      r1,[r0,#0x48]
;;;630                      (SYS_GPD_MFPL_PD0MFP_I2C2_SDA | SYS_GPD_MFPL_PD1MFP_I2C2_SCL);
;;;631    
;;;632      /* I2C pin enable schmitt trigger */
;;;633      PD->SMTEN |= GPIO_SMTEN_SMTEN0_Msk | GPIO_SMTEN_SMTEN1_Msk;
000032  f04f2440          MOV      r4,#0x40004000
000036  f8d400e4          LDR      r0,[r4,#0xe4]
00003a  f0400003          ORR      r0,r0,#3
00003e  f8c400e4          STR      r0,[r4,#0xe4]
;;;634    
;;;635      GPIO_SetMode(PA, BIT0, GPIO_MODE_INPUT);   // SW1 Key Button
000042  2200              MOVS     r2,#0
000044  2101              MOVS     r1,#1
000046  4620              MOV      r0,r4
000048  f7fffffe          BL       GPIO_SetMode
;;;636      GPIO_SetMode(PA, BIT1, GPIO_MODE_INPUT);   // SW2 Key Button
00004c  2200              MOVS     r2,#0
00004e  2102              MOVS     r1,#2
000050  4620              MOV      r0,r4
000052  f7fffffe          BL       GPIO_SetMode
;;;637      GPIO_SetMode(PG, BIT2, GPIO_MODE_INPUT);   // Up (Joystick)
000056  4c12              LDR      r4,|L5.160|
000058  2200              MOVS     r2,#0
00005a  2104              MOVS     r1,#4
00005c  4620              MOV      r0,r4
00005e  f7fffffe          BL       GPIO_SetMode
;;;638      GPIO_SetMode(PG, BIT3, GPIO_MODE_INPUT);   // Center (Joystick)
000062  2200              MOVS     r2,#0
000064  2108              MOVS     r1,#8
000066  4620              MOV      r0,r4
000068  f7fffffe          BL       GPIO_SetMode
;;;639      GPIO_SetMode(PG, BIT4, GPIO_MODE_INPUT);   // Right (Joystick)
00006c  2200              MOVS     r2,#0
00006e  2110              MOVS     r1,#0x10
000070  4620              MOV      r0,r4
000072  f7fffffe          BL       GPIO_SetMode
;;;640      GPIO_SetMode(PC, BIT9, GPIO_MODE_INPUT);   // Left (Joystick)
000076  1561              ASRS     r1,r4,#21
000078  4c0a              LDR      r4,|L5.164|
00007a  2200              MOVS     r2,#0
00007c  4620              MOV      r0,r4
00007e  f7fffffe          BL       GPIO_SetMode
;;;641      GPIO_SetMode(PC, BIT10, GPIO_MODE_INPUT);  // Down (Joystick)
000082  1525              ASRS     r5,r4,#20
000084  2200              MOVS     r2,#0
000086  4629              MOV      r1,r5
000088  4620              MOV      r0,r4
00008a  f7fffffe          BL       GPIO_SetMode
;;;642      GPIO_SetMode(PD, BIT10, GPIO_MODE_INPUT);  // Touch INT
00008e  4629              MOV      r1,r5
000090  e8bd4070          POP      {r4-r6,lr}
000094  4803              LDR      r0,|L5.164|
000096  2200              MOVS     r2,#0
000098  3040              ADDS     r0,r0,#0x40
00009a  f7ffbffe          B.W      GPIO_SetMode
;;;643    
;;;644      return;
;;;645    }
;;;646    
                          ENDP

00009e  0000              DCW      0x0000
                  |L5.160|
                          DCD      0x40004180
                  |L5.164|
                          DCD      0x40004080

                          AREA ||i.I2C1_IRQHandler||, CODE, READONLY, ALIGN=2

                  I2C1_IRQHandler PROC
;;;187     **********************************************************************************************/
;;;188    void I2C1_IRQHandler(void) {
000000  4801              LDR      r0,|L6.8|
;;;189    
;;;190      I2C_IRQHandler_Common(&I2C1_Ctx);
000002  f7ffbffe          B.W      I2C_IRQHandler_Common
;;;191    
;;;192      return;
;;;193    }
;;;194    
                          ENDP

000006  0000              DCW      0x0000
                  |L6.8|
                          DCD      ||.data||+0x10

                          AREA ||i.I2C1_Initialize||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  I2C1_Initialize PROC
;;;706     *----------------------------------------------------------------------------*/
;;;707    void I2C1_Initialize (void) {
000000  b510              PUSH     {r4,lr}
;;;708    
;;;709      /* Reset I2C1 */
;;;710      SYS_ResetModule(I2C1_RST);
000002  480b              LDR      r0,|L7.48|
000004  f7fffffe          BL       SYS_ResetModule
;;;711    
;;;712      /* Open I2C1 and set clock to 100k */
;;;713      I2C_Open(I2C1, 100000);
000008  4c0b              LDR      r4,|L7.56|
00000a  490a              LDR      r1,|L7.52|
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       I2C_Open
;;;714    
;;;715      /* Get I2C1 Bus Clock */
;;;716      printf("I2C1 clock %d Hz\n", I2C_GetBusClockFreq(I2C1));
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       I2C_GetBusClockFreq
000018  4601              MOV      r1,r0
00001a  a008              ADR      r0,|L7.60|
00001c  f7fffffe          BL       __2printf
;;;717    
;;;718      I2C_EnableInt(I2C1);
000020  4620              MOV      r0,r4
000022  f7fffffe          BL       I2C_EnableInt
;;;719      NVIC_EnableIRQ(I2C1_IRQn);
000026  e8bd4010          POP      {r4,lr}
00002a  2027              MOVS     r0,#0x27
00002c  f7ffbffe          B.W      __NVIC_EnableIRQ
;;;720    }
;;;721    
                          ENDP

                  |L7.48|
                          DCD      0x04000009
                  |L7.52|
                          DCD      0x000186a0
                  |L7.56|
                          DCD      0x40081000
                  |L7.60|
00003c  49324331          DCB      "I2C1 clock %d Hz\n",0
000040  20636c6f
000044  636b2025
000048  6420487a
00004c  0a00    
00004e  00                DCB      0
00004f  00                DCB      0

                          AREA ||i.I2C2_IRQHandler||, CODE, READONLY, ALIGN=2

                  I2C2_IRQHandler PROC
;;;197     **********************************************************************************************/
;;;198    void I2C2_IRQHandler(void) {
000000  4801              LDR      r0,|L8.8|
;;;199    
;;;200      I2C_IRQHandler_Common(&I2C2_Ctx);
000002  f7ffbffe          B.W      I2C_IRQHandler_Common
;;;201    
;;;202      return;
;;;203    }
;;;204    
                          ENDP

000006  0000              DCW      0x0000
                  |L8.8|
                          DCD      ||.data||+0x20

                          AREA ||i.I2C2_Initialize||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  I2C2_Initialize PROC
;;;724     *----------------------------------------------------------------------------*/
;;;725    void I2C2_Initialize (void) {
000000  b510              PUSH     {r4,lr}
;;;726    
;;;727      /* Reset I2C2 */
;;;728      SYS_ResetModule(I2C2_RST);
000002  480b              LDR      r0,|L9.48|
000004  f7fffffe          BL       SYS_ResetModule
;;;729    
;;;730      /* Open I2C2 and set clock to 100k */
;;;731      I2C_Open(I2C2, 100000);
000008  4c0b              LDR      r4,|L9.56|
00000a  490a              LDR      r1,|L9.52|
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       I2C_Open
;;;732    
;;;733      /* Get I2C2 Bus Clock */
;;;734      printf("I2C2 clock %d Hz\n", I2C_GetBusClockFreq(I2C2));
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       I2C_GetBusClockFreq
000018  4601              MOV      r1,r0
00001a  a008              ADR      r0,|L9.60|
00001c  f7fffffe          BL       __2printf
;;;735    
;;;736      I2C_EnableInt(I2C2);
000020  4620              MOV      r0,r4
000022  f7fffffe          BL       I2C_EnableInt
;;;737      NVIC_EnableIRQ(I2C2_IRQn);
000026  e8bd4010          POP      {r4,lr}
00002a  2052              MOVS     r0,#0x52
00002c  f7ffbffe          B.W      __NVIC_EnableIRQ
;;;738    }
;;;739    
                          ENDP

                  |L9.48|
                          DCD      0x0400000a
                  |L9.52|
                          DCD      0x000186a0
                  |L9.56|
                          DCD      0x40082000
                  |L9.60|
00003c  49324332          DCB      "I2C2 clock %d Hz\n",0
000040  20636c6f
000044  636b2025
000048  6420487a
00004c  0a00    
00004e  00                DCB      0
00004f  00                DCB      0

                          AREA ||i.I2C_IRQHandler_Common||, CODE, READONLY, ALIGN=1

                  I2C_IRQHandler_Common PROC
;;;168     **********************************************************************************************/
;;;169    static void I2C_IRQHandler_Common(I2C_CONTEXT *ctx) {
000000  4601              MOV      r1,r0
;;;170      uint32_t Status = I2C_GET_STATUS(ctx->base);
000002  6800              LDR      r0,[r0,#0]
000004  68c2              LDR      r2,[r0,#0xc]
;;;171    
;;;172      if (I2C_GET_TIMEOUT_FLAG(ctx->base)) {
000006  6943              LDR      r3,[r0,#0x14]
000008  43db              MVNS     r3,r3
00000a  07db              LSLS     r3,r3,#31
00000c  d004              BEQ      |L10.24|
;;;173          I2C_ClearTimeoutFlag(ctx->base);
;;;174          return;
;;;175      }
;;;176    
;;;177      if (ctx->handler != NULL) {
00000e  6849              LDR      r1,[r1,#4]
000010  2900              CMP      r1,#0
000012  d003              BEQ      |L10.28|
;;;178          ctx->handler(Status);
000014  4610              MOV      r0,r2
000016  4708              BX       r1
                  |L10.24|
000018  f7ffbffe          B.W      I2C_ClearTimeoutFlag
                  |L10.28|
;;;179      }
;;;180    
;;;181      return;
;;;182    }
00001c  4770              BX       lr
;;;183    
                          ENDP


                          AREA ||i.I2cReadByte||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                  I2cReadByte PROC
;;;207     **********************************************************************************************/
;;;208    static void I2cReadByte (uint32_t Status) {
000000  b430              PUSH     {r4,r5}
;;;209      I2C_CONTEXT *ctx = &I2C2_Ctx;
000002  4b23              LDR      r3,|L11.144|
;;;210      I2C_T *i2c = ctx->base;
;;;211    
;;;212      //printf("I2cReadByte - Status: 0x%x\n", Status);
;;;213      switch (Status) {
;;;214          case 0x08:  /* START has been transmitted and prepare SLA+W */
;;;215              I2C_SET_DATA(i2c, (ctx->slaveAddr << 1));
;;;216              I2C_SET_CONTROL_REG(i2c, I2C_CTL_SI);
;;;217              break;
;;;218          case 0x18:  /* SLA+W has been transmitted and ACK has been received */
;;;219              I2C_SET_DATA(i2c, ctx->txBuf[ctx->byteCount++]);
;;;220              I2C_SET_CONTROL_REG(i2c, I2C_CTL_SI);
;;;221              break;
;;;222          case 0x20:  /* SLA+W has been transmitted and NACK has been received */
;;;223              I2C_SET_CONTROL_REG(i2c, I2C_CTL_STO | I2C_CTL_SI);
;;;224              break;
;;;225          case 0x28:  /* DATA has been transmitted and ACK has been received */
;;;226              if (ctx->byteCount < ctx->length) {
;;;227                  I2C_SET_DATA(i2c, ctx->txBuf[ctx->length++]);
;;;228                  I2C_SET_CONTROL_REG(i2c, I2C_CTL_SI);
;;;229              } else {
;;;230                  I2C_SET_CONTROL_REG(i2c, I2C_CTL_STA | I2C_CTL_SI);
;;;231              }
;;;232              break;
;;;233          case 0x10: /* Repeat START has been transmitted and prepare SLA+R */
;;;234              I2C_SET_DATA(i2c, (ctx->slaveAddr << 1) | 0x01);
000004  2101              MOVS     r1,#1
000006  2820              CMP      r0,#0x20              ;213
000008  681a              LDR      r2,[r3,#0]            ;213
00000a  d01b              BEQ      |L11.68|
00000c  dc08              BGT      |L11.32|
00000e  4c20              LDR      r4,|L11.144|
000010  2808              CMP      r0,#8                 ;213
000012  7a24              LDRB     r4,[r4,#8]            ;215
000014  d00f              BEQ      |L11.54|
000016  2810              CMP      r0,#0x10              ;213
000018  d032              BEQ      |L11.128|
00001a  2818              CMP      r0,#0x18              ;213
00001c  d106              BNE      |L11.44|
00001e  e00c              B        |L11.58|
                  |L11.32|
000020  2828              CMP      r0,#0x28              ;213
000022  d015              BEQ      |L11.80|
000024  2840              CMP      r0,#0x40              ;213
000026  d01d              BEQ      |L11.100|
000028  2858              CMP      r0,#0x58              ;213
00002a  d02c              BEQ      |L11.134|
                  |L11.44|
;;;235              I2C_SET_CONTROL_REG(i2c, I2C_CTL_SI);
;;;236              break;
;;;237          case 0x40:  /* SLA+R has been transmitted and ACK has been received */
;;;238              I2C_SET_CONTROL_REG(i2c, I2C_CTL_SI);
;;;239              break;
;;;240          case 0x58:  /* DATA has been received and NACK has been returned */
;;;241              ctx->rxData = I2C_GET_DATA(i2c);
;;;242              ctx->txrxDone = TRUE;
;;;243              I2C_SET_CONTROL_REG(i2c, I2C_CTL_STO | I2C_CTL_SI);
;;;244              break;
;;;245          default:
;;;246              printf("Status 0x%x is NOT processed\n", Status);
00002c  4601              MOV      r1,r0
00002e  bc30              POP      {r4,r5}
000030  a018              ADR      r0,|L11.148|
000032  f7ffbffe          B.W      __2printf
                  |L11.54|
000036  0060              LSLS     r0,r4,#1              ;215
000038  e013              B        |L11.98|
                  |L11.58|
00003a  7b58              LDRB     r0,[r3,#0xd]          ;219
00003c  1819              ADDS     r1,r3,r0              ;219
00003e  1c40              ADDS     r0,r0,#1              ;219
000040  7358              STRB     r0,[r3,#0xd]          ;219
000042  e00d              B        |L11.96|
                  |L11.68|
000044  6810              LDR      r0,[r2,#0]            ;223
000046  f020003c          BIC      r0,r0,#0x3c           ;223
00004a  f0400018          ORR      r0,r0,#0x18           ;223
00004e  e014              B        |L11.122|
                  |L11.80|
000050  7b58              LDRB     r0,[r3,#0xd]          ;226
000052  7b99              LDRB     r1,[r3,#0xe]          ;226
000054  4288              CMP      r0,r1                 ;226
000056  d20b              BCS      |L11.112|
000058  7b98              LDRB     r0,[r3,#0xe]          ;227
00005a  1819              ADDS     r1,r3,r0              ;227
00005c  1c40              ADDS     r0,r0,#1              ;227
00005e  7398              STRB     r0,[r3,#0xe]          ;227
                  |L11.96|
000060  7a48              LDRB     r0,[r1,#9]            ;219
                  |L11.98|
000062  6090              STR      r0,[r2,#8]            ;227
                  |L11.100|
000064  6810              LDR      r0,[r2,#0]            ;238
000066  f020003c          BIC      r0,r0,#0x3c           ;238
00006a  f0400008          ORR      r0,r0,#8              ;238
00006e  e004              B        |L11.122|
                  |L11.112|
000070  6810              LDR      r0,[r2,#0]            ;230
000072  f020003c          BIC      r0,r0,#0x3c           ;230
000076  f0400028          ORR      r0,r0,#0x28           ;230
                  |L11.122|
00007a  6010              STR      r0,[r2,#0]            ;243
;;;247              break;
;;;248        }
;;;249    }
00007c  bc30              POP      {r4,r5}
00007e  4770              BX       lr
                  |L11.128|
000080  eb010044          ADD      r0,r1,r4,LSL #1       ;234
000084  e7ed              B        |L11.98|
                  |L11.134|
000086  6890              LDR      r0,[r2,#8]            ;241
000088  7318              STRB     r0,[r3,#0xc]          ;241
00008a  73d9              STRB     r1,[r3,#0xf]          ;242
00008c  e7da              B        |L11.68|
;;;250    
                          ENDP

00008e  0000              DCW      0x0000
                  |L11.144|
                          DCD      ||.data||+0x20
                  |L11.148|
000094  53746174          DCB      "Status 0x%x is NOT processed\n",0
000098  75732030
00009c  78257820
0000a0  6973204e
0000a4  4f542070
0000a8  726f6365
0000ac  73736564
0000b0  0a00    
0000b2  00                DCB      0
0000b3  00                DCB      0

                          AREA ||i.Platform_Initialize||, CODE, READONLY, ALIGN=2

                  Platform_Initialize PROC
;;;742     *----------------------------------------------------------------------------*/
;;;743    void Platform_Initialize (void) {
000000  b570              PUSH     {r4-r6,lr}
;;;744    
;;;745    #if defined(NUCONSOLE_SUPPORT) && (NUCONSOLE_SUPPORT == 1)
;;;746      NuConsole_Init ();
;;;747    #endif
;;;748    
;;;749      SysClock_Initialize ();
000002  f7fffffe          BL       SysClock_Initialize
;;;750    
;;;751      Uart_Initialize ();
000006  f7fffffe          BL       Uart_Initialize
;;;752    
;;;753      Gpio_Initialize ();
00000a  f7fffffe          BL       Gpio_Initialize
;;;754    	 
;;;755      Timer0_Initialize ();
00000e  f7fffffe          BL       Timer0_Initialize
;;;756    	 
;;;757      Timer1_Initialize ();
000012  f7fffffe          BL       Timer1_Initialize
;;;758    
;;;759      Timer3_Initialize ();
000016  f7fffffe          BL       Timer3_Initialize
;;;760    
;;;761      I2C1_Initialize ();
00001a  f7fffffe          BL       I2C1_Initialize
;;;762    
;;;763      I2C2_Initialize ();
00001e  f7fffffe          BL       I2C2_Initialize
;;;764      
;;;765      g_enable_Touch = 0;
000022  4d18              LDR      r5,|L12.132|
000024  2600              MOVS     r6,#0
000026  60ee              STR      r6,[r5,#0xc]  ; g_enable_Touch
;;;766    
;;;767    #if GUI_SUPPORT_TOUCH
;;;768        //WM_SetCreateFlags(WM_CF_MEMDEV);
;;;769        GUI_Init();
000028  f7fffffe          BL       GUI_Init
;;;770        //WM_MULTIBUF_Enable(1);
;;;771    
;;;772        Init_TouchPanel();
00002c  f7fffffe          BL       Init_TouchPanel
;;;773        /* Unlock protected registers */
;;;774        SYS_UnlockReg();
000030  f7fffffe          BL       SYS_UnlockReg
;;;775    
;;;776        /* Enable FMC ISP function */
;;;777        FMC_Open();
000034  f7fffffe          BL       FMC_Open
;;;778    
;;;779        /* SPI flash 256KB + 0x1C marker address */
;;;780        if (FMC_Read(__DEMO_TSFILE_ADDR__ + 0x1C) != 0x55AAA55A)
000038  4813              LDR      r0,|L12.136|
00003a  f7fffffe          BL       FMC_Read
00003e  4913              LDR      r1,|L12.140|
000040  4288              CMP      r0,r1
000042  d014              BEQ      |L12.110|
;;;781        //if ( 1 )
;;;782        {
;;;783            FMC_ENABLE_AP_UPDATE();
000044  4c12              LDR      r4,|L12.144|
000046  6820              LDR      r0,[r4,#0]
000048  f0400008          ORR      r0,r0,#8
00004c  6020              STR      r0,[r4,#0]
;;;784            ts_calibrate(__DEMO_TS_WIDTH__, __DEMO_TS_HEIGHT__);
00004e  21f0              MOVS     r1,#0xf0
000050  f44f70a0          MOV      r0,#0x140
000054  f7fffffe          BL       ts_calibrate
;;;785            // Erase page
;;;786            FMC_Erase(__DEMO_TSFILE_ADDR__);
000058  480b              LDR      r0,|L12.136|
00005a  381c              SUBS     r0,r0,#0x1c
00005c  f7fffffe          BL       FMC_Erase
;;;787            ts_writefile();
000060  f7fffffe          BL       ts_writefile
;;;788            FMC_DISABLE_AP_UPDATE();
000064  6820              LDR      r0,[r4,#0]
000066  f0200008          BIC      r0,r0,#8
00006a  6020              STR      r0,[r4,#0]
00006c  e001              B        |L12.114|
                  |L12.110|
;;;789        }
;;;790        else
;;;791        {
;;;792            ts_readfile();
00006e  f7fffffe          BL       ts_readfile
                  |L12.114|
;;;793        }
;;;794    
;;;795        /* Disable FMC ISP function */
;;;796        FMC_Close();
000072  f7fffffe          BL       FMC_Close
000076  f04f4080          MOV      r0,#0x40000000
00007a  f8c06100          STR      r6,[r0,#0x100]
;;;797    
;;;798        /* Lock protected registers */
;;;799        SYS_LockReg();
;;;800    #endif
;;;801    
;;;802      g_enable_Touch = 1;
00007e  2001              MOVS     r0,#1
000080  60e8              STR      r0,[r5,#0xc]  ; g_enable_Touch
;;;803    
;;;804      return;
;;;805    }
000082  bd70              POP      {r4-r6,pc}
                          ENDP

                  |L12.132|
                          DCD      ||.data||
                  |L12.136|
                          DCD      0x0007fffc
                  |L12.140|
                          DCD      0x55aaa55a
                  |L12.144|
                          DCD      0x4000c000

                          AREA ||i.ReadingTouchSensor||, CODE, READONLY, ALIGN=2

                  ReadingTouchSensor PROC
;;;253    /*---------------------------------------------------------------------------------------------------------*/
;;;254    void ReadingTouchSensor (I2C_CONTEXT *ctx, uint8_t SlaveAddr, uint8_t Command, uint8_t Lenght, uint8_t Rw) {
000000  b510              PUSH     {r4,lr}
000002  9c02              LDR      r4,[sp,#8]
000004  b104              CBZ      r4,|L13.8|
;;;255    
;;;256      /* I2C function to read data from slave */
;;;257      ctx->handler = (Rw) ? (I2C_FUNC)I2cReadByte: NULL;
000006  4c09              LDR      r4,|L13.44|
                  |L13.8|
;;;258    
;;;259      if (ctx->handler != NULL) {
000008  6044              STR      r4,[r0,#4]
00000a  2c00              CMP      r4,#0
00000c  d00d              BEQ      |L13.42|
;;;260          ctx->slaveAddr = SlaveAddr;
00000e  7201              STRB     r1,[r0,#8]
;;;261          ctx->txBuf[0]  = Command;
000010  7242              STRB     r2,[r0,#9]
;;;262          ctx->length    = Lenght;
000012  7383              STRB     r3,[r0,#0xe]
;;;263          ctx->byteCount = 0;
000014  2100              MOVS     r1,#0
000016  7341              STRB     r1,[r0,#0xd]
;;;264          ctx->rxData    = 0;
000018  7301              STRB     r1,[r0,#0xc]
;;;265          ctx->txrxDone  = FALSE;
00001a  73c1              STRB     r1,[r0,#0xf]
;;;266    
;;;267          /* I2C as master sends START signal */
;;;268          I2C_SET_CONTROL_REG(ctx->base, I2C_CTL_STA);
00001c  6800              LDR      r0,[r0,#0]
00001e  6801              LDR      r1,[r0,#0]
000020  f021013c          BIC      r1,r1,#0x3c
000024  f0410120          ORR      r1,r1,#0x20
000028  6001              STR      r1,[r0,#0]
                  |L13.42|
;;;269      }
;;;270    
;;;271      return;
;;;272    }
00002a  bd10              POP      {r4,pc}
;;;273    #endif
                          ENDP

                  |L13.44|
                          DCD      I2cReadByte

                          AREA ||i.RwEepromDataByte||, CODE, READONLY, ALIGN=2

                  RwEepromDataByte PROC
;;;476    /*---------------------------------------------------------------------------------------------------------*/
;;;477    void RwEepromDataByte (uint32_t Addr, uint8_t Data, uint8_t Rw) {
000000  b510              PUSH     {r4,lr}
;;;478    
;;;479      if (Rw) {
;;;480          /* I2C function to read data from slave */
;;;481          s_I2C2HandlerFn = (I2C_FUNC)EepromReadByte;
000002  4c0c              LDR      r4,|L14.52|
;;;482      } else {
;;;483          /* I2C function to write data from slave */
;;;484          s_I2C2HandlerFn = (I2C_FUNC)EepromWriteByte;
;;;485          g_au8TxData[2] = Data;
000004  1d23              ADDS     r3,r4,#4
000006  b112              CBZ      r2,|L14.14|
000008  490b              LDR      r1,|L14.56|
00000a  60a1              STR      r1,[r4,#8]            ;481  ; s_I2C2HandlerFn
00000c  e002              B        |L14.20|
                  |L14.14|
00000e  4a0b              LDR      r2,|L14.60|
000010  60a2              STR      r2,[r4,#8]  ; s_I2C2HandlerFn
000012  7099              STRB     r1,[r3,#2]
                  |L14.20|
;;;486      }
;;;487    
;;;488      g_au8TxData[0] = (uint8_t)((Addr & 0xFF00) >> 8);
000014  0a01              LSRS     r1,r0,#8
000016  7019              STRB     r1,[r3,#0]
;;;489      g_au8TxData[1] = (uint8_t)(Addr & 0x00FF);
000018  7058              STRB     r0,[r3,#1]
;;;490    
;;;491      g_u8DeviceAddr = 0x10;
00001a  2010              MOVS     r0,#0x10
00001c  7060              STRB     r0,[r4,#1]
;;;492      g_u8DataLen = 0;
00001e  2000              MOVS     r0,#0
000020  70e0              STRB     r0,[r4,#3]
;;;493      g_u8EndFlag = 0;
000022  7020              STRB     r0,[r4,#0]
;;;494    
;;;495      /* I2C as master sends START signal */
;;;496      I2C_SET_CONTROL_REG(I2C2, I2C_CTL_STA);
000024  4806              LDR      r0,|L14.64|
000026  6801              LDR      r1,[r0,#0]
000028  f021013c          BIC      r1,r1,#0x3c
00002c  f0410120          ORR      r1,r1,#0x20
000030  6001              STR      r1,[r0,#0]
;;;497    
;;;498      return;
;;;499    }
000032  bd10              POP      {r4,pc}
;;;500    
                          ENDP

                  |L14.52|
                          DCD      ||.data||
                  |L14.56|
                          DCD      EepromReadByte
                  |L14.60|
                          DCD      EepromWriteByte
                  |L14.64|
                          DCD      0x40082000

                          AREA ||i.SYS_UnlockReg||, CODE, READONLY, ALIGN=2

                  SYS_UnlockReg PROC
;;;1585     */
;;;1586   __STATIC_INLINE void SYS_UnlockReg(void)
000000  2159              MOVS     r1,#0x59
;;;1587   {
000002  b510              PUSH     {r4,lr}
;;;1588       do
;;;1589       {
;;;1590           SYS->REGLCTL = 0x59UL;
000004  0788              LSLS     r0,r1,#30
;;;1591           SYS->REGLCTL = 0x16UL;
000006  2316              MOVS     r3,#0x16
;;;1592           SYS->REGLCTL = 0x88UL;
000008  f05f0288          MOVS.W   r2,#0x88
                  |L15.12|
00000c  f8c01100          STR      r1,[r0,#0x100]        ;1590
000010  f8c03100          STR      r3,[r0,#0x100]        ;1591
000014  f8c02100          STR      r2,[r0,#0x100]
;;;1593       }
;;;1594       while(SYS->REGLCTL == 0UL);
000018  f8d04100          LDR      r4,[r0,#0x100]
00001c  2c00              CMP      r4,#0
00001e  d0f5              BEQ      |L15.12|
;;;1595   }
000020  bd10              POP      {r4,pc}
;;;1596   
                          ENDP


                          AREA ||i.SysClock_Initialize||, CODE, READONLY, ALIGN=2

                  SysClock_Initialize PROC
;;;519     *----------------------------------------------------------------------------*/
;;;520    void SysClock_Initialize (void) {
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;521    
;;;522        /*---------------------------------------------------------------------------------------------------------*/
;;;523        /* Init System Clock                                                                                       */
;;;524        /*---------------------------------------------------------------------------------------------------------*/
;;;525        /* Unlock protected registers */
;;;526        SYS_UnlockReg();
000004  f7fffffe          BL       SYS_UnlockReg
;;;527    
;;;528        /* Enable HIRC clock */
;;;529        CLK_EnableXtalRC(CLK_PWRCTL_HIRCEN_Msk);
000008  2004              MOVS     r0,#4
00000a  f7fffffe          BL       CLK_EnableXtalRC
;;;530    
;;;531        /* Waiting for HIRC clock ready */
;;;532        CLK_WaitClockReady(CLK_STATUS_HIRCSTB_Msk);
00000e  2010              MOVS     r0,#0x10
000010  f7fffffe          BL       CLK_WaitClockReady
;;;533    
;;;534        /* Switch HCLK clock source to HIRC */
;;;535        CLK_SetHCLK(CLK_CLKSEL0_HCLKSEL_HIRC, CLK_CLKDIV0_HCLK(1));
000014  2100              MOVS     r1,#0
000016  2007              MOVS     r0,#7
000018  f7fffffe          BL       CLK_SetHCLK
;;;536    
;;;537        /* Enable HXT */
;;;538        CLK_EnableXtalRC(CLK_PWRCTL_HXTEN_Msk);
00001c  2001              MOVS     r0,#1
00001e  f7fffffe          BL       CLK_EnableXtalRC
;;;539    
;;;540        /* Waiting for clock ready */
;;;541        CLK_WaitClockReady(CLK_STATUS_HXTSTB_Msk);
000022  2001              MOVS     r0,#1
000024  f7fffffe          BL       CLK_WaitClockReady
;;;542    
;;;543        /* Set core clock as PLL_CLOCK from PLL */
;;;544        CLK_SetCoreClock(FREQ_192MHZ);
000028  4824              LDR      r0,|L16.188|
00002a  f7fffffe          BL       CLK_SetCoreClock
;;;545    
;;;546        /* Set SysTick source to HCLK/2 */
;;;547        CLK_SetSysTickClockSrc(CLK_CLKSEL0_STCLKSEL_HCLK_DIV2);
00002e  2018              MOVS     r0,#0x18
000030  f7fffffe          BL       CLK_SetSysTickClockSrc
;;;548    
;;;549        /* Set both PCLK0 and PCLK1 as HCLK/2 */
;;;550        //CLK->PCLKDIV = CLK_PCLKDIV_APB0DIV_DIV2 | CLK_PCLKDIV_APB1DIV_DIV2;
;;;551        CLK->PCLKDIV = CLK_PCLKDIV_APB0DIV_DIV1 | CLK_PCLKDIV_APB1DIV_DIV1;
000034  f04f4480          MOV      r4,#0x40000000
000038  2500              MOVS     r5,#0
00003a  f8c45234          STR      r5,[r4,#0x234]
;;;552     
;;;553        /* Enable peripheral clock */
;;;554        CLK_EnableModuleClock(UART0_MODULE);
00003e  4e20              LDR      r6,|L16.192|
000040  f50474dc          ADD      r4,r4,#0x1b8
000044  4630              MOV      r0,r6
000046  f7fffffe          BL       CLK_EnableModuleClock
;;;555        CLK_EnableModuleClock(EBI_MODULE);
00004a  2003              MOVS     r0,#3
00004c  f7fffffe          BL       CLK_EnableModuleClock
;;;556        CLK_EnableModuleClock(TMR0_MODULE);
000050  4f1c              LDR      r7,|L16.196|
000052  4638              MOV      r0,r7
000054  f7fffffe          BL       CLK_EnableModuleClock
;;;557        CLK_EnableModuleClock(TMR1_MODULE);
000058  f8df806c          LDR      r8,|L16.200|
00005c  4640              MOV      r0,r8
00005e  f7fffffe          BL       CLK_EnableModuleClock
;;;558        CLK_EnableModuleClock(TMR3_MODULE);
000062  f8df9068          LDR      r9,|L16.204|
000066  4648              MOV      r0,r9
000068  f7fffffe          BL       CLK_EnableModuleClock
;;;559        /* Enable I2C1/I2C2 clock */
;;;560        CLK_EnableModuleClock(I2C1_MODULE);
00006c  4818              LDR      r0,|L16.208|
00006e  f7fffffe          BL       CLK_EnableModuleClock
;;;561        CLK_EnableModuleClock(I2C2_MODULE);
000072  4817              LDR      r0,|L16.208|
000074  1c40              ADDS     r0,r0,#1
000076  f7fffffe          BL       CLK_EnableModuleClock
;;;562    
;;;563        /* Select IP clock source */
;;;564        CLK_SetModuleClock(UART0_MODULE, CLK_CLKSEL1_UART0SEL_HXT, CLK_CLKDIV0_UART0(1));
00007a  2200              MOVS     r2,#0
00007c  4611              MOV      r1,r2
00007e  4630              MOV      r0,r6
000080  f7fffffe          BL       CLK_SetModuleClock
;;;565        CLK_SetModuleClock(TMR0_MODULE, CLK_CLKSEL1_TMR0SEL_HXT, 0);
000084  2200              MOVS     r2,#0
000086  4611              MOV      r1,r2
000088  4638              MOV      r0,r7
00008a  f7fffffe          BL       CLK_SetModuleClock
;;;566        CLK_SetModuleClock(TMR1_MODULE, CLK_CLKSEL1_TMR1SEL_HXT, 0);
00008e  2200              MOVS     r2,#0
000090  4611              MOV      r1,r2
000092  4640              MOV      r0,r8
000094  f7fffffe          BL       CLK_SetModuleClock
;;;567        CLK_SetModuleClock(TMR3_MODULE, CLK_CLKSEL1_TMR3SEL_HXT, 0);
000098  2200              MOVS     r2,#0
00009a  4611              MOV      r1,r2
00009c  4648              MOV      r0,r9
00009e  f7fffffe          BL       CLK_SetModuleClock
;;;568    
;;;569        CLK->AHBCLK |= (1 << 14);  // 128k~160k for SPIM
0000a2  6ce0              LDR      r0,[r4,#0x4c]
0000a4  f4404080          ORR      r0,r0,#0x4000
0000a8  64e0              STR      r0,[r4,#0x4c]
;;;570        outpw(0x40007004,0x16);  // control SPIM can write
0000aa  490a              LDR      r1,|L16.212|
0000ac  2016              MOVS     r0,#0x16
0000ae  6048              STR      r0,[r1,#4]
;;;571    
;;;572        /* Update System Core Clock */
;;;573        /* User can use SystemCoreClockUpdate() to calculate SystemCoreClock. */
;;;574        SystemCoreClockUpdate();
0000b0  f7fffffe          BL       SystemCoreClockUpdate
0000b4  f8445cb8          STR      r5,[r4,#-0xb8]
;;;575    
;;;576        /* Lock protected registers */
;;;577        SYS_LockReg();
;;;578    
;;;579      return;
;;;580    }
0000b8  e8bd87f0          POP      {r4-r10,pc}
;;;581    
                          ENDP

                  |L16.188|
                          DCD      0x0b71b000
                  |L16.192|
                          DCD      0x57803d10
                  |L16.196|
                          DCD      0x5e800002
                  |L16.200|
                          DCD      0x5ec00003
                  |L16.204|
                          DCD      0x5f400005
                  |L16.208|
                          DCD      0x40000009
                  |L16.212|
                          DCD      0x40007000

                          AREA ||i.TMR0_IRQHandler||, CODE, READONLY, ALIGN=2

                  TMR0_IRQHandler PROC
;;;73     /*---------------------------------------------------------------------------------------------------------*/
;;;74     void TMR0_IRQHandler(void){
000000  b570              PUSH     {r4-r6,lr}
;;;75       int Key;
;;;76       OS_TimeMS++;
000002  4c2a              LDR      r4,|L17.172|
000004  6820              LDR      r0,[r4,#0]  ; OS_TimeMS
000006  1c40              ADDS     r0,r0,#1
000008  6020              STR      r0,[r4,#0]  ; OS_TimeMS
00000a  4d29              LDR      r5,|L17.176|
00000c  68a8              LDR      r0,[r5,#8]
00000e  f0100f01          TST      r0,#1
000012  d04a              BEQ      |L17.170|
;;;77     	
;;;78       if (TIMER_GetIntFlag(TIMER0)) {
;;;79     #if GUI_SUPPORT_TOUCH
;;;80         if ( OS_TimeMS % 10 == 0 ) {
000014  6820              LDR      r0,[r4,#0]  ; OS_TimeMS
000016  210a              MOVS     r1,#0xa
000018  fb90f2f1          SDIV     r2,r0,r1
00001c  fb010012          MLS      r0,r1,r2,r0
;;;81             if ( g_enable_Touch == 1 ) {
000020  4e24              LDR      r6,|L17.180|
000022  b920              CBNZ     r0,|L17.46|
000024  68f0              LDR      r0,[r6,#0xc]  ; g_enable_Touch
000026  2801              CMP      r0,#1
000028  d101              BNE      |L17.46|
;;;82                 GUI_TOUCH_Exec();
00002a  f7fffffe          BL       GUI_TOUCH_Exec
                  |L17.46|
;;;83             }
;;;84         }
;;;85     #endif
;;;86         if ( (g_enable_Touch == 1) && (OS_TimeMS % 200 == 0) ) {
00002e  68f0              LDR      r0,[r6,#0xc]  ; g_enable_Touch
000030  2801              CMP      r0,#1
000032  d138              BNE      |L17.166|
000034  6820              LDR      r0,[r4,#0]  ; OS_TimeMS
000036  21c8              MOVS     r1,#0xc8
000038  fb90f2f1          SDIV     r2,r0,r1
00003c  fb010012          MLS      r0,r1,r2,r0
000040  bb88              CBNZ     r0,|L17.166|
;;;87             if (PA0 == 0) {
000042  481d              LDR      r0,|L17.184|
000044  6800              LDR      r0,[r0,#0]
000046  b918              CBNZ     r0,|L17.80|
;;;88                 Key = GUI_KEY_TAB;
000048  2009              MOVS     r0,#9
;;;89                 GUI_StoreKeyMsg(Key, 1);
00004a  2101              MOVS     r1,#1
00004c  f7fffffe          BL       GUI_StoreKeyMsg
                  |L17.80|
;;;90             }
;;;91             if ((PA1 == 0) || (PG3 == 0)) {
000050  4819              LDR      r0,|L17.184|
000052  1d00              ADDS     r0,r0,#4
000054  6800              LDR      r0,[r0,#0]
000056  b110              CBZ      r0,|L17.94|
000058  4818              LDR      r0,|L17.188|
00005a  6800              LDR      r0,[r0,#0]
00005c  b918              CBNZ     r0,|L17.102|
                  |L17.94|
;;;92                 Key = GUI_KEY_ENTER;
00005e  200d              MOVS     r0,#0xd
;;;93                 GUI_StoreKeyMsg(Key, 1);
000060  2101              MOVS     r1,#1
000062  f7fffffe          BL       GUI_StoreKeyMsg
                  |L17.102|
;;;94             }
;;;95             if (PG2 == 0) {
000066  4815              LDR      r0,|L17.188|
000068  1f00              SUBS     r0,r0,#4
00006a  6800              LDR      r0,[r0,#0]
00006c  b918              CBNZ     r0,|L17.118|
;;;96                 Key = GUI_KEY_UP;
00006e  2011              MOVS     r0,#0x11
;;;97                 GUI_StoreKeyMsg(Key, 1);
000070  2101              MOVS     r1,#1
000072  f7fffffe          BL       GUI_StoreKeyMsg
                  |L17.118|
;;;98             }
;;;99             if (PC10 == 0) {
000076  4810              LDR      r0,|L17.184|
000078  30a8              ADDS     r0,r0,#0xa8
00007a  6800              LDR      r0,[r0,#0]
00007c  b918              CBNZ     r0,|L17.134|
;;;100                Key = GUI_KEY_DOWN;
00007e  2013              MOVS     r0,#0x13
;;;101                GUI_StoreKeyMsg(Key, 1);
000080  2101              MOVS     r1,#1
000082  f7fffffe          BL       GUI_StoreKeyMsg
                  |L17.134|
;;;102            }
;;;103            if (PC9 == 0) {
000086  480c              LDR      r0,|L17.184|
000088  30a4              ADDS     r0,r0,#0xa4
00008a  6800              LDR      r0,[r0,#0]
00008c  b918              CBNZ     r0,|L17.150|
;;;104                Key = GUI_KEY_LEFT;
00008e  2010              MOVS     r0,#0x10
;;;105                GUI_StoreKeyMsg(Key, 1);
000090  2101              MOVS     r1,#1
000092  f7fffffe          BL       GUI_StoreKeyMsg
                  |L17.150|
;;;106            }
;;;107            if (PG4 == 0) {
000096  4809              LDR      r0,|L17.188|
000098  1d00              ADDS     r0,r0,#4
00009a  6800              LDR      r0,[r0,#0]
00009c  b918              CBNZ     r0,|L17.166|
;;;108                Key = GUI_KEY_RIGHT;
00009e  2012              MOVS     r0,#0x12
;;;109                GUI_StoreKeyMsg(Key, 1);
0000a0  2101              MOVS     r1,#1
0000a2  f7fffffe          BL       GUI_StoreKeyMsg
                  |L17.166|
0000a6  2001              MOVS     r0,#1
0000a8  60a8              STR      r0,[r5,#8]
                  |L17.170|
;;;110            }
;;;111        }
;;;112        TIMER_ClearIntFlag(TIMER0);   /* Clear Timer0 time-out interrupt flag */
;;;113      }
;;;114    
;;;115      return;
;;;116    }
0000aa  bd70              POP      {r4-r6,pc}
;;;117    
                          ENDP

                  |L17.172|
                          DCD      OS_TimeMS
                  |L17.176|
                          DCD      0x40050000
                  |L17.180|
                          DCD      ||.data||
                  |L17.184|
                          DCD      0x40004800
                  |L17.188|
                          DCD      0x4000498c

                          AREA ||i.TMR1_IRQHandler||, CODE, READONLY, ALIGN=2

                  TMR1_IRQHandler PROC
;;;120    /*---------------------------------------------------------------------------------------------------------*/
;;;121    void TMR1_IRQHandler(void) {
000000  4817              LDR      r0,|L18.96|
000002  4b18              LDR      r3,|L18.100|
;;;122      TIMER_CTRL_STRC *ptr = TimerCtrlPtr;
000004  6800              LDR      r0,[r0,#0]  ; TimerCtrlPtr
000006  6899              LDR      r1,[r3,#8]
000008  f0110f01          TST      r1,#1
00000c  d026              BEQ      |L18.92|
;;;123    	
;;;124      if (TIMER_GetIntFlag(TIMER1)){
;;;125    
;;;126        if (ptr->FMC_STATE_TIMER < 0xFFFFFFF0)
00000e  6802              LDR      r2,[r0,#0]
000010  f06f010f          MVN      r1,#0xf
000014  428a              CMP      r2,r1
000016  d201              BCS      |L18.28|
000018  1c52              ADDS     r2,r2,#1
;;;127            ptr->FMC_STATE_TIMER++;
00001a  6002              STR      r2,[r0,#0]
                  |L18.28|
;;;128    
;;;129        if (ptr->GUI_EXEC_TIMER < 0xFFFFFFF0)
00001c  6842              LDR      r2,[r0,#4]
00001e  428a              CMP      r2,r1
000020  d201              BCS      |L18.38|
000022  1c52              ADDS     r2,r2,#1
;;;130            ptr->GUI_EXEC_TIMER++;
000024  6042              STR      r2,[r0,#4]
                  |L18.38|
;;;131    
;;;132        if (ptr->TOUCH_PAD_TIMER < 0xFFFFFFF0)
000026  6882              LDR      r2,[r0,#8]
000028  428a              CMP      r2,r1
00002a  d201              BCS      |L18.48|
00002c  1c52              ADDS     r2,r2,#1
;;;133            ptr->TOUCH_PAD_TIMER++;
00002e  6082              STR      r2,[r0,#8]
                  |L18.48|
;;;134    
;;;135        if (ptr->GUI_ROTARY_TIMER < 0xFFFFFFF0)
000030  68c2              LDR      r2,[r0,#0xc]
000032  428a              CMP      r2,r1
000034  d201              BCS      |L18.58|
000036  1c52              ADDS     r2,r2,#1
;;;136            ptr->GUI_ROTARY_TIMER++;
000038  60c2              STR      r2,[r0,#0xc]
                  |L18.58|
;;;137    
;;;138        if (ptr->I2C_TOUCH_TIMER < 0xFFFFFFF0)
00003a  6902              LDR      r2,[r0,#0x10]
00003c  428a              CMP      r2,r1
00003e  d201              BCS      |L18.68|
000040  1c52              ADDS     r2,r2,#1
;;;139            ptr->I2C_TOUCH_TIMER++;
000042  6102              STR      r2,[r0,#0x10]
                  |L18.68|
;;;140    
;;;141        if (ptr->EEPROM_READ_TIMER < 0xFFFFFFF0)
000044  6942              LDR      r2,[r0,#0x14]
000046  428a              CMP      r2,r1
000048  d201              BCS      |L18.78|
00004a  1c52              ADDS     r2,r2,#1
;;;142            ptr->EEPROM_READ_TIMER++;
00004c  6142              STR      r2,[r0,#0x14]
                  |L18.78|
;;;143    
;;;144        if (ptr->EEPROM_WRITE_TIMER < 0xFFFFFFF0)
00004e  6982              LDR      r2,[r0,#0x18]
000050  428a              CMP      r2,r1
000052  d201              BCS      |L18.88|
000054  1c52              ADDS     r2,r2,#1
;;;145            ptr->EEPROM_WRITE_TIMER++;
000056  6182              STR      r2,[r0,#0x18]
                  |L18.88|
000058  2001              MOVS     r0,#1
00005a  6098              STR      r0,[r3,#8]
                  |L18.92|
;;;146    
;;;147           TIMER_ClearIntFlag(TIMER1);   /* Clear Timer1 time-out interrupt flag */
;;;148      }
;;;149    
;;;150      return;
;;;151    }
00005c  4770              BX       lr
;;;152    
                          ENDP

00005e  0000              DCW      0x0000
                  |L18.96|
                          DCD      TimerCtrlPtr
                  |L18.100|
                          DCD      0x40050100

                          AREA ||i.TMR3_IRQHandler||, CODE, READONLY, ALIGN=2

                  TMR3_IRQHandler PROC
;;;155     *----------------------------------------------------------------------------*/
;;;156    void TMR3_IRQHandler (void){
000000  4803              LDR      r0,|L19.16|
000002  6881              LDR      r1,[r0,#8]
000004  f0110f01          TST      r1,#1
000008  d001              BEQ      |L19.14|
00000a  2101              MOVS     r1,#1
00000c  6081              STR      r1,[r0,#8]
                  |L19.14|
;;;157      
;;;158      if (TIMER_GetIntFlag(TIMER3)) {
;;;159    
;;;160           TIMER_ClearIntFlag(TIMER3);   /* Clear Timer3 time-out interrupt flag */
;;;161      }
;;;162    
;;;163      return;
;;;164    }
00000e  4770              BX       lr
;;;165    
                          ENDP

                  |L19.16|
                          DCD      0x40051100

                          AREA ||i.Timer0_Initialize||, CODE, READONLY, ALIGN=2

                  Timer0_Initialize PROC
;;;649     *----------------------------------------------------------------------------*/
;;;650    void Timer0_Initialize (void) {
000000  b510              PUSH     {r4,lr}
;;;651    
;;;652        /* Open Timer0 in periodic mode, enable interrupt and 1000 interrupt tick per second */
;;;653        TIMER_Open(TIMER0, TIMER_PERIODIC_MODE, 1000);
000002  4c0c              LDR      r4,|L20.52|
000004  f44f727a          MOV      r2,#0x3e8
000008  f04f6100          MOV      r1,#0x8000000
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       TIMER_Open
000012  6820              LDR      r0,[r4,#0]
000014  f0405000          ORR      r0,r0,#0x20000000
000018  6020              STR      r0,[r4,#0]
;;;654        TIMER_EnableInt(TIMER0);
;;;655      
;;;656        /* Enable Timer0 NVIC */
;;;657        NVIC_SetPriority(TMR0_IRQn, 1);
00001a  2101              MOVS     r1,#1
00001c  2020              MOVS     r0,#0x20
00001e  f7fffffe          BL       __NVIC_SetPriority
;;;658        NVIC_EnableIRQ(TMR0_IRQn);
000022  2020              MOVS     r0,#0x20
000024  f7fffffe          BL       __NVIC_EnableIRQ
000028  6820              LDR      r0,[r4,#0]
00002a  f0404080          ORR      r0,r0,#0x40000000
00002e  6020              STR      r0,[r4,#0]
;;;659      
;;;660        /* Start Timer0 counting */
;;;661        TIMER_Start(TIMER0);
;;;662      
;;;663        return;
;;;664    }
000030  bd10              POP      {r4,pc}
;;;665    
                          ENDP

000032  0000              DCW      0x0000
                  |L20.52|
                          DCD      0x40050000

                          AREA ||i.Timer1_Initialize||, CODE, READONLY, ALIGN=2

                  Timer1_Initialize PROC
;;;668     *----------------------------------------------------------------------------*/
;;;669    void Timer1_Initialize (void) {  
000000  b510              PUSH     {r4,lr}
;;;670    
;;;671        /* Open Timer1 in periodic mode, enable interrupt and 10000 interrupt tick per second */
;;;672        TIMER_Open(TIMER1, TIMER_PERIODIC_MODE, 1000);
000002  4c0c              LDR      r4,|L21.52|
000004  f44f727a          MOV      r2,#0x3e8
000008  f04f6100          MOV      r1,#0x8000000
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       TIMER_Open
000012  6820              LDR      r0,[r4,#0]
000014  f0405000          ORR      r0,r0,#0x20000000
000018  6020              STR      r0,[r4,#0]
;;;673        TIMER_EnableInt(TIMER1);
;;;674    
;;;675        /* Enable Timer1 NVIC */
;;;676        NVIC_SetPriority(TMR1_IRQn, 1);
00001a  2101              MOVS     r1,#1
00001c  2021              MOVS     r0,#0x21
00001e  f7fffffe          BL       __NVIC_SetPriority
;;;677        NVIC_EnableIRQ(TMR1_IRQn);
000022  2021              MOVS     r0,#0x21
000024  f7fffffe          BL       __NVIC_EnableIRQ
000028  6820              LDR      r0,[r4,#0]
00002a  f0404080          ORR      r0,r0,#0x40000000
00002e  6020              STR      r0,[r4,#0]
;;;678    
;;;679        /* Start Timer1 counting */
;;;680        TIMER_Start(TIMER1);
;;;681      
;;;682        return;
;;;683    }
000030  bd10              POP      {r4,pc}
;;;684    
                          ENDP

000032  0000              DCW      0x0000
                  |L21.52|
                          DCD      0x40050100

                          AREA ||i.Timer3_Initialize||, CODE, READONLY, ALIGN=2

                  Timer3_Initialize PROC
;;;687     *----------------------------------------------------------------------------*/
;;;688    void Timer3_Initialize (void) {  
000000  b510              PUSH     {r4,lr}
;;;689    
;;;690      /* Open Timer3 in periodic mode, enable interrupt and 10000 interrupt tick per second */
;;;691      TIMER_Open(TIMER3, TIMER_PERIODIC_MODE, 10000);
000002  4c0c              LDR      r4,|L22.52|
000004  f2427210          MOV      r2,#0x2710
000008  f04f6100          MOV      r1,#0x8000000
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       TIMER_Open
000012  6820              LDR      r0,[r4,#0]
000014  f0405000          ORR      r0,r0,#0x20000000
000018  6020              STR      r0,[r4,#0]
;;;692      TIMER_EnableInt(TIMER3);
;;;693    
;;;694      /* Enable Timer1 NVIC */
;;;695      NVIC_SetPriority(TMR3_IRQn, 1);
00001a  2101              MOVS     r1,#1
00001c  2023              MOVS     r0,#0x23
00001e  f7fffffe          BL       __NVIC_SetPriority
;;;696      NVIC_EnableIRQ(TMR3_IRQn);
000022  2023              MOVS     r0,#0x23
000024  f7fffffe          BL       __NVIC_EnableIRQ
000028  6820              LDR      r0,[r4,#0]
00002a  f0404080          ORR      r0,r0,#0x40000000
00002e  6020              STR      r0,[r4,#0]
;;;697    
;;;698      /* Start Timer1 counting */
;;;699      TIMER_Start(TIMER3);
;;;700      
;;;701      return;
;;;702    }
000030  bd10              POP      {r4,pc}
;;;703    
                          ENDP

000032  0000              DCW      0x0000
                  |L22.52|
                          DCD      0x40051100

                          AREA ||i.UART0_IRQHandler||, CODE, READONLY, ALIGN=1

                  UART0_IRQHandler PROC
;;;64     /*---------------------------------------------------------------------------------------------------------*/
;;;65     void UART0_IRQHandler(void)
000000  4770              BX       lr
;;;66     {
;;;67     
;;;68       return;
;;;69     }
;;;70     
                          ENDP


                          AREA ||i.Uart_Initialize||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  Uart_Initialize PROC
;;;584     *----------------------------------------------------------------------------*/
;;;585    void Uart_Initialize (void) {
000000  b510              PUSH     {r4,lr}
;;;586    
;;;587      /* Reset IP */
;;;588      SYS_ResetModule(UART0_RST);
000002  480a              LDR      r0,|L24.44|
000004  f7fffffe          BL       SYS_ResetModule
;;;589     
;;;590      /* Configure UART0 and set UART0 Baudrate */
;;;591      UART_Open(UART0, 115200);
000008  4c09              LDR      r4,|L24.48|
00000a  f44f31e1          MOV      r1,#0x1c200
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       UART_Open
;;;592    
;;;593      UART_SetTimeoutCnt(UART0, 0x10); // Set Rx Time-out counter
000014  2110              MOVS     r1,#0x10
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       UART_SetTimeoutCnt
;;;594    
;;;595      // Set RX FIFO Interrupt Trigger Level
;;;596      //UART0->FIFO &= ~ UART_FIFO_RFITL_Msk;
;;;597      //UART0->FIFO |= UART_FIFO_RFITL_4BYTES;
;;;598    
;;;599      /* Enable UART RDA/THRE/Time-out interrupt */
;;;600      //NVIC_EnableIRQ(UART0_IRQn);
;;;601    
;;;602      //UART_EnableInt(UART0, (UART_INTEN_RDAIEN_Msk | UART_INTEN_THREIEN_Msk | UART_INTEN_RXTOIEN_Msk));
;;;603      //UART_EnableInt(UART0, (UART_INTEN_RDAIEN_Msk | UART_INTEN_RXTOIEN_Msk));
;;;604    
;;;605      UART_MSG("\n\nCPU @ %d Hz\n", SystemCoreClock);
00001c  4805              LDR      r0,|L24.52|
00001e  6801              LDR      r1,[r0,#0]  ; SystemCoreClock
000020  e8bd4010          POP      {r4,lr}
000024  a004              ADR      r0,|L24.56|
000026  f7ffbffe          B.W      __2printf
;;;606    
;;;607      return;
;;;608    }
;;;609    
                          ENDP

00002a  0000              DCW      0x0000
                  |L24.44|
                          DCD      0x04000010
                  |L24.48|
                          DCD      0x40070000
                  |L24.52|
                          DCD      SystemCoreClock
                  |L24.56|
000038  0a0a4350          DCB      "\n\nCPU @ %d Hz\n",0
00003c  55204020
000040  25642048
000044  7a0a00  
000047  00                DCB      0

                          AREA ||i.__NVIC_EnableIRQ||, CODE, READONLY, ALIGN=1

                  __NVIC_EnableIRQ PROC
;;;1671    */
;;;1672   __STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
000000  2800              CMP      r0,#0
;;;1673   {
000002  db09              BLT      |L25.24|
;;;1674     if ((int32_t)(IRQn) >= 0)
;;;1675     {
;;;1676       NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
000004  f000021f          AND      r2,r0,#0x1f
000008  2101              MOVS     r1,#1
00000a  4091              LSLS     r1,r1,r2
00000c  0940              LSRS     r0,r0,#5
00000e  0080              LSLS     r0,r0,#2
000010  f10020e0          ADD      r0,r0,#0xe000e000
000014  f8c01100          STR      r1,[r0,#0x100]
                  |L25.24|
;;;1677     }
;;;1678   }
000018  4770              BX       lr
;;;1679   
                          ENDP


                          AREA ||i.__NVIC_SetPriority||, CODE, READONLY, ALIGN=1

                  __NVIC_SetPriority PROC
;;;1799    */
;;;1800   __STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
000000  0709              LSLS     r1,r1,#28
;;;1801   {
;;;1802     if ((int32_t)(IRQn) >= 0)
;;;1803     {
;;;1804       NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
000002  0e09              LSRS     r1,r1,#24
000004  2800              CMP      r0,#0                 ;1802
000006  db04              BLT      |L26.18|
000008  f10020e0          ADD      r0,r0,#0xe000e000     ;1801
00000c  f8801400          STRB     r1,[r0,#0x400]
;;;1805     }
;;;1806     else
;;;1807     {
;;;1808       SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
;;;1809     }
;;;1810   }
000010  4770              BX       lr
                  |L26.18|
000012  f000000f          AND      r0,r0,#0xf            ;1808
000016  f10020e0          ADD      r0,r0,#0xe000e000     ;1808
00001a  f8801d14          STRB     r1,[r0,#0xd14]        ;1808
00001e  4770              BX       lr
;;;1811   
                          ENDP


                          AREA ||.data||, DATA, ALIGN=2

                  g_u8EndFlag
000000  00                DCB      0x00
                  g_u8DeviceAddr
000001  00                DCB      0x00
                  g_u8RxData
000002  00                DCB      0x00
                  g_u8DataLen
000003  00                DCB      0x00
                  g_au8TxData
000004  00000000          DCB      0x00,0x00,0x00,0x00
                  s_I2C2HandlerFn
                          DCD      0x00000000
                  g_enable_Touch
                          DCD      0x00000000
                  I2C1_Ctx
                          DCD      0x40081000
                          DCD      0x00000000
000018  00000000          DCB      0x00,0x00,0x00,0x00
00001c  00000000          DCB      0x00,0x00,0x00,0x00
                  I2C2_Ctx
                          DCD      0x40082000
                          DCD      0x00000000
000028  00000000          DCB      0x00,0x00,0x00,0x00
00002c  00000000          DCB      0x00,0x00,0x00,0x00

                          AREA ||area_number.30||, DATA, ALIGN=0

                          EXPORTAS ||area_number.30||, ||.data||
                  I2c1_EndFlag
000000  00                DCB      0x00

                          AREA ||area_number.31||, DATA, ALIGN=0

                          EXPORTAS ||area_number.31||, ||.data||
                  I2c1_DeviceAddr
000000  00                DCB      0x00

                          AREA ||area_number.32||, DATA, ALIGN=0

                          EXPORTAS ||area_number.32||, ||.data||
                  I2c1_TxData
000000  0000              DCB      0x00,0x00

                          AREA ||area_number.33||, DATA, ALIGN=0

                          EXPORTAS ||area_number.33||, ||.data||
                  I2c1_RxData
000000  00                DCB      0x00

                          AREA ||area_number.34||, DATA, ALIGN=0

                          EXPORTAS ||area_number.34||, ||.data||
                  I2c1_DataLen
000000  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "..\\Thermostat\\platform.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___10_platform_c_I2C1_Ctx____REV16|
#line 464 "..\\..\\..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___10_platform_c_I2C1_Ctx____REV16| PROC
#line 465

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___10_platform_c_I2C1_Ctx____REVSH|
#line 479
|__asm___10_platform_c_I2C1_Ctx____REVSH| PROC
#line 480

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___10_platform_c_I2C1_Ctx____RRX|
#line 666
|__asm___10_platform_c_I2C1_Ctx____RRX| PROC
#line 667

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
