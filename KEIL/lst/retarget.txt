; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\obj\retarget.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\retarget.d --cpu=Cortex-M4.fp --apcs=interwork -O3 --diag_suppress=9931 -I..\..\..\..\Library\Device\Nuvoton\M480\Include -I..\..\..\..\Library\StdDriver\inc -I..\..\..\..\ThirdParty\emWin\Config -I..\..\..\..\ThirdParty\emWin\Include -I..\tslib -I..\..\..\..\Library\CMSIS\Include -I..\Thermostat -I..\Application\Source\Generated -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=523 --omf_browse=.\obj\retarget.crf ..\..\..\..\Library\StdDriver\src\retarget.c]
                          THUMB

                          AREA ||i.GetChar||, CODE, READONLY, ALIGN=2

                  GetChar PROC
;;;558     */
;;;559    char GetChar(void)
000000  4803              LDR      r0,|L1.16|
                  |L1.2|
;;;560    {
;;;561    #ifdef DEBUG_ENABLE_SEMIHOST
;;;562    
;;;563        int nRet;
;;;564    
;;;565    # if defined (__ICCARM__)
;;;566        while(SH_DoCommand(0x7, 0, &nRet) != 0)
;;;567        {
;;;568            if(nRet != 0)
;;;569                return (char)nRet;
;;;570        }
;;;571    # else
;;;572        while(SH_DoCommand(0x101, 0, &nRet) != 0)
;;;573        {
;;;574            if(nRet != 0)
;;;575            {
;;;576                SH_DoCommand(0x07, 0, &nRet);
;;;577                return (char)nRet;
;;;578            }
;;;579        }
;;;580    # endif
;;;581    
;;;582    # if (DEBUG_ENABLE_SEMIHOST == 2) // Re-direct to UART Debug Port only when DEBUG_ENABLE_SEMIHOST=2
;;;583        /* Use debug port when ICE is not connected at semihost mode */
;;;584        while(!g_ICE_Conneced)
;;;585        {
;;;586            if((DEBUG_PORT->FIFOSTS & UART_FIFOSTS_RXEMPTY_Msk) == 0)
;;;587            {
;;;588                return (DEBUG_PORT->DAT);
;;;589            }
;;;590        }
;;;591    # endif
;;;592    
;;;593        return (0);
;;;594    #else
;;;595    
;;;596    #ifndef DISABLE_UART
;;;597        while(1)
;;;598        {
;;;599            if((DEBUG_PORT->FIFOSTS & UART_FIFOSTS_RXEMPTY_Msk) == 0)
000002  6981              LDR      r1,[r0,#0x18]
000004  0449              LSLS     r1,r1,#17
000006  d4fc              BMI      |L1.2|
;;;600            {
;;;601                return (DEBUG_PORT->DAT);
000008  6800              LDR      r0,[r0,#0]
00000a  b2c0              UXTB     r0,r0
;;;602            }
;;;603        }
;;;604    #else
;;;605        return 0;
;;;606    #endif
;;;607    
;;;608    #endif
;;;609    }
00000c  4770              BX       lr
;;;610    
                          ENDP

00000e  0000              DCW      0x0000
                  |L1.16|
                          DCD      0x40070000

                          AREA ||i.IsDebugFifoEmpty||, CODE, READONLY, ALIGN=2

                  IsDebugFifoEmpty PROC
;;;640    
;;;641    int IsDebugFifoEmpty(void)
000000  4802              LDR      r0,|L2.12|
;;;642    {
;;;643    #ifndef DISABLE_UART
;;;644        return ((DEBUG_PORT->FIFOSTS & UART_FIFOSTS_TXEMPTYF_Msk) != 0);
000002  6980              LDR      r0,[r0,#0x18]
000004  f3c07000          UBFX     r0,r0,#28,#1
;;;645    #else
;;;646        return 1;
;;;647    #endif
;;;648    }
000008  4770              BX       lr
;;;649    
                          ENDP

00000a  0000              DCW      0x0000
                  |L2.12|
                          DCD      0x40070000

                          AREA ||i.ProcessHardFault||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_flags
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                          REQUIRE _printf_s
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  ProcessHardFault PROC
;;;289    
;;;290    __WEAK uint32_t ProcessHardFault(uint32_t lr, uint32_t msp, uint32_t psp)
000000  b51c              PUSH     {r2-r4,lr}
;;;291    {
;;;292    		uint32_t *sp = NULL;
000002  2500              MOVS     r5,#0
;;;293    		uint32_t inst, addr, taddr, tdata;
;;;294    		int32_t secure;
;;;295    		uint32_t rm, rn, rt, imm5, imm8;
;;;296    
;;;297    		/* It is casued by hardfault. Just process the hard fault */
;;;298    		/* TODO: Implement your hardfault handle code here */
;;;299    
;;;300    
;;;301    		/* Check the used stack */
;;;302    		secure = (lr & 0x40ul) ? 1 : 0;
000004  f3c01380          UBFX     r3,r0,#6,#1
000008  b123              CBZ      r3,|L3.20|
;;;303    		if(secure)
;;;304    		{
;;;305    				/* Secure stack used */
;;;306    				if(lr & 4UL)
00000a  0740              LSLS     r0,r0,#29
00000c  d501              BPL      |L3.18|
;;;307    				{
;;;308    						sp = (uint32_t *)psp;
00000e  4615              MOV      r5,r2
000010  e000              B        |L3.20|
                  |L3.18|
;;;309    				}
;;;310    				else
;;;311    				{
;;;312    						sp = (uint32_t *)msp;
000012  460d              MOV      r5,r1
                  |L3.20|
;;;313    				}
;;;314    
;;;315    		}
;;;316    #if defined (__ARM_FEATURE_CMSE) &&  (__ARM_FEATURE_CMSE == 3)
;;;317    		else
;;;318    		{
;;;319    				/* Non-secure stack used */
;;;320    				if(lr & 4)
;;;321    						sp = (uint32_t *)(__TZ_get_PSP_NS());
;;;322    				else
;;;323    						sp = (uint32_t *)(__TZ_get_MSP_NS());
;;;324    
;;;325    		}
;;;326    #endif
;;;327    
;;;328    		/*
;;;329    				r0  = sp[0]
;;;330    				r1  = sp[1]
;;;331    				r2  = sp[2]
;;;332    				r3  = sp[3]
;;;333    				r12 = sp[4]
;;;334    				lr  = sp[5]
;;;335    				pc  = sp[6]
;;;336    				psr = sp[7]
;;;337    		*/
;;;338    
;;;339    		printf("HardFault @ 0x%08x\n", sp[6]);
000014  a03d              ADR      r0,|L3.268|
000016  69a9              LDR      r1,[r5,#0x18]
000018  f7fffffe          BL       __2printf
;;;340    		/* Get the instruction caused the hardfault */
;;;341    		if( sp != NULL )
00001c  b11d              CBZ      r5,|L3.38|
;;;342    		{
;;;343    				addr = sp[6];
;;;344    				inst = M16(addr);
00001e  f8d59018          LDR      r9,[r5,#0x18]
000022  f8b94000          LDRH     r4,[r9,#0]
                  |L3.38|
;;;345    		}
;;;346    
;;;347    		printf("HardFault Analysis:\n");
000026  a03e              ADR      r0,|L3.288|
000028  f7fffffe          BL       __2printf
;;;348    
;;;349    		printf("Instruction code = %x\n", inst);
00002c  4621              MOV      r1,r4
00002e  a042              ADR      r0,|L3.312|
000030  f7fffffe          BL       __2printf
;;;350    
;;;351    		if(inst == 0xBEAB)
000034  f5a4403e          SUB      r0,r4,#0xbe00
000038  38ab              SUBS     r0,r0,#0xab
00003a  d01a              BEQ      |L3.114|
;;;352    		{
;;;353    				printf("Execute BKPT without ICE connected\n");
;;;354    		}
;;;355    		else if((inst >> 12) == 5)
00003c  2005              MOVS     r0,#5
00003e  ebb03f14          CMP      r0,r4,LSR #12
000042  d121              BNE      |L3.136|
;;;356    		{
;;;357    				/* 0101xx Load/store (register offset) on page C2-327 of armv8m ref */
;;;358    				rm = (inst >> 6) & 0x7;
;;;359    				rn = (inst >> 3) & 0x7;
;;;360    				rt = inst & 0x7;
000044  f0040007          AND      r0,r4,#7
000048  f3c41682          UBFX     r6,r4,#6,#3           ;358
00004c  f3c407c2          UBFX     r7,r4,#3,#3           ;359
000050  4680              MOV      r8,r0
;;;361    
;;;362    				printf("LDR/STR rt=%x rm=%x rn=%x\n", rt, rm, rn);
000052  4601              MOV      r1,r0
000054  463b              MOV      r3,r7
000056  4632              MOV      r2,r6
000058  a03d              ADR      r0,|L3.336|
00005a  f7fffffe          BL       __2printf
;;;363    				taddr = sp[rn] + sp[rm];
00005e  f8550027          LDR      r0,[r5,r7,LSL #2]
000062  f8551026          LDR      r1,[r5,r6,LSL #2]
000066  4401              ADD      r1,r1,r0
;;;364    				tdata = sp[rt];
000068  f8550028          LDR      r0,[r5,r8,LSL #2]
00006c  e9cd0100          STRD     r0,r1,[sp,#0]
;;;365    				printf("[0x%08x] 0x%04x %s 0x%x [0x%x]\n", addr, inst,
000070  e044              B        |L3.252|
                  |L3.114|
000072  a03e              ADR      r0,|L3.364|
000074  e046              B        |L3.260|
                  |L3.118|
;;;366    							 (inst & BIT11) ? "LDR" : "STR", tdata, taddr);
000076  a346              ADR      r3,|L3.400|
000078  e000              B        |L3.124|
                  |L3.122|
00007a  a346              ADR      r3,|L3.404|
                  |L3.124|
;;;367    
;;;368    		}
;;;369    		else if((inst >> 13) == 3)
;;;370    		{
;;;371    				/* 011xxx    Load/store word/byte (immediate offset) on page C2-327 of armv8m ref */
;;;372    				imm5 = (inst >> 6) & 0x1f;
;;;373    				rn = (inst >> 3) & 0x7;
;;;374    				rt = inst & 0x7;
;;;375    
;;;376    				printf("LDR/STR rt=%x rn=%x imm5=%x\n", rt, rn, imm5);
;;;377    				taddr = sp[rn] + imm5;
;;;378    				tdata = sp[rt];
;;;379    				printf("[0x%08x] 0x%04x %s 0x%x [0x%x]\n", addr, inst,
;;;380    							 (inst & BIT11) ? "LDR" : "STR", tdata, taddr);
;;;381    		}
;;;382    		else if((inst >> 12) == 8)
;;;383    		{
;;;384    				/* 1000xx    Load/store halfword (immediate offset) on page C2-328 */
;;;385    				imm5 = (inst >> 6) & 0x1f;
;;;386    				rn = (inst >> 3) & 0x7;
;;;387    				rt = inst & 0x7;
;;;388    
;;;389    				printf("LDRH/STRH rt=%x rn=%x imm5=%x\n", rt, rn, imm5);
;;;390    				taddr = sp[rn] + imm5;
;;;391    				tdata = sp[rt];
;;;392    				printf("[0x%08x] 0x%04x %s 0x%x [0x%x]\n", addr, inst,
;;;393    							 (inst & BIT11) ? "LDR" : "STR", tdata, taddr);
;;;394    
;;;395    		}
;;;396    		else if((inst >> 12) == 9)
;;;397    		{
;;;398    				/* 1001xx    Load/store (SP-relative) on page C2-328 */
;;;399    				imm8 = inst & 0xff;
;;;400    				rt = (inst >> 8) & 0x7;
;;;401    
;;;402    				printf("LDRH/STRH rt=%x imm8=%x\n", rt, imm8);
;;;403    				taddr = sp[6] + imm8;
;;;404    				tdata = sp[rt];
;;;405    				printf("[0x%08x] 0x%04x %s 0x%x [0x%x]\n", addr, inst,
;;;406    							 (inst & BIT11) ? "LDR" : "STR", tdata, taddr);
00007c  4622              MOV      r2,r4
00007e  4649              MOV      r1,r9
000080  a045              ADR      r0,|L3.408|
000082  f7fffffe          BL       __2printf
000086  e03f              B        |L3.264|
                  |L3.136|
000088  2003              MOVS     r0,#3                 ;369
00008a  ebb03f54          CMP      r0,r4,LSR #13         ;369
00008e  d10b              BNE      |L3.168|
000090  f3c41084          UBFX     r0,r4,#6,#5           ;372
000094  4680              MOV      r8,r0                 ;372
000096  f3c406c2          UBFX     r6,r4,#3,#3           ;373
00009a  f0040707          AND      r7,r4,#7              ;374
00009e  4603              MOV      r3,r0                 ;376
0000a0  4632              MOV      r2,r6                 ;376
0000a2  4639              MOV      r1,r7                 ;376
0000a4  a044              ADR      r0,|L3.440|
0000a6  e00e              B        |L3.198|
                  |L3.168|
0000a8  2008              MOVS     r0,#8                 ;382
0000aa  ebb03f14          CMP      r0,r4,LSR #12         ;382
0000ae  d113              BNE      |L3.216|
0000b0  f3c41084          UBFX     r0,r4,#6,#5           ;385
0000b4  4680              MOV      r8,r0                 ;385
0000b6  f3c406c2          UBFX     r6,r4,#3,#3           ;386
0000ba  f0040707          AND      r7,r4,#7              ;387
0000be  4603              MOV      r3,r0                 ;389
0000c0  4632              MOV      r2,r6                 ;389
0000c2  4639              MOV      r1,r7                 ;389
0000c4  a044              ADR      r0,|L3.472|
                  |L3.198|
0000c6  f7fffffe          BL       __2printf
0000ca  f8551026          LDR      r1,[r5,r6,LSL #2]     ;377
0000ce  eb010008          ADD      r0,r1,r8              ;377
0000d2  f8551027          LDR      r1,[r5,r7,LSL #2]     ;378
0000d6  e00f              B        |L3.248|
                  |L3.216|
0000d8  2009              MOVS     r0,#9                 ;396
0000da  ebb03f14          CMP      r0,r4,LSR #12         ;396
0000de  d110              BNE      |L3.258|
0000e0  f3c42602          UBFX     r6,r4,#8,#3           ;400
0000e4  b2e2              UXTB     r2,r4                 ;399
0000e6  4631              MOV      r1,r6                 ;402
0000e8  a043              ADR      r0,|L3.504|
0000ea  f7fffffe          BL       __2printf
;;;407    		}
;;;408    		else
;;;409    		{
;;;410    				printf("Unexpected instruction\n");
;;;411    		}
;;;412    
;;;413    		/* Or *sp to remove compiler warning */
;;;414    		while(1U | *sp) {}
;;;415    
;;;416    		return lr;
;;;417    }
0000ee  69a8              LDR      r0,[r5,#0x18]
0000f0  fa50f084          UXTAB    r0,r0,r4
0000f4  f8551026          LDR      r1,[r5,r6,LSL #2]     ;404
                  |L3.248|
0000f8  e9cd1000          STRD     r1,r0,[sp,#0]         ;404
                  |L3.252|
0000fc  0520              LSLS     r0,r4,#20             ;405
0000fe  d5bc              BPL      |L3.122|
000100  e7b9              B        |L3.118|
                  |L3.258|
000102  a044              ADR      r0,|L3.532|
                  |L3.260|
000104  f7fffffe          BL       __2printf
                  |L3.264|
000108  e7fe              B        |L3.264|
;;;418    
                          ENDP

00010a  0000              DCW      0x0000
                  |L3.268|
00010c  48617264          DCB      "HardFault @ 0x%08x\n",0
000110  4661756c
000114  74204020
000118  30782530
00011c  38780a00
                  |L3.288|
000120  48617264          DCB      "HardFault Analysis:\n",0
000124  4661756c
000128  7420416e
00012c  616c7973
000130  69733a0a
000134  00      
000135  00                DCB      0
000136  00                DCB      0
000137  00                DCB      0
                  |L3.312|
000138  496e7374          DCB      "Instruction code = %x\n",0
00013c  72756374
000140  696f6e20
000144  636f6465
000148  203d2025
00014c  780a00  
00014f  00                DCB      0
                  |L3.336|
000150  4c44522f          DCB      "LDR/STR rt=%x rm=%x rn=%x\n",0
000154  53545220
000158  72743d25
00015c  7820726d
000160  3d257820
000164  726e3d25
000168  780a00  
00016b  00                DCB      0
                  |L3.364|
00016c  45786563          DCB      "Execute BKPT without ICE connected\n",0
000170  75746520
000174  424b5054
000178  20776974
00017c  686f7574
000180  20494345
000184  20636f6e
000188  6e656374
00018c  65640a00
                  |L3.400|
000190  4c445200          DCB      "LDR",0
                  |L3.404|
000194  53545200          DCB      "STR",0
                  |L3.408|
000198  5b307825          DCB      "[0x%08x] 0x%04x %s 0x%x [0x%x]\n",0
00019c  3038785d
0001a0  20307825
0001a4  30347820
0001a8  25732030
0001ac  78257820
0001b0  5b307825
0001b4  785d0a00
                  |L3.440|
0001b8  4c44522f          DCB      "LDR/STR rt=%x rn=%x imm5=%x\n",0
0001bc  53545220
0001c0  72743d25
0001c4  7820726e
0001c8  3d257820
0001cc  696d6d35
0001d0  3d25780a
0001d4  00      
0001d5  00                DCB      0
0001d6  00                DCB      0
0001d7  00                DCB      0
                  |L3.472|
0001d8  4c445248          DCB      "LDRH/STRH rt=%x rn=%x imm5=%x\n",0
0001dc  2f535452
0001e0  48207274
0001e4  3d257820
0001e8  726e3d25
0001ec  7820696d
0001f0  6d353d25
0001f4  780a00  
0001f7  00                DCB      0
                  |L3.504|
0001f8  4c445248          DCB      "LDRH/STRH rt=%x imm8=%x\n",0
0001fc  2f535452
000200  48207274
000204  3d257820
000208  696d6d38
00020c  3d25780a
000210  00      
000211  00                DCB      0
000212  00                DCB      0
000213  00                DCB      0
                  |L3.532|
000214  556e6578          DCB      "Unexpected instruction\n",0
000218  70656374
00021c  65642069
000220  6e737472
000224  75637469
000228  6f6e0a00

                          AREA ||i.SH_Return||, CODE, READONLY, ALIGN=1

                  SH_Return PROC
;;;418    
;;;419    int32_t SH_Return(int32_t n32In_R0, int32_t n32In_R1, int32_t *pn32Out_R0)
000000  2000              MOVS     r0,#0
;;;420    {
;;;421        return 0;
;;;422    }
000002  4770              BX       lr
;;;423    
                          ENDP


                          AREA ||i.SendChar||, CODE, READONLY, ALIGN=1

                  SendChar PROC
;;;514     */
;;;515    void SendChar(int ch)
000000  f7ffbffe          B.W      SendChar_ToUART
;;;516    {
;;;517    #if defined(DEBUG_ENABLE_SEMIHOST)
;;;518        g_buf[g_buf_len++] = ch;
;;;519        g_buf[g_buf_len] = '\0';
;;;520        if(g_buf_len + 1 >= sizeof(g_buf) || ch == '\n' || ch == '\0')
;;;521        {
;;;522            /* Send the char */
;;;523            if(g_ICE_Conneced)
;;;524            {
;;;525                if(SH_DoCommand(0x04, (int)g_buf, NULL) != 0)
;;;526                {
;;;527                    g_buf_len = 0;
;;;528                    return;
;;;529                }
;;;530            }
;;;531            else
;;;532            {
;;;533    # if (DEBUG_ENABLE_SEMIHOST == 2) // Re-direct to UART Debug Port only when DEBUG_ENABLE_SEMIHOST=2
;;;534                int i;
;;;535                for(i = 0; i < g_buf_len; i++)
;;;536                    SendChar_ToUART(g_buf[i]);
;;;537                g_buf_len = 0;
;;;538    # endif
;;;539            }
;;;540        }
;;;541    #else
;;;542    
;;;543    #ifndef DISABLE_UART
;;;544        SendChar_ToUART(ch);
;;;545    #endif
;;;546    
;;;547    #endif
;;;548    }
;;;549    
                          ENDP


                          AREA ||i.SendChar_ToUART||, CODE, READONLY, ALIGN=2

                  SendChar_ToUART PROC
;;;437    #ifndef NONBLOCK_PRINTF
;;;438    void SendChar_ToUART(int ch)
000000  4906              LDR      r1,|L6.28|
                  |L6.2|
;;;439    {
;;;440        while(DEBUG_PORT->FIFOSTS & UART_FIFOSTS_TXFULL_Msk);
000002  698a              LDR      r2,[r1,#0x18]
000004  0212              LSLS     r2,r2,#8
000006  d4fc              BMI      |L6.2|
;;;441    
;;;442        if(ch == '\n')
000008  280a              CMP      r0,#0xa
00000a  d104              BNE      |L6.22|
;;;443        {
;;;444            DEBUG_PORT->DAT = '\r';
00000c  220d              MOVS     r2,#0xd
00000e  600a              STR      r2,[r1,#0]
                  |L6.16|
;;;445            while(DEBUG_PORT->FIFOSTS & UART_FIFOSTS_TXFULL_Msk);
000010  698a              LDR      r2,[r1,#0x18]
000012  0212              LSLS     r2,r2,#8
000014  d4fc              BMI      |L6.16|
                  |L6.22|
;;;446        }
;;;447        DEBUG_PORT->DAT = ch;
000016  6008              STR      r0,[r1,#0]
;;;448    }
000018  4770              BX       lr
;;;449    #else
                          ENDP

00001a  0000              DCW      0x0000
                  |L6.28|
                          DCD      0x40070000

                          AREA ||i._ttywrch||, CODE, READONLY, ALIGN=1

                  _ttywrch PROC
;;;659    
;;;660    void _ttywrch(int ch)
000000  f7ffbffe          B.W      SendChar_ToUART
;;;661    {
;;;662        SendChar(ch);
;;;663        return;
;;;664    }
;;;665    
                          ENDP


                          AREA ||i.ferror||, CODE, READONLY, ALIGN=1

                  ferror PROC
;;;793    
;;;794    int ferror(FILE *stream)
000000  f04f30ff          MOV      r0,#0xffffffff
;;;795    {
;;;796        (void)stream;
;;;797        return EOF;
;;;798    }
000004  4770              BX       lr
;;;799    
                          ENDP


                          AREA ||i.fgetc||, CODE, READONLY, ALIGN=1

                  fgetc PROC
;;;772    
;;;773    int fgetc(FILE *stream)
000000  f7ffbffe          B.W      GetChar
;;;774    {
;;;775        (void)stream;
;;;776        return ((int)GetChar());
;;;777    }
;;;778    
                          ENDP


                          AREA ||i.fputc||, CODE, READONLY, ALIGN=1

                  fputc PROC
;;;684    
;;;685    int fputc(int ch, FILE *stream)
000000  b500              PUSH     {lr}
;;;686    {
000002  4603              MOV      r3,r0
000004  f7fffffe          BL       SendChar_ToUART
;;;687        (void)stream;
;;;688        SendChar(ch);
;;;689        return ch;
000008  4618              MOV      r0,r3
;;;690    }
00000a  bd00              POP      {pc}
;;;691    
                          ENDP


                          AREA ||i.kbhit||, CODE, READONLY, ALIGN=2

                  kbhit PROC
;;;621    
;;;622    int kbhit(void)
000000  4802              LDR      r0,|L11.12|
;;;623    {
;;;624    #ifndef DISABLE_UART
;;;625        return !((DEBUG_PORT->FIFOSTS & UART_FIFOSTS_RXEMPTY_Msk) == 0);
000002  6980              LDR      r0,[r0,#0x18]
000004  f3c03080          UBFX     r0,r0,#14,#1
;;;626    #else
;;;627        return 1;
;;;628    #endif
;;;629    }
000008  4770              BX       lr
;;;630    /**
                          ENDP

00000a  0000              DCW      0x0000
                  |L11.12|
                          DCD      0x40070000

                          AREA ||.data||, DATA, ALIGN=2

                  __stdout
                          DCD      0x00000000

                          AREA ||area_number.15||, DATA, ALIGN=2

                          EXPORTAS ||area_number.15||, ||.data||
                  __stdin
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\..\\Library\\StdDriver\\src\\retarget.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___10_retarget_c_93c3b281____REV16|
#line 464 "..\\..\\..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___10_retarget_c_93c3b281____REV16| PROC
#line 465

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___10_retarget_c_93c3b281____REVSH|
#line 479
|__asm___10_retarget_c_93c3b281____REVSH| PROC
#line 480

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___10_retarget_c_93c3b281____RRX|
#line 666
|__asm___10_retarget_c_93c3b281____RRX| PROC
#line 667

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
