; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\obj\thermostat.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\thermostat.d --cpu=Cortex-M4.fp --apcs=interwork -O3 --diag_suppress=9931 -I..\..\..\..\Library\Device\Nuvoton\M480\Include -I..\..\..\..\Library\StdDriver\inc -I..\..\..\..\ThirdParty\emWin\Config -I..\..\..\..\ThirdParty\emWin\Include -I..\tslib -I..\..\..\..\Library\CMSIS\Include -I..\Thermostat -I..\Application\Source\Generated -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=523 --omf_browse=.\obj\thermostat.crf ..\Thermostat\thermostat.c]
                          THUMB

                          AREA ||i.APPW_X_FS_Init||, CODE, READONLY, ALIGN=1

                  APPW_X_FS_Init PROC
;;;244    */
;;;245    void APPW_X_FS_Init(void)
000000  4770              BX       lr
;;;246    {
;;;247        /* TODO */
;;;248        ;
;;;249    }
;;;250    
                          ENDP


                          AREA ||i.DataFlashRead||, CODE, READONLY, ALIGN=1

                  DataFlashRead PROC
;;;49      *----------------------------------------------------------------------------*/
;;;50     uint8_t DataFlashRead (FMC_CTRL_STRC *Ctrl) {
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
;;;51       uint32_t   u32DataFlashBase = NULL;
;;;52       uint32_t   *DataPtr;	
;;;53       uint32_t   i;
;;;54     
;;;55       DataPtr = (uint32_t *)Ctrl->FlashDataPtr;
;;;56     
;;;57       SYS_UnlockReg();
000004  6885              LDR      r5,[r0,#8]
000006  f7fffffe          BL       SYS_UnlockReg
;;;58       FMC_Open();
00000a  f7fffffe          BL       FMC_Open
;;;59       
;;;60       /* Read Data Flash base address */
;;;61       u32DataFlashBase = FMC_ReadDataFlashBaseAddr();
00000e  f7fffffe          BL       FMC_ReadDataFlashBaseAddr
;;;62     
;;;63       FMC_STATE_MSG("FLASH DATA Base Address: %x\n", u32DataFlashBase);
;;;64     
;;;65       //Build-in 40KB flash ROM
;;;66       if (u32DataFlashBase == NULL || u32DataFlashBase >= 0x0A000) {
000012  b110              CBZ      r0,|L2.26|
000014  f5b04f20          CMP      r0,#0xa000
000018  d305              BCC      |L2.38|
                  |L2.26|
;;;67           //Data flash was no longer available, restore default setting
;;;68           Ctrl->FlashDataPtr->NvramBrightness = 0xFFFFFFFF;
00001a  68a1              LDR      r1,[r4,#8]
00001c  f04f30ff          MOV      r0,#0xffffffff
;;;69           return FALSE;
000020  6008              STR      r0,[r1,#0]
000022  2000              MOVS     r0,#0
;;;70       }
;;;71     
;;;72       for (i=u32DataFlashBase; \
;;;73            i<(u32DataFlashBase + sizeof(FLASH_DATA_STRC)); \
;;;74            i+=4, DataPtr++) {
;;;75     
;;;76            *DataPtr = FMC_Read(i);
;;;77     	   
;;;78     	   FMC_STATE_MSG("OFFSET: %x DATA: %x \n", i, *DataPtr);
;;;79       }
;;;80     
;;;81       FMC_Close();
;;;82       SYS_LockReg();
;;;83       
;;;84       return TRUE;
;;;85     }
000024  bd70              POP      {r4-r6,pc}
                  |L2.38|
000026  4604              MOV      r4,r0                 ;72
000028  1d06              ADDS     r6,r0,#4              ;73
00002a  e004              B        |L2.54|
                  |L2.44|
00002c  4620              MOV      r0,r4                 ;76
00002e  f7fffffe          BL       FMC_Read
000032  c501              STM      r5!,{r0}              ;76
000034  1d24              ADDS     r4,r4,#4              ;76
                  |L2.54|
000036  42b4              CMP      r4,r6                 ;73
000038  d3f8              BCC      |L2.44|
00003a  f7fffffe          BL       FMC_Close
00003e  f04f4180          MOV      r1,#0x40000000        ;81
000042  2000              MOVS     r0,#0                 ;81
000044  f8c10100          STR      r0,[r1,#0x100]        ;81
000048  2001              MOVS     r0,#1                 ;84
00004a  bd70              POP      {r4-r6,pc}
;;;86     
                          ENDP


                          AREA ||i.DataFlashWrite||, CODE, READONLY, ALIGN=1

                  DataFlashWrite PROC
;;;93      *----------------------------------------------------------------------------*/
;;;94     void DataFlashWrite (FMC_CTRL_STRC *Ctrl) {
000000  b570              PUSH     {r4-r6,lr}
;;;95       uint32_t   u32DataFlashBase;
;;;96       uint32_t   *DataPtr;  
;;;97       uint32_t   i;
;;;98     
;;;99       DataPtr = (uint32_t *)Ctrl->FlashDataPtr;
;;;100    
;;;101      SYS_UnlockReg();
000002  6885              LDR      r5,[r0,#8]
000004  f7fffffe          BL       SYS_UnlockReg
;;;102      FMC_Open();
000008  f7fffffe          BL       FMC_Open
;;;103    
;;;104      /* Read Data Flash base address */
;;;105      u32DataFlashBase = FMC_ReadDataFlashBaseAddr();
00000c  f7fffffe          BL       FMC_ReadDataFlashBaseAddr
000010  0004              MOVS     r4,r0
;;;106    
;;;107      FMC_STATE_MSG("DataFlashWrite - Base Addr: %x\n", u32DataFlashBase);
;;;108      
;;;109      //Data flash was no longer available
;;;110      if (u32DataFlashBase == NULL || u32DataFlashBase >= 0x0A000)
000012  d00f              BEQ      |L3.52|
000014  f5b44f20          CMP      r4,#0xa000
000018  d20c              BCS      |L3.52|
;;;111          return;
;;;112    
;;;113      FMC_Erase(u32DataFlashBase);
00001a  f7fffffe          BL       FMC_Erase
;;;114    
;;;115      for (i=0; i<sizeof(FLASH_DATA_STRC) / sizeof(uint32_t); i++) {
;;;116    	   FMC_Write(u32DataFlashBase + i*4, DataPtr[i]);
00001e  4620              MOV      r0,r4
000020  6829              LDR      r1,[r5,#0]
000022  f7fffffe          BL       FMC_Write
;;;117      }
;;;118    
;;;119      FMC_Close();
000026  f7fffffe          BL       FMC_Close
00002a  f04f4180          MOV      r1,#0x40000000
00002e  2000              MOVS     r0,#0
000030  f8c10100          STR      r0,[r1,#0x100]
                  |L3.52|
;;;120      SYS_LockReg();
;;;121    
;;;122      return;
;;;123    }
000034  bd70              POP      {r4-r6,pc}
;;;124    
                          ENDP


                          AREA ||i.EepromReadStateCtrl||, CODE, READONLY, ALIGN=2

                  EepromReadStateCtrl PROC
;;;701     *----------------------------------------------------------------------------*/
;;;702    void EepromReadStateCtrl (EEPROM_READ_CTRL_STRC *Ctrl) {
000000  b510              PUSH     {r4,lr}
;;;703    
;;;704      switch(Ctrl->Read_State) {
000002  7843              LDRB     r3,[r0,#1]
000004  2101              MOVS     r1,#1
000006  b193              CBZ      r3,|L4.46|
000008  2200              MOVS     r2,#0                 ;702
00000a  2b01              CMP      r3,#1
00000c  d026              BEQ      |L4.92|
00000e  2b02              CMP      r3,#2
000010  d00f              BEQ      |L4.50|
000012  2b03              CMP      r3,#3
000014  d10c              BNE      |L4.48|
;;;705             case INIT_STATE:
;;;706                  Ctrl->ThermostatDataPtr = ThermostatDataPtr;
;;;707                  Ctrl->TimerPtr          = TimerCtrlPtr;
;;;708                  Ctrl->DevAddr           = &g_u8DeviceAddr;
;;;709                  Ctrl->TxDataBuff        = g_au8TxData;
;;;710                  Ctrl->RxData            = &g_u8RxData;
;;;711                  Ctrl->DataLen           = &g_u8DataLen;
;;;712                  Ctrl->DataReady         = &g_u8EndFlag;
;;;713                  Ctrl->ctx               = &I2C2_Ctx;
;;;714                  Ctrl->Offset            = 0xC0;
;;;715                  Ctrl->Read_State        = WAIT_CMD_STATE;
;;;716                  Ctrl->Valid             = FALSE;
;;;717                  break;
;;;718             case CHANGE_STATE:
;;;719                  Ctrl->Read_State = WAIT_CMD_STATE;
;;;720                  break;
;;;721             case HOLD_STATE:
;;;722                  // to execute EEPROM read per 5ms
;;;723                  if (Ctrl->TimerPtr->EEPROM_READ_TIMER >= 10 && \
000016  6a43              LDR      r3,[r0,#0x24]
000018  695b              LDR      r3,[r3,#0x14]
00001a  2b0a              CMP      r3,#0xa
00001c  d308              BCC      |L4.48|
;;;724                      *Ctrl->DataReady == TRUE) {
00001e  6983              LDR      r3,[r0,#0x18]
000020  781c              LDRB     r4,[r3,#0]
000022  2c01              CMP      r4,#1
000024  d104              BNE      |L4.48|
;;;725                      EEPROM_READ_STATE_MSG("R - DATA: 0x%x\n", *Ctrl->RxData);
;;;726                      Ctrl->Offset++;
000026  6844              LDR      r4,[r0,#4]
000028  1c64              ADDS     r4,r4,#1
;;;727                      *Ctrl->DataReady = FALSE;
00002a  6044              STR      r4,[r0,#4]
00002c  701a              STRB     r2,[r3,#0]
                  |L4.46|
00002e  7041              STRB     r1,[r0,#1]            ;719
                  |L4.48|
;;;728                      Ctrl->Read_State = WAIT_CMD_STATE;
;;;729                  }
;;;730                  break;
;;;731             case WAIT_CMD_STATE:
;;;732                  if (Ctrl->Valid) {
;;;733                      Ctrl->Read_State = HOLD_STATE;
;;;734                      Ctrl->TimerPtr->EEPROM_READ_TIMER = 0;
;;;735                      Ctrl->Valid = FALSE;
;;;736                  }
;;;737                  break;
;;;738             default:
;;;739                  break;
;;;740      }
;;;741    
;;;742      return;
;;;743    }
000030  bd10              POP      {r4,pc}
                  |L4.50|
000032  4b0f              LDR      r3,|L4.112|
000034  681c              LDR      r4,[r3,#0]            ;706  ; ThermostatDataPtr
000036  6204              STR      r4,[r0,#0x20]         ;707
000038  689b              LDR      r3,[r3,#8]            ;707  ; TimerCtrlPtr
00003a  6243              STR      r3,[r0,#0x24]         ;708
00003c  4b0d              LDR      r3,|L4.116|
00003e  6083              STR      r3,[r0,#8]            ;709
000040  4b0d              LDR      r3,|L4.120|
000042  60c3              STR      r3,[r0,#0xc]          ;710
000044  4b0d              LDR      r3,|L4.124|
000046  6103              STR      r3,[r0,#0x10]         ;711
000048  4b0d              LDR      r3,|L4.128|
00004a  6143              STR      r3,[r0,#0x14]         ;712
00004c  4b0d              LDR      r3,|L4.132|
00004e  6183              STR      r3,[r0,#0x18]         ;713
000050  4b0d              LDR      r3,|L4.136|
000052  61c3              STR      r3,[r0,#0x1c]         ;714
000054  23c0              MOVS     r3,#0xc0              ;714
000056  6043              STR      r3,[r0,#4]            ;715
000058  7041              STRB     r1,[r0,#1]            ;715
00005a  e006              B        |L4.106|
                  |L4.92|
00005c  7801              LDRB     r1,[r0,#0]            ;732
00005e  2900              CMP      r1,#0                 ;732
000060  d0e6              BEQ      |L4.48|
000062  2103              MOVS     r1,#3                 ;733
000064  7041              STRB     r1,[r0,#1]            ;733
000066  6a41              LDR      r1,[r0,#0x24]         ;734
000068  614a              STR      r2,[r1,#0x14]         ;734
                  |L4.106|
00006a  7002              STRB     r2,[r0,#0]            ;716
00006c  bd10              POP      {r4,pc}
;;;744    
                          ENDP

00006e  0000              DCW      0x0000
                  |L4.112|
                          DCD      ||.data||
                  |L4.116|
                          DCD      g_u8DeviceAddr
                  |L4.120|
                          DCD      g_au8TxData
                  |L4.124|
                          DCD      g_u8RxData
                  |L4.128|
                          DCD      g_u8DataLen
                  |L4.132|
                          DCD      g_u8EndFlag
                  |L4.136|
                          DCD      I2C2_Ctx

                          AREA ||i.EepromReadStateInit||, CODE, READONLY, ALIGN=1

                  EepromReadStateInit PROC
;;;666     *----------------------------------------------------------------------------*/
;;;667    void EepromReadStateInit (EEPROM_READ_CTRL_STRC *Ctrl) {
000000  2102              MOVS     r1,#2
;;;668    
;;;669      Ctrl->Read_State = INIT_STATE;
000002  7041              STRB     r1,[r0,#1]
;;;670    
;;;671      EEPROM_READ_STATE_MSG("EepromReadStateInit\n");
;;;672    
;;;673      return;
;;;674    }
000004  4770              BX       lr
;;;675    
                          ENDP


                          AREA ||i.EepromReadStateTask||, CODE, READONLY, ALIGN=1

                  EepromReadStateTask PROC
;;;678     *----------------------------------------------------------------------------*/
;;;679    void EepromReadStateTask (EEPROM_READ_CTRL_STRC *Ctrl) {
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
;;;680      
;;;681      if (Ctrl->Read_State == INIT_STATE   || \
000004  7840              LDRB     r0,[r0,#1]
000006  2802              CMP      r0,#2
000008  d014              BEQ      |L6.52|
;;;682          Ctrl->Read_State == CHANGE_STATE || \
00000a  2800              CMP      r0,#0
00000c  d012              BEQ      |L6.52|
;;;683      	  Ctrl->Read_State == HOLD_STATE   || \
00000e  2803              CMP      r0,#3
000010  d010              BEQ      |L6.52|
;;;684          Ctrl->Valid                      || \
000012  7820              LDRB     r0,[r4,#0]
000014  2800              CMP      r0,#0
000016  d10d              BNE      |L6.52|
;;;685          Ctrl->ThermostatDataPtr->MISC.EEPROM_WRITE_DONE == FALSE) {
000018  6a20              LDR      r0,[r4,#0x20]
00001a  7a00              LDRB     r0,[r0,#8]
00001c  0640              LSLS     r0,r0,#25
00001e  d509              BPL      |L6.52|
;;;686          return;
;;;687      }
;;;688     
;;;689      if (Ctrl->Offset < (64 * 1024)) {
000020  6860              LDR      r0,[r4,#4]
000022  f5b03f80          CMP      r0,#0x10000
000026  d205              BCS      |L6.52|
;;;690      //if (Ctrl->Offset < (512)) {
;;;691          RwEepromDataByte (Ctrl->Offset, 0, TRUE);
000028  2201              MOVS     r2,#1
00002a  2100              MOVS     r1,#0
00002c  f7fffffe          BL       RwEepromDataByte
;;;692          Ctrl->Valid = TRUE;
000030  2001              MOVS     r0,#1
000032  7020              STRB     r0,[r4,#0]
                  |L6.52|
;;;693          EEPROM_READ_STATE_MSG("Eeprom Read Start, Offset: 0x%x\n", Ctrl->Offset);
;;;694      }
;;;695    
;;;696      return;
;;;697    }
000034  bd10              POP      {r4,pc}
;;;698    
                          ENDP


                          AREA ||i.EepromWriteStateCtrl||, CODE, READONLY, ALIGN=2

                  EepromWriteStateCtrl PROC
;;;780     *----------------------------------------------------------------------------*/
;;;781    void EepromWriteStateCtrl (EEPROM_WRITE_CTRL_STRC *Ctrl) {
000000  b510              PUSH     {r4,lr}
;;;782    
;;;783      switch(Ctrl->Write_State) {
000002  7842              LDRB     r2,[r0,#1]
000004  2301              MOVS     r3,#1
000006  b192              CBZ      r2,|L7.46|
000008  2100              MOVS     r1,#0                 ;781
00000a  2a01              CMP      r2,#1
00000c  d029              BEQ      |L7.98|
00000e  2a02              CMP      r2,#2
000010  d00f              BEQ      |L7.50|
000012  2a03              CMP      r2,#3
000014  d10c              BNE      |L7.48|
;;;784             case INIT_STATE:
;;;785                  Ctrl->ThermostatDataPtr = ThermostatDataPtr;
;;;786                  Ctrl->TimerPtr          = TimerCtrlPtr;
;;;787                  Ctrl->Dummy             = 0;
;;;788                  Ctrl->DevAddr           = &g_u8DeviceAddr;
;;;789                  Ctrl->TxDataBuff        = g_au8TxData;
;;;790                  Ctrl->RxData            = &g_u8RxData;
;;;791                  Ctrl->DataLen           = &g_u8DataLen;
;;;792                  Ctrl->DataReady         = &g_u8EndFlag;
;;;793                  Ctrl->Offset            = 0;
;;;794                  Ctrl->Write_State       = WAIT_CMD_STATE;
;;;795                  Ctrl->Valid             = FALSE;
;;;796                  Ctrl->ThermostatDataPtr->MISC.EEPROM_WRITE_DONE = FALSE;
;;;797                  break;
;;;798             case CHANGE_STATE:
;;;799                  Ctrl->Write_State = WAIT_CMD_STATE;
;;;800                  break;
;;;801             case HOLD_STATE:
;;;802                  // to execute EEPROM read per 5ms
;;;803                  if (Ctrl->TimerPtr->EEPROM_WRITE_TIMER >= 1 && \
000016  6a42              LDR      r2,[r0,#0x24]
000018  6992              LDR      r2,[r2,#0x18]
00001a  2a00              CMP      r2,#0
00001c  d008              BEQ      |L7.48|
;;;804                      *Ctrl->DataReady == TRUE) {
00001e  69c2              LDR      r2,[r0,#0x1c]
000020  7814              LDRB     r4,[r2,#0]
000022  2c01              CMP      r4,#1
000024  d104              BNE      |L7.48|
;;;805                      EEPROM_WRITE_STATE_MSG("W - Offset(0x%x): 0x%x\n", Ctrl->Offset, Ctrl->Dummy);
;;;806                      Ctrl->Offset++;
000026  6844              LDR      r4,[r0,#4]
000028  1c64              ADDS     r4,r4,#1
;;;807                      *Ctrl->DataReady = FALSE;
00002a  6044              STR      r4,[r0,#4]
00002c  7011              STRB     r1,[r2,#0]
                  |L7.46|
00002e  7043              STRB     r3,[r0,#1]            ;799
                  |L7.48|
;;;808                      Ctrl->Write_State = WAIT_CMD_STATE;
;;;809                  }
;;;810                  break;
;;;811             case WAIT_CMD_STATE:
;;;812                  if (Ctrl->Valid) {
;;;813                      Ctrl->Write_State = HOLD_STATE;
;;;814                      Ctrl->TimerPtr->EEPROM_WRITE_TIMER = 0;
;;;815                      Ctrl->Valid = FALSE;
;;;816                  }
;;;817                  break;
;;;818             default:
;;;819                  break;
;;;820      }
;;;821      
;;;822      return;
;;;823    }
000030  bd10              POP      {r4,pc}
                  |L7.50|
000032  4c10              LDR      r4,|L7.116|
000034  6822              LDR      r2,[r4,#0]            ;785  ; ThermostatDataPtr
000036  6202              STR      r2,[r0,#0x20]         ;786
000038  68a4              LDR      r4,[r4,#8]            ;786  ; TimerCtrlPtr
00003a  6244              STR      r4,[r0,#0x24]         ;787
00003c  7201              STRB     r1,[r0,#8]            ;787
00003e  4c0e              LDR      r4,|L7.120|
000040  60c4              STR      r4,[r0,#0xc]          ;789
000042  4c0e              LDR      r4,|L7.124|
000044  6104              STR      r4,[r0,#0x10]         ;790
000046  4c0e              LDR      r4,|L7.128|
000048  6144              STR      r4,[r0,#0x14]         ;791
00004a  4c0e              LDR      r4,|L7.132|
00004c  6184              STR      r4,[r0,#0x18]         ;792
00004e  4c0e              LDR      r4,|L7.136|
000050  61c4              STR      r4,[r0,#0x1c]         ;794
000052  6041              STR      r1,[r0,#4]            ;794
000054  7043              STRB     r3,[r0,#1]            ;794
000056  7001              STRB     r1,[r0,#0]            ;795
000058  6890              LDR      r0,[r2,#8]            ;796
00005a  f0200040          BIC      r0,r0,#0x40           ;796
00005e  6090              STR      r0,[r2,#8]            ;797
                  |L7.96|
000060  bd10              POP      {r4,pc}
                  |L7.98|
000062  7802              LDRB     r2,[r0,#0]            ;812
000064  2a00              CMP      r2,#0                 ;812
000066  d0fb              BEQ      |L7.96|
000068  2203              MOVS     r2,#3                 ;813
00006a  7042              STRB     r2,[r0,#1]            ;813
00006c  6a42              LDR      r2,[r0,#0x24]         ;814
00006e  6191              STR      r1,[r2,#0x18]         ;815
000070  7001              STRB     r1,[r0,#0]            ;815
000072  bd10              POP      {r4,pc}
;;;824    
                          ENDP

                  |L7.116|
                          DCD      ||.data||
                  |L7.120|
                          DCD      g_u8DeviceAddr
                  |L7.124|
                          DCD      g_au8TxData
                  |L7.128|
                          DCD      g_u8RxData
                  |L7.132|
                          DCD      g_u8DataLen
                  |L7.136|
                          DCD      g_u8EndFlag

                          AREA ||i.EepromWriteStateInit||, CODE, READONLY, ALIGN=1

                  EepromWriteStateInit PROC
;;;747     *----------------------------------------------------------------------------*/
;;;748    void EepromWriteStateInit (EEPROM_WRITE_CTRL_STRC *Ctrl) {
000000  2102              MOVS     r1,#2
;;;749    
;;;750      Ctrl->Write_State = INIT_STATE;
000002  7041              STRB     r1,[r0,#1]
;;;751    
;;;752      return;
;;;753    }
000004  4770              BX       lr
;;;754    
                          ENDP


                          AREA ||i.EepromWriteStateTask||, CODE, READONLY, ALIGN=1

                  EepromWriteStateTask PROC
;;;757     *----------------------------------------------------------------------------*/
;;;758    void EepromWriteStateTask (EEPROM_WRITE_CTRL_STRC *Ctrl) {
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
;;;759      
;;;760      if (Ctrl->Write_State == INIT_STATE   || \
000004  7840              LDRB     r0,[r0,#1]
000006  2802              CMP      r0,#2
000008  d012              BEQ      |L9.48|
;;;761          Ctrl->Write_State == CHANGE_STATE || \
00000a  2800              CMP      r0,#0
00000c  d010              BEQ      |L9.48|
;;;762      	  Ctrl->Write_State == HOLD_STATE   || \
00000e  2803              CMP      r0,#3
000010  d00e              BEQ      |L9.48|
;;;763          Ctrl->Valid) {
000012  7820              LDRB     r0,[r4,#0]
000014  2800              CMP      r0,#0
000016  d10b              BNE      |L9.48|
;;;764          return;
;;;765      }
;;;766     
;;;767      if (Ctrl->Offset < (1024)) {
000018  6860              LDR      r0,[r4,#4]
00001a  f5b06f80          CMP      r0,#0x400
00001e  d208              BCS      |L9.50|
;;;768          RwEepromDataByte (Ctrl->Offset, Ctrl->Dummy++, FALSE);
000020  7a21              LDRB     r1,[r4,#8]
000022  1c4a              ADDS     r2,r1,#1
000024  7222              STRB     r2,[r4,#8]
000026  2200              MOVS     r2,#0
000028  f7fffffe          BL       RwEepromDataByte
;;;769          EEPROM_WRITE_STATE_MSG("Eeprom WRITE Start, Offset: 0x%x\n", Ctrl->Offset);
;;;770          Ctrl->Valid = TRUE;
00002c  2001              MOVS     r0,#1
00002e  7020              STRB     r0,[r4,#0]
                  |L9.48|
;;;771      } else {
;;;772          Ctrl->ThermostatDataPtr->MISC.EEPROM_WRITE_DONE = TRUE;
;;;773      }
;;;774    
;;;775      return;
;;;776    }
000030  bd10              POP      {r4,pc}
                  |L9.50|
000032  6a20              LDR      r0,[r4,#0x20]         ;772
000034  6881              LDR      r1,[r0,#8]            ;772
000036  f0410140          ORR      r1,r1,#0x40           ;772
00003a  6081              STR      r1,[r0,#8]            ;772
00003c  bd10              POP      {r4,pc}
;;;777    
                          ENDP


                          AREA ||i.FlashDataToVariable||, CODE, READONLY, ALIGN=1

                  FlashDataToVariable PROC
;;;127     *----------------------------------------------------------------------------*/
;;;128    void FlashDataToVariable (FMC_CTRL_STRC *Ctrl) {
000000  6881              LDR      r1,[r0,#8]
;;;129    
;;;130      if (Ctrl->FlashDataPtr->NvramBrightness == 0xffffffff) {
;;;131          Ctrl->ThermostatDataPtr->Brightness = DEFAULT_BRIGHTNESS;
000002  6840              LDR      r0,[r0,#4]
000004  6809              LDR      r1,[r1,#0]            ;130
000006  1c4a              ADDS     r2,r1,#1              ;130
000008  d100              BNE      |L10.12|
00000a  2150              MOVS     r1,#0x50
                  |L10.12|
;;;132      } else {
;;;133          Ctrl->ThermostatDataPtr->Brightness = Ctrl->FlashDataPtr->NvramBrightness;
00000c  6001              STR      r1,[r0,#0]
;;;134      }
;;;135      
;;;136      FMC_STATE_MSG("FlashDataToVariable - Brightness: %d\n", \
;;;137                    Ctrl->ThermostatDataPtr->Brightness);
;;;138    
;;;139      return;
;;;140    }
00000e  4770              BX       lr
;;;141    
                          ENDP


                          AREA ||i.FmcStateCtrl||, CODE, READONLY, ALIGN=2

                  FmcStateCtrl PROC
;;;197     *----------------------------------------------------------------------------*/
;;;198    void FmcStateCtrl (FMC_CTRL_STRC *Ctrl) {
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
;;;199      
;;;200      switch(Ctrl->Fmc_State) {
000004  7841              LDRB     r1,[r0,#1]
000006  2001              MOVS     r0,#1
000008  b1d1              CBZ      r1,|L11.64|
00000a  2500              MOVS     r5,#0                 ;198
00000c  2901              CMP      r1,#1
00000e  d01f              BEQ      |L11.80|
000010  2902              CMP      r1,#2
000012  d002              BEQ      |L11.26|
000014  2903              CMP      r1,#3
000016  d11a              BNE      |L11.78|
000018  e018              B        |L11.76|
                  |L11.26|
;;;201             case INIT_STATE:
;;;202                  Ctrl->ThermostatDataPtr = ThermostatDataPtr;
00001a  4918              LDR      r1,|L11.124|
00001c  680a              LDR      r2,[r1,#0]  ; ThermostatDataPtr
;;;203                  Ctrl->FlashDataPtr      = FlashDataPtr;
00001e  6062              STR      r2,[r4,#4]
000020  684a              LDR      r2,[r1,#4]  ; FlashDataPtr
;;;204                  Ctrl->TimerPtr          = TimerCtrlPtr;
000022  60a2              STR      r2,[r4,#8]
000024  6889              LDR      r1,[r1,#8]  ; TimerCtrlPtr
;;;205                  Ctrl->Valid             = 0;
000026  60e1              STR      r1,[r4,#0xc]
000028  7025              STRB     r5,[r4,#0]
;;;206                  Ctrl->Fmc_State         = WAIT_CMD_STATE;
00002a  7060              STRB     r0,[r4,#1]
;;;207                  if (DataFlashRead (Ctrl)) {
00002c  4620              MOV      r0,r4
00002e  f7fffffe          BL       DataFlashRead
000032  2800              CMP      r0,#0
000034  d00b              BEQ      |L11.78|
;;;208                      FlashDataToVariable(Ctrl);
000036  4620              MOV      r0,r4
000038  e8bd4070          POP      {r4-r6,lr}
00003c  f7ffbffe          B.W      FlashDataToVariable
                  |L11.64|
;;;209                  }
;;;210                  break;
;;;211             case CHANGE_STATE:
;;;212                  if (Ctrl->TimerPtr->FMC_STATE_TIMER >= 30000) {
000040  68e1              LDR      r1,[r4,#0xc]
000042  f2475230          MOV      r2,#0x7530
000046  6809              LDR      r1,[r1,#0]
000048  4291              CMP      r1,r2
00004a  d300              BCC      |L11.78|
                  |L11.76|
;;;213                    Ctrl->Fmc_State = WAIT_CMD_STATE;
;;;214                  }
;;;215                  break;
;;;216             case HOLD_STATE:
;;;217                  Ctrl->Fmc_State = WAIT_CMD_STATE;
00004c  7060              STRB     r0,[r4,#1]
                  |L11.78|
;;;218                  break;
;;;219             case WAIT_CMD_STATE:
;;;220                  if (Ctrl->Valid) {
;;;221                      if (UpdateFlashData (Ctrl)) {
;;;222                          VariableToFlashData (Ctrl);
;;;223                          DataFlashWrite (Ctrl);
;;;224                          DataFlashRead (Ctrl);
;;;225                      }
;;;226                      Ctrl->TimerPtr->FMC_STATE_TIMER = 0;
;;;227                      Ctrl->Fmc_State = CHANGE_STATE;
;;;228                      Ctrl->Valid = FALSE;
;;;229                      FMC_STATE_MSG("FmcStateCtrl - Checking Flash Data!\n");
;;;230                  }
;;;231    			  break;
;;;232             default:
;;;233                  break;
;;;234      }
;;;235      
;;;236      return;
;;;237    }
00004e  bd70              POP      {r4-r6,pc}
                  |L11.80|
000050  7820              LDRB     r0,[r4,#0]            ;220
000052  2800              CMP      r0,#0                 ;220
000054  d0fb              BEQ      |L11.78|
000056  4620              MOV      r0,r4                 ;221
000058  f7fffffe          BL       UpdateFlashData
00005c  b148              CBZ      r0,|L11.114|
00005e  6860              LDR      r0,[r4,#4]            ;221
000060  68a1              LDR      r1,[r4,#8]            ;221
000062  6800              LDR      r0,[r0,#0]            ;221
000064  6008              STR      r0,[r1,#0]            ;223
000066  4620              MOV      r0,r4                 ;223
000068  f7fffffe          BL       DataFlashWrite
00006c  4620              MOV      r0,r4                 ;224
00006e  f7fffffe          BL       DataFlashRead
                  |L11.114|
000072  68e0              LDR      r0,[r4,#0xc]          ;226
000074  6005              STR      r5,[r0,#0]            ;227
000076  7065              STRB     r5,[r4,#1]            ;227
000078  7025              STRB     r5,[r4,#0]            ;228
00007a  bd70              POP      {r4-r6,pc}
;;;238    
                          ENDP

                  |L11.124|
                          DCD      ||.data||

                          AREA ||i.FmcStateInit||, CODE, READONLY, ALIGN=1

                  FmcStateInit PROC
;;;172     *----------------------------------------------------------------------------*/
;;;173    void FmcStateInit (FMC_CTRL_STRC *Ctrl) {
000000  2102              MOVS     r1,#2
;;;174      Ctrl->Fmc_State = INIT_STATE;
000002  7041              STRB     r1,[r0,#1]
;;;175      return;
;;;176    }
000004  4770              BX       lr
;;;177    
                          ENDP


                          AREA ||i.FmcStateTask||, CODE, READONLY, ALIGN=1

                  FmcStateTask PROC
;;;180     *----------------------------------------------------------------------------*/
;;;181    void FmcStateTask (FMC_CTRL_STRC *Ctrl) {
000000  7841              LDRB     r1,[r0,#1]
;;;182    
;;;183      if (Ctrl->Fmc_State == INIT_STATE   || \
000002  2902              CMP      r1,#2
000004  d008              BEQ      |L13.24|
;;;184          Ctrl->Fmc_State == CHANGE_STATE || \
000006  2900              CMP      r1,#0
000008  d006              BEQ      |L13.24|
;;;185          Ctrl->Fmc_State == HOLD_STATE   || \
00000a  2903              CMP      r1,#3
00000c  d004              BEQ      |L13.24|
;;;186          Ctrl->Valid) {
00000e  7801              LDRB     r1,[r0,#0]
000010  2900              CMP      r1,#0
000012  d101              BNE      |L13.24|
;;;187          return;
;;;188      }
;;;189    
;;;190      Ctrl->Valid = TRUE;
000014  2101              MOVS     r1,#1
000016  7001              STRB     r1,[r0,#0]
                  |L13.24|
;;;191    
;;;192      return;
;;;193    }
000018  4770              BX       lr
;;;194    
                          ENDP


                          AREA ||i.GuiExecStateCtrl||, CODE, READONLY, ALIGN=2

                  GuiExecStateCtrl PROC
;;;322     *----------------------------------------------------------------------------*/
;;;323    void GuiExecStateCtrl (GUIEXEC_CTRL_STRC *Ctrl) {
000000  7843              LDRB     r3,[r0,#1]
;;;324    
;;;325      switch(Ctrl->Gui_State) {
000002  2101              MOVS     r1,#1
000004  b15b              CBZ      r3,|L14.30|
000006  2200              MOVS     r2,#0                 ;323
000008  2b01              CMP      r3,#1
00000a  d010              BEQ      |L14.46|
00000c  2b02              CMP      r3,#2
00000e  d008              BEQ      |L14.34|
000010  2b03              CMP      r3,#3
000012  d105              BNE      |L14.32|
;;;326             case INIT_STATE:
;;;327                  Ctrl->TimerPtr = TimerCtrlPtr;
;;;328                  Ctrl->GuiRefreshRate = 1;
;;;329                  Ctrl->Gui_State         = WAIT_CMD_STATE;
;;;330                  Ctrl->Valid             = FALSE;
;;;331                  break;
;;;332             case CHANGE_STATE:
;;;333                  Ctrl->Gui_State = WAIT_CMD_STATE;
;;;334                  break;
;;;335             case HOLD_STATE:
;;;336                  // to execute GUI per 5ms
;;;337                  if (Ctrl->TimerPtr->GUI_EXEC_TIMER >= Ctrl->GuiRefreshRate) {
000014  68c2              LDR      r2,[r0,#0xc]
000016  6843              LDR      r3,[r0,#4]
000018  6852              LDR      r2,[r2,#4]
00001a  429a              CMP      r2,r3
00001c  d300              BCC      |L14.32|
                  |L14.30|
00001e  7041              STRB     r1,[r0,#1]            ;333
                  |L14.32|
;;;338                      Ctrl->Gui_State = WAIT_CMD_STATE;
;;;339                      //GUIEXEC_STATE_MSG("GuiExecStateCtrl - to execute GUI per 5ms\n");
;;;340                  }
;;;341                  break;
;;;342             case WAIT_CMD_STATE:
;;;343                  if (Ctrl->Valid) {
;;;344                      Ctrl->Gui_State = HOLD_STATE;
;;;345                      Ctrl->TimerPtr->GUI_EXEC_TIMER = 0;
;;;346                      Ctrl->Valid = FALSE;
;;;347                  }
;;;348                  break;
;;;349             default:
;;;350                  break;		 	
;;;351      }
;;;352      
;;;353      return;
;;;354    }
000020  4770              BX       lr
                  |L14.34|
000022  4b07              LDR      r3,|L14.64|
000024  689b              LDR      r3,[r3,#8]            ;327  ; TimerCtrlPtr
000026  60c3              STR      r3,[r0,#0xc]          ;329
000028  6041              STR      r1,[r0,#4]            ;329
00002a  7041              STRB     r1,[r0,#1]            ;329
00002c  e006              B        |L14.60|
                  |L14.46|
00002e  7801              LDRB     r1,[r0,#0]            ;343
000030  2900              CMP      r1,#0                 ;343
000032  d0f5              BEQ      |L14.32|
000034  2103              MOVS     r1,#3                 ;344
000036  7041              STRB     r1,[r0,#1]            ;344
000038  68c1              LDR      r1,[r0,#0xc]          ;345
00003a  604a              STR      r2,[r1,#4]            ;345
                  |L14.60|
00003c  7002              STRB     r2,[r0,#0]            ;330
00003e  4770              BX       lr
;;;355    
                          ENDP

                  |L14.64|
                          DCD      ||.data||

                          AREA ||i.GuiExecStateInit||, CODE, READONLY, ALIGN=2

                  GuiExecStateInit PROC
;;;253     *----------------------------------------------------------------------------*/
;;;254    void GuiExecStateInit (GUIEXEC_CTRL_STRC *Ctrl) {
000000  b510              PUSH     {r4,lr}
000002  b090              SUB      sp,sp,#0x40
000004  4604              MOV      r4,r0
;;;255      GUI_ALLOC_INFO Info;
;;;256      char  acVersion[40] = "Framewin: Version of emWin: ";
000006  2228              MOVS     r2,#0x28
000008  4914              LDR      r1,|L15.92|
00000a  4668              MOV      r0,sp
00000c  f7fffffe          BL       __aeabi_memcpy4
;;;257    
;;;258      /* Init of GUI internal data structures & variables */
;;;259      //
;;;260      // Setup configuration dependent pointers
;;;261      //
;;;262      APPW_X_Setup();
000010  f7fffffe          BL       APPW_X_Setup
;;;263      //
;;;264      // Initialize AppWizard
;;;265      //
;;;266      APPW_Init(APPW_PROJECT_PATH);
000014  a012              ADR      r0,|L15.96|
000016  f7fffffe          BL       APPW_Init
;;;267      //
;;;268      // Create all persistent screens except initial screen
;;;269      //
;;;270      APPW_CreatePersistentScreens();
00001a  f7fffffe          BL       APPW_CreatePersistentScreens
;;;271      //
;;;272      // Create initial screen...
;;;273      //
;;;274      APPW_CreateRoot(APPW_INITIAL_SCREEN, WM_HBKWIN);
00001e  f7fffffe          BL       WM_GetDesktopWindow
000022  4601              MOV      r1,r0
000024  4817              LDR      r0,|L15.132|
000026  f7fffffe          BL       APPW_CreateRoot
;;;275    
;;;276      GUI_ALLOC_GetMemInfo(&Info);
00002a  a80a              ADD      r0,sp,#0x28
00002c  f7fffffe          BL       GUI_ALLOC_GetMemInfo
;;;277      strcat(acVersion, GUI_GetVersionString());
000030  f7fffffe          BL       GUI_GetVersionString
000034  4601              MOV      r1,r0
000036  4668              MOV      r0,sp
000038  f7fffffe          BL       strcat
;;;278      GUIEXEC_STATE_MSG("emWin Memory Info:\n");
;;;279      GUIEXEC_STATE_MSG("  Total Memory      : %lu bytes\n", Info.TotalBytes);
;;;280      GUIEXEC_STATE_MSG("  Used Bytes        : %lu bytes\n", Info.UsedBytes);
;;;281      GUIEXEC_STATE_MSG("  Free Bytes        : %lu bytes\n", Info.FreeBytes);
;;;282      GUIEXEC_STATE_MSG("  Bytes available   : %lu bytes\n", Info.AllocSize);
;;;283      GUIEXEC_STATE_MSG("  Fixed bytes       : %lu bytes\n", Info.NumFixedBytes);
;;;284      GUIEXEC_STATE_MSG("  Peak of used bytes: %lu bytes\n", Info.MaxUsedBytes);
;;;285      GUIEXEC_STATE_MSG("%s\n", acVersion);
;;;286    
;;;287      Ctrl->ThermostatDataPtr = ThermostatDataPtr;
00003c  4812              LDR      r0,|L15.136|
00003e  6800              LDR      r0,[r0,#0]  ; ThermostatDataPtr
;;;288      Ctrl->ThermostatDataPtr->MISC.GUI_INIT_READY = TRUE;
000040  60a0              STR      r0,[r4,#8]
000042  6881              LDR      r1,[r0,#8]
000044  f0410101          ORR      r1,r1,#1
;;;289      Ctrl->ThermostatDataPtr->MISC.GUI_READY = TRUE;
000048  6081              STR      r1,[r0,#8]
00004a  68a0              LDR      r0,[r4,#8]
00004c  f0410102          ORR      r1,r1,#2
;;;290      Ctrl->Gui_State = INIT_STATE;
000050  6081              STR      r1,[r0,#8]
000052  2002              MOVS     r0,#2
000054  7060              STRB     r0,[r4,#1]
;;;291    
;;;292      return;
;;;293    }
000056  b010              ADD      sp,sp,#0x40
000058  bd10              POP      {r4,pc}
;;;294    
                          ENDP

00005a  0000              DCW      0x0000
                  |L15.92|
                          DCD      ||.constdata||
                  |L15.96|
000060  433a2f74          DCB      "C:/temp/AppWizard/ClimateControl8",0
000064  656d702f
000068  41707057
00006c  697a6172
000070  642f436c
000074  696d6174
000078  65436f6e
00007c  74726f6c
000080  3800    
000082  00                DCB      0
000083  00                DCB      0
                  |L15.132|
                          DCD      ID_SCREEN_00_RootInfo
                  |L15.136|
                          DCD      ||.data||

                          AREA ||i.GuiExecStateTask||, CODE, READONLY, ALIGN=1

                  GuiExecStateTask PROC
;;;297     *----------------------------------------------------------------------------*/
;;;298    void GuiExecStateTask (GUIEXEC_CTRL_STRC *Ctrl) {
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
;;;299      
;;;300      if (Ctrl->Gui_State == INIT_STATE   || \
000004  7840              LDRB     r0,[r0,#1]
000006  2802              CMP      r0,#2
000008  d00a              BEQ      |L16.32|
;;;301          Ctrl->Gui_State == CHANGE_STATE || \
00000a  2800              CMP      r0,#0
00000c  d008              BEQ      |L16.32|
;;;302      	  Ctrl->Gui_State == HOLD_STATE   || \
00000e  2803              CMP      r0,#3
000010  d006              BEQ      |L16.32|
;;;303          Ctrl->Valid) {
000012  7820              LDRB     r0,[r4,#0]
000014  2800              CMP      r0,#0
000016  d103              BNE      |L16.32|
;;;304          return;
;;;305      }
;;;306     
;;;307      //GUI_Exec1();
;;;308      APPW_Exec();
000018  f7fffffe          BL       APPW_Exec
;;;309      //GUI_X_Delay(5);
;;;310    
;;;311      Ctrl->Valid = TRUE;
00001c  2001              MOVS     r0,#1
00001e  7020              STRB     r0,[r4,#0]
                  |L16.32|
;;;312    
;;;313      #if 0
;;;314      GUIEXEC_STATE_MSG("GuiExecStateTask\n");
;;;315      #endif
;;;316    
;;;317      return;
;;;318    }
000020  bd10              POP      {r4,pc}
;;;319    
                          ENDP


                          AREA ||i.JoystickStateCtrl||, CODE, READONLY, ALIGN=2

                  JoystickStateCtrl PROC
;;;629     *----------------------------------------------------------------------------*/
;;;630    void JoystickStateCtrl (JOYSTICK_CTRL_STRC *Ctrl) {
000000  7843              LDRB     r3,[r0,#1]
;;;631      
;;;632      switch(Ctrl->Joystick_State) {
000002  2201              MOVS     r2,#1
000004  b183              CBZ      r3,|L17.40|
000006  2100              MOVS     r1,#0                 ;630
000008  2b01              CMP      r3,#1
00000a  d013              BEQ      |L17.52|
00000c  2b02              CMP      r3,#2
00000e  d002              BEQ      |L17.22|
000010  2b03              CMP      r3,#3
000012  d10e              BNE      |L17.50|
000014  e00c              B        |L17.48|
                  |L17.22|
;;;633             case INIT_STATE:
;;;634                  Ctrl->TimerPtr     = TimerCtrlPtr;
000016  4b0b              LDR      r3,|L17.68|
000018  689b              LDR      r3,[r3,#8]  ; TimerCtrlPtr
;;;635                  Ctrl->last_val     = 0;
;;;636                  Ctrl->last_pressed = FALSE;
00001a  6103              STR      r3,[r0,#0x10]
00001c  6081              STR      r1,[r0,#8]
00001e  7081              STRB     r1,[r0,#2]
;;;637                  Ctrl->last_up      = FALSE;
000020  70c1              STRB     r1,[r0,#3]
;;;638                  Ctrl->last_down    = FALSE;
000022  7101              STRB     r1,[r0,#4]
;;;639                  Ctrl->Valid        = FALSE;
000024  7001              STRB     r1,[r0,#0]
;;;640                  Ctrl->Joystick_State  = WAIT_CMD_STATE;
;;;641                  break;
000026  e003              B        |L17.48|
                  |L17.40|
;;;642             case CHANGE_STATE:
;;;643                  if (Ctrl->TimerPtr->I2C_TOUCH_TIMER >= 50) {
000028  6901              LDR      r1,[r0,#0x10]
00002a  6909              LDR      r1,[r1,#0x10]
00002c  2932              CMP      r1,#0x32
00002e  d300              BCC      |L17.50|
                  |L17.48|
;;;644                      Ctrl->Joystick_State = WAIT_CMD_STATE;
;;;645                  }
;;;646                  break;
;;;647             case HOLD_STATE:
;;;648                  Ctrl->Joystick_State = WAIT_CMD_STATE;
000030  7042              STRB     r2,[r0,#1]
                  |L17.50|
;;;649                  break;
;;;650             case WAIT_CMD_STATE:
;;;651                  if (Ctrl->Valid) {
;;;652                      Ctrl->TimerPtr->I2C_TOUCH_TIMER = 0;
;;;653                      Ctrl->Joystick_State = CHANGE_STATE;
;;;654                      Ctrl->Valid = FALSE;
;;;655                  }
;;;656    			  break;
;;;657             default:
;;;658                  break;
;;;659      }
;;;660      
;;;661      return;
;;;662    }
000032  4770              BX       lr
                  |L17.52|
000034  7802              LDRB     r2,[r0,#0]            ;651
000036  2a00              CMP      r2,#0                 ;651
000038  d0fb              BEQ      |L17.50|
00003a  6902              LDR      r2,[r0,#0x10]         ;652
00003c  6111              STR      r1,[r2,#0x10]         ;653
00003e  7041              STRB     r1,[r0,#1]            ;653
000040  7001              STRB     r1,[r0,#0]            ;654
000042  4770              BX       lr
;;;663    
                          ENDP

                  |L17.68|
                          DCD      ||.data||

                          AREA ||i.JoystickStateInit||, CODE, READONLY, ALIGN=2

                  JoystickStateInit PROC
;;;572     *----------------------------------------------------------------------------*/
;;;573    void JoystickStateInit (JOYSTICK_CTRL_STRC *Ctrl) {
000000  4902              LDR      r1,|L18.12|
;;;574      Ctrl->ThermostatDataPtr = ThermostatDataPtr;
000002  6809              LDR      r1,[r1,#0]  ; ThermostatDataPtr
;;;575      Ctrl->Joystick_State = INIT_STATE;
000004  60c1              STR      r1,[r0,#0xc]
000006  2102              MOVS     r1,#2
000008  7041              STRB     r1,[r0,#1]
;;;576      return;
;;;577    }
00000a  4770              BX       lr
;;;578    
                          ENDP

                  |L18.12|
                          DCD      ||.data||

                          AREA ||i.JoystickStateTask||, CODE, READONLY, ALIGN=2

                  JoystickStateTask PROC
;;;581     *----------------------------------------------------------------------------*/
;;;582    void JoystickStateTask (JOYSTICK_CTRL_STRC *Ctrl) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4604              MOV      r4,r0
;;;583      uint8_t  pressed = !KEY_TOUCH, up = !KEY_UP, down = !KEY_DOWN;
000006  4826              LDR      r0,|L19.160|
000008  6800              LDR      r0,[r0,#0]
00000a  b300              CBZ      r0,|L19.78|
00000c  2600              MOVS     r6,#0
                  |L19.14|
00000e  4825              LDR      r0,|L19.164|
000010  6800              LDR      r0,[r0,#0]
000012  b1f0              CBZ      r0,|L19.82|
000014  2000              MOVS     r0,#0
                  |L19.22|
000016  4680              MOV      r8,r0
000018  4821              LDR      r0,|L19.160|
00001a  30a4              ADDS     r0,r0,#0xa4
00001c  6800              LDR      r0,[r0,#0]
00001e  b1d0              CBZ      r0,|L19.86|
000020  f05f0700          MOVS.W   r7,#0
                  |L19.36|
;;;584      I32      val = APP_Target_Rotary_GetValue();
000024  f7fffffe          BL       APP_Target_Rotary_GetValue
000028  4605              MOV      r5,r0
;;;585    
;;;586      if (Ctrl->Joystick_State == INIT_STATE   || \
00002a  7860              LDRB     r0,[r4,#1]
00002c  2802              CMP      r0,#2
00002e  d034              BEQ      |L19.154|
;;;587          Ctrl->Joystick_State == CHANGE_STATE || \
000030  2800              CMP      r0,#0
000032  d032              BEQ      |L19.154|
;;;588          Ctrl->Joystick_State == HOLD_STATE   || \
000034  2803              CMP      r0,#3
000036  d030              BEQ      |L19.154|
;;;589          Ctrl->Valid                          || \
000038  7820              LDRB     r0,[r4,#0]
00003a  2800              CMP      r0,#0
00003c  d12d              BNE      |L19.154|
;;;590          Ctrl->ThermostatDataPtr->MISC.GUI_INIT_READY == FALSE) {
00003e  68e0              LDR      r0,[r4,#0xc]
000040  7a00              LDRB     r0,[r0,#8]
000042  07c0              LSLS     r0,r0,#31
000044  d029              BEQ      |L19.154|
;;;591          return;
;;;592      }
;;;593    
;;;594      if (pressed == TRUE && Ctrl->last_pressed == FALSE) {
000046  b1de              CBZ      r6,|L19.128|
000048  78a0              LDRB     r0,[r4,#2]
00004a  b130              CBZ      r0,|L19.90|
00004c  e007              B        |L19.94|
                  |L19.78|
00004e  2601              MOVS     r6,#1                 ;583
000050  e7dd              B        |L19.14|
                  |L19.82|
000052  2001              MOVS     r0,#1                 ;583
000054  e7df              B        |L19.22|
                  |L19.86|
000056  2701              MOVS     r7,#1                 ;583
000058  e7e4              B        |L19.36|
                  |L19.90|
;;;595          APP_Target_Rotary_Clicked();
00005a  f7fffffe          BL       APP_Target_Rotary_Clicked
                  |L19.94|
;;;596          JOYSTICK_STATE_MSG("APP_Target_Rotary_Clicked\n");
;;;597      }
;;;598    
;;;599      if (pressed == TRUE) {
;;;600         if (up == TRUE && Ctrl->last_up == FALSE) {
00005e  f1b80f00          CMP      r8,#0
000062  d002              BEQ      |L19.106|
000064  78e0              LDRB     r0,[r4,#3]
000066  b900              CBNZ     r0,|L19.106|
000068  3532              ADDS     r5,r5,#0x32
                  |L19.106|
;;;601             val +=50;
;;;602         }
;;;603         if (down == TRUE && Ctrl->last_down == FALSE) {
00006a  b117              CBZ      r7,|L19.114|
00006c  7920              LDRB     r0,[r4,#4]
00006e  b900              CBNZ     r0,|L19.114|
000070  3d32              SUBS     r5,r5,#0x32
                  |L19.114|
;;;604             val -=50;
;;;605         }
;;;606         if (val != Ctrl->last_val) {
000072  68a0              LDR      r0,[r4,#8]
000074  42a8              CMP      r0,r5
000076  d009              BEQ      |L19.140|
;;;607             APP_Target_Rotary_SetValue(val);
000078  4628              MOV      r0,r5
00007a  f7fffffe          BL       APP_Target_Rotary_SetValue
;;;608             JOYSTICK_STATE_MSG("APP_Target_Rotary_SetValue: %d\n", val);
00007e  e005              B        |L19.140|
                  |L19.128|
;;;609         }
;;;610         //JOYSTICK_STATE_MSG("Value: %d, Up: %x, Down: %x\n", val, up, down);
;;;611      }
;;;612    
;;;613      if (pressed == FALSE && Ctrl->last_pressed == TRUE) {
000080  b926              CBNZ     r6,|L19.140|
000082  78a0              LDRB     r0,[r4,#2]
000084  2801              CMP      r0,#1
000086  d101              BNE      |L19.140|
;;;614          APP_Target_Rotary_Released();
000088  f7fffffe          BL       APP_Target_Rotary_Released
                  |L19.140|
;;;615          JOYSTICK_STATE_MSG("APP_Target_Rotary_Released\n");
;;;616      }
;;;617    
;;;618      Ctrl->last_pressed = pressed;
00008c  70a6              STRB     r6,[r4,#2]
;;;619      Ctrl->last_up      = up;
00008e  f8848003          STRB     r8,[r4,#3]
;;;620      Ctrl->last_down    = down;
000092  7127              STRB     r7,[r4,#4]
;;;621      Ctrl->last_val     = val;
;;;622      Ctrl->Valid        = TRUE;
000094  2001              MOVS     r0,#1
000096  60a5              STR      r5,[r4,#8]
000098  7020              STRB     r0,[r4,#0]
                  |L19.154|
;;;623    
;;;624      return;
;;;625    }
00009a  e8bd81f0          POP      {r4-r8,pc}
;;;626    
                          ENDP

00009e  0000              DCW      0x0000
                  |L19.160|
                          DCD      0x40004804
                  |L19.164|
                          DCD      0x40004988

                          AREA ||i.MainTask||, CODE, READONLY, ALIGN=1

                  MainTask PROC
;;;894     *----------------------------------------------------------------------------*/
;;;895    void MainTask (void) {
000000  f7fffffe          BL       ThermostatInit
                  |L20.4|
;;;896      
;;;897      /* Gauge State Init */
;;;898      ThermostatInit ();
;;;899    
;;;900      while (TRUE) {
;;;901    
;;;902        ThermostatTask ();
000004  f7fffffe          BL       ThermostatTask
;;;903    
;;;904        ThermostatCtrl ();
000008  f7fffffe          BL       ThermostatCtrl
00000c  e7fa              B        |L20.4|
;;;905    
;;;906       }
;;;907    
;;;908    }
;;;909    
                          ENDP


                          AREA ||i.RotaryStateCtrl||, CODE, READONLY, ALIGN=2

                  RotaryStateCtrl PROC
;;;502     *----------------------------------------------------------------------------*/
;;;503    void RotaryStateCtrl (GUI_ROTARY_CTRL_STRC *Ctrl) {
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
;;;504    
;;;505      switch(Ctrl->Rotary_State) {
000004  7841              LDRB     r1,[r0,#1]
000006  2500              MOVS     r5,#0
000008  2006              MOVS     r0,#6
00000a  2601              MOVS     r6,#1
;;;506             case INIT_STATE:
;;;507                  Ctrl->TimerPtr       = TimerCtrlPtr;
;;;508                  Ctrl->last_rotaryVal = 0;
;;;509                  Ctrl->pressed        = FALSE;
;;;510                  Ctrl->last_pressed   = FALSE;
;;;511                  Ctrl->Valid          = FALSE;
;;;512                  Ctrl->Rotary_State  = WAIT_CMD_STATE;
;;;513                  break;
;;;514             case CHANGE_STATE:
;;;515                  if (Ctrl->TimerPtr->GUI_ROTARY_TIMER >= 300) {
00000c  f44f7296          MOV      r2,#0x12c
000010  2909              CMP      r1,#9                 ;505
000012  d213              BCS      |L21.60|
000014  e8dff001          TBB      [pc,r1]               ;505
000018  0d3e0511          DCB      0x0d,0x3e,0x05,0x11
00001c  13191e30          DCB      0x13,0x19,0x1e,0x30
000020  3b00              DCB      0x3b,0x00
000022  4820              LDR      r0,|L21.164|
000024  6880              LDR      r0,[r0,#8]            ;507  ; TimerCtrlPtr
000026  6125              STR      r5,[r4,#0x10]         ;509
000028  61a0              STR      r0,[r4,#0x18]         ;509
00002a  7325              STRB     r5,[r4,#0xc]          ;509
00002c  7365              STRB     r5,[r4,#0xd]          ;510
00002e  7025              STRB     r5,[r4,#0]            ;511
000030  e003              B        |L21.58|
000032  69a0              LDR      r0,[r4,#0x18]
000034  68c0              LDR      r0,[r0,#0xc]
000036  4290              CMP      r0,r2
000038  d300              BCC      |L21.60|
                  |L21.58|
;;;516                      Ctrl->Rotary_State = WAIT_CMD_STATE;
;;;517                  }
;;;518                  break;
;;;519             case HOLD_STATE:
;;;520                  Ctrl->Rotary_State = WAIT_CMD_STATE;
00003a  7066              STRB     r6,[r4,#1]
                  |L21.60|
;;;521                  break;
;;;522             case ROTARY_CLICK_STATE:
;;;523                  APP_Target_Rotary_Clicked();
;;;524                  Ctrl->TimerPtr->GUI_ROTARY_TIMER = 0;
;;;525                  Ctrl->Rotary_State = ROTARY_CLICKED_HOLD_STATE;
;;;526                  //GUI_ROTARY_STATE_MSG("ROTARY_CLICK_STATE\n");
;;;527                  break;
;;;528             case ROTARY_CLICKED_HOLD_STATE:
;;;529                  if (Ctrl->TimerPtr->GUI_ROTARY_TIMER >= 10) {
;;;530                      Ctrl->Rotary_State = ROTARY_SET_VALUE_STATE;
;;;531                  }
;;;532                  break;
;;;533             case ROTARY_SET_VALUE_STATE:
;;;534                  if (Ctrl->rotaryVal < Ctrl->target)
;;;535                      Ctrl->rotaryVal += 50;
;;;536                  else if (Ctrl->rotaryVal > Ctrl->target)
;;;537                      Ctrl->rotaryVal -= 50;
;;;538    
;;;539                  APP_Target_Rotary_SetValue(Ctrl->rotaryVal);
;;;540                  Ctrl->TimerPtr->GUI_ROTARY_TIMER = 0;
;;;541                  Ctrl->Rotary_State = ROTARY_SET_VALUE_HOLD_STATE;
;;;542                  //GUI_ROTARY_STATE_MSG("ROTARY_SET_VALUE_STATE - %d\n", Ctrl->rotaryVal);
;;;543                  break;
;;;544             case ROTARY_SET_VALUE_HOLD_STATE:
;;;545                  if (Ctrl->TimerPtr->GUI_ROTARY_TIMER >= 300) {
;;;546                      Ctrl->Rotary_State = ROTARY_RELEASE_STATE;
;;;547                      if (Ctrl->rotaryVal != Ctrl->target)
;;;548                          Ctrl->Rotary_State = ROTARY_SET_VALUE_STATE;
;;;549                  }
;;;550                  break;
;;;551             case ROTARY_RELEASE_STATE:
;;;552                  APP_Target_Rotary_Released();
;;;553                  Ctrl->Rotary_State = WAIT_CMD_STATE;
;;;554                  //GUI_ROTARY_STATE_MSG("ROTARY_RELEASE_STATE\n");
;;;555                  break;
;;;556             case WAIT_CMD_STATE:
;;;557                  if (Ctrl->Valid) {
;;;558                      Ctrl->TimerPtr->GUI_ROTARY_TIMER = 0;
;;;559                      Ctrl->Rotary_State = CHANGE_STATE;
;;;560                      Ctrl->Valid = FALSE;
;;;561                  }
;;;562    			  break;
;;;563             default:
;;;564                  break;
;;;565      }
;;;566      
;;;567      return;
;;;568    }
00003c  bd70              POP      {r4-r6,pc}
00003e  f7fffffe          BL       APP_Target_Rotary_Clicked
000042  69a0              LDR      r0,[r4,#0x18]         ;524
000044  60c5              STR      r5,[r0,#0xc]          ;525
000046  2005              MOVS     r0,#5                 ;525
000048  e014              B        |L21.116|
00004a  69a1              LDR      r1,[r4,#0x18]         ;529
00004c  68c9              LDR      r1,[r1,#0xc]          ;529
00004e  290a              CMP      r1,#0xa               ;529
000050  d210              BCS      |L21.116|
000052  bd70              POP      {r4-r6,pc}
000054  e9d41001          LDRD     r1,r0,[r4,#4]
000058  4288              CMP      r0,r1                 ;534
00005a  da02              BGE      |L21.98|
00005c  f1000032          ADD      r0,r0,#0x32           ;534
000060  e002              B        |L21.104|
                  |L21.98|
000062  dd02              BLE      |L21.106|
000064  f1a00032          SUB      r0,r0,#0x32           ;536
                  |L21.104|
000068  60a0              STR      r0,[r4,#8]            ;537
                  |L21.106|
00006a  f7fffffe          BL       APP_Target_Rotary_SetValue
00006e  69a0              LDR      r0,[r4,#0x18]         ;540
000070  60c5              STR      r5,[r0,#0xc]          ;541
000072  2007              MOVS     r0,#7                 ;541
                  |L21.116|
000074  7060              STRB     r0,[r4,#1]            ;541
                  |L21.118|
000076  bd70              POP      {r4-r6,pc}
000078  69a1              LDR      r1,[r4,#0x18]         ;545
00007a  68c9              LDR      r1,[r1,#0xc]          ;545
00007c  4291              CMP      r1,r2                 ;545
00007e  d3fa              BCC      |L21.118|
000080  2108              MOVS     r1,#8                 ;546
000082  7061              STRB     r1,[r4,#1]            ;546
000084  e9d41201          LDRD     r1,r2,[r4,#4]         ;546
000088  428a              CMP      r2,r1                 ;547
00008a  d1f3              BNE      |L21.116|
                  |L21.140|
00008c  bd70              POP      {r4-r6,pc}
00008e  f7fffffe          BL       APP_Target_Rotary_Released
000092  e7d2              B        |L21.58|
000094  7820              LDRB     r0,[r4,#0]            ;557
000096  2800              CMP      r0,#0                 ;557
000098  d0f8              BEQ      |L21.140|
00009a  69a0              LDR      r0,[r4,#0x18]         ;558
00009c  60c5              STR      r5,[r0,#0xc]          ;559
00009e  7065              STRB     r5,[r4,#1]            ;559
0000a0  7025              STRB     r5,[r4,#0]            ;560
0000a2  bd70              POP      {r4-r6,pc}
;;;569    
                          ENDP

                  |L21.164|
                          DCD      ||.data||

                          AREA ||i.RotaryStateInit||, CODE, READONLY, ALIGN=2

                  RotaryStateInit PROC
;;;458     *----------------------------------------------------------------------------*/
;;;459    void RotaryStateInit (GUI_ROTARY_CTRL_STRC *Ctrl) {
000000  4902              LDR      r1,|L22.12|
;;;460      Ctrl->ThermostatDataPtr = ThermostatDataPtr;
000002  6809              LDR      r1,[r1,#0]  ; ThermostatDataPtr
;;;461      Ctrl->Rotary_State = INIT_STATE;
000004  6141              STR      r1,[r0,#0x14]
000006  2102              MOVS     r1,#2
000008  7041              STRB     r1,[r0,#1]
;;;462      return;
;;;463    }
00000a  4770              BX       lr
;;;464    
                          ENDP

                  |L22.12|
                          DCD      ||.data||

                          AREA ||i.RotaryStateTask||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  RotaryStateTask PROC
;;;467     *----------------------------------------------------------------------------*/
;;;468    void RotaryStateTask (GUI_ROTARY_CTRL_STRC *Ctrl) {
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
;;;469      uint16_t cursorVal;
;;;470    
;;;471      if (Ctrl->Rotary_State == INIT_STATE                  || \
000004  7840              LDRB     r0,[r0,#1]
000006  2802              CMP      r0,#2
000008  d02d              BEQ      |L23.102|
;;;472          Ctrl->Rotary_State == CHANGE_STATE                || \
00000a  2800              CMP      r0,#0
00000c  d02b              BEQ      |L23.102|
;;;473          Ctrl->Rotary_State == HOLD_STATE                  || \
00000e  2803              CMP      r0,#3
000010  d029              BEQ      |L23.102|
;;;474          Ctrl->Rotary_State == ROTARY_CLICK_STATE          || \
000012  2804              CMP      r0,#4
000014  d027              BEQ      |L23.102|
;;;475          Ctrl->Rotary_State == ROTARY_CLICKED_HOLD_STATE   || \
000016  2805              CMP      r0,#5
000018  d025              BEQ      |L23.102|
;;;476          Ctrl->Rotary_State == ROTARY_SET_VALUE_STATE      || \
00001a  2806              CMP      r0,#6
00001c  d023              BEQ      |L23.102|
;;;477          Ctrl->Rotary_State == ROTARY_SET_VALUE_HOLD_STATE || \
00001e  2807              CMP      r0,#7
000020  d021              BEQ      |L23.102|
;;;478          Ctrl->Rotary_State == ROTARY_RELEASE_STATE        || \
000022  2808              CMP      r0,#8
000024  d01f              BEQ      |L23.102|
;;;479          Ctrl->Valid                                       || \
000026  7820              LDRB     r0,[r4,#0]
000028  2800              CMP      r0,#0
00002a  d11c              BNE      |L23.102|
;;;480          Ctrl->ThermostatDataPtr->MISC.GUI_INIT_READY == FALSE) {
00002c  6960              LDR      r0,[r4,#0x14]
00002e  7a01              LDRB     r1,[r0,#8]
000030  07c9              LSLS     r1,r1,#31
000032  d018              BEQ      |L23.102|
;;;481          return;
;;;482      }
;;;483    
;;;484      cursorVal = (Ctrl->ThermostatDataPtr->TouchRawData0 | \
000034  8885              LDRH     r5,[r0,#4]
;;;485                   (Ctrl->ThermostatDataPtr->TouchRawData1 << 8));
;;;486    
;;;487      Ctrl->target = (I32)(1500 + (cursorVal * 50));
000036  f24051dc          MOV      r1,#0x5dc
00003a  eb0500c5          ADD      r0,r5,r5,LSL #3
00003e  eb001005          ADD      r0,r0,r5,LSL #4
000042  eb010040          ADD      r0,r1,r0,LSL #1
;;;488      Ctrl->rotaryVal = APP_Target_Rotary_GetValue();
000046  6060              STR      r0,[r4,#4]
000048  f7fffffe          BL       APP_Target_Rotary_GetValue
;;;489    
;;;490      if (Ctrl->rotaryVal != Ctrl->target) {
00004c  60a0              STR      r0,[r4,#8]
00004e  6863              LDR      r3,[r4,#4]
000050  4602              MOV      r2,r0                 ;488
000052  4298              CMP      r0,r3
000054  d007              BEQ      |L23.102|
;;;491          Ctrl->Rotary_State = ROTARY_CLICK_STATE;
000056  2004              MOVS     r0,#4
000058  7060              STRB     r0,[r4,#1]
;;;492          GUI_ROTARY_STATE_MSG("cursorVal: %d, rotaryVal: %d, taget: %d\n", cursorVal, Ctrl->rotaryVal, Ctrl->target);
00005a  4629              MOV      r1,r5
00005c  e8bd4070          POP      {r4-r6,lr}
000060  a001              ADR      r0,|L23.104|
000062  f7ffbffe          B.W      __2printf
                  |L23.102|
;;;493      }
;;;494    
;;;495      //Ctrl->Valid = TRUE;
;;;496    
;;;497      return;
;;;498    }
000066  bd70              POP      {r4-r6,pc}
;;;499    
                          ENDP

                  |L23.104|
000068  63757273          DCB      "cursorVal: %d, rotaryVal: %d, taget: %d\n",0
00006c  6f725661
000070  6c3a2025
000074  642c2072
000078  6f746172
00007c  7956616c
000080  3a202564
000084  2c207461
000088  6765743a
00008c  2025640a
000090  00      
000091  00                DCB      0
000092  00                DCB      0
000093  00                DCB      0

                          AREA ||i.SYS_UnlockReg||, CODE, READONLY, ALIGN=2

                  SYS_UnlockReg PROC
;;;1585     */
;;;1586   __STATIC_INLINE void SYS_UnlockReg(void)
000000  2159              MOVS     r1,#0x59
;;;1587   {
000002  b510              PUSH     {r4,lr}
;;;1588       do
;;;1589       {
;;;1590           SYS->REGLCTL = 0x59UL;
000004  0788              LSLS     r0,r1,#30
;;;1591           SYS->REGLCTL = 0x16UL;
000006  2316              MOVS     r3,#0x16
;;;1592           SYS->REGLCTL = 0x88UL;
000008  f05f0288          MOVS.W   r2,#0x88
                  |L24.12|
00000c  f8c01100          STR      r1,[r0,#0x100]        ;1590
000010  f8c03100          STR      r3,[r0,#0x100]        ;1591
000014  f8c02100          STR      r2,[r0,#0x100]
;;;1593       }
;;;1594       while(SYS->REGLCTL == 0UL);
000018  f8d04100          LDR      r4,[r0,#0x100]
00001c  2c00              CMP      r4,#0
00001e  d0f5              BEQ      |L24.12|
;;;1595   }
000020  bd10              POP      {r4,pc}
;;;1596   
                          ENDP


                          AREA ||i.ThermostatCtrl||, CODE, READONLY, ALIGN=2

                  ThermostatCtrl PROC
;;;872     *----------------------------------------------------------------------------*/
;;;873    void ThermostatCtrl (void) {
000000  b510              PUSH     {r4,lr}
;;;874    
;;;875      FmcStateCtrl (FmcCtrlPtr);
000002  4c09              LDR      r4,|L25.40|
000004  68e0              LDR      r0,[r4,#0xc]  ; FmcCtrlPtr
000006  f7fffffe          BL       FmcStateCtrl
;;;876    
;;;877      GuiExecStateCtrl (GuiCtrlPtr);
00000a  6920              LDR      r0,[r4,#0x10]  ; GuiCtrlPtr
00000c  f7fffffe          BL       GuiExecStateCtrl
;;;878    
;;;879      TouchPadStateCtrl (TouchPadCtrlPtr);
000010  6960              LDR      r0,[r4,#0x14]  ; TouchPadCtrlPtr
000012  f7fffffe          BL       TouchPadStateCtrl
;;;880    
;;;881      RotaryStateCtrl (RotaryCtrlPtr);
000016  69a0              LDR      r0,[r4,#0x18]  ; RotaryCtrlPtr
000018  f7fffffe          BL       RotaryStateCtrl
;;;882    
;;;883      JoystickStateCtrl (JoystickCtrlPtr);
00001c  69e0              LDR      r0,[r4,#0x1c]  ; JoystickCtrlPtr
00001e  e8bd4010          POP      {r4,lr}
000022  f7ffbffe          B.W      JoystickStateCtrl
;;;884    
;;;885      //EepromReadStateCtrl (EepromReadPtr);
;;;886    
;;;887      //EepromWriteStateCtrl (EepromWritePtr);
;;;888    
;;;889      return;
;;;890    }
;;;891    
                          ENDP

000026  0000              DCW      0x0000
                  |L25.40|
                          DCD      ||.data||

                          AREA ||i.ThermostatInit||, CODE, READONLY, ALIGN=2

                  ThermostatInit PROC
;;;827     *----------------------------------------------------------------------------*/
;;;828    void ThermostatInit (void) {
000000  b570              PUSH     {r4-r6,lr}
;;;829    
;;;830      /* Initialize all of task structures */
;;;831      FmcStateInit (FmcCtrlPtr);
000002  4c0a              LDR      r4,|L26.44|
000004  2502              MOVS     r5,#2
000006  68e0              LDR      r0,[r4,#0xc]  ; FmcCtrlPtr
000008  7045              STRB     r5,[r0,#1]
;;;832    
;;;833      GuiExecStateInit (GuiCtrlPtr);
00000a  6920              LDR      r0,[r4,#0x10]  ; GuiCtrlPtr
00000c  f7fffffe          BL       GuiExecStateInit
;;;834    
;;;835      TouchPadStateInit (TouchPadCtrlPtr);
000010  6960              LDR      r0,[r4,#0x14]  ; TouchPadCtrlPtr
000012  f7fffffe          BL       TouchPadStateInit
;;;836    
;;;837      RotaryStateInit (RotaryCtrlPtr);
000016  69a0              LDR      r0,[r4,#0x18]  ; RotaryCtrlPtr
000018  f7fffffe          BL       RotaryStateInit
;;;838    
;;;839      JoystickStateInit (JoystickCtrlPtr);
00001c  69e0              LDR      r0,[r4,#0x1c]  ; JoystickCtrlPtr
00001e  f7fffffe          BL       JoystickStateInit
000022  6a20              LDR      r0,[r4,#0x20]  ; EepromReadPtr
000024  7045              STRB     r5,[r0,#1]
000026  6a60              LDR      r0,[r4,#0x24]  ; EepromWritePtr
000028  7045              STRB     r5,[r0,#1]
;;;840    
;;;841      EepromReadStateInit (EepromReadPtr);
;;;842    
;;;843      EepromWriteStateInit (EepromWritePtr);
;;;844    
;;;845      return;
;;;846    }
00002a  bd70              POP      {r4-r6,pc}
;;;847    
                          ENDP

                  |L26.44|
                          DCD      ||.data||

                          AREA ||i.ThermostatTask||, CODE, READONLY, ALIGN=2

                  ThermostatTask PROC
;;;850     *----------------------------------------------------------------------------*/
;;;851    void ThermostatTask (void) {
000000  b510              PUSH     {r4,lr}
;;;852      
;;;853      FmcStateTask (FmcCtrlPtr);
000002  4c09              LDR      r4,|L27.40|
000004  68e0              LDR      r0,[r4,#0xc]  ; FmcCtrlPtr
000006  f7fffffe          BL       FmcStateTask
;;;854    
;;;855      GuiExecStateTask (GuiCtrlPtr);
00000a  6920              LDR      r0,[r4,#0x10]  ; GuiCtrlPtr
00000c  f7fffffe          BL       GuiExecStateTask
;;;856    
;;;857      TouchPadStateTask (TouchPadCtrlPtr);
000010  6960              LDR      r0,[r4,#0x14]  ; TouchPadCtrlPtr
000012  f7fffffe          BL       TouchPadStateTask
;;;858    
;;;859      RotaryStateTask (RotaryCtrlPtr);
000016  69a0              LDR      r0,[r4,#0x18]  ; RotaryCtrlPtr
000018  f7fffffe          BL       RotaryStateTask
;;;860    
;;;861      JoystickStateTask (JoystickCtrlPtr);
00001c  69e0              LDR      r0,[r4,#0x1c]  ; JoystickCtrlPtr
00001e  e8bd4010          POP      {r4,lr}
000022  f7ffbffe          B.W      JoystickStateTask
;;;862    
;;;863      //EepromReadStateTask (EepromReadPtr);
;;;864    
;;;865      //EepromWriteStateTask (EepromWritePtr);
;;;866    
;;;867      return;
;;;868    }
;;;869    
                          ENDP

000026  0000              DCW      0x0000
                  |L27.40|
                          DCD      ||.data||

                          AREA ||i.TouchPadStateCtrl||, CODE, READONLY, ALIGN=2

                  TouchPadStateCtrl PROC
;;;388     *----------------------------------------------------------------------------*/
;;;389    void TouchPadStateCtrl (TOUCH_PAD_CTRL_STRC *Ctrl) {
000000  b510              PUSH     {r4,lr}
;;;390      
;;;391      switch(Ctrl->Touch_State) {
000002  7841              LDRB     r1,[r0,#1]
000004  2200              MOVS     r2,#0
000006  2301              MOVS     r3,#1
000008  b179              CBZ      r1,|L28.42|
00000a  2901              CMP      r1,#1
00000c  d057              BEQ      |L28.190|
00000e  2902              CMP      r1,#2
000010  d002              BEQ      |L28.24|
000012  2903              CMP      r1,#3
000014  d152              BNE      |L28.188|
000016  e050              B        |L28.186|
                  |L28.24|
;;;392             case INIT_STATE:
;;;393                  Ctrl->TimerPtr = TimerCtrlPtr;
000018  492d              LDR      r1,|L28.208|
00001a  6889              LDR      r1,[r1,#8]  ; TimerCtrlPtr
;;;394                  Ctrl->ctx      = &I2C2_Ctx;
00001c  60c1              STR      r1,[r0,#0xc]
00001e  492d              LDR      r1,|L28.212|
;;;395                  Ctrl->Offset   = eWD608_RESULT;
000020  6041              STR      r1,[r0,#4]
000022  21c0              MOVS     r1,#0xc0
000024  7081              STRB     r1,[r0,#2]
;;;396                  Ctrl->Valid    = FALSE;
000026  7002              STRB     r2,[r0,#0]
;;;397                  Ctrl->Touch_State = WAIT_CMD_STATE;
;;;398                  break;
000028  e047              B        |L28.186|
                  |L28.42|
;;;399             case CHANGE_STATE:
;;;400                  if (Ctrl->TimerPtr->TOUCH_PAD_TIMER >= 30 && Ctrl->ctx->txrxDone == TRUE) {
00002a  68c1              LDR      r1,[r0,#0xc]
00002c  6889              LDR      r1,[r1,#8]
00002e  291e              CMP      r1,#0x1e
000030  d344              BCC      |L28.188|
000032  6841              LDR      r1,[r0,#4]
000034  7bcc              LDRB     r4,[r1,#0xf]
000036  2c01              CMP      r4,#1
000038  d140              BNE      |L28.188|
;;;401                      switch (Ctrl->Offset) {
00003a  7884              LDRB     r4,[r0,#2]
00003c  2cc0              CMP      r4,#0xc0
00003e  d006              BEQ      |L28.78|
000040  2cc1              CMP      r4,#0xc1
000042  d010              BEQ      |L28.102|
000044  2cc2              CMP      r4,#0xc2
000046  d012              BEQ      |L28.110|
000048  2cc3              CMP      r4,#0xc3
00004a  d12c              BNE      |L28.166|
00004c  e013              B        |L28.118|
                  |L28.78|
;;;402                              case eWD608_RESULT:
;;;403                                   if (Ctrl->ctx->rxData == (TOUCH_EVENT | NEW_CURSOR_EVENT | CURSOR_0_EVENT)) {
00004e  7b09              LDRB     r1,[r1,#0xc]
000050  29c1              CMP      r1,#0xc1
;;;404                                       Ctrl->ThermostatDataPtr->MISC.TOUCH_PRESSED = TRUE;
;;;405                                   } else {
;;;406                                       Ctrl->ThermostatDataPtr->MISC.TOUCH_PRESSED = FALSE;
000052  6881              LDR      r1,[r0,#8]
000054  688c              LDR      r4,[r1,#8]            ;403
000056  d003              BEQ      |L28.96|
000058  f0240404          BIC      r4,r4,#4
                  |L28.92|
00005c  608c              STR      r4,[r1,#8]            ;404
00005e  e022              B        |L28.166|
                  |L28.96|
000060  f0440404          ORR      r4,r4,#4              ;404
000064  e7fa              B        |L28.92|
                  |L28.102|
;;;407                                   }
;;;408                                   break;
;;;409                              case eWD608_CURSOR_L:
;;;410                                   Ctrl->ThermostatDataPtr->TouchRawData0 = Ctrl->ctx->rxData;
000066  6884              LDR      r4,[r0,#8]
000068  7b09              LDRB     r1,[r1,#0xc]
00006a  7121              STRB     r1,[r4,#4]
;;;411                                   break;
00006c  e01b              B        |L28.166|
                  |L28.110|
;;;412                              case eWD608_CURSOR_H:
;;;413                                   Ctrl->ThermostatDataPtr->TouchRawData1 = Ctrl->ctx->rxData;
00006e  6884              LDR      r4,[r0,#8]
000070  7b09              LDRB     r1,[r1,#0xc]
000072  7161              STRB     r1,[r4,#5]
;;;414                                   break;
000074  e017              B        |L28.166|
                  |L28.118|
;;;415                              case eWD608_VECTOR:
;;;416                                   if (Ctrl->ctx->rxData == eWD608_FORWARD) {
000076  7b09              LDRB     r1,[r1,#0xc]
000078  2901              CMP      r1,#1
00007a  d002              BEQ      |L28.130|
;;;417                                       Ctrl->ThermostatDataPtr->MISC.TOUCH_FORWARD = TRUE;
;;;418                                       Ctrl->ThermostatDataPtr->MISC.TOUCH_REVERSE = FALSE;
;;;419                                   } else if (Ctrl->ctx->rxData == eWD608_REVERSE) {
00007c  29ff              CMP      r1,#0xff
00007e  d009              BEQ      |L28.148|
000080  e011              B        |L28.166|
                  |L28.130|
000082  6884              LDR      r4,[r0,#8]            ;417
000084  68a1              LDR      r1,[r4,#8]            ;417
000086  f0410110          ORR      r1,r1,#0x10           ;417
00008a  60a1              STR      r1,[r4,#8]            ;418
00008c  f0210120          BIC      r1,r1,#0x20           ;418
000090  6884              LDR      r4,[r0,#8]            ;418
000092  e007              B        |L28.164|
                  |L28.148|
;;;420                                       Ctrl->ThermostatDataPtr->MISC.TOUCH_REVERSE = TRUE;
000094  6884              LDR      r4,[r0,#8]
000096  68a1              LDR      r1,[r4,#8]
000098  f0410120          ORR      r1,r1,#0x20
;;;421                                       Ctrl->ThermostatDataPtr->MISC.TOUCH_FORWARD = FALSE;
00009c  60a1              STR      r1,[r4,#8]
00009e  6884              LDR      r4,[r0,#8]
0000a0  f0210110          BIC      r1,r1,#0x10
                  |L28.164|
0000a4  60a1              STR      r1,[r4,#8]
                  |L28.166|
;;;422                                   }
;;;423                                   break;
;;;424                      }
;;;425                      Ctrl->Offset = (++Ctrl->Offset <= eWD608_VECTOR) ? Ctrl->Offset : eWD608_RESULT;
0000a6  7881              LDRB     r1,[r0,#2]
0000a8  1c49              ADDS     r1,r1,#1
0000aa  b2c9              UXTB     r1,r1
0000ac  7081              STRB     r1,[r0,#2]
0000ae  29c3              CMP      r1,#0xc3
0000b0  d900              BLS      |L28.180|
0000b2  21c0              MOVS     r1,#0xc0
                  |L28.180|
0000b4  7081              STRB     r1,[r0,#2]
;;;426                      Ctrl->ctx->txrxDone = FALSE;
0000b6  6841              LDR      r1,[r0,#4]
0000b8  73ca              STRB     r2,[r1,#0xf]
                  |L28.186|
;;;427                      Ctrl->Touch_State = WAIT_CMD_STATE;
;;;428                      TOUCH_PAD_STATE_MSG("Data: 0x%x, PRESS: %x, FORWARD: %x, REVERSE: %x\n", \
;;;429                                          (Ctrl->ThermostatDataPtr->TouchRawData0 | (Ctrl->ThermostatDataPtr->TouchRawData1 << 8)), \
;;;430                                          Ctrl->ThermostatDataPtr->MISC.TOUCH_PRESSED, Ctrl->ThermostatDataPtr->MISC.TOUCH_FORWARD, \
;;;431                                          Ctrl->ThermostatDataPtr->MISC.TOUCH_REVERSE);
;;;432                  }
;;;433                  break;
;;;434             case HOLD_STATE:
;;;435                  Ctrl->Touch_State = WAIT_CMD_STATE;
0000ba  7043              STRB     r3,[r0,#1]
                  |L28.188|
;;;436                  break;
;;;437             case WAIT_CMD_STATE:
;;;438                  if (Ctrl->Valid) {
;;;439                      Ctrl->TimerPtr->TOUCH_PAD_TIMER = 0;
;;;440                      Ctrl->Touch_State = CHANGE_STATE;
;;;441                      Ctrl->Valid = FALSE;
;;;442                  }
;;;443    			  break;
;;;444             default:
;;;445                  break;
;;;446      }
;;;447      
;;;448      return;
;;;449    }
0000bc  bd10              POP      {r4,pc}
                  |L28.190|
0000be  7801              LDRB     r1,[r0,#0]            ;438
0000c0  2900              CMP      r1,#0                 ;438
0000c2  d0fb              BEQ      |L28.188|
0000c4  68c1              LDR      r1,[r0,#0xc]          ;439
0000c6  608a              STR      r2,[r1,#8]            ;440
0000c8  7042              STRB     r2,[r0,#1]            ;440
0000ca  7002              STRB     r2,[r0,#0]            ;441
0000cc  bd10              POP      {r4,pc}
;;;450    
                          ENDP

0000ce  0000              DCW      0x0000
                  |L28.208|
                          DCD      ||.data||
                  |L28.212|
                          DCD      I2C2_Ctx

                          AREA ||i.TouchPadStateInit||, CODE, READONLY, ALIGN=2

                  TouchPadStateInit PROC
;;;358     *----------------------------------------------------------------------------*/
;;;359    void TouchPadStateInit (TOUCH_PAD_CTRL_STRC *Ctrl) {
000000  4902              LDR      r1,|L29.12|
;;;360      Ctrl->ThermostatDataPtr = ThermostatDataPtr;
000002  6809              LDR      r1,[r1,#0]  ; ThermostatDataPtr
;;;361      Ctrl->Touch_State = INIT_STATE;
000004  6081              STR      r1,[r0,#8]
000006  2102              MOVS     r1,#2
000008  7041              STRB     r1,[r0,#1]
;;;362      return;
;;;363    }
00000a  4770              BX       lr
;;;364    
                          ENDP

                  |L29.12|
                          DCD      ||.data||

                          AREA ||i.TouchPadStateTask||, CODE, READONLY, ALIGN=1

                  TouchPadStateTask PROC
;;;367     *----------------------------------------------------------------------------*/
;;;368    void TouchPadStateTask (TOUCH_PAD_CTRL_STRC *Ctrl) {
000000  b538              PUSH     {r3-r5,lr}
000002  4604              MOV      r4,r0
;;;369      if (Ctrl->Touch_State == INIT_STATE   || \
000004  7840              LDRB     r0,[r0,#1]
000006  2802              CMP      r0,#2
000008  d015              BEQ      |L30.54|
;;;370          Ctrl->Touch_State == CHANGE_STATE || \
00000a  2800              CMP      r0,#0
00000c  d013              BEQ      |L30.54|
;;;371          Ctrl->Touch_State == HOLD_STATE   || \
00000e  2803              CMP      r0,#3
000010  d011              BEQ      |L30.54|
;;;372          Ctrl->Valid                       || \
000012  7820              LDRB     r0,[r4,#0]
000014  2800              CMP      r0,#0
000016  d10e              BNE      |L30.54|
;;;373          Ctrl->ThermostatDataPtr->MISC.GUI_INIT_READY == FALSE) {
000018  68a0              LDR      r0,[r4,#8]
00001a  7a00              LDRB     r0,[r0,#8]
00001c  07c0              LSLS     r0,r0,#31
00001e  d00a              BEQ      |L30.54|
;;;374          return;
;;;375      }
;;;376    
;;;377      if (Ctrl->Offset <= eWD608_VECTOR) {
000020  78a2              LDRB     r2,[r4,#2]
000022  2ac3              CMP      r2,#0xc3
000024  d807              BHI      |L30.54|
;;;378          ReadingTouchSensor (Ctrl->ctx, TOUCH_SLAVE_ADDR, Ctrl->Offset, 0x01, TRUE);
000026  2501              MOVS     r5,#1
000028  9500              STR      r5,[sp,#0]
00002a  462b              MOV      r3,r5
00002c  2110              MOVS     r1,#0x10
00002e  6860              LDR      r0,[r4,#4]
000030  f7fffffe          BL       ReadingTouchSensor
;;;379          Ctrl->Valid = TRUE;
000034  7025              STRB     r5,[r4,#0]
                  |L30.54|
;;;380          //TOUCH_PAD_STATE_MSG("ReadingTouchSensor(), Offset: %x\n", Ctrl->Offset);
;;;381      }
;;;382    
;;;383      return;
;;;384    }
000036  bd38              POP      {r3-r5,pc}
;;;385    
                          ENDP


                          AREA ||i.UpdateFlashData||, CODE, READONLY, ALIGN=1

                  UpdateFlashData PROC
;;;157     *----------------------------------------------------------------------------*/
;;;158    uint8_t UpdateFlashData (FMC_CTRL_STRC *Ctrl) {
000000  6882              LDR      r2,[r0,#8]
;;;159      uint8_t  Status = FALSE;
;;;160    
;;;161      if (Ctrl->FlashDataPtr->NvramBrightness != Ctrl->ThermostatDataPtr->Brightness) {
000002  6840              LDR      r0,[r0,#4]
000004  2100              MOVS     r1,#0                 ;159
000006  6812              LDR      r2,[r2,#0]
000008  6800              LDR      r0,[r0,#0]
00000a  4282              CMP      r2,r0
00000c  d000              BEQ      |L31.16|
;;;162          Status = TRUE;
00000e  2101              MOVS     r1,#1
                  |L31.16|
;;;163      }
;;;164      
;;;165      FMC_STATE_MSG("UpdateFlashData - Status: %x\n", Status);
;;;166    
;;;167      return Status;
000010  4608              MOV      r0,r1
;;;168    }
000012  4770              BX       lr
;;;169    
                          ENDP


                          AREA ||i.VariableToFlashData||, CODE, READONLY, ALIGN=1

                  VariableToFlashData PROC
;;;144     *----------------------------------------------------------------------------*/
;;;145    void VariableToFlashData (FMC_CTRL_STRC *Ctrl) {
000000  6841              LDR      r1,[r0,#4]
;;;146    
;;;147      Ctrl->FlashDataPtr->NvramBrightness = Ctrl->ThermostatDataPtr->Brightness;
000002  6880              LDR      r0,[r0,#8]
000004  6809              LDR      r1,[r1,#0]
000006  6001              STR      r1,[r0,#0]
;;;148    
;;;149      FMC_STATE_MSG("VariableToFlashData - Brightness: %d\n", \
;;;150                     Ctrl->ThermostatDataPtr->Brightness);
;;;151    
;;;152      return;
;;;153    }
000008  4770              BX       lr
;;;154    
                          ENDP


                          AREA ||i.main||, CODE, READONLY, ALIGN=1

                  main PROC
;;;912    /*---------------------------------------------------------------------------------------------------------*/
;;;913    int32_t main (void) {
000000  f7fffffe          BL       Platform_Initialize
;;;914    
;;;915      Platform_Initialize ();
;;;916    
;;;917      MainTask ();
000004  f7fffffe          BL       MainTask
;;;918    
;;;919    }
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  ThermostatData
                          %        12

                          AREA ||area_number.36||, DATA, NOINIT, ALIGN=2

                          EXPORTAS ||area_number.36||, ||.bss||
                  TimerCtrl
                          %        28

                          AREA ||area_number.37||, DATA, NOINIT, ALIGN=2

                          EXPORTAS ||area_number.37||, ||.bss||
                  FmcCtrl
                          %        16

                          AREA ||area_number.38||, DATA, NOINIT, ALIGN=2

                          EXPORTAS ||area_number.38||, ||.bss||
                  GuiCtrl
                          %        16

                          AREA ||area_number.39||, DATA, NOINIT, ALIGN=2

                          EXPORTAS ||area_number.39||, ||.bss||
                  TouchPadCtrl
                          %        16

                          AREA ||area_number.40||, DATA, NOINIT, ALIGN=2

                          EXPORTAS ||area_number.40||, ||.bss||
                  RotaryCtrl
                          %        28

                          AREA ||area_number.41||, DATA, NOINIT, ALIGN=2

                          EXPORTAS ||area_number.41||, ||.bss||
                  JoystickCtrl
                          %        20

                          AREA ||area_number.42||, DATA, NOINIT, ALIGN=2

                          EXPORTAS ||area_number.42||, ||.bss||
                  EepromRead
                          %        40

                          AREA ||area_number.43||, DATA, NOINIT, ALIGN=2

                          EXPORTAS ||area_number.43||, ||.bss||
                  EepromWrite
                          %        40

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

000000  4672616d          DCB      0x46,0x72,0x61,0x6d
000004  6577696e          DCB      0x65,0x77,0x69,0x6e
000008  3a205665          DCB      0x3a,0x20,0x56,0x65
00000c  7273696f          DCB      0x72,0x73,0x69,0x6f
000010  6e206f66          DCB      0x6e,0x20,0x6f,0x66
000014  20656d57          DCB      0x20,0x65,0x6d,0x57
000018  696e3a20          DCB      0x69,0x6e,0x3a,0x20
00001c  00000000          DCB      0x00,0x00,0x00,0x00
                          %        8

                          AREA ||.data||, DATA, ALIGN=2

                  ThermostatDataPtr
                          DCD      ThermostatData
                  FlashDataPtr
                          DCD      FlashData
                  TimerCtrlPtr
                          DCD      TimerCtrl
                  FmcCtrlPtr
                          DCD      FmcCtrl
                  GuiCtrlPtr
                          DCD      GuiCtrl
                  TouchPadCtrlPtr
                          DCD      TouchPadCtrl
                  RotaryCtrlPtr
                          DCD      RotaryCtrl
                  JoystickCtrlPtr
                          DCD      JoystickCtrl
                  EepromReadPtr
                          DCD      EepromRead
                  EepromWritePtr
                          DCD      EepromWrite

                          AREA ||area_number.47||, DATA, ALIGN=2

                          EXPORTAS ||area_number.47||, ||.data||
                  FlashData
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\Thermostat\\thermostat.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___12_thermostat_c_d3177e17____REV16|
#line 464 "..\\..\\..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___12_thermostat_c_d3177e17____REV16| PROC
#line 465

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___12_thermostat_c_d3177e17____REVSH|
#line 479
|__asm___12_thermostat_c_d3177e17____REVSH| PROC
#line 480

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___12_thermostat_c_d3177e17____RRX|
#line 666
|__asm___12_thermostat_c_d3177e17____RRX| PROC
#line 667

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***

                  __ARM_use_no_argv EQU 0
