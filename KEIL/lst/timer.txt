; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\obj\timer.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\timer.d --cpu=Cortex-M4.fp --apcs=interwork -O3 --diag_suppress=9931 -I..\..\..\..\Library\Device\Nuvoton\M480\Include -I..\..\..\..\Library\StdDriver\inc -I..\..\..\..\ThirdParty\emWin\Config -I..\..\..\..\ThirdParty\emWin\Include -I..\tslib -I..\..\..\..\Library\CMSIS\Include -I..\Thermostat -I..\Application\Source\Generated -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=523 --omf_browse=.\obj\timer.crf ..\..\..\..\Library\StdDriver\src\timer.c]
                          THUMB

                          AREA ||i.TIMER_Close||, CODE, READONLY, ALIGN=1

                  TIMER_Close PROC
;;;73       */
;;;74     void TIMER_Close(TIMER_T *timer)
000000  2100              MOVS     r1,#0
;;;75     {
;;;76         timer->CTL = 0UL;
000002  6001              STR      r1,[r0,#0]
;;;77         timer->EXTCTL = 0UL;
000004  6141              STR      r1,[r0,#0x14]
;;;78     }
000006  4770              BX       lr
;;;79     
                          ENDP


                          AREA ||i.TIMER_Delay||, CODE, READONLY, ALIGN=2

                  TIMER_Delay PROC
;;;93       */
;;;94     int32_t TIMER_Delay(TIMER_T *timer, uint32_t u32Usec)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;95     {
000004  460c              MOV      r4,r1
000006  4605              MOV      r5,r0
;;;96         uint32_t u32Clk = TIMER_GetModuleClock(timer);
000008  f7fffffe          BL       TIMER_GetModuleClock
;;;97         uint32_t u32Prescale = 0UL, u32Delay;
00000c  2600              MOVS     r6,#0
00000e  4601              MOV      r1,r0                 ;96
;;;98         uint32_t u32Cmpr, u32Cntr, u32NsecPerTick, i = 0UL;
000010  4637              MOV      r7,r6
;;;99     
;;;100        /* Clear current timer configuration */
;;;101        timer->CTL = 0UL;
000012  602e              STR      r6,[r5,#0]
;;;102        timer->EXTCTL = 0UL;
000014  616e              STR      r6,[r5,#0x14]
;;;103    
;;;104        if(u32Clk <= 1000000UL)   /* min delay is 1000 us if timer clock source is <= 1 MHz */
000016  4825              LDR      r0,|L2.172|
000018  4281              CMP      r1,r0
00001a  d805              BHI      |L2.40|
;;;105        {
;;;106            if(u32Usec < 1000UL)
00001c  f44f727a          MOV      r2,#0x3e8
000020  4294              CMP      r4,r2
000022  d205              BCS      |L2.48|
;;;107            {
;;;108                u32Usec = 1000UL;
000024  4614              MOV      r4,r2
000026  e006              B        |L2.54|
                  |L2.40|
;;;109            }
;;;110            if(u32Usec > 1000000UL)
;;;111            {
;;;112                u32Usec = 1000000UL;
;;;113            }
;;;114        }
;;;115        else
;;;116        {
;;;117            if(u32Usec < 100UL)
000028  2c64              CMP      r4,#0x64
00002a  d201              BCS      |L2.48|
;;;118            {
;;;119                u32Usec = 100UL;
00002c  2464              MOVS     r4,#0x64
00002e  e002              B        |L2.54|
                  |L2.48|
;;;120            }
;;;121            if(u32Usec > 1000000UL)
000030  4284              CMP      r4,r0
000032  d900              BLS      |L2.54|
;;;122            {
;;;123                u32Usec = 1000000UL;
000034  4604              MOV      r4,r0
                  |L2.54|
;;;124            }
;;;125        }
;;;126    
;;;127        if(u32Clk <= 1000000UL)
000036  4281              CMP      r1,r0
000038  d808              BHI      |L2.76|
;;;128        {
;;;129            u32Prescale = 0UL;
;;;130            u32NsecPerTick = 1000000000UL / u32Clk;
00003a  481d              LDR      r0,|L2.176|
;;;131            u32Cmpr = (u32Usec * 1000UL) / u32NsecPerTick;
00003c  f44f727a          MOV      r2,#0x3e8
000040  fbb0f0f1          UDIV     r0,r0,r1              ;130
000044  4354              MULS     r4,r2,r4
000046  fbb4f0f0          UDIV     r0,r4,r0
00004a  e007              B        |L2.92|
                  |L2.76|
;;;132        }
;;;133        else
;;;134        {
;;;135            u32Cmpr = u32Usec * (u32Clk / 1000000UL);
00004c  fbb1f0f0          UDIV     r0,r1,r0
000050  4360              MULS     r0,r4,r0
;;;136            u32Prescale = (u32Cmpr >> 24);  /* for 24 bits CMPDAT */
000052  0e06              LSRS     r6,r0,#24
;;;137            if (u32Prescale > 0UL)
000054  d002              BEQ      |L2.92|
;;;138                u32Cmpr = u32Cmpr / (u32Prescale + 1UL);
000056  1c72              ADDS     r2,r6,#1
000058  fbb0f0f2          UDIV     r0,r0,r2
                  |L2.92|
;;;139        }
;;;140    
;;;141        timer->CMP = u32Cmpr;
00005c  6068              STR      r0,[r5,#4]
;;;142        timer->CTL = TIMER_CTL_CNTEN_Msk | TIMER_ONESHOT_MODE | u32Prescale;
00005e  f0464080          ORR      r0,r6,#0x40000000
000062  6028              STR      r0,[r5,#0]
;;;143    
;;;144        /* When system clock is faster than timer clock, it is possible timer active bit cannot set
;;;145           in time while we check it. And the while loop below return immediately, so put a tiny
;;;146           delay larger than 1 ECLK here allowing timer start counting and raise active flag. */
;;;147        for(u32Delay = (SystemCoreClock / u32Clk) + 1UL; u32Delay > 0UL; u32Delay--)
000064  4c13              LDR      r4,|L2.180|
000066  6820              LDR      r0,[r4,#0]  ; SystemCoreClock
000068  fbb0f0f1          UDIV     r0,r0,r1
00006c  1c40              ADDS     r0,r0,#1
00006e  d002              BEQ      |L2.118|
                  |L2.112|
;;;148        {
;;;149            __NOP();
000070  bf00              NOP      
000072  1e40              SUBS     r0,r0,#1
000074  d1fc              BNE      |L2.112|
                  |L2.118|
;;;150        }
;;;151    
;;;152        /* Add a bail out counter here in case timer clock source is disabled accidentally.
;;;153           Prescale counter reset every ECLK * (prescale value + 1).
;;;154           The u32Delay here is to make sure timer counter value changed when prescale counter reset */
;;;155        u32Delay = (SystemCoreClock / TIMER_GetModuleClock(timer)) * (u32Prescale + 1);
000076  4628              MOV      r0,r5
000078  f7fffffe          BL       TIMER_GetModuleClock
00007c  6821              LDR      r1,[r4,#0]  ; SystemCoreClock
00007e  1c76              ADDS     r6,r6,#1
000080  fbb1f0f0          UDIV     r0,r1,r0
000084  4370              MULS     r0,r6,r0
;;;156        u32Cntr = timer->CNT;
;;;157        while(timer->CTL & TIMER_CTL_ACTSTS_Msk)
000086  e00b              B        |L2.160|
                  |L2.136|
;;;158        {
;;;159            /* Bailed out if timer stop counting e.g. Some interrupt handler close timer clock source. */
;;;160            if(u32Cntr == timer->CNT)
000088  68ea              LDR      r2,[r5,#0xc]
00008a  428a              CMP      r2,r1
00008c  d107              BNE      |L2.158|
;;;161            {
;;;162                if(i++ > u32Delay)
00008e  463a              MOV      r2,r7
000090  1c7f              ADDS     r7,r7,#1
000092  4282              CMP      r2,r0
000094  d905              BLS      |L2.162|
;;;163                {
;;;164                    return TIMER_TIMEOUT_ERR;
000096  f04f30ff          MOV      r0,#0xffffffff
                  |L2.154|
;;;165                }
;;;166            }
;;;167            else
;;;168            {
;;;169                i = 0;
;;;170                u32Cntr = timer->CNT;
;;;171            }
;;;172        }
;;;173        return 0;
;;;174    }
00009a  e8bd81f0          POP      {r4-r8,pc}
                  |L2.158|
00009e  2700              MOVS     r7,#0                 ;169
                  |L2.160|
0000a0  68e9              LDR      r1,[r5,#0xc]          ;156
                  |L2.162|
0000a2  682a              LDR      r2,[r5,#0]            ;157
0000a4  0192              LSLS     r2,r2,#6              ;157
0000a6  d4ef              BMI      |L2.136|
0000a8  2000              MOVS     r0,#0                 ;173
0000aa  e7f6              B        |L2.154|
;;;175    
                          ENDP

                  |L2.172|
                          DCD      0x000f4240
                  |L2.176|
                          DCD      0x3b9aca00
                  |L2.180|
                          DCD      SystemCoreClock

                          AREA ||i.TIMER_DisableCapture||, CODE, READONLY, ALIGN=1

                  TIMER_DisableCapture PROC
;;;209      */
;;;210    void TIMER_DisableCapture(TIMER_T *timer)
000000  6941              LDR      r1,[r0,#0x14]
;;;211    {
;;;212        timer->EXTCTL &= ~TIMER_EXTCTL_CAPEN_Msk;
000002  f0210108          BIC      r1,r1,#8
000006  6141              STR      r1,[r0,#0x14]
;;;213    }
000008  4770              BX       lr
;;;214    
                          ENDP


                          AREA ||i.TIMER_DisableEventCounter||, CODE, READONLY, ALIGN=1

                  TIMER_DisableEventCounter PROC
;;;243      */
;;;244    void TIMER_DisableEventCounter(TIMER_T *timer)
000000  6801              LDR      r1,[r0,#0]
;;;245    {
;;;246        timer->CTL &= ~TIMER_CTL_EXTCNTEN_Msk;
000002  f0217180          BIC      r1,r1,#0x1000000
000006  6001              STR      r1,[r0,#0]
;;;247    }
000008  4770              BX       lr
;;;248    
                          ENDP


                          AREA ||i.TIMER_DisableFreqCounter||, CODE, READONLY, ALIGN=1

                  TIMER_DisableFreqCounter PROC
;;;334      */
;;;335    void TIMER_DisableFreqCounter(TIMER_T *timer)
000000  6801              LDR      r1,[r0,#0]
;;;336    {
;;;337        timer->CTL &= ~TIMER_CTL_INTRGEN_Msk;
000002  f4212100          BIC      r1,r1,#0x80000
000006  6001              STR      r1,[r0,#0]
;;;338    }
000008  4770              BX       lr
;;;339    
                          ENDP


                          AREA ||i.TIMER_EnableCapture||, CODE, READONLY, ALIGN=1

                  TIMER_EnableCapture PROC
;;;194      */
;;;195    void TIMER_EnableCapture(TIMER_T *timer, uint32_t u32CapMode, uint32_t u32Edge)
000000  b510              PUSH     {r4,lr}
;;;196    {
;;;197        timer->EXTCTL = (timer->EXTCTL & ~(TIMER_EXTCTL_CAPFUNCS_Msk | TIMER_EXTCTL_CAPEDGE_Msk)) |
000002  6943              LDR      r3,[r0,#0x14]
000004  f2470410          MOV      r4,#0x7010
000008  43a3              BICS     r3,r3,r4
00000a  430b              ORRS     r3,r3,r1
00000c  4313              ORRS     r3,r3,r2
00000e  f0430108          ORR      r1,r3,#8
000012  6141              STR      r1,[r0,#0x14]
;;;198                        u32CapMode | u32Edge | TIMER_EXTCTL_CAPEN_Msk;
;;;199    }
000014  bd10              POP      {r4,pc}
;;;200    
                          ENDP


                          AREA ||i.TIMER_EnableEventCounter||, CODE, READONLY, ALIGN=1

                  TIMER_EnableEventCounter PROC
;;;228      */
;;;229    void TIMER_EnableEventCounter(TIMER_T *timer, uint32_t u32Edge)
000000  6942              LDR      r2,[r0,#0x14]
;;;230    {
;;;231        timer->EXTCTL = (timer->EXTCTL & ~TIMER_EXTCTL_CNTPHASE_Msk) | u32Edge;
000002  f0220201          BIC      r2,r2,#1
000006  430a              ORRS     r2,r2,r1
000008  6142              STR      r2,[r0,#0x14]
;;;232        timer->CTL |= TIMER_CTL_EXTCNTEN_Msk;
00000a  6801              LDR      r1,[r0,#0]
00000c  f0417180          ORR      r1,r1,#0x1000000
000010  6001              STR      r1,[r0,#0]
;;;233    }
000012  4770              BX       lr
;;;234    
                          ENDP


                          AREA ||i.TIMER_EnableFreqCounter||, CODE, READONLY, ALIGN=2

                  TIMER_EnableFreqCounter PROC
;;;314      */
;;;315    void TIMER_EnableFreqCounter(TIMER_T *timer,
000000  4908              LDR      r1,|L8.36|
;;;316                                 uint32_t u32DropCount,
;;;317                                 uint32_t u32Timeout,
;;;318                                 uint32_t u32EnableInt)
;;;319    {
;;;320        TIMER_T *t;    /* store the timer base to configure compare value */
;;;321    
;;;322        t = (timer == TIMER0) ? TIMER1 : TIMER3;
000002  4288              CMP      r0,r1
000004  d101              BNE      |L8.10|
000006  4908              LDR      r1,|L8.40|
000008  e000              B        |L8.12|
                  |L8.10|
00000a  4908              LDR      r1,|L8.44|
                  |L8.12|
;;;323    
;;;324        t->CMP = 0xFFFFFFUL;
00000c  f06f427f          MVN      r2,#0xff000000
000010  604a              STR      r2,[r1,#4]
;;;325        t->EXTCTL = u32EnableInt ? TIMER_EXTCTL_CAPIEN_Msk : 0UL;
000012  b10b              CBZ      r3,|L8.24|
000014  2220              MOVS     r2,#0x20
000016  e000              B        |L8.26|
                  |L8.24|
000018  2200              MOVS     r2,#0
                  |L8.26|
00001a  614a              STR      r2,[r1,#0x14]
;;;326        timer->CTL = TIMER_CTL_INTRGEN_Msk | TIMER_CTL_CNTEN_Msk;
00001c  4904              LDR      r1,|L8.48|
00001e  6001              STR      r1,[r0,#0]
;;;327    
;;;328        return;
;;;329    }
000020  4770              BX       lr
;;;330    /**
                          ENDP

000022  0000              DCW      0x0000
                  |L8.36|
                          DCD      0x40050000
                  |L8.40|
                          DCD      0x40050100
                  |L8.44|
                          DCD      0x40051100
                  |L8.48|
                          DCD      0x40080000

                          AREA ||i.TIMER_GetModuleClock||, CODE, READONLY, ALIGN=2

                  TIMER_GetModuleClock PROC
;;;258      */
;;;259    uint32_t TIMER_GetModuleClock(TIMER_T *timer)
000000  b510              PUSH     {r4,lr}
;;;260    {
000002  b088              SUB      sp,sp,#0x20
000004  4604              MOV      r4,r0
;;;261        uint32_t u32Src, u32Clk;
;;;262        const uint32_t au32Clk[] = {__HXT, __LXT, 0UL, 0UL, 0UL, __LIRC, 0UL, __HIRC};
000006  2220              MOVS     r2,#0x20
000008  4917              LDR      r1,|L9.104|
00000a  4668              MOV      r0,sp
00000c  f7fffffe          BL       __aeabi_memcpy4
;;;263    
;;;264        if(timer == TIMER0)
000010  4916              LDR      r1,|L9.108|
;;;265        {
;;;266            u32Src = (CLK->CLKSEL1 & CLK_CLKSEL1_TMR0SEL_Msk) >> CLK_CLKSEL1_TMR0SEL_Pos;
;;;267        }
;;;268        else if(timer == TIMER1)
000012  4a17              LDR      r2,|L9.112|
000014  0388              LSLS     r0,r1,#14             ;266
000016  428c              CMP      r4,r1                 ;264
000018  d104              BNE      |L9.36|
00001a  f8d00214          LDR      r0,[r0,#0x214]        ;266
00001e  f3c02002          UBFX     r0,r0,#8,#3           ;266
000022  e010              B        |L9.70|
                  |L9.36|
000024  4294              CMP      r4,r2
000026  d104              BNE      |L9.50|
;;;269        {
;;;270            u32Src = (CLK->CLKSEL1 & CLK_CLKSEL1_TMR1SEL_Msk) >> CLK_CLKSEL1_TMR1SEL_Pos;
000028  f8d00214          LDR      r0,[r0,#0x214]
00002c  f3c03002          UBFX     r0,r0,#12,#3
000030  e009              B        |L9.70|
                  |L9.50|
;;;271        }
;;;272        else if(timer == TIMER2)
000032  4b10              LDR      r3,|L9.116|
;;;273        {
;;;274            u32Src = (CLK->CLKSEL1 & CLK_CLKSEL1_TMR2SEL_Msk) >> CLK_CLKSEL1_TMR2SEL_Pos;
;;;275        }
;;;276        else      /* Timer 3 */
;;;277        {
;;;278            u32Src = (CLK->CLKSEL1 & CLK_CLKSEL1_TMR3SEL_Msk) >> CLK_CLKSEL1_TMR3SEL_Pos;
000034  f8d00214          LDR      r0,[r0,#0x214]
000038  429c              CMP      r4,r3                 ;272
00003a  d102              BNE      |L9.66|
00003c  f3c04002          UBFX     r0,r0,#16,#3          ;274
000040  e001              B        |L9.70|
                  |L9.66|
000042  f3c05002          UBFX     r0,r0,#20,#3
                  |L9.70|
;;;279        }
;;;280    
;;;281        if(u32Src == 2UL)
000046  2802              CMP      r0,#2
000048  d003              BEQ      |L9.82|
;;;282        {
;;;283            if((timer == TIMER0) || (timer == TIMER1))
;;;284            {
;;;285                u32Clk = CLK_GetPCLK0Freq();
;;;286            }
;;;287            else
;;;288            {
;;;289                u32Clk = CLK_GetPCLK1Freq();
;;;290            }
;;;291        }
;;;292        else
;;;293        {
;;;294            u32Clk = au32Clk[u32Src];
00004a  f85d0020          LDR      r0,[sp,r0,LSL #2]
                  |L9.78|
;;;295        }
;;;296    
;;;297        return u32Clk;
;;;298    }
00004e  b008              ADD      sp,sp,#0x20
000050  bd10              POP      {r4,pc}
                  |L9.82|
000052  428c              CMP      r4,r1                 ;283
000054  d001              BEQ      |L9.90|
000056  4294              CMP      r4,r2                 ;283
000058  d102              BNE      |L9.96|
                  |L9.90|
00005a  f7fffffe          BL       CLK_GetPCLK0Freq
00005e  e7f6              B        |L9.78|
                  |L9.96|
000060  f7fffffe          BL       CLK_GetPCLK1Freq
000064  e7f3              B        |L9.78|
;;;299    
                          ENDP

000066  0000              DCW      0x0000
                  |L9.104|
                          DCD      ||.constdata||
                  |L9.108|
                          DCD      0x40050000
                  |L9.112|
                          DCD      0x40050100
                  |L9.116|
                          DCD      0x40051000

                          AREA ||i.TIMER_Open||, CODE, READONLY, ALIGN=1

                  TIMER_Open PROC
;;;40       */
;;;41     uint32_t TIMER_Open(TIMER_T *timer, uint32_t u32Mode, uint32_t u32Freq)
000000  b570              PUSH     {r4-r6,lr}
;;;42     {
000002  4616              MOV      r6,r2
000004  460d              MOV      r5,r1
000006  4604              MOV      r4,r0
;;;43         uint32_t u32Clk = TIMER_GetModuleClock(timer);
000008  f7fffffe          BL       TIMER_GetModuleClock
;;;44         uint32_t u32Cmpr = 0UL, u32Prescale = 0UL;
00000c  2300              MOVS     r3,#0
;;;45     
;;;46         /* Fastest possible timer working freq is (u32Clk / 2). While cmpr = 2, prescaler = 0. */
;;;47         if(u32Freq > (u32Clk / 2UL))
00000e  ebb60f50          CMP      r6,r0,LSR #1
000012  d901              BLS      |L10.24|
;;;48         {
;;;49             u32Cmpr = 2UL;
000014  2202              MOVS     r2,#2
000016  e006              B        |L10.38|
                  |L10.24|
;;;50         }
;;;51         else
;;;52         {
;;;53             u32Cmpr = u32Clk / u32Freq;
000018  fbb0f2f6          UDIV     r2,r0,r6
;;;54             u32Prescale = (u32Cmpr >> 24);  /* for 24 bits CMPDAT */
00001c  0e13              LSRS     r3,r2,#24
;;;55             if (u32Prescale > 0UL)
00001e  d002              BEQ      |L10.38|
;;;56                 u32Cmpr = u32Cmpr / (u32Prescale + 1UL);
000020  1c59              ADDS     r1,r3,#1
000022  fbb2f2f1          UDIV     r2,r2,r1
                  |L10.38|
;;;57         }
;;;58     
;;;59         timer->CTL = u32Mode | u32Prescale;
000026  431d              ORRS     r5,r5,r3
000028  6025              STR      r5,[r4,#0]
;;;60         timer->CMP = u32Cmpr;
00002a  6062              STR      r2,[r4,#4]
00002c  1c5b              ADDS     r3,r3,#1
;;;61     
;;;62         return(u32Clk / (u32Cmpr * (u32Prescale + 1UL)));
00002e  435a              MULS     r2,r3,r2
000030  fbb0f0f2          UDIV     r0,r0,r2
;;;63     }
000034  bd70              POP      {r4-r6,pc}
;;;64     
                          ENDP


                          AREA ||i.TIMER_ResetCounter||, CODE, READONLY, ALIGN=2

                  TIMER_ResetCounter PROC
;;;379      */
;;;380    int32_t TIMER_ResetCounter(TIMER_T *timer)
000000  b510              PUSH     {r4,lr}
;;;381    {
000002  4604              MOV      r4,r0
;;;382        uint32_t u32Delay;
;;;383    
;;;384        timer->CNT = 0UL;
000004  2000              MOVS     r0,#0
000006  60e0              STR      r0,[r4,#0xc]
;;;385        /* Takes 2~3 ECLKs to reset timer counter */
;;;386        u32Delay = (SystemCoreClock / TIMER_GetModuleClock(timer)) * 3;
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       TIMER_GetModuleClock
00000e  490a              LDR      r1,|L11.56|
000010  6809              LDR      r1,[r1,#0]  ; SystemCoreClock
000012  fbb1f0f0          UDIV     r0,r1,r0
000016  eb000140          ADD      r1,r0,r0,LSL #1
;;;387        while(((timer->CNT&TIMER_CNT_RSTACT_Msk) == TIMER_CNT_RSTACT_Msk) && (--u32Delay))
00001a  e000              B        |L11.30|
                  |L11.28|
;;;388        {
;;;389            __NOP();
00001c  bf00              NOP      
                  |L11.30|
00001e  68e0              LDR      r0,[r4,#0xc]          ;387
000020  2800              CMP      r0,#0                 ;387
000022  da02              BGE      |L11.42|
000024  1e49              SUBS     r1,r1,#1              ;387
000026  d1f9              BNE      |L11.28|
000028  e002              B        |L11.48|
                  |L11.42|
;;;390        }
;;;391        return u32Delay > 0 ? 0 : TIMER_TIMEOUT_ERR;
00002a  b109              CBZ      r1,|L11.48|
00002c  2000              MOVS     r0,#0
;;;392    }
00002e  bd10              POP      {r4,pc}
                  |L11.48|
000030  f04f30ff          MOV      r0,#0xffffffff        ;391
000034  bd10              POP      {r4,pc}
;;;393    
                          ENDP

000036  0000              DCW      0x0000
                  |L11.56|
                          DCD      SystemCoreClock

                          AREA ||i.TIMER_SetTriggerSource||, CODE, READONLY, ALIGN=1

                  TIMER_SetTriggerSource PROC
;;;348      */
;;;349    void TIMER_SetTriggerSource(TIMER_T *timer, uint32_t u32Src)
000000  69c2              LDR      r2,[r0,#0x1c]
;;;350    {
;;;351        timer->TRGCTL = (timer->TRGCTL & ~TIMER_TRGCTL_TRGSSEL_Msk) | u32Src;
000002  f0220201          BIC      r2,r2,#1
000006  430a              ORRS     r2,r2,r1
000008  61c2              STR      r2,[r0,#0x1c]
;;;352    }
00000a  4770              BX       lr
;;;353    
                          ENDP


                          AREA ||i.TIMER_SetTriggerTarget||, CODE, READONLY, ALIGN=1

                  TIMER_SetTriggerTarget PROC
;;;363      */
;;;364    void TIMER_SetTriggerTarget(TIMER_T *timer, uint32_t u32Mask)
000000  69c2              LDR      r2,[r0,#0x1c]
;;;365    {
;;;366        timer->TRGCTL = (timer->TRGCTL & ~(TIMER_TRGCTL_TRGEPWM_Msk | TIMER_TRGCTL_TRGDAC_Msk | TIMER_TRGCTL_TRGEADC_Msk | TIMER_TRGCTL_TRGPDMA_Msk)) | u32Mask;
000002  f022021e          BIC      r2,r2,#0x1e
000006  430a              ORRS     r2,r2,r1
000008  61c2              STR      r2,[r0,#0x1c]
;;;367    }
00000a  4770              BX       lr
;;;368    
                          ENDP


                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                          DCD      0x00b71b00
                          DCD      0x00008000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00002710
                          DCD      0x00000000
                          DCD      0x00b71b00

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\..\\Library\\StdDriver\\src\\timer.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___7_timer_c_5bec749a____REV16|
#line 464 "..\\..\\..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___7_timer_c_5bec749a____REV16| PROC
#line 465

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___7_timer_c_5bec749a____REVSH|
#line 479
|__asm___7_timer_c_5bec749a____REVSH| PROC
#line 480

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___7_timer_c_5bec749a____RRX|
#line 666
|__asm___7_timer_c_5bec749a____RRX| PROC
#line 667

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
