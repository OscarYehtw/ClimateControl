; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\obj\ts_calibrate.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\ts_calibrate.d --cpu=Cortex-M4.fp --apcs=interwork -O3 --diag_suppress=9931 -I..\..\..\..\Library\Device\Nuvoton\M480\Include -I..\..\..\..\Library\StdDriver\inc -I..\..\..\..\ThirdParty\emWin\Config -I..\..\..\..\ThirdParty\emWin\Include -I..\tslib -I..\..\..\..\Library\CMSIS\Include -I..\Thermostat -I..\Application\Source\Generated -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=523 --omf_browse=.\obj\ts_calibrate.crf ..\tslib\ts_calibrate.c]
                          THUMB

                          AREA ||i.DisplayFailStatus||, CODE, READONLY, ALIGN=2

                  DisplayFailStatus PROC
;;;65     
;;;66     int DisplayFailStatus(int xsize, int ysize)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;67     {
000004  4606              MOV      r6,r0
000006  460c              MOV      r4,r1
;;;68         int i;
;;;69     
;;;70         GUI_SetFont(&GUI_Font32_ASCII);
000008  4813              LDR      r0,|L1.88|
00000a  f7fffffe          BL       GUI_SetFont
;;;71         GUI_SetTextMode(GUI_TM_XOR);
00000e  2001              MOVS     r0,#1
000010  f7fffffe          BL       GUI_SetTextMode
;;;72     
;;;73         for (i=0; i<3; i++)
000014  2500              MOVS     r5,#0
;;;74         {
;;;75             GUI_DispStringHCenterAt("Fail to calibrate", xsize / 2, ysize / 4 + 30);
000016  201e              MOVS     r0,#0x1e
000018  17e1              ASRS     r1,r4,#31
00001a  eb047191          ADD      r1,r4,r1,LSR #30
;;;76             GUI_X_Delay(500);
00001e  f44f77fa          MOV      r7,#0x1f4
000022  eb0676d6          ADD      r6,r6,r6,LSR #31      ;75
000026  eb0004a1          ADD      r4,r0,r1,ASR #2       ;75
                  |L1.42|
00002a  4622              MOV      r2,r4                 ;75
00002c  1071              ASRS     r1,r6,#1              ;75
00002e  a00b              ADR      r0,|L1.92|
000030  f7fffffe          BL       GUI_DispStringHCenterAt
000034  4638              MOV      r0,r7
000036  f7fffffe          BL       GUI_X_Delay
00003a  4622              MOV      r2,r4
;;;77             GUI_DispStringHCenterAt("Fail to calibrate", xsize / 2, ysize / 4 + 30);
00003c  1071              ASRS     r1,r6,#1
00003e  a007              ADR      r0,|L1.92|
000040  f7fffffe          BL       GUI_DispStringHCenterAt
;;;78             GUI_X_Delay(500);
000044  4638              MOV      r0,r7
000046  f7fffffe          BL       GUI_X_Delay
00004a  1c6d              ADDS     r5,r5,#1
00004c  2d03              CMP      r5,#3                 ;73
00004e  dbec              BLT      |L1.42|
;;;79         }
;;;80     
;;;81         return -1;
000050  f04f30ff          MOV      r0,#0xffffffff
;;;82     }
000054  e8bd81f0          POP      {r4-r8,pc}
;;;83     
                          ENDP

                  |L1.88|
                          DCD      GUI_Font32_ASCII
                  |L1.92|
00005c  4661696c          DCB      "Fail to calibrate",0
000060  20746f20
000064  63616c69
000068  62726174
00006c  6500    
00006e  00                DCB      0
00006f  00                DCB      0

                          AREA ||i.compare_x||, CODE, READONLY, ALIGN=1

                  compare_x PROC
;;;99     
;;;100    static int compare_x(const void* arg1, const void *arg2)
000000  6800              LDR      r0,[r0,#0]
;;;101    {
;;;102        int ret;
;;;103        ret = *(int *)arg1 -*(int *)arg2;
000002  6809              LDR      r1,[r1,#0]
000004  1a40              SUBS     r0,r0,r1
;;;104        if ( ret > 0 )
000006  2800              CMP      r0,#0
000008  dd02              BLE      |L2.16|
;;;105            return 1;
00000a  f04f0001          MOV      r0,#1
;;;106        else if ( ret < 0 )
;;;107            return -1;
;;;108        return 0;
;;;109    }
00000e  4770              BX       lr
                  |L2.16|
000010  da02              BGE      |L2.24|
000012  f04f30ff          MOV      r0,#0xffffffff        ;107
000016  4770              BX       lr
                  |L2.24|
000018  f04f0000          MOV      r0,#0                 ;108
00001c  4770              BX       lr
;;;110    
                          ENDP


                          AREA ||i.compare_y||, CODE, READONLY, ALIGN=1

                  compare_y PROC
;;;110    
;;;111    static int compare_y(const void* arg1, const void *arg2)
000000  6800              LDR      r0,[r0,#0]
;;;112    {
;;;113        int ret;
;;;114        ret = *(int *)arg1 -*(int *)arg2;
000002  6809              LDR      r1,[r1,#0]
000004  1a40              SUBS     r0,r0,r1
;;;115        if ( ret > 0 )
000006  2800              CMP      r0,#0
000008  dd02              BLE      |L3.16|
;;;116            return 1;
00000a  f04f0001          MOV      r0,#1
;;;117        else if ( ret < 0 )
;;;118            return -1;
;;;119        return 0;
;;;120    }
00000e  4770              BX       lr
                  |L3.16|
000010  da02              BGE      |L3.24|
000012  f04f30ff          MOV      r0,#0xffffffff        ;118
000016  4770              BX       lr
                  |L3.24|
000018  f04f0000          MOV      r0,#0                 ;119
00001c  4770              BX       lr
;;;121    
                          ENDP


                          AREA ||i.read_calib_sample||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  read_calib_sample PROC
;;;266    
;;;267    int read_calib_sample(char *rect_name, int index, int logx, int logy)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;268    {
000004  4682              MOV      r10,r0
000006  4698              MOV      r8,r3
000008  4615              MOV      r5,r2
00000a  460c              MOV      r4,r1
;;;269        int result;
;;;270    	  GUI_SetColor(GUI_WHITE);
00000c  f04f30ff          MOV      r0,#0xffffffff
000010  f7fffffe          BL       GUI_SetColor
;;;271        write_cross(logx, logy);
000014  4641              MOV      r1,r8
000016  4628              MOV      r0,r5
000018  f7fffffe          BL       write_cross
;;;272        result = read_phy_xy (&physical[index].x, &physical[index].y);
00001c  4e10              LDR      r6,|L4.96|
00001e  eb0607c4          ADD      r7,r6,r4,LSL #3
000022  1d39              ADDS     r1,r7,#4
000024  4638              MOV      r0,r7
000026  f7fffffe          BL       read_phy_xy
00002a  4681              MOV      r9,r0
;;;273    	  GUI_SetColor(GUI_BLACK);
00002c  f04f407f          MOV      r0,#0xff000000
000030  f7fffffe          BL       GUI_SetColor
;;;274        write_cross(logx, logy);
000034  4641              MOV      r1,r8
000036  4628              MOV      r0,r5
000038  f7fffffe          BL       write_cross
;;;275    
;;;276        logical[index].x = logx;
00003c  f1060028          ADD      r0,r6,#0x28
;;;277        logical[index].y = logy;
;;;278    
;;;279        printf("%s : X = %4d Y = %4d\n", rect_name, physical[index].x, physical[index].y);
000040  4651              MOV      r1,r10
000042  f8405034          STR      r5,[r0,r4,LSL #3]     ;276
000046  eb0000c4          ADD      r0,r0,r4,LSL #3       ;277
00004a  f8c08004          STR      r8,[r0,#4]
00004e  f8562034          LDR      r2,[r6,r4,LSL #3]
000052  a004              ADR      r0,|L4.100|
000054  687b              LDR      r3,[r7,#4]
000056  f7fffffe          BL       __2printf
;;;280        return result;
00005a  4648              MOV      r0,r9
;;;281    }
00005c  e8bd87f0          POP      {r4-r10,pc}
;;;282    
                          ENDP

                  |L4.96|
                          DCD      ||.bss||
                  |L4.100|
000064  2573203a          DCB      "%s : X = %4d Y = %4d\n",0
000068  2058203d
00006c  20253464
000070  2059203d
000074  20253464
000078  0a00    
00007a  00                DCB      0
00007b  00                DCB      0

                          AREA ||i.read_phy_xy||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  read_phy_xy PROC
;;;121    
;;;122    int read_phy_xy(int *x, int *y)
000000  e92d47fc          PUSH     {r2-r10,lr}
;;;123    {
000004  4681              MOV      r9,r0
000006  4688              MOV      r8,r1
;;;124    
;;;125        int number, middle;
;;;126        int phyx, phyy;
;;;127    
;;;128        printf("read physical x, y\n");
000008  a036              ADR      r0,|L5.228|
00000a  f7fffffe          BL       __2printf
;;;129    again:
;;;130        while (1)
;;;131        {
;;;132            if ( Read_TouchPanel(&phyx, &phyy) > 0 )
;;;133            {
;;;134                if ( (phyx < 0) || ( phyy < 0 ) )
;;;135                    continue;
;;;136                break;
;;;137            }
;;;138        }
;;;139    
;;;140    // Delay 50 ms to wait HW ADC to be ready
;;;141        GUI_X_Delay(50);
;;;142        number = 0;
;;;143        while (1)
;;;144        {
;;;145            if ( Read_TouchPanel(&phyx, &phyy) > 0)
;;;146            {
;;;147                sampleX[number] = phyx;
00000e  4e3a              LDR      r6,|L5.248|
;;;148                sampleY[number] = phyy;
000010  f5067748          ADD      r7,r6,#0x320
                  |L5.20|
000014  a901              ADD      r1,sp,#4              ;132
000016  4668              MOV      r0,sp                 ;132
000018  f7fffffe          BL       Read_TouchPanel
00001c  2800              CMP      r0,#0                 ;132
00001e  ddf9              BLE      |L5.20|
000020  9800              LDR      r0,[sp,#0]            ;134
000022  2800              CMP      r0,#0                 ;134
000024  dbf6              BLT      |L5.20|
000026  9801              LDR      r0,[sp,#4]            ;134
000028  2800              CMP      r0,#0                 ;134
00002a  dbf3              BLT      |L5.20|
00002c  2032              MOVS     r0,#0x32              ;141
00002e  f7fffffe          BL       GUI_X_Delay
000032  2400              MOVS     r4,#0                 ;142
                  |L5.52|
000034  a901              ADD      r1,sp,#4              ;145
000036  4668              MOV      r0,sp                 ;145
000038  f7fffffe          BL       Read_TouchPanel
00003c  2800              CMP      r0,#0                 ;145
00003e  dd09              BLE      |L5.84|
000040  9800              LDR      r0,[sp,#0]            ;147
000042  f8460024          STR      r0,[r6,r4,LSL #2]     ;147
000046  9801              LDR      r0,[sp,#4]
000048  f8470024          STR      r0,[r7,r4,LSL #2]
;;;149            }
;;;150            else
;;;151            {
;;;152                break;
;;;153            }
;;;154            if ( number < MAX_NUM-1)
00004c  2cc7              CMP      r4,#0xc7
00004e  daf1              BGE      |L5.52|
000050  1c64              ADDS     r4,r4,#1              ;148
;;;155                number++;
000052  e7ef              B        |L5.52|
                  |L5.84|
;;;156        }
;;;157    
;;;158        printf("Capture %d samples\n",number);
000054  4621              MOV      r1,r4
000056  a029              ADR      r0,|L5.252|
000058  f7fffffe          BL       __2printf
;;;159    
;;;160    // pick the average value of the middle for the coordinate x, y
;;;161        middle = number/2;
00005c  eb0470d4          ADD      r0,r4,r4,LSR #31
000060  1045              ASRS     r5,r0,#1
;;;162        qsort(sampleX, number, sizeof(int), compare_x);
000062  4b2b              LDR      r3,|L5.272|
000064  2204              MOVS     r2,#4
000066  4621              MOV      r1,r4
000068  4823              LDR      r0,|L5.248|
00006a  f7fffffe          BL       qsort
;;;163        *x = (sampleX[middle-1] + sampleX[middle]) / 2;
00006e  eb060085          ADD      r0,r6,r5,LSL #2
000072  f8561025          LDR      r1,[r6,r5,LSL #2]
000076  f8500c04          LDR      r0,[r0,#-4]
;;;164    
;;;165        qsort(sampleY, number, sizeof(int), compare_y);
00007a  4b26              LDR      r3,|L5.276|
00007c  4408              ADD      r0,r0,r1              ;163
00007e  eb0070d0          ADD      r0,r0,r0,LSR #31      ;163
000082  1041              ASRS     r1,r0,#1              ;163
000084  f8c91000          STR      r1,[r9,#0]
000088  2204              MOVS     r2,#4
00008a  4621              MOV      r1,r4
00008c  4822              LDR      r0,|L5.280|
00008e  f7fffffe          BL       qsort
;;;166        *y = (sampleY[middle-1] + sampleY[middle]) / 2;
000092  eb070085          ADD      r0,r7,r5,LSL #2
000096  f8571025          LDR      r1,[r7,r5,LSL #2]
00009a  f8500c04          LDR      r0,[r0,#-4]
00009e  4408              ADD      r0,r0,r1
0000a0  eb0070d0          ADD      r0,r0,r0,LSR #31
0000a4  1041              ASRS     r1,r0,#1
;;;167    
;;;168        if ( number <= 10)
0000a6  f8c81000          STR      r1,[r8,#0]
0000aa  2c0a              CMP      r4,#0xa
0000ac  ddb2              BLE      |L5.20|
;;;169            goto again;
;;;170    
;;;171    // >= DIFF, it means touch screen is not stable. stop the calibration
;;;172        if ( abs(sampleY[middle-1] - sampleY[middle]) >= DIFF )
0000ae  eb070085          ADD      r0,r7,r5,LSL #2
0000b2  f8571025          LDR      r1,[r7,r5,LSL #2]
0000b6  f8500c04          LDR      r0,[r0,#-4]
0000ba  1a40              SUBS     r0,r0,r1
0000bc  d500              BPL      |L5.192|
0000be  4240              RSBS     r0,r0,#0
                  |L5.192|
0000c0  2805              CMP      r0,#5
0000c2  da0a              BGE      |L5.218|
;;;173            return 0;
;;;174        if ( abs(sampleX[middle-1] - sampleX[middle]) >= DIFF )
0000c4  eb060085          ADD      r0,r6,r5,LSL #2
0000c8  f8561025          LDR      r1,[r6,r5,LSL #2]
0000cc  f8500c04          LDR      r0,[r0,#-4]
0000d0  1a40              SUBS     r0,r0,r1
0000d2  d500              BPL      |L5.214|
0000d4  4240              RSBS     r0,r0,#0
                  |L5.214|
0000d6  2805              CMP      r0,#5
0000d8  db02              BLT      |L5.224|
                  |L5.218|
;;;175            return 0;
0000da  2000              MOVS     r0,#0
                  |L5.220|
;;;176        return 1;
;;;177    }
0000dc  e8bd87fc          POP      {r2-r10,pc}
                  |L5.224|
0000e0  2001              MOVS     r0,#1                 ;176
0000e2  e7fb              B        |L5.220|
;;;178    
                          ENDP

                  |L5.228|
0000e4  72656164          DCB      "read physical x, y\n",0
0000e8  20706879
0000ec  73696361
0000f0  6c20782c
0000f4  20790a00
                  |L5.248|
                          DCD      ||.bss||+0x50
                  |L5.252|
0000fc  43617074          DCB      "Capture %d samples\n",0
000100  75726520
000104  25642073
000108  616d706c
00010c  65730a00
                  |L5.272|
                          DCD      compare_x
                  |L5.276|
                          DCD      compare_y
                  |L5.280|
                          DCD      ||.bss||+0x370

                          AREA ||i.run_calibration||, CODE, READONLY, ALIGN=2

                  run_calibration PROC
;;;178    
;;;179    int run_calibration(void)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;180    {
;;;181        int i, no;
;;;182        int sum_px, sum_py, sum_pxy, sum_square_px, sum_square_py, sum_lx, sum_lpx, sum_lpy, sum_ly;
;;;183        float deter, im11, im12, im13, im21, im22, im23, im31, im32, im33;
;;;184    
;;;185    // logical.x = physical.x X A + physical.y X B + C
;;;186    // logical.y = physical.x X D + physical.y X E + F
;;;187    
;;;188    // multiple physic.y and physic.y as follows
;;;189    //  logical.x X physical.x = physical.x X A X physical.x+ physical.y X B X physical.x + C X physical.x
;;;190    //  logical.x X physical.y = physical.x X A X physical.y+ physical.y X B X physical.y + C X physical.y
;;;191    // we can obtain the paramters A, B, C from 3 x 3 matrix
;;;192    // In the similiar method, we could also obtain the parameters D, E, F
;;;193    //  logical.y X physical.x = physical.x X D X physical.x+ physical.y X E X physical.x + F X physical.x
;;;194    //  logical.y X physical.y = physical.x X D X physical.y+ physical.y X E X physical.y + F X physical.y
;;;195    
;;;196        cal_values[6] = 65536;
;;;197        sum_px = sum_py = sum_square_px = sum_square_py = sum_pxy = 0;
000004  2000              MOVS     r0,#0
000006  f8dfa310          LDR      r10,|L6.792|
00000a  4602              MOV      r2,r0
00000c  4615              MOV      r5,r2
00000e  f44f3380          MOV      r3,#0x10000           ;196
000012  462c              MOV      r4,r5
000014  4621              MOV      r1,r4
;;;198    
;;;199    // Get sums of physical x, y for matrix
;;;200    
;;;201        no = POINT_NUM;
000016  f04f0805          MOV      r8,#5
;;;202        for(i=0; i<POINT_NUM; i++)
00001a  4606              MOV      r6,r0
;;;203        {
;;;204            sum_px += physical[i].x;
00001c  f5aa69d2          SUB      r9,r10,#0x690
000020  f8ca3018          STR      r3,[r10,#0x18]  ; cal_values
                  |L6.36|
;;;205            sum_py += physical[i].y;
000024  eb090cc6          ADD      r12,r9,r6,LSL #3
000028  f8597036          LDR      r7,[r9,r6,LSL #3]     ;204
00002c  f8dcc004          LDR      r12,[r12,#4]
;;;206            sum_square_px += (physical[i].x * physical[i].x);
000030  fb074407          MLA      r4,r7,r7,r4
;;;207            sum_square_py += (physical[i].y * physical[i].y);
000034  fb0c550c          MLA      r5,r12,r12,r5
;;;208            sum_pxy += (physical[i].x * physical[i].y);
000038  fb07220c          MLA      r2,r7,r12,r2
00003c  1c76              ADDS     r6,r6,#1
00003e  4438              ADD      r0,r0,r7              ;204
000040  4461              ADD      r1,r1,r12             ;205
000042  2e05              CMP      r6,#5                 ;202
000044  dbee              BLT      |L6.36|
;;;209        }
;;;210    // From 3x3 matix Z, ZX= Y, X, Y is a 3 x 1 matrix
;;;211    // deter is the determinant for 3 x 3 matix
;;;212    
;;;213        im11 = (float)sum_pxy*sum_py - (float)sum_px*sum_square_py;
000046  ee002a10          VMOV     s0,r2
;;;214        im21 = (float)sum_px*sum_pxy - (float)sum_py*sum_square_px;
;;;215        im31=  (float)sum_square_px*sum_square_py - (float)sum_pxy*sum_pxy;
;;;216        deter = im11*sum_px+im21*sum_py+im31*no;
;;;217    
;;;218        if(deter < 0.01f && deter > -0.01f)
00004a  4fb4              LDR      r7,|L6.796|
00004c  eef80ac0          VCVT.F32.S32 s1,s0                 ;213
000050  ee001a10          VMOV     s0,r1                 ;213
000054  eeb80ac0          VCVT.F32.S32 s0,s0                 ;213
000058  ee601a80          VMUL.F32 s3,s1,s0              ;213
00005c  ee000a10          VMOV     s0,r0                 ;213
000060  eef80ac0          VCVT.F32.S32 s1,s0                 ;213
000064  ee005a10          VMOV     s0,r5                 ;213
000068  eeb80ac0          VCVT.F32.S32 s0,s0                 ;213
00006c  ee401ac0          VMLS.F32 s3,s1,s0              ;213
000070  ee000a10          VMOV     s0,r0                 ;214
000074  eef80ac0          VCVT.F32.S32 s1,s0                 ;214
000078  ee002a10          VMOV     s0,r2                 ;214
00007c  eeb80ac0          VCVT.F32.S32 s0,s0                 ;214
000080  ee600a80          VMUL.F32 s1,s1,s0              ;214
000084  ee001a10          VMOV     s0,r1                 ;214
000088  eeb81ac0          VCVT.F32.S32 s2,s0                 ;214
00008c  ee004a10          VMOV     s0,r4                 ;214
000090  eeb80ac0          VCVT.F32.S32 s0,s0                 ;214
000094  ee410a40          VMLS.F32 s1,s2,s0              ;214
000098  ee004a10          VMOV     s0,r4                 ;215
00009c  eeb81ac0          VCVT.F32.S32 s2,s0                 ;215
0000a0  ee005a10          VMOV     s0,r5                 ;215
0000a4  eeb80ac0          VCVT.F32.S32 s0,s0                 ;215
0000a8  ee211a00          VMUL.F32 s2,s2,s0              ;215
0000ac  ee002a10          VMOV     s0,r2                 ;215
0000b0  eeb82ac0          VCVT.F32.S32 s4,s0                 ;215
0000b4  ee002a10          VMOV     s0,r2                 ;215
0000b8  eeb80ac0          VCVT.F32.S32 s0,s0                 ;215
0000bc  ee021a40          VMLS.F32 s2,s4,s0              ;215
0000c0  ee000a10          VMOV     s0,r0                 ;216
0000c4  ee021a10          VMOV     s4,r1                 ;216
0000c8  eeb80ac0          VCVT.F32.S32 s0,s0                 ;216
0000cc  eeb82ac2          VCVT.F32.S32 s4,s4                 ;216
0000d0  ee210a80          VMUL.F32 s0,s3,s0              ;216
0000d4  ee000a82          VMLA.F32 s0,s1,s4              ;216
0000d8  ee028a10          VMOV     s4,r8                 ;216
0000dc  eeb82ac2          VCVT.F32.S32 s4,s4                 ;216
0000e0  ee010a02          VMLA.F32 s0,s2,s4              ;216
0000e4  ee106a10          VMOV     r6,s0
0000e8  42be              CMP      r6,r7
0000ea  da0a              BGE      |L6.258|
0000ec  ee106a10          VMOV     r6,s0
0000f0  4f8b              LDR      r7,|L6.800|
0000f2  42be              CMP      r6,r7
0000f4  d205              BCS      |L6.258|
;;;219        {
;;;220            printf("ts_calibrate: No inverse matrix \n");
0000f6  a08b              ADR      r0,|L6.804|
0000f8  f7fffffe          BL       __2printf
;;;221            return 0;
0000fc  2000              MOVS     r0,#0
                  |L6.254|
;;;222        }
;;;223    
;;;224    // Get elements of inverse matrix as follows
;;;225        // im11 im12 im13
;;;226        // im21 im22 im23
;;;227        // im31 im32 im33
;;;228        im32 = im11 = im11/deter;
;;;229        im12 = (float)(no*sum_square_py - sum_py*sum_py)/deter;
;;;230        im22 = im13 = (float)(sum_px*sum_py - no*sum_pxy)/deter;
;;;231        im33 = im21 = im21/deter;
;;;232        im23 = (float)(no*sum_square_px - sum_px*sum_px)/deter;
;;;233        im31= im31/deter;
;;;234    
;;;235    // Get sums of logical and physical for x calibration
;;;236        sum_lx = sum_lpx = sum_lpy = 0;
;;;237        for(i=0; i<POINT_NUM; i++)
;;;238        {
;;;239            sum_lx += logical[i].x;
;;;240            sum_lpx += (logical[i].x*physical[i].x);
;;;241            sum_lpy += (logical[i].x*physical[i].y);
;;;242        }
;;;243    
;;;244    // get the calibration for A, B, C mapping cal_values[0], cal_values[1], cal_values[2]
;;;245        cal_values[0] = (int)((im11*sum_lx + im12*sum_lpx + im13*sum_lpy)* cal_values[6]);
;;;246        cal_values[1] = (int)((im21*sum_lx + im22*sum_lpx + im23*sum_lpy)* cal_values[6]);
;;;247        cal_values[2] = (int)((im31*sum_lx + im32*sum_lpx + im33*sum_lpy)* cal_values[6]);
;;;248    
;;;249    // Get sums of logical and physical for y calibration
;;;250        sum_ly = sum_lpx = sum_lpy = 0;
;;;251        for(i=0; i<POINT_NUM; i++)
;;;252        {
;;;253            sum_ly += logical[i].y;
;;;254            sum_lpx += (logical[i].y*physical[i].x);
;;;255            sum_lpy += (logical[i].y*physical[i].y);
;;;256        }
;;;257    
;;;258    // get the calibration for D, E, F mapping cal_values[3], cal_values[4], cal_values[5]
;;;259        cal_values[3] = (int)((im11*sum_ly + im12*sum_lpx + im13*sum_lpy)* cal_values[6]);
;;;260        cal_values[4] = (int)((im21*sum_ly + im22*sum_lpx + im23*sum_lpy)* cal_values[6]);
;;;261        cal_values[5] = (int)((im31*sum_ly + im32*sum_lpx + im33*sum_lpy)* cal_values[6]);
;;;262    
;;;263        return 1;
;;;264    }
0000fe  e8bd87f0          POP      {r4-r10,pc}
                  |L6.258|
000102  ee812a80          VDIV.F32 s4,s3,s0              ;228
000106  fb08f505          MUL      r5,r8,r5              ;229
00010a  fb015511          MLS      r5,r1,r1,r5           ;229
00010e  ee015a90          VMOV     s3,r5                 ;229
000112  4341              MULS     r1,r0,r1              ;230
000114  fb081112          MLS      r1,r8,r2,r1           ;230
000118  eef81ae1          VCVT.F32.S32 s3,s3                 ;229
00011c  fb08f804          MUL      r8,r8,r4              ;232
000120  fb008010          MLS      r0,r0,r0,r8           ;232
000124  f8dfc220          LDR      r12,|L6.840|
000128  ee813a80          VDIV.F32 s6,s3,s0              ;229
00012c  ee011a90          VMOV     s3,r1                 ;230
000130  464c              MOV      r4,r9                 ;204
000132  eef82ae1          VCVT.F32.S32 s5,s3                 ;230
000136  eec21a80          VDIV.F32 s3,s5,s0              ;230
00013a  eec02a80          VDIV.F32 s5,s1,s0              ;231
00013e  ee000a90          VMOV     s1,r0                 ;232
000142  2000              MOVS     r0,#0                 ;236
000144  4601              MOV      r1,r0                 ;236
000146  eef83ae0          VCVT.F32.S32 s7,s1                 ;232
00014a  460a              MOV      r2,r1                 ;236
00014c  4605              MOV      r5,r0                 ;237
00014e  eec30a80          VDIV.F32 s1,s7,s0              ;232
000152  eec13a00          VDIV.F32 s7,s2,s0              ;233
000156  bf00              NOP                            ;239
                  |L6.344|
000158  f85c6035          LDR      r6,[r12,r5,LSL #3]    ;239
00015c  f8547035          LDR      r7,[r4,r5,LSL #3]     ;240
000160  4430              ADD      r0,r0,r6              ;239
000162  fb062207          MLA      r2,r6,r7,r2           ;240
000166  eb0407c5          ADD      r7,r4,r5,LSL #3       ;241
00016a  1c6d              ADDS     r5,r5,#1              ;241
00016c  687f              LDR      r7,[r7,#4]            ;241
00016e  2d05              CMP      r5,#5                 ;237
000170  fb061107          MLA      r1,r6,r7,r1           ;241
000174  dbf0              BLT      |L6.344|
000176  ee000a10          VMOV     s0,r0                 ;245
00017a  eeb01a42          VMOV.F32 s2,s4                 ;245
00017e  eeb04a61          VMOV.F32 s8,s3                 ;245
000182  eeb80ac0          VCVT.F32.S32 s0,s0                 ;245
000186  4655              MOV      r5,r10                ;245
000188  ee210a00          VMUL.F32 s0,s2,s0              ;245
00018c  ee012a10          VMOV     s2,r2                 ;245
000190  eeb81ac1          VCVT.F32.S32 s2,s2                 ;245
000194  ee030a01          VMLA.F32 s0,s6,s2              ;245
000198  ee011a10          VMOV     s2,r1                 ;245
00019c  eeb81ac1          VCVT.F32.S32 s2,s2                 ;245
0001a0  ee040a01          VMLA.F32 s0,s8,s2              ;245
0001a4  ee013a10          VMOV     s2,r3                 ;245
0001a8  eeb81ac1          VCVT.F32.S32 s2,s2                 ;245
0001ac  ee200a01          VMUL.F32 s0,s0,s2              ;245
0001b0  eeb01a62          VMOV.F32 s2,s5                 ;246
0001b4  eebd0ac0          VCVT.S32.F32 s0,s0                 ;245
0001b8  ed8a0a00          VSTR     s0,[r10,#0]           ;245
0001bc  ee000a10          VMOV     s0,r0                 ;246
0001c0  eeb80ac0          VCVT.F32.S32 s0,s0                 ;246
0001c4  ee210a00          VMUL.F32 s0,s2,s0              ;246
0001c8  ee012a10          VMOV     s2,r2                 ;246
0001cc  eeb81ac1          VCVT.F32.S32 s2,s2                 ;246
0001d0  ee040a01          VMLA.F32 s0,s8,s2              ;246
0001d4  ee011a10          VMOV     s2,r1                 ;246
0001d8  eeb04a42          VMOV.F32 s8,s4                 ;247
0001dc  eeb81ac1          VCVT.F32.S32 s2,s2                 ;246
0001e0  ee000a81          VMLA.F32 s0,s1,s2              ;246
0001e4  ee013a10          VMOV     s2,r3                 ;246
0001e8  eeb81ac1          VCVT.F32.S32 s2,s2                 ;246
0001ec  ee200a01          VMUL.F32 s0,s0,s2              ;246
0001f0  ee012a10          VMOV     s2,r2                 ;247
0001f4  eebd0ac0          VCVT.S32.F32 s0,s0                 ;246
0001f8  eeb81ac1          VCVT.F32.S32 s2,s2                 ;247
0001fc  ed850a01          VSTR     s0,[r5,#4]            ;246
000200  ee000a10          VMOV     s0,r0                 ;247
000204  2000              MOVS     r0,#0                 ;250
000206  4606              MOV      r6,r0                 ;251
000208  eeb80ac0          VCVT.F32.S32 s0,s0                 ;247
00020c  ee230a80          VMUL.F32 s0,s7,s0              ;247
000210  ee040a01          VMLA.F32 s0,s8,s2              ;247
000214  ee011a10          VMOV     s2,r1                 ;247
000218  eeb04a62          VMOV.F32 s8,s5                 ;247
00021c  4601              MOV      r1,r0                 ;250
00021e  eeb81ac1          VCVT.F32.S32 s2,s2                 ;247
000222  460a              MOV      r2,r1                 ;250
000224  ee040a01          VMLA.F32 s0,s8,s2              ;247
000228  ee013a10          VMOV     s2,r3                 ;247
00022c  eeb81ac1          VCVT.F32.S32 s2,s2                 ;247
000230  ee200a01          VMUL.F32 s0,s0,s2              ;247
000234  eebd0ac0          VCVT.S32.F32 s0,s0                 ;247
000238  ed850a02          VSTR     s0,[r5,#8]            ;247
                  |L6.572|
00023c  eb0c07c6          ADD      r7,r12,r6,LSL #3      ;253
000240  f8548036          LDR      r8,[r4,r6,LSL #3]     ;254
000244  687f              LDR      r7,[r7,#4]            ;253
000246  fb072208          MLA      r2,r7,r8,r2           ;254
00024a  eb0408c6          ADD      r8,r4,r6,LSL #3       ;255
00024e  1c76              ADDS     r6,r6,#1              ;255
000250  f8d88004          LDR      r8,[r8,#4]            ;255
000254  4438              ADD      r0,r0,r7              ;253
000256  fb071108          MLA      r1,r7,r8,r1           ;255
00025a  2e05              CMP      r6,#5                 ;251
00025c  dbee              BLT      |L6.572|
00025e  ee000a10          VMOV     s0,r0                 ;259
000262  eeb01a42          VMOV.F32 s2,s4                 ;259
000266  eeb80ac0          VCVT.F32.S32 s0,s0                 ;259
00026a  ee210a00          VMUL.F32 s0,s2,s0              ;259
00026e  ee012a10          VMOV     s2,r2                 ;259
000272  eeb81ac1          VCVT.F32.S32 s2,s2                 ;259
000276  ee030a01          VMLA.F32 s0,s6,s2              ;259
00027a  ee011a10          VMOV     s2,r1                 ;259
00027e  eeb03a61          VMOV.F32 s6,s3                 ;259
000282  eeb81ac1          VCVT.F32.S32 s2,s2                 ;259
000286  ee030a01          VMLA.F32 s0,s6,s2              ;259
00028a  ee013a10          VMOV     s2,r3                 ;259
00028e  eeb81ac1          VCVT.F32.S32 s2,s2                 ;259
000292  ee200a01          VMUL.F32 s0,s0,s2              ;259
000296  eeb01a62          VMOV.F32 s2,s5                 ;260
00029a  eebd0ac0          VCVT.S32.F32 s0,s0                 ;259
00029e  ed850a03          VSTR     s0,[r5,#0xc]          ;259
0002a2  ee000a10          VMOV     s0,r0                 ;260
0002a6  eeb80ac0          VCVT.F32.S32 s0,s0                 ;260
0002aa  ee210a00          VMUL.F32 s0,s2,s0              ;260
0002ae  ee012a10          VMOV     s2,r2                 ;260
0002b2  eeb81ac1          VCVT.F32.S32 s2,s2                 ;260
0002b6  ee010a81          VMLA.F32 s0,s3,s2              ;260
0002ba  ee011a10          VMOV     s2,r1                 ;260
0002be  eeb81ac1          VCVT.F32.S32 s2,s2                 ;260
0002c2  ee000a81          VMLA.F32 s0,s1,s2              ;260
0002c6  ee003a90          VMOV     s1,r3                 ;260
0002ca  eef80ae0          VCVT.F32.S32 s1,s1                 ;260
0002ce  ee200a20          VMUL.F32 s0,s0,s1              ;260
0002d2  ee002a90          VMOV     s1,r2                 ;261
0002d6  eebd0ac0          VCVT.S32.F32 s0,s0                 ;260
0002da  eef80ae0          VCVT.F32.S32 s1,s1                 ;261
0002de  ed850a04          VSTR     s0,[r5,#0x10]         ;260
0002e2  ee000a10          VMOV     s0,r0                 ;261
0002e6  2001              MOVS     r0,#1                 ;263
0002e8  eeb80ac0          VCVT.F32.S32 s0,s0                 ;261
0002ec  ee230a80          VMUL.F32 s0,s7,s0              ;261
0002f0  ee020a20          VMLA.F32 s0,s4,s1              ;261
0002f4  ee001a90          VMOV     s1,r1                 ;261
0002f8  eef80ae0          VCVT.F32.S32 s1,s1                 ;261
0002fc  ee020aa0          VMLA.F32 s0,s5,s1              ;261
000300  ee003a90          VMOV     s1,r3                 ;261
000304  eef80ae0          VCVT.F32.S32 s1,s1                 ;261
000308  ee200a20          VMUL.F32 s0,s0,s1              ;261
00030c  eebd0ac0          VCVT.S32.F32 s0,s0                 ;261
000310  ed8a0a05          VSTR     s0,[r10,#0x14]        ;261
000314  e6f3              B        |L6.254|
;;;265    
                          ENDP

000316  0000              DCW      0x0000
                  |L6.792|
                          DCD      ||.bss||+0x690
                  |L6.796|
                          DCD      0x3c23d70a
                  |L6.800|
                          DCD      0xbc23d70a
                  |L6.804|
000324  74735f63          DCB      "ts_calibrate: No inverse matrix \n",0
000328  616c6962
00032c  72617465
000330  3a204e6f
000334  20696e76
000338  65727365
00033c  206d6174
000340  72697820
000344  0a00    
000346  00                DCB      0
000347  00                DCB      0
                  |L6.840|
                          DCD      ||.bss||+0x28

                          AREA ||i.ts_calibrate||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  ts_calibrate PROC
;;;282    
;;;283    int ts_calibrate(int xsize, int ysize)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;284    {
000004  4605              MOV      r5,r0
000006  4688              MOV      r8,r1
;;;285        int result,d1, d2, d3;
;;;286        GUI_SetBkColor(GUI_BLACK);
000008  f04f407f          MOV      r0,#0xff000000
00000c  f7fffffe          BL       GUI_SetBkColor
;;;287    	  GUI_Clear();
000010  f7fffffe          BL       GUI_Clear
;;;288    
;;;289    	  if ( xsize >= 800 ) // 800x480
;;;290    		{
;;;291            GUI_SetFont(&GUI_Font24B_ASCII);
;;;292    			  d1 = -50;
000014  f06f0631          MVN      r6,#0x31
;;;293    			  d2 = -20;
000018  f06f0413          MVN      r4,#0x13
00001c  f5b57f48          CMP      r5,#0x320             ;289
000020  db04              BLT      |L7.44|
000022  484b              LDR      r0,|L7.336|
000024  f7fffffe          BL       GUI_SetFont
;;;294    			  d3 = 10;
000028  270a              MOVS     r7,#0xa
00002a  e010              B        |L7.78|
                  |L7.44|
;;;295    		} 
;;;296    		else if ( xsize >= 480 ) // 480 x272
;;;297    		{
;;;298            GUI_SetFont(&GUI_Font13B_ASCII);
;;;299    				d1 = -50;
;;;300    			  d2 = -30;
;;;301    			  d3 = -10;
00002c  f06f0709          MVN      r7,#9
000030  f5b57ff0          CMP      r5,#0x1e0             ;296
000034  db05              BLT      |L7.66|
000036  4847              LDR      r0,|L7.340|
000038  f7fffffe          BL       GUI_SetFont
00003c  f06f041d          MVN      r4,#0x1d              ;300
000040  e005              B        |L7.78|
                  |L7.66|
;;;302    		}
;;;303    		else
;;;304    		{
;;;305    			  GUI_SetFont(&GUI_Font8_ASCII);
000042  4845              LDR      r0,|L7.344|
000044  f7fffffe          BL       GUI_SetFont
;;;306    				d1 = -20;
000048  4626              MOV      r6,r4
;;;307    			  d2 = -10;
00004a  463c              MOV      r4,r7
;;;308    			  d3 = 0;
00004c  2700              MOVS     r7,#0
                  |L7.78|
;;;309    		}
;;;310    
;;;311        GUI_SetColor(GUI_RED);
00004e  4843              LDR      r0,|L7.348|
000050  f7fffffe          BL       GUI_SetColor
;;;312        GUI_DispStringHCenterAt("Nuvoton's TS calibration utility", xsize / 2, ysize / 4 +d1);
000054  ea4f71e8          ASR      r1,r8,#31
000058  eb087991          ADD      r9,r8,r1,LSR #30
00005c  eb0602a9          ADD      r2,r6,r9,ASR #2
000060  eb0576d5          ADD      r6,r5,r5,LSR #31
000064  1071              ASRS     r1,r6,#1
000066  a03e              ADR      r0,|L7.352|
000068  f7fffffe          BL       GUI_DispStringHCenterAt
;;;313    
;;;314        GUI_SetColor(GUI_BLUE);
00006c  4845              LDR      r0,|L7.388|
00006e  f7fffffe          BL       GUI_SetColor
;;;315        GUI_DispStringHCenterAt("Touch crosshair to calibrate", xsize / 2, ysize / 4 +d2 );
000072  eb0402a9          ADD      r2,r4,r9,ASR #2
000076  1071              ASRS     r1,r6,#1
000078  a043              ADR      r0,|L7.392|
00007a  f7fffffe          BL       GUI_DispStringHCenterAt
;;;316    
;;;317        GUI_SetColor(GUI_GREEN);
00007e  f04f20ff          MOV      r0,#0xff00ff00
000082  f7fffffe          BL       GUI_SetColor
;;;318        GUI_DispStringHCenterAt("Click down 2 seconds and release", xsize / 2, ysize / 4 + d3);
000086  eb0702a9          ADD      r2,r7,r9,ASR #2
00008a  1071              ASRS     r1,r6,#1
00008c  a046              ADR      r0,|L7.424|
00008e  f7fffffe          BL       GUI_DispStringHCenterAt
;;;319    
;;;320        printf("xsize = %d, ysize = %d\n", xsize, ysize);
000092  4642              MOV      r2,r8
000094  4629              MOV      r1,r5
000096  a04d              ADR      r0,|L7.460|
000098  f7fffffe          BL       __2printf
;;;321    
;;;322        //GUI_SetColor(GUI_WHITE);
;;;323        //GUI_SetDrawMode(GUI_DRAWMODE_XOR);
;;;324        GUI_SetPenSize(1);
00009c  2001              MOVS     r0,#1
00009e  f7fffffe          BL       GUI_SetPenSize
;;;325    
;;;326        //Top left
;;;327        result = read_calib_sample ("Top left", 0, 40, 40);
0000a2  2328              MOVS     r3,#0x28
0000a4  461a              MOV      r2,r3
0000a6  2100              MOVS     r1,#0
0000a8  a04e              ADR      r0,|L7.484|
0000aa  f7fffffe          BL       read_calib_sample
0000ae  4607              MOV      r7,r0
;;;328        GUI_X_Delay(300);
0000b0  f44f7496          MOV      r4,#0x12c
0000b4  4620              MOV      r0,r4
0000b6  f7fffffe          BL       GUI_X_Delay
;;;329        if ( result == 0 )
0000ba  2f00              CMP      r7,#0
0000bc  d03b              BEQ      |L7.310|
;;;330        {
;;;331            return(DisplayFailStatus(xsize, ysize));
;;;332        }
;;;333    
;;;334        //Top right
;;;335        result = read_calib_sample ("Top right", 1, xsize - 40, 40);
0000be  f1a50228          SUB      r2,r5,#0x28
0000c2  2328              MOVS     r3,#0x28
0000c4  4692              MOV      r10,r2
0000c6  2101              MOVS     r1,#1
0000c8  a049              ADR      r0,|L7.496|
0000ca  f7fffffe          BL       read_calib_sample
0000ce  4607              MOV      r7,r0
;;;336        GUI_X_Delay(300);
0000d0  4620              MOV      r0,r4
0000d2  f7fffffe          BL       GUI_X_Delay
;;;337        if ( result == 0 )
0000d6  2f00              CMP      r7,#0
0000d8  d02d              BEQ      |L7.310|
;;;338        {
;;;339            return(DisplayFailStatus(xsize, ysize));
;;;340        }
;;;341    
;;;342        //Bottom right
;;;343        result = read_calib_sample ("Bottom right", 2, xsize - 40, ysize - 40);
0000da  f1a80328          SUB      r3,r8,#0x28
0000de  4699              MOV      r9,r3
0000e0  4652              MOV      r2,r10
0000e2  2102              MOVS     r1,#2
0000e4  a045              ADR      r0,|L7.508|
0000e6  f7fffffe          BL       read_calib_sample
0000ea  4607              MOV      r7,r0
;;;344        GUI_X_Delay(300);
0000ec  4620              MOV      r0,r4
0000ee  f7fffffe          BL       GUI_X_Delay
;;;345        if ( result == 0 )
0000f2  b307              CBZ      r7,|L7.310|
0000f4  464b              MOV      r3,r9
;;;346        {
;;;347            return(DisplayFailStatus(xsize, ysize));
;;;348        }
;;;349    
;;;350        //Bottom left
;;;351        result = read_calib_sample ("Bottom left", 3, 40, ysize - 40);
0000f6  2228              MOVS     r2,#0x28
0000f8  2103              MOVS     r1,#3
0000fa  a044              ADR      r0,|L7.524|
0000fc  f7fffffe          BL       read_calib_sample
000100  4607              MOV      r7,r0
;;;352        GUI_X_Delay(300);
000102  4620              MOV      r0,r4
000104  f7fffffe          BL       GUI_X_Delay
;;;353        if ( result == 0 )
000108  b1af              CBZ      r7,|L7.310|
;;;354        {
;;;355            return(DisplayFailStatus(xsize, ysize));
;;;356        }
;;;357    
;;;358        // Center
;;;359        result = read_calib_sample ("Center", 4, xsize / 2,  ysize / 2);
00010a  eb0870d8          ADD      r0,r8,r8,LSR #31
00010e  1043              ASRS     r3,r0,#1
000110  1072              ASRS     r2,r6,#1
000112  2104              MOVS     r1,#4
000114  a040              ADR      r0,|L7.536|
000116  f7fffffe          BL       read_calib_sample
00011a  4606              MOV      r6,r0
;;;360        GUI_X_Delay(300);
00011c  4620              MOV      r0,r4
00011e  f7fffffe          BL       GUI_X_Delay
;;;361        if ( result == 0 )
000122  b146              CBZ      r6,|L7.310|
;;;362        {
;;;363            return(DisplayFailStatus(xsize, ysize));
;;;364        }
;;;365    
;;;366    // After running API run_calibration, global variable cal_values is exported.
;;;367        if (run_calibration())
000124  f7fffffe          BL       run_calibration
000128  b158              CBZ      r0,|L7.322|
;;;368        {
;;;369            printf("Calibration OK.\n");
00012a  a03d              ADR      r0,|L7.544|
00012c  f7fffffe          BL       __2printf
;;;370            result = 1;
000130  2001              MOVS     r0,#1
                  |L7.306|
;;;371        }
;;;372        else
;;;373        {
;;;374            printf("Calibration failed.\n");
;;;375            result = -1;
;;;376        }
;;;377    
;;;378        return result;
;;;379    }
000132  e8bd87f0          POP      {r4-r10,pc}
                  |L7.310|
000136  4641              MOV      r1,r8                 ;363
000138  4628              MOV      r0,r5                 ;363
00013a  e8bd47f0          POP      {r4-r10,lr}           ;363
00013e  f7ffbffe          B.W      DisplayFailStatus
                  |L7.322|
000142  a03c              ADR      r0,|L7.564|
000144  f7fffffe          BL       __2printf
000148  f04f30ff          MOV      r0,#0xffffffff        ;375
00014c  e7f1              B        |L7.306|
;;;380    
                          ENDP

00014e  0000              DCW      0x0000
                  |L7.336|
                          DCD      GUI_Font24B_ASCII
                  |L7.340|
                          DCD      GUI_Font13B_ASCII
                  |L7.344|
                          DCD      GUI_Font8_ASCII
                  |L7.348|
                          DCD      0xffff0000
                  |L7.352|
000160  4e75766f          DCB      "Nuvoton's TS calibration utility",0
000164  746f6e27
000168  73205453
00016c  2063616c
000170  69627261
000174  74696f6e
000178  20757469
00017c  6c697479
000180  00      
000181  00                DCB      0
000182  00                DCB      0
000183  00                DCB      0
                  |L7.388|
                          DCD      0xff0000ff
                  |L7.392|
000188  546f7563          DCB      "Touch crosshair to calibrate",0
00018c  68206372
000190  6f737368
000194  61697220
000198  746f2063
00019c  616c6962
0001a0  72617465
0001a4  00      
0001a5  00                DCB      0
0001a6  00                DCB      0
0001a7  00                DCB      0
                  |L7.424|
0001a8  436c6963          DCB      "Click down 2 seconds and release",0
0001ac  6b20646f
0001b0  776e2032
0001b4  20736563
0001b8  6f6e6473
0001bc  20616e64
0001c0  2072656c
0001c4  65617365
0001c8  00      
0001c9  00                DCB      0
0001ca  00                DCB      0
0001cb  00                DCB      0
                  |L7.460|
0001cc  7873697a          DCB      "xsize = %d, ysize = %d\n",0
0001d0  65203d20
0001d4  25642c20
0001d8  7973697a
0001dc  65203d20
0001e0  25640a00
                  |L7.484|
0001e4  546f7020          DCB      "Top left",0
0001e8  6c656674
0001ec  00      
0001ed  00                DCB      0
0001ee  00                DCB      0
0001ef  00                DCB      0
                  |L7.496|
0001f0  546f7020          DCB      "Top right",0
0001f4  72696768
0001f8  7400    
0001fa  00                DCB      0
0001fb  00                DCB      0
                  |L7.508|
0001fc  426f7474          DCB      "Bottom right",0
000200  6f6d2072
000204  69676874
000208  00      
000209  00                DCB      0
00020a  00                DCB      0
00020b  00                DCB      0
                  |L7.524|
00020c  426f7474          DCB      "Bottom left",0
000210  6f6d206c
000214  65667400
                  |L7.536|
000218  43656e74          DCB      "Center",0
00021c  657200  
00021f  00                DCB      0
                  |L7.544|
000220  43616c69          DCB      "Calibration OK.\n",0
000224  62726174
000228  696f6e20
00022c  4f4b2e0a
000230  00      
000231  00                DCB      0
000232  00                DCB      0
000233  00                DCB      0
                  |L7.564|
000234  43616c69          DCB      "Calibration failed.\n",0
000238  62726174
00023c  696f6e20
000240  6661696c
000244  65642e0a
000248  00      
000249  00                DCB      0
00024a  00                DCB      0
00024b  00                DCB      0

                          AREA ||i.ts_phy2log||, CODE, READONLY, ALIGN=2

                  ts_phy2log PROC
;;;382    // logical.y = physical.x X D + physical.y X E + F
;;;383    int ts_phy2log(int *logx, int *logy)
000000  b570              PUSH     {r4-r6,lr}
;;;384    {
;;;385        int phyx,phyy;
;;;386    
;;;387        phyx = *logx;
;;;388        phyy = *logy;
;;;389        *logx = ( phyx*cal_values[0] + phyy*cal_values[1] + cal_values[2] ) / cal_values[6];
000002  4a0d              LDR      r2,|L8.56|
000004  6803              LDR      r3,[r0,#0]            ;388
000006  680c              LDR      r4,[r1,#0]
000008  6815              LDR      r5,[r2,#0]  ; cal_values
00000a  6856              LDR      r6,[r2,#4]  ; cal_values
00000c  435d              MULS     r5,r3,r5
00000e  fb045506          MLA      r5,r4,r6,r5
000012  6896              LDR      r6,[r2,#8]  ; cal_values
000014  4435              ADD      r5,r5,r6
000016  6996              LDR      r6,[r2,#0x18]  ; cal_values
000018  fb95f5f6          SDIV     r5,r5,r6
;;;390        *logy = ( phyx*cal_values[3]+  phyy*cal_values[4] + cal_values[5] ) / cal_values[6];
00001c  6005              STR      r5,[r0,#0]
00001e  68d0              LDR      r0,[r2,#0xc]  ; cal_values
000020  4358              MULS     r0,r3,r0
000022  6913              LDR      r3,[r2,#0x10]  ; cal_values
000024  fb040003          MLA      r0,r4,r3,r0
000028  6953              LDR      r3,[r2,#0x14]  ; cal_values
00002a  6992              LDR      r2,[r2,#0x18]  ; cal_values
00002c  4418              ADD      r0,r0,r3
00002e  fb90f0f2          SDIV     r0,r0,r2
;;;391        return 1;
000032  6008              STR      r0,[r1,#0]
000034  2001              MOVS     r0,#1
;;;392    }
000036  bd70              POP      {r4-r6,pc}
;;;393    
                          ENDP

                  |L8.56|
                          DCD      ||.bss||+0x690

                          AREA ||i.ts_readfile||, CODE, READONLY, ALIGN=2

                  ts_readfile PROC
;;;425    
;;;426    int ts_readfile(void)
000000  b510              PUSH     {r4,lr}
;;;427    {
;;;428    #ifdef __USE_SD__
;;;429        size_t cnt;
;;;430        FRESULT res;
;;;431        res = f_lseek(&hFile, 0);
;;;432        if (res != FR_OK)
;;;433        {
;;;434            printf("CANNOT seek the calibration into file\n");
;;;435            return -1;
;;;436        }
;;;437    
;;;438        res = f_read(&hFile, (char *)&cal_values[0], 28, &cnt);
;;;439        if (res != FR_OK)
;;;440        {
;;;441            printf("CANNOT read the calibration into file, %d\n", cnt);
;;;442            return -1;
;;;443        }
;;;444    #else
;;;445        cal_values[0] = FMC_Read(__DEMO_TSFILE_ADDR__ + 0x00);
000002  4812              LDR      r0,|L9.76|
000004  f7fffffe          BL       FMC_Read
000008  4c11              LDR      r4,|L9.80|
;;;446        cal_values[1] = FMC_Read(__DEMO_TSFILE_ADDR__ + 0x04);
00000a  6020              STR      r0,[r4,#0]  ; cal_values
00000c  480f              LDR      r0,|L9.76|
00000e  1d00              ADDS     r0,r0,#4
000010  f7fffffe          BL       FMC_Read
;;;447        cal_values[2] = FMC_Read(__DEMO_TSFILE_ADDR__ + 0x08);
000014  6060              STR      r0,[r4,#4]  ; cal_values
000016  480d              LDR      r0,|L9.76|
000018  3008              ADDS     r0,r0,#8
00001a  f7fffffe          BL       FMC_Read
;;;448        cal_values[3] = FMC_Read(__DEMO_TSFILE_ADDR__ + 0x0C);
00001e  60a0              STR      r0,[r4,#8]  ; cal_values
000020  480a              LDR      r0,|L9.76|
000022  300c              ADDS     r0,r0,#0xc
000024  f7fffffe          BL       FMC_Read
;;;449        cal_values[4] = FMC_Read(__DEMO_TSFILE_ADDR__ + 0x10);
000028  60e0              STR      r0,[r4,#0xc]  ; cal_values
00002a  4808              LDR      r0,|L9.76|
00002c  3010              ADDS     r0,r0,#0x10
00002e  f7fffffe          BL       FMC_Read
;;;450        cal_values[5] = FMC_Read(__DEMO_TSFILE_ADDR__ + 0x14);
000032  6120              STR      r0,[r4,#0x10]  ; cal_values
000034  4805              LDR      r0,|L9.76|
000036  3014              ADDS     r0,r0,#0x14
000038  f7fffffe          BL       FMC_Read
;;;451        cal_values[6] = FMC_Read(__DEMO_TSFILE_ADDR__ + 0x18);
00003c  6160              STR      r0,[r4,#0x14]  ; cal_values
00003e  4803              LDR      r0,|L9.76|
000040  3018              ADDS     r0,r0,#0x18
000042  f7fffffe          BL       FMC_Read
;;;452    #endif
;;;453        return 0;
000046  61a0              STR      r0,[r4,#0x18]  ; cal_values
000048  2000              MOVS     r0,#0
;;;454    }
00004a  bd10              POP      {r4,pc}
                          ENDP

                  |L9.76|
                          DCD      0x0007ffe0
                  |L9.80|
                          DCD      ||.bss||+0x690

                          AREA ||i.ts_writefile||, CODE, READONLY, ALIGN=2

                  ts_writefile PROC
;;;394    // write the calibration parameters into one file
;;;395    int ts_writefile(void)
000000  b510              PUSH     {r4,lr}
;;;396    {
;;;397    #ifdef __USE_SD__
;;;398        size_t cnt;
;;;399        FRESULT res;
;;;400        res = f_lseek(&hFile, 0);
;;;401        if (res != FR_OK)
;;;402        {
;;;403            printf("CANNOT seek the calibration into file\n");
;;;404            return -1;
;;;405        }
;;;406    
;;;407        res = f_write(&hFile, (char *)&cal_values[0], 28, &cnt);
;;;408        if (res != FR_OK)
;;;409        {
;;;410            printf("CANNOT write the calibration into file, %d\n", cnt);
;;;411            return -1;
;;;412        }
;;;413    #else
;;;414        FMC_Write(__DEMO_TSFILE_ADDR__ + 0x00, cal_values[0]);
000002  4c15              LDR      r4,|L10.88|
000004  4815              LDR      r0,|L10.92|
000006  6821              LDR      r1,[r4,#0]  ; cal_values
000008  f7fffffe          BL       FMC_Write
;;;415        FMC_Write(__DEMO_TSFILE_ADDR__ + 0x04, cal_values[1]);
00000c  4813              LDR      r0,|L10.92|
00000e  6861              LDR      r1,[r4,#4]  ; cal_values
000010  1d00              ADDS     r0,r0,#4
000012  f7fffffe          BL       FMC_Write
;;;416        FMC_Write(__DEMO_TSFILE_ADDR__ + 0x08, cal_values[2]);
000016  4811              LDR      r0,|L10.92|
000018  68a1              LDR      r1,[r4,#8]  ; cal_values
00001a  3008              ADDS     r0,r0,#8
00001c  f7fffffe          BL       FMC_Write
;;;417        FMC_Write(__DEMO_TSFILE_ADDR__ + 0x0C, cal_values[3]);
000020  480e              LDR      r0,|L10.92|
000022  68e1              LDR      r1,[r4,#0xc]  ; cal_values
000024  300c              ADDS     r0,r0,#0xc
000026  f7fffffe          BL       FMC_Write
;;;418        FMC_Write(__DEMO_TSFILE_ADDR__ + 0x10, cal_values[4]);
00002a  480c              LDR      r0,|L10.92|
00002c  6921              LDR      r1,[r4,#0x10]  ; cal_values
00002e  3010              ADDS     r0,r0,#0x10
000030  f7fffffe          BL       FMC_Write
;;;419        FMC_Write(__DEMO_TSFILE_ADDR__ + 0x14, cal_values[5]);
000034  4809              LDR      r0,|L10.92|
000036  6961              LDR      r1,[r4,#0x14]  ; cal_values
000038  3014              ADDS     r0,r0,#0x14
00003a  f7fffffe          BL       FMC_Write
;;;420        FMC_Write(__DEMO_TSFILE_ADDR__ + 0x18, cal_values[6]);
00003e  4807              LDR      r0,|L10.92|
000040  69a1              LDR      r1,[r4,#0x18]  ; cal_values
000042  3018              ADDS     r0,r0,#0x18
000044  f7fffffe          BL       FMC_Write
;;;421        FMC_Write(__DEMO_TSFILE_ADDR__ + 0x1C, 0x55AAA55A);
000048  4804              LDR      r0,|L10.92|
00004a  4905              LDR      r1,|L10.96|
00004c  301c              ADDS     r0,r0,#0x1c
00004e  f7fffffe          BL       FMC_Write
;;;422    #endif
;;;423        return 0;
000052  2000              MOVS     r0,#0
;;;424    }
000054  bd10              POP      {r4,pc}
;;;425    
                          ENDP

000056  0000              DCW      0x0000
                  |L10.88|
                          DCD      ||.bss||+0x690
                  |L10.92|
                          DCD      0x0007ffe0
                  |L10.96|
                          DCD      0x55aaa55a

                          AREA ||i.write_cross||, CODE, READONLY, ALIGN=1

                  write_cross PROC
;;;83     
;;;84     void write_cross(int x, int y)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;85     {
000004  4605              MOV      r5,r0
;;;86         GUI_DrawLine(x - 12, y, x - 2, y);
000006  1e82              SUBS     r2,r0,#2
000008  380c              SUBS     r0,r0,#0xc
00000a  460c              MOV      r4,r1                 ;85
00000c  460b              MOV      r3,r1
00000e  4680              MOV      r8,r0
000010  f7fffffe          BL       GUI_DrawLine
;;;87         GUI_DrawLine(x + 2, y, x + 12, y);
000014  4623              MOV      r3,r4
000016  f105020c          ADD      r2,r5,#0xc
00001a  4691              MOV      r9,r2
00001c  4619              MOV      r1,r3
00001e  1ca8              ADDS     r0,r5,#2
000020  f7fffffe          BL       GUI_DrawLine
;;;88         GUI_DrawLine(x, y - 12, x, y - 2);
000024  462a              MOV      r2,r5
000026  f1a4010c          SUB      r1,r4,#0xc
00002a  1ea3              SUBS     r3,r4,#2
00002c  460e              MOV      r6,r1
00002e  4610              MOV      r0,r2
000030  f7fffffe          BL       GUI_DrawLine
;;;89         GUI_DrawLine(x, y + 2, x, y + 12);
000034  f104030c          ADD      r3,r4,#0xc
000038  462a              MOV      r2,r5
00003a  461f              MOV      r7,r3
00003c  1ca1              ADDS     r1,r4,#2
00003e  4610              MOV      r0,r2
000040  f7fffffe          BL       GUI_DrawLine
000044  4633              MOV      r3,r6
000046  4642              MOV      r2,r8
000048  4619              MOV      r1,r3
;;;90         GUI_DrawLine(x - 6, y - 12, x - 12, y - 12);
00004a  1fa8              SUBS     r0,r5,#6
00004c  f7fffffe          BL       GUI_DrawLine
;;;91         GUI_DrawLine(x - 12, y - 12, x - 12, y - 6);
000050  4642              MOV      r2,r8
000052  1fa3              SUBS     r3,r4,#6
000054  4631              MOV      r1,r6
000056  4610              MOV      r0,r2
000058  f7fffffe          BL       GUI_DrawLine
00005c  4642              MOV      r2,r8
00005e  463b              MOV      r3,r7
;;;92         GUI_DrawLine(x - 12, y + 6, x - 12, y + 12);
000060  1da1              ADDS     r1,r4,#6
000062  4610              MOV      r0,r2
000064  f7fffffe          BL       GUI_DrawLine
000068  463b              MOV      r3,r7
;;;93         GUI_DrawLine(x - 12, y + 12, x - 6, y + 12);
00006a  1faa              SUBS     r2,r5,#6
00006c  4619              MOV      r1,r3
00006e  4640              MOV      r0,r8
000070  f7fffffe          BL       GUI_DrawLine
000074  463b              MOV      r3,r7
000076  464a              MOV      r2,r9
000078  4619              MOV      r1,r3
;;;94         GUI_DrawLine(x + 6, y + 12, x + 12, y + 12);
00007a  1da8              ADDS     r0,r5,#6
00007c  f7fffffe          BL       GUI_DrawLine
;;;95         GUI_DrawLine(x + 12, y + 12, x + 12, y + 6);
000080  464a              MOV      r2,r9
000082  1da3              ADDS     r3,r4,#6
000084  4639              MOV      r1,r7
000086  4610              MOV      r0,r2
000088  f7fffffe          BL       GUI_DrawLine
00008c  464a              MOV      r2,r9
00008e  4633              MOV      r3,r6
;;;96         GUI_DrawLine(x + 12, y - 6, x + 12, y - 12);
000090  1fa1              SUBS     r1,r4,#6
000092  4610              MOV      r0,r2
000094  f7fffffe          BL       GUI_DrawLine
000098  4633              MOV      r3,r6
;;;97         GUI_DrawLine(x + 12, y - 12, x + 6, y - 12);
00009a  1daa              ADDS     r2,r5,#6
00009c  4648              MOV      r0,r9
00009e  e8bd47f0          POP      {r4-r10,lr}
0000a2  4619              MOV      r1,r3
0000a4  f7ffbffe          B.W      GUI_DrawLine
;;;98     }
;;;99     
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  physical
                          %        40
                  logical
                          %        40
                  sampleX
                          %        800
                  sampleY
                          %        800
                  cal_values
                          %        32

;*** Start embedded assembler ***

#line 1 "..\\tslib\\ts_calibrate.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___14_ts_calibrate_c_ca64a273____REV16|
#line 464 "..\\..\\..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___14_ts_calibrate_c_ca64a273____REV16| PROC
#line 465

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___14_ts_calibrate_c_ca64a273____REVSH|
#line 479
|__asm___14_ts_calibrate_c_ca64a273____REVSH| PROC
#line 480

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___14_ts_calibrate_c_ca64a273____RRX|
#line 666
|__asm___14_ts_calibrate_c_ca64a273____RRX| PROC
#line 667

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
