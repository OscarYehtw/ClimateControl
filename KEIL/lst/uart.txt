; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\obj\uart.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\uart.d --cpu=Cortex-M4.fp --apcs=interwork -O3 --diag_suppress=9931 -I..\..\..\..\Library\Device\Nuvoton\M480\Include -I..\..\..\..\Library\StdDriver\inc -I..\..\..\..\ThirdParty\emWin\Config -I..\..\..\..\ThirdParty\emWin\Include -I..\tslib -I..\..\..\..\Library\CMSIS\Include -I..\Thermostat -I..\Application\Source\Generated -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=523 --omf_browse=.\obj\uart.crf ..\..\..\..\Library\StdDriver\src\uart.c]
                          THUMB

                          AREA ||i.UART_ClearIntFlag||, CODE, READONLY, ALIGN=2

                  UART_ClearIntFlag PROC
;;;40     
;;;41     void UART_ClearIntFlag(UART_T* uart, uint32_t u32InterruptFlag)
000000  054a              LSLS     r2,r1,#21
;;;42     {
000002  d503              BPL      |L1.12|
;;;43     
;;;44         if(u32InterruptFlag & UART_INTSTS_RLSINT_Msk)   /* Clear Receive Line Status Interrupt */
;;;45         {
;;;46             uart->FIFOSTS = UART_FIFOSTS_BIF_Msk | UART_FIFOSTS_FEF_Msk | UART_FIFOSTS_PEF_Msk;
000004  2270              MOVS     r2,#0x70
000006  6182              STR      r2,[r0,#0x18]
;;;47             uart->FIFOSTS = UART_FIFOSTS_ADDRDETF_Msk;
000008  2208              MOVS     r2,#8
00000a  6182              STR      r2,[r0,#0x18]
                  |L1.12|
;;;48         }
;;;49     
;;;50         if(u32InterruptFlag & UART_INTSTS_MODEMINT_Msk)   /* Clear Modem Status Interrupt */
00000c  050a              LSLS     r2,r1,#20
00000e  d503              BPL      |L1.24|
;;;51         {
;;;52             uart->MODEMSTS |= UART_MODEMSTS_CTSDETF_Msk;
000010  6942              LDR      r2,[r0,#0x14]
000012  f0420201          ORR      r2,r2,#1
000016  6142              STR      r2,[r0,#0x14]
                  |L1.24|
;;;53         }
;;;54         else
;;;55         {
;;;56         }
;;;57     
;;;58         if(u32InterruptFlag & UART_INTSTS_BUFERRINT_Msk)   /* Clear Buffer Error Interrupt */
000018  048a              LSLS     r2,r1,#18
00001a  d501              BPL      |L1.32|
;;;59         {
;;;60             uart->FIFOSTS = UART_FIFOSTS_RXOVIF_Msk | UART_FIFOSTS_TXOVIF_Msk;
00001c  4a06              LDR      r2,|L1.56|
00001e  6182              STR      r2,[r0,#0x18]
                  |L1.32|
;;;61         }
;;;62     
;;;63         if(u32InterruptFlag & UART_INTSTS_WKINT_Msk)   /* Clear Wake-up Interrupt */
000020  044a              LSLS     r2,r1,#17
000022  d501              BPL      |L1.40|
;;;64         {
;;;65             uart->WKSTS = UART_WKSTS_CTSWKF_Msk  | UART_WKSTS_DATWKF_Msk  |
000024  221f              MOVS     r2,#0x1f
000026  6442              STR      r2,[r0,#0x44]
                  |L1.40|
;;;66                           UART_WKSTS_RFRTWKF_Msk |UART_WKSTS_RS485WKF_Msk |
;;;67                           UART_WKSTS_TOUTWKF_Msk;
;;;68         }
;;;69     
;;;70         if(u32InterruptFlag & UART_INTSTS_LININT_Msk)   /* Clear LIN Bus Interrupt */
000028  0409              LSLS     r1,r1,#16
00002a  d504              BPL      |L1.54|
;;;71         {
;;;72             uart->INTSTS = UART_INTSTS_LINIF_Msk;
00002c  2180              MOVS     r1,#0x80
00002e  61c1              STR      r1,[r0,#0x1c]
;;;73             uart->LINSTS = UART_LINSTS_BITEF_Msk    | UART_LINSTS_BRKDETF_Msk  |
000030  f240310f          MOV      r1,#0x30f
000034  6381              STR      r1,[r0,#0x38]
                  |L1.54|
;;;74                            UART_LINSTS_SLVSYNCF_Msk | UART_LINSTS_SLVIDPEF_Msk |
;;;75                            UART_LINSTS_SLVHEF_Msk   | UART_LINSTS_SLVHDETF_Msk ;
;;;76         }
;;;77     }
000036  4770              BX       lr
;;;78     
                          ENDP

                  |L1.56|
                          DCD      0x01000001

                          AREA ||i.UART_Close||, CODE, READONLY, ALIGN=1

                  UART_Close PROC
;;;88      */
;;;89     void UART_Close(UART_T* uart)
000000  2100              MOVS     r1,#0
;;;90     {
;;;91         uart->INTEN = 0ul;
000002  6041              STR      r1,[r0,#4]
;;;92     }
000004  4770              BX       lr
;;;93     
                          ENDP


                          AREA ||i.UART_DisableFlowCtrl||, CODE, READONLY, ALIGN=1

                  UART_DisableFlowCtrl PROC
;;;103     */
;;;104    void UART_DisableFlowCtrl(UART_T* uart)
000000  6841              LDR      r1,[r0,#4]
;;;105    {
;;;106        uart->INTEN &= ~(UART_INTEN_ATORTSEN_Msk | UART_INTEN_ATOCTSEN_Msk);
000002  f4215140          BIC      r1,r1,#0x3000
000006  6041              STR      r1,[r0,#4]
;;;107    }
000008  4770              BX       lr
;;;108    
                          ENDP


                          AREA ||i.UART_DisableInt||, CODE, READONLY, ALIGN=1

                  UART_DisableInt PROC
;;;127     */
;;;128    void UART_DisableInt(UART_T*  uart, uint32_t u32InterruptFlag)
000000  6842              LDR      r2,[r0,#4]
;;;129    {
;;;130        /* Disable UART specified interrupt */
;;;131        UART_DISABLE_INT(uart, u32InterruptFlag);
000002  438a              BICS     r2,r2,r1
000004  6042              STR      r2,[r0,#4]
;;;132    }
000006  4770              BX       lr
;;;133    
                          ENDP


                          AREA ||i.UART_EnableFlowCtrl||, CODE, READONLY, ALIGN=1

                  UART_EnableFlowCtrl PROC
;;;143     */
;;;144    void UART_EnableFlowCtrl(UART_T* uart)
000000  6901              LDR      r1,[r0,#0x10]
;;;145    {
;;;146        /* Set RTS pin output is low level active */
;;;147        uart->MODEM |= UART_MODEM_RTSACTLV_Msk;
000002  f4417100          ORR      r1,r1,#0x200
000006  6101              STR      r1,[r0,#0x10]
;;;148    
;;;149        /* Set CTS pin input is low level active */
;;;150        uart->MODEMSTS |= UART_MODEMSTS_CTSACTLV_Msk;
000008  6941              LDR      r1,[r0,#0x14]
00000a  f4417180          ORR      r1,r1,#0x100
00000e  6141              STR      r1,[r0,#0x14]
;;;151    
;;;152        /* Set RTS and CTS auto flow control enable */
;;;153        uart->INTEN |= UART_INTEN_ATORTSEN_Msk | UART_INTEN_ATOCTSEN_Msk;
000010  6841              LDR      r1,[r0,#4]
000012  f4415140          ORR      r1,r1,#0x3000
000016  6041              STR      r1,[r0,#4]
;;;154    }
000018  4770              BX       lr
;;;155    
                          ENDP


                          AREA ||i.UART_EnableInt||, CODE, READONLY, ALIGN=1

                  UART_EnableInt PROC
;;;174     */
;;;175    void UART_EnableInt(UART_T*  uart, uint32_t u32InterruptFlag)
000000  6842              LDR      r2,[r0,#4]
;;;176    {
;;;177        /* Enable UART specified interrupt */
;;;178        UART_ENABLE_INT(uart, u32InterruptFlag);
000002  430a              ORRS     r2,r2,r1
000004  6042              STR      r2,[r0,#4]
;;;179    }
000006  4770              BX       lr
;;;180    
                          ENDP


                          AREA ||i.UART_Open||, CODE, READONLY, ALIGN=2

                  UART_Open PROC
;;;191     */
;;;192    void UART_Open(UART_T* uart, uint32_t u32baudrate)
000000  e92d41ff          PUSH     {r0-r8,lr}
;;;193    {
;;;194        uint32_t u32UartClkSrcSel=0ul, u32UartClkDivNum=0ul;
;;;195        uint32_t u32ClkTbl[4] = {__HXT, 0ul, __LXT, __HIRC};
000004  4b4d              LDR      r3,|L7.316|
000006  460f              MOV      r7,r1                 ;193
000008  4604              MOV      r4,r0                 ;193
00000a  cb0f              LDM      r3,{r0-r3}
00000c  e88d000f          STM      sp,{r0-r3}
000010  2600              MOVS     r6,#0                 ;194
;;;196        uint32_t u32Baud_Div = 0ul;
;;;197    
;;;198    
;;;199        if(uart==(UART_T*)UART0)
000012  494b              LDR      r1,|L7.320|
000014  4635              MOV      r5,r6                 ;194
;;;200        {
;;;201            /* Get UART clock source selection */
;;;202            u32UartClkSrcSel = ((uint32_t)(CLK->CLKSEL1 & CLK_CLKSEL1_UART0SEL_Msk)) >> CLK_CLKSEL1_UART0SEL_Pos;
000016  f04f4080          MOV      r0,#0x40000000
00001a  428c              CMP      r4,r1                 ;199
00001c  d106              BNE      |L7.44|
00001e  f8d01214          LDR      r1,[r0,#0x214]
;;;203            /* Get UART clock divider number */
;;;204            u32UartClkDivNum = (CLK->CLKDIV0 & CLK_CLKDIV0_UART0DIV_Msk) >> CLK_CLKDIV0_UART0DIV_Pos;
000022  f8d00220          LDR      r0,[r0,#0x220]
000026  f3c16601          UBFX     r6,r1,#24,#2          ;202
00002a  e02a              B        |L7.130|
                  |L7.44|
;;;205        }
;;;206        else if(uart==(UART_T*)UART1)
00002c  4945              LDR      r1,|L7.324|
00002e  428c              CMP      r4,r1
000030  d106              BNE      |L7.64|
;;;207        {
;;;208            /* Get UART clock source selection */
;;;209            u32UartClkSrcSel = (CLK->CLKSEL1 & CLK_CLKSEL1_UART1SEL_Msk) >> CLK_CLKSEL1_UART1SEL_Pos;
000032  f8d01214          LDR      r1,[r0,#0x214]
;;;210            /* Get UART clock divider number */
;;;211            u32UartClkDivNum = (CLK->CLKDIV0 & CLK_CLKDIV0_UART1DIV_Msk) >> CLK_CLKDIV0_UART1DIV_Pos;
000036  f8d00220          LDR      r0,[r0,#0x220]
00003a  f3c16681          UBFX     r6,r1,#26,#2          ;209
00003e  e02b              B        |L7.152|
                  |L7.64|
;;;212        }
;;;213        else if(uart==(UART_T*)UART2)
000040  4941              LDR      r1,|L7.328|
000042  428c              CMP      r4,r1
000044  d108              BNE      |L7.88|
;;;214        {
;;;215            /* Get UART clock source selection */
;;;216            u32UartClkSrcSel = (CLK->CLKSEL3 & CLK_CLKSEL3_UART2SEL_Msk) >> CLK_CLKSEL3_UART2SEL_Pos;
000046  f8d0121c          LDR      r1,[r0,#0x21c]
;;;217            /* Get UART clock divider number */
;;;218            u32UartClkDivNum = (CLK->CLKDIV4 & CLK_CLKDIV4_UART2DIV_Msk) >> CLK_CLKDIV4_UART2DIV_Pos;
00004a  f8d00230          LDR      r0,[r0,#0x230]
00004e  f3c16601          UBFX     r6,r1,#24,#2          ;216
000052  f000050f          AND      r5,r0,#0xf
000056  e043              B        |L7.224|
                  |L7.88|
;;;219        }
;;;220        else if(uart==(UART_T*)UART3)
000058  493c              LDR      r1,|L7.332|
00005a  428c              CMP      r4,r1
00005c  d108              BNE      |L7.112|
;;;221        {
;;;222            /* Get UART clock source selection */
;;;223            u32UartClkSrcSel = (CLK->CLKSEL3 & CLK_CLKSEL3_UART3SEL_Msk) >> CLK_CLKSEL3_UART3SEL_Pos;
00005e  f8d0121c          LDR      r1,[r0,#0x21c]
;;;224            /* Get UART clock divider number */
;;;225            u32UartClkDivNum = (CLK->CLKDIV4 & CLK_CLKDIV4_UART3DIV_Msk) >> CLK_CLKDIV4_UART3DIV_Pos;
000062  f8d00230          LDR      r0,[r0,#0x230]
000066  f3c16681          UBFX     r6,r1,#26,#2          ;223
00006a  f3c01503          UBFX     r5,r0,#4,#4
00006e  e037              B        |L7.224|
                  |L7.112|
;;;226        }
;;;227        else if(uart==(UART_T*)UART4)
000070  4937              LDR      r1,|L7.336|
000072  428c              CMP      r4,r1
000074  d108              BNE      |L7.136|
;;;228        {
;;;229            /* Get UART clock source selection */
;;;230            u32UartClkSrcSel = (CLK->CLKSEL3 & CLK_CLKSEL3_UART4SEL_Msk) >> CLK_CLKSEL3_UART4SEL_Pos;
000076  f8d0121c          LDR      r1,[r0,#0x21c]
;;;231            /* Get UART clock divider number */
;;;232            u32UartClkDivNum = (CLK->CLKDIV4 & CLK_CLKDIV4_UART4DIV_Msk) >> CLK_CLKDIV4_UART4DIV_Pos;
00007a  f8d00230          LDR      r0,[r0,#0x230]
00007e  f3c17601          UBFX     r6,r1,#28,#2          ;230
                  |L7.130|
000082  f3c02503          UBFX     r5,r0,#8,#4
000086  e02b              B        |L7.224|
                  |L7.136|
;;;233        }
;;;234        else if(uart==(UART_T*)UART5)
000088  4932              LDR      r1,|L7.340|
00008a  428c              CMP      r4,r1
00008c  d107              BNE      |L7.158|
;;;235        {
;;;236            /* Get UART clock source selection */
;;;237            u32UartClkSrcSel = (CLK->CLKSEL3 & CLK_CLKSEL3_UART5SEL_Msk) >> CLK_CLKSEL3_UART5SEL_Pos;
00008e  f8d0121c          LDR      r1,[r0,#0x21c]
;;;238            /* Get UART clock divider number */
;;;239            u32UartClkDivNum = (CLK->CLKDIV4 & CLK_CLKDIV4_UART5DIV_Msk) >> CLK_CLKDIV4_UART5DIV_Pos;
000092  f8d00230          LDR      r0,[r0,#0x230]
000096  0f8e              LSRS     r6,r1,#30             ;237
                  |L7.152|
000098  f3c03503          UBFX     r5,r0,#12,#4
00009c  e020              B        |L7.224|
                  |L7.158|
;;;240        }
;;;241        else if((uart==(UART_T*)UART6) && ((SYS->CSERVER & SYS_CSERVER_VERSION_Msk) == 0x1)) // M480LD
00009e  4a2e              LDR      r2,|L7.344|
;;;242        {
;;;243            /* Get UART clock source selection */
;;;244            u32UartClkSrcSel = (CLK->CLKSEL3 & CLK_CLKSEL3_UART6SEL_Msk) >> CLK_CLKSEL3_UART6SEL_Pos;
;;;245            /* Get UART clock divider number */
;;;246            u32UartClkDivNum = (CLK->CLKDIV4 & CLK_CLKDIV4_UART6DIV_Msk) >> CLK_CLKDIV4_UART6DIV_Pos;
;;;247        }
;;;248        else if((uart==(UART_T*)UART7) && ((SYS->CSERVER & SYS_CSERVER_VERSION_Msk) == 0x1)) // M480LD
0000a0  492e              LDR      r1,|L7.348|
0000a2  4294              CMP      r4,r2                 ;241
0000a4  d10d              BNE      |L7.194|
0000a6  f8d011f4          LDR      r1,[r0,#0x1f4]        ;241
0000aa  b2c9              UXTB     r1,r1                 ;241
0000ac  2901              CMP      r1,#1                 ;241
0000ae  d117              BNE      |L7.224|
0000b0  f8d0121c          LDR      r1,[r0,#0x21c]        ;244
0000b4  f8d00230          LDR      r0,[r0,#0x230]        ;246
0000b8  f3c15601          UBFX     r6,r1,#20,#2          ;244
0000bc  f3c04503          UBFX     r5,r0,#16,#4          ;246
0000c0  e00e              B        |L7.224|
                  |L7.194|
0000c2  428c              CMP      r4,r1
0000c4  d10c              BNE      |L7.224|
0000c6  f8d011f4          LDR      r1,[r0,#0x1f4]
0000ca  b2c9              UXTB     r1,r1
0000cc  2901              CMP      r1,#1
0000ce  d107              BNE      |L7.224|
;;;249        {
;;;250            /* Get UART clock source selection */
;;;251            u32UartClkSrcSel = (CLK->CLKSEL3 & CLK_CLKSEL3_UART7SEL_Msk) >> CLK_CLKSEL3_UART7SEL_Pos;
0000d0  f8d0121c          LDR      r1,[r0,#0x21c]
;;;252            /* Get UART clock divider number */
;;;253            u32UartClkDivNum = (CLK->CLKDIV4 & CLK_CLKDIV4_UART7DIV_Msk) >> CLK_CLKDIV4_UART7DIV_Pos;
0000d4  f8d00230          LDR      r0,[r0,#0x230]
0000d8  f3c15681          UBFX     r6,r1,#22,#2          ;251
0000dc  f3c05503          UBFX     r5,r0,#20,#4
                  |L7.224|
;;;254        }
;;;255    
;;;256        /* Select UART function */
;;;257        uart->FUNCSEL = UART_FUNCSEL_UART;
0000e0  2000              MOVS     r0,#0
0000e2  6320              STR      r0,[r4,#0x30]
;;;258    
;;;259        /* Set UART line configuration */
;;;260        uart->LINE = UART_WORD_LEN_8 | UART_PARITY_NONE | UART_STOP_BIT_1;
0000e4  2003              MOVS     r0,#3
0000e6  60e0              STR      r0,[r4,#0xc]
;;;261    
;;;262        /* Set UART Rx and RTS trigger level */
;;;263        uart->FIFO &= ~(UART_FIFO_RFITL_Msk | UART_FIFO_RTSTRGLV_Msk);
0000e8  68a0              LDR      r0,[r4,#8]
0000ea  491d              LDR      r1,|L7.352|
0000ec  4008              ANDS     r0,r0,r1
0000ee  60a0              STR      r0,[r4,#8]
0000f0  46e8              MOV      r8,sp                 ;195
;;;264    
;;;265        /* Get PLL clock frequency if UART clock source selection is PLL */
;;;266        if(u32UartClkSrcSel == 1ul)
0000f2  2e01              CMP      r6,#1
0000f4  d102              BNE      |L7.252|
;;;267        {
;;;268            u32ClkTbl[u32UartClkSrcSel] = CLK_GetPLLClockFreq();
0000f6  f7fffffe          BL       CLK_GetPLLClockFreq
0000fa  9001              STR      r0,[sp,#4]
                  |L7.252|
;;;269        }
;;;270    
;;;271        /* Set UART baud rate */
;;;272        if(u32baudrate != 0ul)
0000fc  2f00              CMP      r7,#0
0000fe  d01a              BEQ      |L7.310|
;;;273        {
;;;274            u32Baud_Div = UART_BAUD_MODE2_DIVIDER((u32ClkTbl[u32UartClkSrcSel]) / (u32UartClkDivNum + 1ul), u32baudrate);
000100  f8581026          LDR      r1,[r8,r6,LSL #2]
000104  1c6d              ADDS     r5,r5,#1
000106  fbb1f0f5          UDIV     r0,r1,r5
00010a  eb000057          ADD      r0,r0,r7,LSR #1
00010e  fbb0f0f7          UDIV     r0,r0,r7
000112  1e80              SUBS     r0,r0,#2
;;;275    
;;;276            if(u32Baud_Div > 0xFFFFul)
000114  f5b03f80          CMP      r0,#0x10000
000118  d30a              BCC      |L7.304|
;;;277            {
;;;278                uart->BAUD = (UART_BAUD_MODE0 | UART_BAUD_MODE0_DIVIDER((u32ClkTbl[u32UartClkSrcSel]) / (u32UartClkDivNum + 1ul), u32baudrate));
00011a  fbb1f0f5          UDIV     r0,r1,r5
00011e  eb0000c7          ADD      r0,r0,r7,LSL #3
000122  fbb0f0f7          UDIV     r0,r0,r7
000126  f06f0101          MVN      r1,#1
00012a  eb011010          ADD      r0,r1,r0,LSR #4
00012e  e001              B        |L7.308|
                  |L7.304|
;;;279            }
;;;280            else
;;;281            {
;;;282                uart->BAUD = (UART_BAUD_MODE2 | u32Baud_Div);
000130  f0405040          ORR      r0,r0,#0x30000000
                  |L7.308|
000134  6260              STR      r0,[r4,#0x24]
                  |L7.310|
;;;283            }
;;;284        }
;;;285    }
000136  e8bd81ff          POP      {r0-r8,pc}
;;;286    
                          ENDP

00013a  0000              DCW      0x0000
                  |L7.316|
                          DCD      ||.constdata||
                  |L7.320|
                          DCD      0x40070000
                  |L7.324|
                          DCD      0x40071000
                  |L7.328|
                          DCD      0x40072000
                  |L7.332|
                          DCD      0x40073000
                  |L7.336|
                          DCD      0x40074000
                  |L7.340|
                          DCD      0x40075000
                  |L7.344|
                          DCD      0x40076000
                  |L7.348|
                          DCD      0x40077000
                  |L7.352|
                          DCD      0xfff0ff0f

                          AREA ||i.UART_Read||, CODE, READONLY, ALIGN=1

                  UART_Read PROC
;;;298     */
;;;299    uint32_t UART_Read(UART_T* uart, uint8_t pu8RxBuf[], uint32_t u32ReadBytes)
000000  b5f0              PUSH     {r4-r7,lr}
;;;300    {
000002  4604              MOV      r4,r0
;;;301        uint32_t  u32Count, u32delayno;
;;;302        uint32_t  u32Exit = 0ul;
000004  2500              MOVS     r5,#0
;;;303    
;;;304        for(u32Count = 0ul; u32Count < u32ReadBytes; u32Count++)
000006  4628              MOV      r0,r5
;;;305        {
;;;306            u32delayno = 0ul;
;;;307    
;;;308            while(uart->FIFOSTS & UART_FIFOSTS_RXEMPTY_Msk)   /* Check RX empty => failed */
;;;309            {
;;;310                u32delayno++;
;;;311                if(u32delayno >= 0x40000000ul)
000008  f04f4680          MOV      r6,#0x40000000
00000c  e00c              B        |L8.40|
                  |L8.14|
00000e  2300              MOVS     r3,#0                 ;306
000010  e002              B        |L8.24|
                  |L8.18|
000012  1c5b              ADDS     r3,r3,#1              ;308
000014  42b3              CMP      r3,r6
000016  d209              BCS      |L8.44|
                  |L8.24|
000018  69a7              LDR      r7,[r4,#0x18]         ;308
00001a  047f              LSLS     r7,r7,#17             ;308
00001c  d4f9              BMI      |L8.18|
;;;312                {
;;;313                    u32Exit = 1ul;
;;;314                    break;
;;;315                }
;;;316                else
;;;317                {
;;;318                }
;;;319            }
;;;320    
;;;321            if(u32Exit == 1ul)
00001e  2d00              CMP      r5,#0
000020  d104              BNE      |L8.44|
;;;322            {
;;;323                break;
;;;324            }
;;;325            else
;;;326            {
;;;327                pu8RxBuf[u32Count] = (uint8_t)uart->DAT; /* Get Data from UART RX  */
000022  6823              LDR      r3,[r4,#0]
000024  540b              STRB     r3,[r1,r0]
000026  1c40              ADDS     r0,r0,#1
                  |L8.40|
000028  4290              CMP      r0,r2                 ;304
00002a  d3f0              BCC      |L8.14|
                  |L8.44|
;;;328            }
;;;329        }
;;;330    
;;;331        return u32Count;
;;;332    
;;;333    }
00002c  bdf0              POP      {r4-r7,pc}
;;;334    
                          ENDP


                          AREA ||i.UART_SelectIrDAMode||, CODE, READONLY, ALIGN=2

                  UART_SelectIrDAMode PROC
;;;487     */
;;;488    void UART_SelectIrDAMode(UART_T* uart, uint32_t u32Buadrate, uint32_t u32Direction)
000000  e92d47ff          PUSH     {r0-r10,lr}
;;;489    {
;;;490        uint32_t u32UartClkSrcSel=0ul, u32UartClkDivNum=0ul;
;;;491        uint32_t u32ClkTbl[4ul] = {__HXT, 0ul, __LXT, __HIRC};
000004  4b4d              LDR      r3,|L9.316|
000006  4691              MOV      r9,r2                 ;489
000008  460f              MOV      r7,r1                 ;489
00000a  4604              MOV      r4,r0                 ;489
00000c  cb0f              LDM      r3,{r0-r3}
00000e  e88d000f          STM      sp,{r0-r3}
000012  2500              MOVS     r5,#0                 ;490
;;;492        uint32_t u32Baud_Div;
;;;493    
;;;494        /* Select IrDA function mode */
;;;495        uart->FUNCSEL = UART_FUNCSEL_IrDA;
000014  2002              MOVS     r0,#2
000016  462e              MOV      r6,r5                 ;490
000018  6320              STR      r0,[r4,#0x30]
;;;496    
;;;497    
;;;498        if(uart==UART0)
00001a  4949              LDR      r1,|L9.320|
;;;499        {
;;;500            /* Get UART clock source selection */
;;;501            u32UartClkSrcSel = (CLK->CLKSEL1 & CLK_CLKSEL1_UART0SEL_Msk) >> CLK_CLKSEL1_UART0SEL_Pos;
00001c  0740              LSLS     r0,r0,#29
00001e  46e8              MOV      r8,sp                 ;491
000020  428c              CMP      r4,r1                 ;498
000022  d106              BNE      |L9.50|
000024  f8d01214          LDR      r1,[r0,#0x214]
;;;502            /* Get UART clock divider number */
;;;503            u32UartClkDivNum = (CLK->CLKDIV0 & CLK_CLKDIV0_UART0DIV_Msk) >> CLK_CLKDIV0_UART0DIV_Pos;
000028  f8d00220          LDR      r0,[r0,#0x220]
00002c  f3c16501          UBFX     r5,r1,#24,#2          ;501
000030  e02a              B        |L9.136|
                  |L9.50|
;;;504        }
;;;505        else if(uart==UART1)
000032  4944              LDR      r1,|L9.324|
000034  428c              CMP      r4,r1
000036  d106              BNE      |L9.70|
;;;506        {
;;;507            /* Get UART clock source selection */
;;;508            u32UartClkSrcSel = (CLK->CLKSEL1 & CLK_CLKSEL1_UART1SEL_Msk) >> CLK_CLKSEL1_UART1SEL_Pos;
000038  f8d01214          LDR      r1,[r0,#0x214]
;;;509            /* Get UART clock divider number */
;;;510            u32UartClkDivNum = (CLK->CLKDIV0 & CLK_CLKDIV0_UART1DIV_Msk) >> CLK_CLKDIV0_UART1DIV_Pos;
00003c  f8d00220          LDR      r0,[r0,#0x220]
000040  f3c16581          UBFX     r5,r1,#26,#2          ;508
000044  e02b              B        |L9.158|
                  |L9.70|
;;;511        }
;;;512        else if(uart==UART2)
000046  4940              LDR      r1,|L9.328|
000048  428c              CMP      r4,r1
00004a  d108              BNE      |L9.94|
;;;513        {
;;;514            /* Get UART clock source selection */
;;;515            u32UartClkSrcSel = (CLK->CLKSEL3 & CLK_CLKSEL3_UART2SEL_Msk) >> CLK_CLKSEL3_UART2SEL_Pos;
00004c  f8d0121c          LDR      r1,[r0,#0x21c]
;;;516            /* Get UART clock divider number */
;;;517            u32UartClkDivNum = (CLK->CLKDIV4 & CLK_CLKDIV4_UART2DIV_Msk) >> CLK_CLKDIV4_UART2DIV_Pos;
000050  f8d00230          LDR      r0,[r0,#0x230]
000054  f3c16501          UBFX     r5,r1,#24,#2          ;515
000058  f000060f          AND      r6,r0,#0xf
00005c  e043              B        |L9.230|
                  |L9.94|
;;;518        }
;;;519        else if(uart==UART3)
00005e  493b              LDR      r1,|L9.332|
000060  428c              CMP      r4,r1
000062  d108              BNE      |L9.118|
;;;520        {
;;;521            /* Get UART clock source selection */
;;;522            u32UartClkSrcSel = (CLK->CLKSEL3 & CLK_CLKSEL3_UART3SEL_Msk) >> CLK_CLKSEL3_UART3SEL_Pos;
000064  f8d0121c          LDR      r1,[r0,#0x21c]
;;;523            /* Get UART clock divider number */
;;;524            u32UartClkDivNum = (CLK->CLKDIV4 & CLK_CLKDIV4_UART3DIV_Msk) >> CLK_CLKDIV4_UART3DIV_Pos;
000068  f8d00230          LDR      r0,[r0,#0x230]
00006c  f3c16581          UBFX     r5,r1,#26,#2          ;522
000070  f3c01603          UBFX     r6,r0,#4,#4
000074  e037              B        |L9.230|
                  |L9.118|
;;;525        }
;;;526        else if(uart==UART4)
000076  4936              LDR      r1,|L9.336|
000078  428c              CMP      r4,r1
00007a  d108              BNE      |L9.142|
;;;527        {
;;;528            /* Get UART clock source selection */
;;;529            u32UartClkSrcSel = (CLK->CLKSEL3 & CLK_CLKSEL3_UART4SEL_Msk) >> CLK_CLKSEL3_UART4SEL_Pos;
00007c  f8d0121c          LDR      r1,[r0,#0x21c]
;;;530            /* Get UART clock divider number */
;;;531            u32UartClkDivNum = (CLK->CLKDIV4 & CLK_CLKDIV4_UART4DIV_Msk) >> CLK_CLKDIV4_UART4DIV_Pos;
000080  f8d00230          LDR      r0,[r0,#0x230]
000084  f3c17501          UBFX     r5,r1,#28,#2          ;529
                  |L9.136|
000088  f3c02603          UBFX     r6,r0,#8,#4
00008c  e02b              B        |L9.230|
                  |L9.142|
;;;532        }
;;;533        else if(uart==UART5)
00008e  4931              LDR      r1,|L9.340|
000090  428c              CMP      r4,r1
000092  d107              BNE      |L9.164|
;;;534        {
;;;535            /* Get UART clock source selection */
;;;536            u32UartClkSrcSel = (CLK->CLKSEL3 & CLK_CLKSEL3_UART5SEL_Msk) >> CLK_CLKSEL3_UART5SEL_Pos;
000094  f8d0121c          LDR      r1,[r0,#0x21c]
;;;537            /* Get UART clock divider number */
;;;538            u32UartClkDivNum = (CLK->CLKDIV4 & CLK_CLKDIV4_UART5DIV_Msk) >> CLK_CLKDIV4_UART5DIV_Pos;
000098  f8d00230          LDR      r0,[r0,#0x230]
00009c  0f8d              LSRS     r5,r1,#30             ;536
                  |L9.158|
00009e  f3c03603          UBFX     r6,r0,#12,#4
0000a2  e020              B        |L9.230|
                  |L9.164|
;;;539        }
;;;540        else if((uart==(UART_T*)UART6) && ((SYS->CSERVER & SYS_CSERVER_VERSION_Msk) == 0x1)) // M480LD
0000a4  4a2c              LDR      r2,|L9.344|
;;;541        {
;;;542            /* Get UART clock source selection */
;;;543            u32UartClkSrcSel = (CLK->CLKSEL3 & CLK_CLKSEL3_UART6SEL_Msk) >> CLK_CLKSEL3_UART6SEL_Pos;
;;;544            /* Get UART clock divider number */
;;;545            u32UartClkDivNum = (CLK->CLKDIV4 & CLK_CLKDIV4_UART6DIV_Msk) >> CLK_CLKDIV4_UART6DIV_Pos;
;;;546        }
;;;547        else if((uart==(UART_T*)UART7) && ((SYS->CSERVER & SYS_CSERVER_VERSION_Msk) == 0x1)) // M480LD
0000a6  492d              LDR      r1,|L9.348|
0000a8  4294              CMP      r4,r2                 ;540
0000aa  d10d              BNE      |L9.200|
0000ac  f8d011f4          LDR      r1,[r0,#0x1f4]        ;540
0000b0  b2c9              UXTB     r1,r1                 ;540
0000b2  2901              CMP      r1,#1                 ;540
0000b4  d11c              BNE      |L9.240|
0000b6  f8d0121c          LDR      r1,[r0,#0x21c]        ;543
0000ba  f8d00230          LDR      r0,[r0,#0x230]        ;545
0000be  f3c15501          UBFX     r5,r1,#20,#2          ;543
0000c2  f3c04603          UBFX     r6,r0,#16,#4          ;545
0000c6  e00e              B        |L9.230|
                  |L9.200|
0000c8  428c              CMP      r4,r1
0000ca  d111              BNE      |L9.240|
0000cc  f8d011f4          LDR      r1,[r0,#0x1f4]
0000d0  b2c9              UXTB     r1,r1
0000d2  2901              CMP      r1,#1
0000d4  d10c              BNE      |L9.240|
;;;548        {
;;;549            /* Get UART clock source selection */
;;;550            u32UartClkSrcSel = (CLK->CLKSEL3 & CLK_CLKSEL3_UART7SEL_Msk) >> CLK_CLKSEL3_UART7SEL_Pos;
0000d6  f8d0121c          LDR      r1,[r0,#0x21c]
;;;551            /* Get UART clock divider number */
;;;552            u32UartClkDivNum = (CLK->CLKDIV4 & CLK_CLKDIV4_UART7DIV_Msk) >> CLK_CLKDIV4_UART7DIV_Pos;
0000da  f8d00230          LDR      r0,[r0,#0x230]
0000de  f3c15581          UBFX     r5,r1,#22,#2          ;550
0000e2  f3c05603          UBFX     r6,r0,#20,#4
                  |L9.230|
;;;553        }
;;;554    
;;;555        /* Get PLL clock frequency if UART clock source selection is PLL */
;;;556        if(u32UartClkSrcSel == 1ul)
0000e6  2d01              CMP      r5,#1
0000e8  d102              BNE      |L9.240|
;;;557        {
;;;558            u32ClkTbl[u32UartClkSrcSel] = CLK_GetPLLClockFreq();
0000ea  f7fffffe          BL       CLK_GetPLLClockFreq
0000ee  9001              STR      r0,[sp,#4]
                  |L9.240|
;;;559        }
;;;560        else
;;;561        {
;;;562        }
;;;563    
;;;564        /* Set UART IrDA baud rate in mode 0 */
;;;565        if(u32Buadrate != 0ul)
0000f0  b187              CBZ      r7,|L9.276|
;;;566        {
;;;567            u32Baud_Div = UART_BAUD_MODE0_DIVIDER((u32ClkTbl[u32UartClkSrcSel]) / (u32UartClkDivNum + 1ul), u32Buadrate);
0000f2  f8580025          LDR      r0,[r8,r5,LSL #2]
0000f6  1c76              ADDS     r6,r6,#1
0000f8  fbb0f0f6          UDIV     r0,r0,r6
0000fc  eb0000c7          ADD      r0,r0,r7,LSL #3
000100  fbb0f0f7          UDIV     r0,r0,r7
000104  f06f0101          MVN      r1,#1
000108  eb011010          ADD      r0,r1,r0,LSR #4
;;;568    
;;;569            if(u32Baud_Div < 0xFFFFul)
00010c  0c09              LSRS     r1,r1,#16
00010e  4288              CMP      r0,r1
000110  d200              BCS      |L9.276|
;;;570            {
;;;571                uart->BAUD = (UART_BAUD_MODE0 | u32Baud_Div);
000112  6260              STR      r0,[r4,#0x24]
                  |L9.276|
;;;572            }
;;;573            else
;;;574            {
;;;575            }
;;;576        }
;;;577    
;;;578        /* Configure IrDA relative settings */
;;;579        if(u32Direction == UART_IRDA_RXEN)
;;;580        {
;;;581            uart->IRDA |= UART_IRDA_RXINV_Msk;     /*Rx signal is inverse*/
;;;582            uart->IRDA &= ~UART_IRDA_TXEN_Msk;
;;;583        }
;;;584        else
;;;585        {
;;;586            uart->IRDA &= ~UART_IRDA_TXINV_Msk;    /*Tx signal is not inverse*/
000114  6aa0              LDR      r0,[r4,#0x28]
000116  f1b90f00          CMP      r9,#0                 ;579
00011a  d008              BEQ      |L9.302|
00011c  f0200020          BIC      r0,r0,#0x20
000120  62a0              STR      r0,[r4,#0x28]
;;;587            uart->IRDA |= UART_IRDA_TXEN_Msk;
000122  6aa0              LDR      r0,[r4,#0x28]
000124  f0400002          ORR      r0,r0,#2
                  |L9.296|
000128  62a0              STR      r0,[r4,#0x28]         ;582
;;;588        }
;;;589    
;;;590    }
00012a  e8bd87ff          POP      {r0-r10,pc}
                  |L9.302|
00012e  f0400040          ORR      r0,r0,#0x40           ;581
000132  62a0              STR      r0,[r4,#0x28]         ;581
000134  6aa0              LDR      r0,[r4,#0x28]         ;582
000136  f0200002          BIC      r0,r0,#2              ;582
00013a  e7f5              B        |L9.296|
;;;591    
                          ENDP

                  |L9.316|
                          DCD      ||.constdata||+0x20
                  |L9.320|
                          DCD      0x40070000
                  |L9.324|
                          DCD      0x40071000
                  |L9.328|
                          DCD      0x40072000
                  |L9.332|
                          DCD      0x40073000
                  |L9.336|
                          DCD      0x40074000
                  |L9.340|
                          DCD      0x40075000
                  |L9.344|
                          DCD      0x40076000
                  |L9.348|
                          DCD      0x40077000

                          AREA ||i.UART_SelectLINMode||, CODE, READONLY, ALIGN=1

                  UART_SelectLINMode PROC
;;;630     */
;;;631    void UART_SelectLINMode(UART_T* uart, uint32_t u32Mode, uint32_t u32BreakLength)
000000  2301              MOVS     r3,#1
;;;632    {
;;;633        /* Select LIN function mode */
;;;634        uart->FUNCSEL = UART_FUNCSEL_LIN;
000002  6303              STR      r3,[r0,#0x30]
;;;635    
;;;636        /* Select LIN function setting : Tx enable, Rx enable and break field length */
;;;637        uart->ALTCTL &= ~(UART_ALTCTL_LINTXEN_Msk | UART_ALTCTL_LINRXEN_Msk | UART_ALTCTL_BRKFL_Msk);
000004  6ac3              LDR      r3,[r0,#0x2c]
000006  f02303cf          BIC      r3,r3,#0xcf
00000a  62c3              STR      r3,[r0,#0x2c]
;;;638        uart->ALTCTL |= (u32Mode | (u32BreakLength << UART_ALTCTL_BRKFL_Pos));
00000c  6ac3              LDR      r3,[r0,#0x2c]
00000e  4311              ORRS     r1,r1,r2
000010  430b              ORRS     r3,r3,r1
000012  62c3              STR      r3,[r0,#0x2c]
;;;639    }
000014  4770              BX       lr
;;;640    
                          ENDP


                          AREA ||i.UART_SelectRS485Mode||, CODE, READONLY, ALIGN=2

                  UART_SelectRS485Mode PROC
;;;606     */
;;;607    void UART_SelectRS485Mode(UART_T* uart, uint32_t u32Mode, uint32_t u32Addr)
000000  b510              PUSH     {r4,lr}
;;;608    {
;;;609        /* Select UART RS485 function mode */
;;;610        uart->FUNCSEL = UART_FUNCSEL_RS485;
000002  2303              MOVS     r3,#3
000004  6303              STR      r3,[r0,#0x30]
;;;611    
;;;612        /* Set RS585 configuration */
;;;613        uart->ALTCTL &= ~(UART_ALTCTL_RS485NMM_Msk | UART_ALTCTL_RS485AUD_Msk | UART_ALTCTL_RS485AAD_Msk | UART_ALTCTL_ADDRMV_Msk);
000006  6ac3              LDR      r3,[r0,#0x2c]
000008  4c04              LDR      r4,|L11.28|
00000a  4023              ANDS     r3,r3,r4
00000c  62c3              STR      r3,[r0,#0x2c]
;;;614        uart->ALTCTL |= (u32Mode | (u32Addr << UART_ALTCTL_ADDRMV_Pos));
00000e  6ac3              LDR      r3,[r0,#0x2c]
000010  ea416102          ORR      r1,r1,r2,LSL #24
000014  430b              ORRS     r3,r3,r1
000016  62c3              STR      r3,[r0,#0x2c]
;;;615    }
000018  bd10              POP      {r4,pc}
;;;616    
                          ENDP

00001a  0000              DCW      0x0000
                  |L11.28|
                          DCD      0x00fff8ff

                          AREA ||i.UART_SetLineConfig||, CODE, READONLY, ALIGN=2

                  UART_SetLineConfig PROC
;;;361     */
;;;362    void UART_SetLineConfig(UART_T* uart, uint32_t u32baudrate, uint32_t u32data_width, uint32_t u32parity, uint32_t  u32stop_bits)
000000  e92d5fff          PUSH     {r0-r12,lr}
;;;363    {
000004  469a              MOV      r10,r3
;;;364        uint32_t u32UartClkSrcSel=0ul, u32UartClkDivNum=0ul;
;;;365        uint32_t u32ClkTbl[4ul] = {__HXT, 0ul, __LXT, __HIRC};
000006  4b4d              LDR      r3,|L12.316|
000008  4691              MOV      r9,r2                 ;363
00000a  460f              MOV      r7,r1                 ;363
00000c  4605              MOV      r5,r0                 ;363
00000e  cb0f              LDM      r3,{r0-r3}
000010  f8ddb038          LDR      r11,[sp,#0x38]
000014  e88d000f          STM      sp,{r0-r3}
000018  2600              MOVS     r6,#0                 ;364
;;;366        uint32_t u32Baud_Div = 0ul;
;;;367    
;;;368    
;;;369        if(uart==(UART_T*)UART0)
00001a  4949              LDR      r1,|L12.320|
00001c  4634              MOV      r4,r6                 ;364
;;;370        {
;;;371            /* Get UART clock source selection */
;;;372            u32UartClkSrcSel = (CLK->CLKSEL1 & CLK_CLKSEL1_UART0SEL_Msk) >> CLK_CLKSEL1_UART0SEL_Pos;
00001e  f04f4080          MOV      r0,#0x40000000
000022  46e8              MOV      r8,sp                 ;365
000024  428d              CMP      r5,r1                 ;369
000026  d106              BNE      |L12.54|
000028  f8d01214          LDR      r1,[r0,#0x214]
;;;373            /* Get UART clock divider number */
;;;374            u32UartClkDivNum = (CLK->CLKDIV0 & CLK_CLKDIV0_UART0DIV_Msk) >> CLK_CLKDIV0_UART0DIV_Pos;
00002c  f8d00220          LDR      r0,[r0,#0x220]
000030  f3c16601          UBFX     r6,r1,#24,#2          ;372
000034  e02a              B        |L12.140|
                  |L12.54|
;;;375        }
;;;376        else if(uart==(UART_T*)UART1)
000036  4943              LDR      r1,|L12.324|
000038  428d              CMP      r5,r1
00003a  d106              BNE      |L12.74|
;;;377        {
;;;378            /* Get UART clock source selection */
;;;379            u32UartClkSrcSel = (CLK->CLKSEL1 & CLK_CLKSEL1_UART1SEL_Msk) >> CLK_CLKSEL1_UART1SEL_Pos;
00003c  f8d01214          LDR      r1,[r0,#0x214]
;;;380            /* Get UART clock divider number */
;;;381            u32UartClkDivNum = (CLK->CLKDIV0 & CLK_CLKDIV0_UART1DIV_Msk) >> CLK_CLKDIV0_UART1DIV_Pos;
000040  f8d00220          LDR      r0,[r0,#0x220]
000044  f3c16681          UBFX     r6,r1,#26,#2          ;379
000048  e02b              B        |L12.162|
                  |L12.74|
;;;382        }
;;;383        else if(uart==(UART_T*)UART2)
00004a  493f              LDR      r1,|L12.328|
00004c  428d              CMP      r5,r1
00004e  d108              BNE      |L12.98|
;;;384        {
;;;385            /* Get UART clock source selection */
;;;386            u32UartClkSrcSel = (CLK->CLKSEL3 & CLK_CLKSEL3_UART2SEL_Msk) >> CLK_CLKSEL3_UART2SEL_Pos;
000050  f8d0121c          LDR      r1,[r0,#0x21c]
;;;387            /* Get UART clock divider number */
;;;388            u32UartClkDivNum = (CLK->CLKDIV4 & CLK_CLKDIV4_UART2DIV_Msk) >> CLK_CLKDIV4_UART2DIV_Pos;
000054  f8d00230          LDR      r0,[r0,#0x230]
000058  f3c16601          UBFX     r6,r1,#24,#2          ;386
00005c  f000040f          AND      r4,r0,#0xf
000060  e043              B        |L12.234|
                  |L12.98|
;;;389        }
;;;390        else if(uart==(UART_T*)UART3)
000062  493a              LDR      r1,|L12.332|
000064  428d              CMP      r5,r1
000066  d108              BNE      |L12.122|
;;;391        {
;;;392            /* Get UART clock source selection */
;;;393            u32UartClkSrcSel = (CLK->CLKSEL3 & CLK_CLKSEL3_UART3SEL_Msk) >> CLK_CLKSEL3_UART3SEL_Pos;
000068  f8d0121c          LDR      r1,[r0,#0x21c]
;;;394            /* Get UART clock divider number */
;;;395            u32UartClkDivNum = (CLK->CLKDIV4 & CLK_CLKDIV4_UART3DIV_Msk) >> CLK_CLKDIV4_UART3DIV_Pos;
00006c  f8d00230          LDR      r0,[r0,#0x230]
000070  f3c16681          UBFX     r6,r1,#26,#2          ;393
000074  f3c01403          UBFX     r4,r0,#4,#4
000078  e037              B        |L12.234|
                  |L12.122|
;;;396        }
;;;397        else if(uart==(UART_T*)UART4)
00007a  4935              LDR      r1,|L12.336|
00007c  428d              CMP      r5,r1
00007e  d108              BNE      |L12.146|
;;;398        {
;;;399            /* Get UART clock source selection */
;;;400            u32UartClkSrcSel = (CLK->CLKSEL3 & CLK_CLKSEL3_UART4SEL_Msk) >> CLK_CLKSEL3_UART4SEL_Pos;
000080  f8d0121c          LDR      r1,[r0,#0x21c]
;;;401            /* Get UART clock divider number */
;;;402            u32UartClkDivNum = (CLK->CLKDIV4 & CLK_CLKDIV4_UART4DIV_Msk) >> CLK_CLKDIV4_UART4DIV_Pos;
000084  f8d00230          LDR      r0,[r0,#0x230]
000088  f3c17601          UBFX     r6,r1,#28,#2          ;400
                  |L12.140|
00008c  f3c02403          UBFX     r4,r0,#8,#4
000090  e02b              B        |L12.234|
                  |L12.146|
;;;403        }
;;;404        else if(uart==(UART_T*)UART5)
000092  4930              LDR      r1,|L12.340|
000094  428d              CMP      r5,r1
000096  d107              BNE      |L12.168|
;;;405        {
;;;406            /* Get UART clock source selection */
;;;407            u32UartClkSrcSel = (CLK->CLKSEL3 & CLK_CLKSEL3_UART5SEL_Msk) >> CLK_CLKSEL3_UART5SEL_Pos;
000098  f8d0121c          LDR      r1,[r0,#0x21c]
;;;408            /* Get UART clock divider number */
;;;409            u32UartClkDivNum = (CLK->CLKDIV4 & CLK_CLKDIV4_UART5DIV_Msk) >> CLK_CLKDIV4_UART5DIV_Pos;
00009c  f8d00230          LDR      r0,[r0,#0x230]
0000a0  0f8e              LSRS     r6,r1,#30             ;407
                  |L12.162|
0000a2  f3c03403          UBFX     r4,r0,#12,#4
0000a6  e020              B        |L12.234|
                  |L12.168|
;;;410        }
;;;411        else if((uart==(UART_T*)UART6) && ((SYS->CSERVER & SYS_CSERVER_VERSION_Msk) == 0x1)) // M480LD
0000a8  4a2b              LDR      r2,|L12.344|
;;;412        {
;;;413            /* Get UART clock source selection */
;;;414            u32UartClkSrcSel = (CLK->CLKSEL3 & CLK_CLKSEL3_UART6SEL_Msk) >> CLK_CLKSEL3_UART6SEL_Pos;
;;;415            /* Get UART clock divider number */
;;;416            u32UartClkDivNum = (CLK->CLKDIV4 & CLK_CLKDIV4_UART6DIV_Msk) >> CLK_CLKDIV4_UART6DIV_Pos;
;;;417        }
;;;418        else if((uart==(UART_T*)UART7) && ((SYS->CSERVER & SYS_CSERVER_VERSION_Msk) == 0x1)) // M480LD
0000aa  492c              LDR      r1,|L12.348|
0000ac  4295              CMP      r5,r2                 ;411
0000ae  d10d              BNE      |L12.204|
0000b0  f8d011f4          LDR      r1,[r0,#0x1f4]        ;411
0000b4  b2c9              UXTB     r1,r1                 ;411
0000b6  2901              CMP      r1,#1                 ;411
0000b8  d11c              BNE      |L12.244|
0000ba  f8d0121c          LDR      r1,[r0,#0x21c]        ;414
0000be  f8d00230          LDR      r0,[r0,#0x230]        ;416
0000c2  f3c15601          UBFX     r6,r1,#20,#2          ;414
0000c6  f3c04403          UBFX     r4,r0,#16,#4          ;416
0000ca  e00e              B        |L12.234|
                  |L12.204|
0000cc  428d              CMP      r5,r1
0000ce  d111              BNE      |L12.244|
0000d0  f8d011f4          LDR      r1,[r0,#0x1f4]
0000d4  b2c9              UXTB     r1,r1
0000d6  2901              CMP      r1,#1
0000d8  d10c              BNE      |L12.244|
;;;419        {
;;;420            /* Get UART clock source selection */
;;;421            u32UartClkSrcSel = (CLK->CLKSEL3 & CLK_CLKSEL3_UART7SEL_Msk) >> CLK_CLKSEL3_UART7SEL_Pos;
0000da  f8d0121c          LDR      r1,[r0,#0x21c]
;;;422            /* Get UART clock divider number */
;;;423            u32UartClkDivNum = (CLK->CLKDIV4 & CLK_CLKDIV4_UART7DIV_Msk) >> CLK_CLKDIV4_UART7DIV_Pos;
0000de  f8d00230          LDR      r0,[r0,#0x230]
0000e2  f3c15681          UBFX     r6,r1,#22,#2          ;421
0000e6  f3c05403          UBFX     r4,r0,#20,#4
                  |L12.234|
;;;424        }
;;;425    
;;;426        /* Get PLL clock frequency if UART clock source selection is PLL */
;;;427        if(u32UartClkSrcSel == 1ul)
0000ea  2e01              CMP      r6,#1
0000ec  d102              BNE      |L12.244|
;;;428        {
;;;429            u32ClkTbl[u32UartClkSrcSel] = CLK_GetPLLClockFreq();
0000ee  f7fffffe          BL       CLK_GetPLLClockFreq
0000f2  9001              STR      r0,[sp,#4]
                  |L12.244|
;;;430        }
;;;431        else
;;;432        {
;;;433        }
;;;434    
;;;435        /* Set UART baud rate */
;;;436        if(u32baudrate != 0ul)
0000f4  b1d7              CBZ      r7,|L12.300|
;;;437        {
;;;438            u32Baud_Div = UART_BAUD_MODE2_DIVIDER((u32ClkTbl[u32UartClkSrcSel]) / (u32UartClkDivNum + 1ul), u32baudrate);
0000f6  f8580026          LDR      r0,[r8,r6,LSL #2]
0000fa  1c64              ADDS     r4,r4,#1
0000fc  fbb0f1f4          UDIV     r1,r0,r4
000100  eb010157          ADD      r1,r1,r7,LSR #1
000104  fbb1f1f7          UDIV     r1,r1,r7
000108  1e89              SUBS     r1,r1,#2
;;;439    
;;;440            if(u32Baud_Div > 0xFFFFul)
00010a  f5b13f80          CMP      r1,#0x10000
00010e  d30a              BCC      |L12.294|
;;;441            {
;;;442                uart->BAUD = (UART_BAUD_MODE0 | UART_BAUD_MODE0_DIVIDER((u32ClkTbl[u32UartClkSrcSel]) / (u32UartClkDivNum + 1ul), u32baudrate));
000110  fbb0f0f4          UDIV     r0,r0,r4
000114  eb0000c7          ADD      r0,r0,r7,LSL #3
000118  fbb0f0f7          UDIV     r0,r0,r7
00011c  f06f0101          MVN      r1,#1
000120  eb011010          ADD      r0,r1,r0,LSR #4
000124  e001              B        |L12.298|
                  |L12.294|
;;;443            }
;;;444            else
;;;445            {
;;;446                uart->BAUD = (UART_BAUD_MODE2 | u32Baud_Div);
000126  f0415040          ORR      r0,r1,#0x30000000
                  |L12.298|
00012a  6268              STR      r0,[r5,#0x24]         ;442
                  |L12.300|
;;;447            }
;;;448        }
;;;449    
;;;450        /* Set UART line configuration */
;;;451        uart->LINE = u32data_width | u32parity | u32stop_bits;
00012c  ea49000a          ORR      r0,r9,r10
000130  ea40000b          ORR      r0,r0,r11
000134  60e8              STR      r0,[r5,#0xc]
;;;452    }
000136  e8bd9fff          POP      {r0-r12,pc}
;;;453    
                          ENDP

00013a  0000              DCW      0x0000
                  |L12.316|
                          DCD      ||.constdata||+0x10
                  |L12.320|
                          DCD      0x40070000
                  |L12.324|
                          DCD      0x40071000
                  |L12.328|
                          DCD      0x40072000
                  |L12.332|
                          DCD      0x40073000
                  |L12.336|
                          DCD      0x40074000
                  |L12.340|
                          DCD      0x40075000
                  |L12.344|
                          DCD      0x40076000
                  |L12.348|
                          DCD      0x40077000

                          AREA ||i.UART_SetTimeoutCnt||, CODE, READONLY, ALIGN=1

                  UART_SetTimeoutCnt PROC
;;;464     */
;;;465    void UART_SetTimeoutCnt(UART_T* uart, uint32_t u32TOC)
000000  6a02              LDR      r2,[r0,#0x20]
;;;466    {
;;;467        /* Set time-out interrupt comparator */
;;;468        uart->TOUT = (uart->TOUT & ~UART_TOUT_TOIC_Msk) | (u32TOC);
000002  f02202ff          BIC      r2,r2,#0xff
000006  430a              ORRS     r2,r2,r1
000008  6202              STR      r2,[r0,#0x20]
;;;469    
;;;470        /* Set time-out counter enable */
;;;471        uart->INTEN |= UART_INTEN_TOCNTEN_Msk;
00000a  6841              LDR      r1,[r0,#4]
00000c  f4416100          ORR      r1,r1,#0x800
000010  6041              STR      r1,[r0,#4]
;;;472    }
000012  4770              BX       lr
;;;473    
                          ENDP


                          AREA ||i.UART_Write||, CODE, READONLY, ALIGN=1

                  UART_Write PROC
;;;652     */
;;;653    uint32_t UART_Write(UART_T* uart, uint8_t pu8TxBuf[], uint32_t u32WriteBytes)
000000  b5f0              PUSH     {r4-r7,lr}
;;;654    {
000002  4604              MOV      r4,r0
;;;655        uint32_t  u32Count, u32delayno;
;;;656        uint32_t  u32Exit = 0ul;
000004  2500              MOVS     r5,#0
;;;657    
;;;658        for(u32Count = 0ul; u32Count != u32WriteBytes; u32Count++)
000006  4628              MOV      r0,r5
;;;659        {
;;;660            u32delayno = 0ul;
;;;661            while(uart->FIFOSTS & UART_FIFOSTS_TXFULL_Msk)   /* Check Tx Full */
;;;662            {
;;;663                u32delayno++;
;;;664                if(u32delayno >= 0x40000000ul)
000008  f04f4680          MOV      r6,#0x40000000
00000c  e00c              B        |L14.40|
                  |L14.14|
00000e  2300              MOVS     r3,#0                 ;660
000010  e002              B        |L14.24|
                  |L14.18|
000012  1c5b              ADDS     r3,r3,#1              ;661
000014  42b3              CMP      r3,r6
000016  d209              BCS      |L14.44|
                  |L14.24|
000018  69a7              LDR      r7,[r4,#0x18]         ;661
00001a  023f              LSLS     r7,r7,#8              ;661
00001c  d4f9              BMI      |L14.18|
;;;665                {
;;;666                    u32Exit = 1ul;
;;;667                    break;
;;;668                }
;;;669                else
;;;670                {
;;;671                }
;;;672            }
;;;673    
;;;674            if(u32Exit == 1ul)
00001e  2d00              CMP      r5,#0
000020  d104              BNE      |L14.44|
;;;675            {
;;;676                break;
;;;677            }
;;;678            else
;;;679            {
;;;680                uart->DAT = pu8TxBuf[u32Count];    /* Send UART Data from buffer */
000022  5c0b              LDRB     r3,[r1,r0]
000024  6023              STR      r3,[r4,#0]
000026  1c40              ADDS     r0,r0,#1
                  |L14.40|
000028  4290              CMP      r0,r2                 ;658
00002a  d1f0              BNE      |L14.14|
                  |L14.44|
;;;681            }
;;;682        }
;;;683    
;;;684        return u32Count;
;;;685    }
00002c  bdf0              POP      {r4-r7,pc}
;;;686    
                          ENDP


                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                          DCD      0x00b71b00
                          DCD      0x00000000
                          DCD      0x00008000
                          DCD      0x00b71b00
                          DCD      0x00b71b00
                          DCD      0x00000000
                          DCD      0x00008000
                          DCD      0x00b71b00
                          DCD      0x00b71b00
                          DCD      0x00000000
                          DCD      0x00008000
                          DCD      0x00b71b00

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\..\\Library\\StdDriver\\src\\uart.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___6_uart_c_f12f5b44____REV16|
#line 464 "..\\..\\..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___6_uart_c_f12f5b44____REV16| PROC
#line 465

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___6_uart_c_f12f5b44____REVSH|
#line 479
|__asm___6_uart_c_f12f5b44____REVSH| PROC
#line 480

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___6_uart_c_f12f5b44____RRX|
#line 666
|__asm___6_uart_c_f12f5b44____RRX| PROC
#line 667

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
